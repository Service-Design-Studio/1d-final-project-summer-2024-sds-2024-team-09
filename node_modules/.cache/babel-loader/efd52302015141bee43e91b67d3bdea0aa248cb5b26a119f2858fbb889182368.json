{"ast":null,"code":"function _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function () { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function (t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function (t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function (e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function (e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function (t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function (t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function (e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n/**\n * AgoraWebSDK_N-v4.21.0-0-g16fdae2c-dirty Copyright AgoraInc.\n */\n\n!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(t) : (e = \"undefined\" != typeof globalThis ? globalThis : e || self).AgoraRTC = t();\n}(this, function () {\n  \"use strict\";\n\n  function e(e, t) {\n    return t.forEach(function (t) {\n      t && \"string\" != typeof t && !Array.isArray(t) && Object.keys(t).forEach(function (i) {\n        if (\"default\" !== i && !(i in e)) {\n          var n = Object.getOwnPropertyDescriptor(t, i);\n          Object.defineProperty(e, i, n.get ? n : {\n            enumerable: !0,\n            get: function () {\n              return t[i];\n            }\n          });\n        }\n      });\n    }), Object.freeze(e);\n  }\n  var t = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\n  function i(e) {\n    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n  }\n  var n = function (e) {\n      try {\n        return !!e();\n      } catch (e) {\n        return !0;\n      }\n    },\n    r = !n(function () {\n      var e = function () {}.bind();\n      return \"function\" != typeof e || e.hasOwnProperty(\"prototype\");\n    }),\n    o = r,\n    s = Function.prototype,\n    a = s.call,\n    c = o && s.bind.bind(a, a),\n    d = o ? c : function (e) {\n      return function () {\n        return a.apply(e, arguments);\n      };\n    },\n    l = d({}.isPrototypeOf),\n    h = function (e) {\n      return e && e.Math == Math && e;\n    },\n    u = h(\"object\" == typeof globalThis && globalThis) || h(\"object\" == typeof window && window) || h(\"object\" == typeof self && self) || h(\"object\" == typeof t && t) || function () {\n      return this;\n    }() || t || Function(\"return this\")(),\n    p = r,\n    _ = Function.prototype,\n    E = _.apply,\n    m = _.call,\n    f = \"object\" == typeof Reflect && Reflect.apply || (p ? m.bind(E) : function () {\n      return m.apply(E, arguments);\n    }),\n    T = d,\n    S = T({}.toString),\n    g = T(\"\".slice),\n    R = function (e) {\n      return g(S(e), 8, -1);\n    },\n    C = R,\n    v = d,\n    I = function (e) {\n      if (\"Function\" === C(e)) return v(e);\n    },\n    y = \"object\" == typeof document && document.all,\n    A = {\n      all: y,\n      IS_HTMLDDA: void 0 === y && void 0 !== y\n    },\n    b = A.all,\n    w = A.IS_HTMLDDA ? function (e) {\n      return \"function\" == typeof e || e === b;\n    } : function (e) {\n      return \"function\" == typeof e;\n    },\n    O = {},\n    N = !n(function () {\n      return 7 != Object.defineProperty({}, 1, {\n        get: function () {\n          return 7;\n        }\n      })[1];\n    }),\n    D = r,\n    P = Function.prototype.call,\n    L = D ? P.bind(P) : function () {\n      return P.apply(P, arguments);\n    },\n    k = {},\n    M = {}.propertyIsEnumerable,\n    U = Object.getOwnPropertyDescriptor,\n    x = U && !M.call({\n      1: 2\n    }, 1);\n  k.f = x ? function (e) {\n    var t = U(this, e);\n    return !!t && t.enumerable;\n  } : M;\n  var V,\n    F,\n    B = function (e, t) {\n      return {\n        enumerable: !(1 & e),\n        configurable: !(2 & e),\n        writable: !(4 & e),\n        value: t\n      };\n    },\n    j = n,\n    G = R,\n    W = Object,\n    H = d(\"\".split),\n    K = j(function () {\n      return !W(\"z\").propertyIsEnumerable(0);\n    }) ? function (e) {\n      return \"String\" == G(e) ? H(e, \"\") : W(e);\n    } : W,\n    Y = function (e) {\n      return null == e;\n    },\n    q = Y,\n    z = TypeError,\n    J = function (e) {\n      if (q(e)) throw z(\"Can't call method on \" + e);\n      return e;\n    },\n    X = K,\n    Q = J,\n    Z = function (e) {\n      return X(Q(e));\n    },\n    $ = w,\n    ee = A.all,\n    te = A.IS_HTMLDDA ? function (e) {\n      return \"object\" == typeof e ? null !== e : $(e) || e === ee;\n    } : function (e) {\n      return \"object\" == typeof e ? null !== e : $(e);\n    },\n    ie = {},\n    ne = ie,\n    re = u,\n    oe = w,\n    se = function (e) {\n      return oe(e) ? e : void 0;\n    },\n    ae = function (e, t) {\n      return arguments.length < 2 ? se(ne[e]) || se(re[e]) : ne[e] && ne[e][t] || re[e] && re[e][t];\n    },\n    ce = \"undefined\" != typeof navigator && String(navigator.userAgent) || \"\",\n    de = u,\n    le = ce,\n    he = de.process,\n    ue = de.Deno,\n    pe = he && he.versions || ue && ue.version,\n    _e = pe && pe.v8;\n  _e && (F = (V = _e.split(\".\"))[0] > 0 && V[0] < 4 ? 1 : +(V[0] + V[1])), !F && le && (!(V = le.match(/Edge\\/(\\d+)/)) || V[1] >= 74) && (V = le.match(/Chrome\\/(\\d+)/)) && (F = +V[1]);\n  var Ee = F,\n    me = Ee,\n    fe = n,\n    Te = u.String,\n    Se = !!Object.getOwnPropertySymbols && !fe(function () {\n      var e = Symbol();\n      return !Te(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && me && me < 41;\n    }),\n    ge = Se && !Symbol.sham && \"symbol\" == typeof Symbol.iterator,\n    Re = ae,\n    Ce = w,\n    ve = l,\n    Ie = Object,\n    ye = ge ? function (e) {\n      return \"symbol\" == typeof e;\n    } : function (e) {\n      var t = Re(\"Symbol\");\n      return Ce(t) && ve(t.prototype, Ie(e));\n    },\n    Ae = String,\n    be = function (e) {\n      try {\n        return Ae(e);\n      } catch (e) {\n        return \"Object\";\n      }\n    },\n    we = w,\n    Oe = be,\n    Ne = TypeError,\n    De = function (e) {\n      if (we(e)) return e;\n      throw Ne(Oe(e) + \" is not a function\");\n    },\n    Pe = De,\n    Le = Y,\n    ke = function (e, t) {\n      var i = e[t];\n      return Le(i) ? void 0 : Pe(i);\n    },\n    Me = L,\n    Ue = w,\n    xe = te,\n    Ve = TypeError,\n    Fe = {\n      exports: {}\n    },\n    Be = u,\n    je = Object.defineProperty,\n    Ge = function (e, t) {\n      try {\n        je(Be, e, {\n          value: t,\n          configurable: !0,\n          writable: !0\n        });\n      } catch (i) {\n        Be[e] = t;\n      }\n      return t;\n    },\n    We = \"__core-js_shared__\",\n    He = u[We] || Ge(We, {}),\n    Ke = He;\n  (Fe.exports = function (e, t) {\n    return Ke[e] || (Ke[e] = void 0 !== t ? t : {});\n  })(\"versions\", []).push({\n    version: \"3.31.1\",\n    mode: \"pure\",\n    copyright: \"Â© 2014-2023 Denis Pushkarev (zloirock.ru)\",\n    license: \"https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE\",\n    source: \"https://github.com/zloirock/core-js\"\n  });\n  var Ye = Fe.exports,\n    qe = J,\n    ze = Object,\n    Je = function (e) {\n      return ze(qe(e));\n    },\n    Xe = Je,\n    Qe = d({}.hasOwnProperty),\n    Ze = Object.hasOwn || function (e, t) {\n      return Qe(Xe(e), t);\n    },\n    $e = d,\n    et = 0,\n    tt = Math.random(),\n    it = $e(1..toString),\n    nt = function (e) {\n      return \"Symbol(\" + (void 0 === e ? \"\" : e) + \")_\" + it(++et + tt, 36);\n    },\n    rt = Ye,\n    ot = Ze,\n    st = nt,\n    at = Se,\n    ct = ge,\n    dt = u.Symbol,\n    lt = rt(\"wks\"),\n    ht = ct ? dt.for || dt : dt && dt.withoutSetter || st,\n    ut = function (e) {\n      return ot(lt, e) || (lt[e] = at && ot(dt, e) ? dt[e] : ht(\"Symbol.\" + e)), lt[e];\n    },\n    pt = L,\n    _t = te,\n    Et = ye,\n    mt = ke,\n    ft = function (e, t) {\n      var i, n;\n      if (\"string\" === t && Ue(i = e.toString) && !xe(n = Me(i, e))) return n;\n      if (Ue(i = e.valueOf) && !xe(n = Me(i, e))) return n;\n      if (\"string\" !== t && Ue(i = e.toString) && !xe(n = Me(i, e))) return n;\n      throw Ve(\"Can't convert object to primitive value\");\n    },\n    Tt = TypeError,\n    St = ut(\"toPrimitive\"),\n    gt = function (e, t) {\n      if (!_t(e) || Et(e)) return e;\n      var i,\n        n = mt(e, St);\n      if (n) {\n        if (void 0 === t && (t = \"default\"), i = pt(n, e, t), !_t(i) || Et(i)) return i;\n        throw Tt(\"Can't convert object to primitive value\");\n      }\n      return void 0 === t && (t = \"number\"), ft(e, t);\n    },\n    Rt = ye,\n    Ct = function (e) {\n      var t = gt(e, \"string\");\n      return Rt(t) ? t : t + \"\";\n    },\n    vt = te,\n    It = u.document,\n    yt = vt(It) && vt(It.createElement),\n    At = function (e) {\n      return yt ? It.createElement(e) : {};\n    },\n    bt = At,\n    wt = !N && !n(function () {\n      return 7 != Object.defineProperty(bt(\"div\"), \"a\", {\n        get: function () {\n          return 7;\n        }\n      }).a;\n    }),\n    Ot = N,\n    Nt = L,\n    Dt = k,\n    Pt = B,\n    Lt = Z,\n    kt = Ct,\n    Mt = Ze,\n    Ut = wt,\n    xt = Object.getOwnPropertyDescriptor;\n  O.f = Ot ? xt : function (e, t) {\n    if (e = Lt(e), t = kt(t), Ut) try {\n      return xt(e, t);\n    } catch (e) {}\n    if (Mt(e, t)) return Pt(!Nt(Dt.f, e, t), e[t]);\n  };\n  var Vt = n,\n    Ft = w,\n    Bt = /#|\\.prototype\\./,\n    jt = function (e, t) {\n      var i = Wt[Gt(e)];\n      return i == Kt || i != Ht && (Ft(t) ? Vt(t) : !!t);\n    },\n    Gt = jt.normalize = function (e) {\n      return String(e).replace(Bt, \".\").toLowerCase();\n    },\n    Wt = jt.data = {},\n    Ht = jt.NATIVE = \"N\",\n    Kt = jt.POLYFILL = \"P\",\n    Yt = jt,\n    qt = De,\n    zt = r,\n    Jt = I(I.bind),\n    Xt = function (e, t) {\n      return qt(e), void 0 === t ? e : zt ? Jt(e, t) : function () {\n        return e.apply(t, arguments);\n      };\n    },\n    Qt = {},\n    Zt = N && n(function () {\n      return 42 != Object.defineProperty(function () {}, \"prototype\", {\n        value: 42,\n        writable: !1\n      }).prototype;\n    }),\n    $t = te,\n    ei = String,\n    ti = TypeError,\n    ii = function (e) {\n      if ($t(e)) return e;\n      throw ti(ei(e) + \" is not an object\");\n    },\n    ni = N,\n    ri = wt,\n    oi = Zt,\n    si = ii,\n    ai = Ct,\n    ci = TypeError,\n    di = Object.defineProperty,\n    li = Object.getOwnPropertyDescriptor,\n    hi = \"enumerable\",\n    ui = \"configurable\",\n    pi = \"writable\";\n  Qt.f = ni ? oi ? function (e, t, i) {\n    if (si(e), t = ai(t), si(i), \"function\" == typeof e && \"prototype\" === t && \"value\" in i && pi in i && !i[pi]) {\n      var n = li(e, t);\n      n && n[pi] && (e[t] = i.value, i = {\n        configurable: ui in i ? i[ui] : n[ui],\n        enumerable: hi in i ? i[hi] : n[hi],\n        writable: !1\n      });\n    }\n    return di(e, t, i);\n  } : di : function (e, t, i) {\n    if (si(e), t = ai(t), si(i), ri) try {\n      return di(e, t, i);\n    } catch (e) {}\n    if (\"get\" in i || \"set\" in i) throw ci(\"Accessors not supported\");\n    return \"value\" in i && (e[t] = i.value), e;\n  };\n  var _i = Qt,\n    Ei = B,\n    mi = N ? function (e, t, i) {\n      return _i.f(e, t, Ei(1, i));\n    } : function (e, t, i) {\n      return e[t] = i, e;\n    },\n    fi = u,\n    Ti = f,\n    Si = I,\n    gi = w,\n    Ri = O.f,\n    Ci = Yt,\n    vi = ie,\n    Ii = Xt,\n    yi = mi,\n    Ai = Ze,\n    bi = function (e) {\n      var t = function (i, n, r) {\n        if (this instanceof t) {\n          switch (arguments.length) {\n            case 0:\n              return new e();\n            case 1:\n              return new e(i);\n            case 2:\n              return new e(i, n);\n          }\n          return new e(i, n, r);\n        }\n        return Ti(e, this, arguments);\n      };\n      return t.prototype = e.prototype, t;\n    },\n    wi = function (e, t) {\n      var i,\n        n,\n        r,\n        o,\n        s,\n        a,\n        c,\n        d,\n        l,\n        h = e.target,\n        u = e.global,\n        p = e.stat,\n        _ = e.proto,\n        E = u ? fi : p ? fi[h] : (fi[h] || {}).prototype,\n        m = u ? vi : vi[h] || yi(vi, h, {})[h],\n        f = m.prototype;\n      for (o in t) n = !(i = Ci(u ? o : h + (p ? \".\" : \"#\") + o, e.forced)) && E && Ai(E, o), a = m[o], n && (c = e.dontCallGetSet ? (l = Ri(E, o)) && l.value : E[o]), s = n && c ? c : t[o], n && typeof a == typeof s || (d = e.bind && n ? Ii(s, fi) : e.wrap && n ? bi(s) : _ && gi(s) ? Si(s) : s, (e.sham || s && s.sham || a && a.sham) && yi(d, \"sham\", !0), yi(m, o, d), _ && (Ai(vi, r = h + \"Prototype\") || yi(vi, r, {}), yi(vi[r], o, s), e.real && f && (i || !f[o]) && yi(f, o, s)));\n    },\n    Oi = Math.ceil,\n    Ni = Math.floor,\n    Di = Math.trunc || function (e) {\n      var t = +e;\n      return (t > 0 ? Ni : Oi)(t);\n    },\n    Pi = Di,\n    Li = function (e) {\n      var t = +e;\n      return t != t || 0 === t ? 0 : Pi(t);\n    },\n    ki = Li,\n    Mi = Math.max,\n    Ui = Math.min,\n    xi = function (e, t) {\n      var i = ki(e);\n      return i < 0 ? Mi(i + t, 0) : Ui(i, t);\n    },\n    Vi = Li,\n    Fi = Math.min,\n    Bi = function (e) {\n      return e > 0 ? Fi(Vi(e), 9007199254740991) : 0;\n    },\n    ji = Bi,\n    Gi = function (e) {\n      return ji(e.length);\n    },\n    Wi = Z,\n    Hi = xi,\n    Ki = Gi,\n    Yi = function (e) {\n      return function (t, i, n) {\n        var r,\n          o = Wi(t),\n          s = Ki(o),\n          a = Hi(n, s);\n        if (e && i != i) {\n          for (; s > a;) if ((r = o[a++]) != r) return !0;\n        } else for (; s > a; a++) if ((e || a in o) && o[a] === i) return e || a || 0;\n        return !e && -1;\n      };\n    },\n    qi = {\n      includes: Yi(!0),\n      indexOf: Yi(!1)\n    },\n    zi = qi.includes;\n  wi({\n    target: \"Array\",\n    proto: !0,\n    forced: n(function () {\n      return !Array(1).includes();\n    })\n  }, {\n    includes: function (e) {\n      return zi(this, e, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n  var Ji = ie,\n    Xi = function (e) {\n      return Ji[e + \"Prototype\"];\n    },\n    Qi = Xi(\"Array\").includes,\n    Zi = te,\n    $i = R,\n    en = ut(\"match\"),\n    tn = function (e) {\n      var t;\n      return Zi(e) && (void 0 !== (t = e[en]) ? !!t : \"RegExp\" == $i(e));\n    },\n    nn = tn,\n    rn = TypeError,\n    on = {};\n  on[ut(\"toStringTag\")] = \"z\";\n  var sn = \"[object z]\" === String(on),\n    an = sn,\n    cn = w,\n    dn = R,\n    ln = ut(\"toStringTag\"),\n    hn = Object,\n    un = \"Arguments\" == dn(function () {\n      return arguments;\n    }()),\n    pn = an ? dn : function (e) {\n      var t, i, n;\n      return void 0 === e ? \"Undefined\" : null === e ? \"Null\" : \"string\" == typeof (i = function (e, t) {\n        try {\n          return e[t];\n        } catch (e) {}\n      }(t = hn(e), ln)) ? i : un ? dn(t) : \"Object\" == (n = dn(t)) && cn(t.callee) ? \"Arguments\" : n;\n    },\n    _n = pn,\n    En = String,\n    mn = function (e) {\n      if (\"Symbol\" === _n(e)) throw TypeError(\"Cannot convert a Symbol value to a string\");\n      return En(e);\n    },\n    fn = ut(\"match\"),\n    Tn = wi,\n    Sn = function (e) {\n      if (nn(e)) throw rn(\"The method doesn't accept regular expressions\");\n      return e;\n    },\n    gn = J,\n    Rn = mn,\n    Cn = function (e) {\n      var t = /./;\n      try {\n        \"/./\"[e](t);\n      } catch (i) {\n        try {\n          return t[fn] = !1, \"/./\"[e](t);\n        } catch (e) {}\n      }\n      return !1;\n    },\n    vn = d(\"\".indexOf);\n  Tn({\n    target: \"String\",\n    proto: !0,\n    forced: !Cn(\"includes\")\n  }, {\n    includes: function (e) {\n      return !!~vn(Rn(gn(this)), Rn(Sn(e)), arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n  var In = Xi(\"String\").includes,\n    yn = l,\n    An = Qi,\n    bn = In,\n    wn = Array.prototype,\n    On = String.prototype,\n    Nn = function (e) {\n      var t = e.includes;\n      return e === wn || yn(wn, e) && t === wn.includes ? An : \"string\" == typeof e || e === On || yn(On, e) && t === On.includes ? bn : t;\n    },\n    Dn = i(Nn),\n    Pn = De,\n    Ln = Je,\n    kn = K,\n    Mn = Gi,\n    Un = TypeError,\n    xn = function (e) {\n      return function (t, i, n, r) {\n        Pn(i);\n        var o = Ln(t),\n          s = kn(o),\n          a = Mn(o),\n          c = e ? a - 1 : 0,\n          d = e ? -1 : 1;\n        if (n < 2) for (;;) {\n          if (c in s) {\n            r = s[c], c += d;\n            break;\n          }\n          if (c += d, e ? c < 0 : a <= c) throw Un(\"Reduce of empty array with no initial value\");\n        }\n        for (; e ? c >= 0 : a > c; c += d) c in s && (r = i(r, s[c], c, o));\n        return r;\n      };\n    },\n    Vn = {\n      left: xn(!1),\n      right: xn(!0)\n    },\n    Fn = n,\n    Bn = function (e, t) {\n      var i = [][e];\n      return !!i && Fn(function () {\n        i.call(null, t || function () {\n          return 1;\n        }, 1);\n      });\n    },\n    jn = \"undefined\" != typeof process && \"process\" == R(process),\n    Gn = Vn.left;\n  wi({\n    target: \"Array\",\n    proto: !0,\n    forced: !jn && Ee > 79 && Ee < 83 || !Bn(\"reduce\")\n  }, {\n    reduce: function (e) {\n      var t = arguments.length;\n      return Gn(this, e, t, t > 1 ? arguments[1] : void 0);\n    }\n  });\n  var Wn = Xi(\"Array\").reduce,\n    Hn = l,\n    Kn = Wn,\n    Yn = Array.prototype,\n    qn = function (e) {\n      var t = e.reduce;\n      return e === Yn || Hn(Yn, e) && t === Yn.reduce ? Kn : t;\n    },\n    zn = qn,\n    Jn = i(zn);\n  let Xn = !0,\n    Qn = !0;\n  function Zn(e, t, i) {\n    const n = e.match(t);\n    return n && n.length >= i && parseInt(n[i], 10);\n  }\n  function $n(e, t, i) {\n    if (!e.RTCPeerConnection) return;\n    const n = e.RTCPeerConnection.prototype,\n      r = n.addEventListener;\n    n.addEventListener = function (e, n) {\n      if (e !== t) return r.apply(this, arguments);\n      const o = e => {\n        const t = i(e);\n        t && (n.handleEvent ? n.handleEvent(t) : n(t));\n      };\n      return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map()), this._eventMap[t].set(n, o), r.apply(this, [e, o]);\n    };\n    const o = n.removeEventListener;\n    n.removeEventListener = function (e, i) {\n      if (e !== t || !this._eventMap || !this._eventMap[t]) return o.apply(this, arguments);\n      if (!this._eventMap[t].has(i)) return o.apply(this, arguments);\n      const n = this._eventMap[t].get(i);\n      return this._eventMap[t].delete(i), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o.apply(this, [e, n]);\n    }, Object.defineProperty(n, \"on\" + t, {\n      get() {\n        return this[\"_on\" + t];\n      },\n      set(e) {\n        this[\"_on\" + t] && (this.removeEventListener(t, this[\"_on\" + t]), delete this[\"_on\" + t]), e && this.addEventListener(t, this[\"_on\" + t] = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n  }\n  function er(e) {\n    return \"boolean\" != typeof e ? new Error(\"Argument type: \" + typeof e + \". Please use a boolean.\") : (Xn = e, e ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\");\n  }\n  function tr(e) {\n    return \"boolean\" != typeof e ? new Error(\"Argument type: \" + typeof e + \". Please use a boolean.\") : (Qn = !e, \"adapter.js deprecation warnings \" + (e ? \"disabled\" : \"enabled\"));\n  }\n  function ir() {\n    if (\"object\" == typeof window) {\n      if (Xn) return;\n      \"undefined\" != typeof console && \"function\" == typeof console.log && console.log.apply(console, arguments);\n    }\n  }\n  function nr(e, t) {\n    Qn && console.warn(e + \" is deprecated, please use \" + t + \" instead.\");\n  }\n  function rr(e) {\n    return \"[object Object]\" === Object.prototype.toString.call(e);\n  }\n  function or(e) {\n    var t;\n    return rr(e) ? Jn(t = Object.keys(e)).call(t, function (t, i) {\n      const n = rr(e[i]),\n        r = n ? or(e[i]) : e[i],\n        o = n && !Object.keys(r).length;\n      return void 0 === r || o ? t : Object.assign(t, {\n        [i]: r\n      });\n    }, {}) : e;\n  }\n  function sr(e, t, i) {\n    t && !i.has(t.id) && (i.set(t.id, t), Object.keys(t).forEach(n => {\n      n.endsWith(\"Id\") ? sr(e, e.get(t[n]), i) : n.endsWith(\"Ids\") && t[n].forEach(t => {\n        sr(e, e.get(t), i);\n      });\n    }));\n  }\n  function ar(e, t, i) {\n    const n = i ? \"outbound-rtp\" : \"inbound-rtp\",\n      r = new Map();\n    if (null === t) return r;\n    const o = [];\n    return e.forEach(e => {\n      \"track\" === e.type && e.trackIdentifier === t.id && o.push(e);\n    }), o.forEach(t => {\n      e.forEach(i => {\n        i.type === n && i.trackId === t.id && sr(e, i, r);\n      });\n    }), r;\n  }\n  var cr = nt,\n    dr = Ye(\"keys\"),\n    lr = function (e) {\n      return dr[e] || (dr[e] = cr(e));\n    },\n    hr = !n(function () {\n      function e() {}\n      return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;\n    }),\n    ur = Ze,\n    pr = w,\n    _r = Je,\n    Er = hr,\n    mr = lr(\"IE_PROTO\"),\n    fr = Object,\n    Tr = fr.prototype,\n    Sr = Er ? fr.getPrototypeOf : function (e) {\n      var t = _r(e);\n      if (ur(t, mr)) return t[mr];\n      var i = t.constructor;\n      return pr(i) && t instanceof i ? i.prototype : t instanceof fr ? Tr : null;\n    },\n    gr = d,\n    Rr = De,\n    Cr = w,\n    vr = String,\n    Ir = TypeError,\n    yr = function (e, t, i) {\n      try {\n        return gr(Rr(Object.getOwnPropertyDescriptor(e, t)[i]));\n      } catch (e) {}\n    },\n    Ar = ii,\n    br = function (e) {\n      if (\"object\" == typeof e || Cr(e)) return e;\n      throw Ir(\"Can't set \" + vr(e) + \" as a prototype\");\n    },\n    wr = Object.setPrototypeOf || (\"__proto__\" in {} ? function () {\n      var e,\n        t = !1,\n        i = {};\n      try {\n        (e = yr(Object.prototype, \"__proto__\", \"set\"))(i, []), t = i instanceof Array;\n      } catch (e) {}\n      return function (i, n) {\n        return Ar(i), br(n), t ? e(i, n) : i.__proto__ = n, i;\n      };\n    }() : void 0),\n    Or = {},\n    Nr = {},\n    Dr = Ze,\n    Pr = Z,\n    Lr = qi.indexOf,\n    kr = Nr,\n    Mr = d([].push),\n    Ur = function (e, t) {\n      var i,\n        n = Pr(e),\n        r = 0,\n        o = [];\n      for (i in n) !Dr(kr, i) && Dr(n, i) && Mr(o, i);\n      for (; t.length > r;) Dr(n, i = t[r++]) && (~Lr(o, i) || Mr(o, i));\n      return o;\n    },\n    xr = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"],\n    Vr = Ur,\n    Fr = xr.concat(\"length\", \"prototype\");\n  Or.f = Object.getOwnPropertyNames || function (e) {\n    return Vr(e, Fr);\n  };\n  var Br = {};\n  Br.f = Object.getOwnPropertySymbols;\n  var jr = ae,\n    Gr = Or,\n    Wr = Br,\n    Hr = ii,\n    Kr = d([].concat),\n    Yr = jr(\"Reflect\", \"ownKeys\") || function (e) {\n      var t = Gr.f(Hr(e)),\n        i = Wr.f;\n      return i ? Kr(t, i(e)) : t;\n    },\n    qr = Ze,\n    zr = Yr,\n    Jr = O,\n    Xr = Qt,\n    Qr = {},\n    Zr = Ur,\n    $r = xr,\n    eo = Object.keys || function (e) {\n      return Zr(e, $r);\n    },\n    to = N,\n    io = Zt,\n    no = Qt,\n    ro = ii,\n    oo = Z,\n    so = eo;\n  Qr.f = to && !io ? Object.defineProperties : function (e, t) {\n    ro(e);\n    for (var i, n = oo(t), r = so(t), o = r.length, s = 0; o > s;) no.f(e, i = r[s++], n[i]);\n    return e;\n  };\n  var ao,\n    co = ae(\"document\", \"documentElement\"),\n    lo = ii,\n    ho = Qr,\n    uo = xr,\n    po = Nr,\n    _o = co,\n    Eo = At,\n    mo = \"prototype\",\n    fo = \"script\",\n    To = lr(\"IE_PROTO\"),\n    So = function () {},\n    go = function (e) {\n      return \"<\" + fo + \">\" + e + \"</\" + fo + \">\";\n    },\n    Ro = function (e) {\n      e.write(go(\"\")), e.close();\n      var t = e.parentWindow.Object;\n      return e = null, t;\n    },\n    Co = function () {\n      try {\n        ao = new ActiveXObject(\"htmlfile\");\n      } catch (e) {}\n      var e, t, i;\n      Co = \"undefined\" != typeof document ? document.domain && ao ? Ro(ao) : (t = Eo(\"iframe\"), i = \"java\" + fo + \":\", t.style.display = \"none\", _o.appendChild(t), t.src = String(i), (e = t.contentWindow.document).open(), e.write(go(\"document.F=Object\")), e.close(), e.F) : Ro(ao);\n      for (var n = uo.length; n--;) delete Co[mo][uo[n]];\n      return Co();\n    };\n  po[To] = !0;\n  var vo = Object.create || function (e, t) {\n      var i;\n      return null !== e ? (So[mo] = lo(e), i = new So(), So[mo] = null, i[To] = e) : i = Co(), void 0 === t ? i : ho.f(i, t);\n    },\n    Io = te,\n    yo = mi,\n    Ao = Error,\n    bo = d(\"\".replace),\n    wo = String(Ao(\"zxcasd\").stack),\n    Oo = /\\n\\s*at [^:]*:[^\\n]*/,\n    No = Oo.test(wo),\n    Do = B,\n    Po = !n(function () {\n      var e = Error(\"a\");\n      return !(\"stack\" in e) || (Object.defineProperty(e, \"stack\", Do(1, 7)), 7 !== e.stack);\n    }),\n    Lo = mi,\n    ko = function (e, t) {\n      if (No && \"string\" == typeof e && !Ao.prepareStackTrace) for (; t--;) e = bo(e, Oo, \"\");\n      return e;\n    },\n    Mo = Po,\n    Uo = Error.captureStackTrace,\n    xo = {},\n    Vo = xo,\n    Fo = ut(\"iterator\"),\n    Bo = Array.prototype,\n    jo = function (e) {\n      return void 0 !== e && (Vo.Array === e || Bo[Fo] === e);\n    },\n    Go = pn,\n    Wo = ke,\n    Ho = Y,\n    Ko = xo,\n    Yo = ut(\"iterator\"),\n    qo = function (e) {\n      if (!Ho(e)) return Wo(e, Yo) || Wo(e, \"@@iterator\") || Ko[Go(e)];\n    },\n    zo = L,\n    Jo = De,\n    Xo = ii,\n    Qo = be,\n    Zo = qo,\n    $o = TypeError,\n    es = function (e, t) {\n      var i = arguments.length < 2 ? Zo(e) : t;\n      if (Jo(i)) return Xo(zo(i, e));\n      throw $o(Qo(e) + \" is not iterable\");\n    },\n    ts = L,\n    is = ii,\n    ns = ke,\n    rs = function (e, t, i) {\n      var n, r;\n      is(e);\n      try {\n        if (!(n = ns(e, \"return\"))) {\n          if (\"throw\" === t) throw i;\n          return i;\n        }\n        n = ts(n, e);\n      } catch (e) {\n        r = !0, n = e;\n      }\n      if (\"throw\" === t) throw i;\n      if (r) throw n;\n      return is(n), i;\n    },\n    os = Xt,\n    ss = L,\n    as = ii,\n    cs = be,\n    ds = jo,\n    ls = Gi,\n    hs = l,\n    us = es,\n    ps = qo,\n    _s = rs,\n    Es = TypeError,\n    ms = function (e, t) {\n      this.stopped = e, this.result = t;\n    },\n    fs = ms.prototype,\n    Ts = function (e, t, i) {\n      var n,\n        r,\n        o,\n        s,\n        a,\n        c,\n        d,\n        l = i && i.that,\n        h = !(!i || !i.AS_ENTRIES),\n        u = !(!i || !i.IS_RECORD),\n        p = !(!i || !i.IS_ITERATOR),\n        _ = !(!i || !i.INTERRUPTED),\n        E = os(t, l),\n        m = function (e) {\n          return n && _s(n, \"normal\", e), new ms(!0, e);\n        },\n        f = function (e) {\n          return h ? (as(e), _ ? E(e[0], e[1], m) : E(e[0], e[1])) : _ ? E(e, m) : E(e);\n        };\n      if (u) n = e.iterator;else if (p) n = e;else {\n        if (!(r = ps(e))) throw Es(cs(e) + \" is not iterable\");\n        if (ds(r)) {\n          for (o = 0, s = ls(e); s > o; o++) if ((a = f(e[o])) && hs(fs, a)) return a;\n          return new ms(!1);\n        }\n        n = us(e, r);\n      }\n      for (c = u ? e.next : n.next; !(d = ss(c, n)).done;) {\n        try {\n          a = f(d.value);\n        } catch (e) {\n          _s(n, \"throw\", e);\n        }\n        if (\"object\" == typeof a && a && hs(fs, a)) return a;\n      }\n      return new ms(!1);\n    },\n    Ss = mn,\n    gs = wi,\n    Rs = l,\n    Cs = Sr,\n    vs = wr,\n    Is = function (e, t, i) {\n      for (var n = zr(t), r = Xr.f, o = Jr.f, s = 0; s < n.length; s++) {\n        var a = n[s];\n        qr(e, a) || i && qr(i, a) || r(e, a, o(t, a));\n      }\n    },\n    ys = vo,\n    As = mi,\n    bs = B,\n    ws = function (e, t) {\n      Io(t) && \"cause\" in t && yo(e, \"cause\", t.cause);\n    },\n    Os = function (e, t, i, n) {\n      Mo && (Uo ? Uo(e, t) : Lo(e, \"stack\", ko(i, n)));\n    },\n    Ns = Ts,\n    Ds = function (e, t) {\n      return void 0 === e ? arguments.length < 2 ? \"\" : t : Ss(e);\n    },\n    Ps = ut(\"toStringTag\"),\n    Ls = Error,\n    ks = [].push,\n    Ms = function (e, t) {\n      var i,\n        n = Rs(Us, this);\n      vs ? i = vs(Ls(), n ? Cs(this) : Us) : (i = n ? this : ys(Us), As(i, Ps, \"Error\")), void 0 !== t && As(i, \"message\", Ds(t)), Os(i, Ms, i.stack, 1), arguments.length > 2 && ws(i, arguments[2]);\n      var r = [];\n      return Ns(e, ks, {\n        that: r\n      }), As(i, \"errors\", r), i;\n    };\n  vs ? vs(Ms, Ls) : Is(Ms, Ls, {\n    name: !0\n  });\n  var Us = Ms.prototype = ys(Ls.prototype, {\n    constructor: bs(1, Ms),\n    message: bs(1, \"\"),\n    name: bs(1, \"AggregateError\")\n  });\n  gs({\n    global: !0,\n    constructor: !0,\n    arity: 2\n  }, {\n    AggregateError: Ms\n  });\n  var xs,\n    Vs,\n    Fs,\n    Bs = w,\n    js = u.WeakMap,\n    Gs = Bs(js) && /native code/.test(String(js)),\n    Ws = u,\n    Hs = te,\n    Ks = mi,\n    Ys = Ze,\n    qs = He,\n    zs = lr,\n    Js = Nr,\n    Xs = \"Object already initialized\",\n    Qs = Ws.TypeError,\n    Zs = Ws.WeakMap;\n  if (Gs || qs.state) {\n    var $s = qs.state || (qs.state = new Zs());\n    $s.get = $s.get, $s.has = $s.has, $s.set = $s.set, xs = function (e, t) {\n      if ($s.has(e)) throw Qs(Xs);\n      return t.facade = e, $s.set(e, t), t;\n    }, Vs = function (e) {\n      return $s.get(e) || {};\n    }, Fs = function (e) {\n      return $s.has(e);\n    };\n  } else {\n    var ea = zs(\"state\");\n    Js[ea] = !0, xs = function (e, t) {\n      if (Ys(e, ea)) throw Qs(Xs);\n      return t.facade = e, Ks(e, ea, t), t;\n    }, Vs = function (e) {\n      return Ys(e, ea) ? e[ea] : {};\n    }, Fs = function (e) {\n      return Ys(e, ea);\n    };\n  }\n  var ta,\n    ia,\n    na,\n    ra = {\n      set: xs,\n      get: Vs,\n      has: Fs,\n      enforce: function (e) {\n        return Fs(e) ? Vs(e) : xs(e, {});\n      },\n      getterFor: function (e) {\n        return function (t) {\n          var i;\n          if (!Hs(t) || (i = Vs(t)).type !== e) throw Qs(\"Incompatible receiver, \" + e + \" required\");\n          return i;\n        };\n      }\n    },\n    oa = N,\n    sa = Ze,\n    aa = Function.prototype,\n    ca = oa && Object.getOwnPropertyDescriptor,\n    da = sa(aa, \"name\"),\n    la = {\n      EXISTS: da,\n      PROPER: da && \"something\" === function () {}.name,\n      CONFIGURABLE: da && (!oa || oa && ca(aa, \"name\").configurable)\n    },\n    ha = mi,\n    ua = function (e, t, i, n) {\n      return n && n.enumerable ? e[t] = i : ha(e, t, i), e;\n    },\n    pa = n,\n    _a = w,\n    Ea = te,\n    ma = vo,\n    fa = Sr,\n    Ta = ua,\n    Sa = ut(\"iterator\"),\n    ga = !1;\n  [].keys && (\"next\" in (na = [].keys()) ? (ia = fa(fa(na))) !== Object.prototype && (ta = ia) : ga = !0);\n  var Ra = !Ea(ta) || pa(function () {\n    var e = {};\n    return ta[Sa].call(e) !== e;\n  });\n  _a((ta = Ra ? {} : ma(ta))[Sa]) || Ta(ta, Sa, function () {\n    return this;\n  });\n  var Ca = {\n      IteratorPrototype: ta,\n      BUGGY_SAFARI_ITERATORS: ga\n    },\n    va = pn,\n    Ia = sn ? {}.toString : function () {\n      return \"[object \" + va(this) + \"]\";\n    },\n    ya = sn,\n    Aa = Qt.f,\n    ba = mi,\n    wa = Ze,\n    Oa = Ia,\n    Na = ut(\"toStringTag\"),\n    Da = function (e, t, i, n) {\n      if (e) {\n        var r = i ? e : e.prototype;\n        wa(r, Na) || Aa(r, Na, {\n          configurable: !0,\n          value: t\n        }), n && !ya && ba(r, \"toString\", Oa);\n      }\n    },\n    Pa = Ca.IteratorPrototype,\n    La = vo,\n    ka = B,\n    Ma = Da,\n    Ua = xo,\n    xa = function () {\n      return this;\n    },\n    Va = function (e, t, i, n) {\n      var r = t + \" Iterator\";\n      return e.prototype = La(Pa, {\n        next: ka(+!n, i)\n      }), Ma(e, r, !1, !0), Ua[r] = xa, e;\n    },\n    Fa = wi,\n    Ba = L,\n    ja = la,\n    Ga = Va,\n    Wa = Sr,\n    Ha = Da,\n    Ka = ua,\n    Ya = xo,\n    qa = Ca,\n    za = ja.PROPER,\n    Ja = qa.BUGGY_SAFARI_ITERATORS,\n    Xa = ut(\"iterator\"),\n    Qa = \"keys\",\n    Za = \"values\",\n    $a = \"entries\",\n    ec = function () {\n      return this;\n    },\n    tc = function (e, t, i, n, r, o, s) {\n      Ga(i, t, n);\n      var a,\n        c,\n        d,\n        l = function (e) {\n          if (e === r && E) return E;\n          if (!Ja && e in p) return p[e];\n          switch (e) {\n            case Qa:\n            case Za:\n            case $a:\n              return function () {\n                return new i(this, e);\n              };\n          }\n          return function () {\n            return new i(this);\n          };\n        },\n        h = t + \" Iterator\",\n        u = !1,\n        p = e.prototype,\n        _ = p[Xa] || p[\"@@iterator\"] || r && p[r],\n        E = !Ja && _ || l(r),\n        m = \"Array\" == t && p.entries || _;\n      if (m && (a = Wa(m.call(new e()))) !== Object.prototype && a.next && (Ha(a, h, !0, !0), Ya[h] = ec), za && r == Za && _ && _.name !== Za && (u = !0, E = function () {\n        return Ba(_, this);\n      }), r) if (c = {\n        values: l(Za),\n        keys: o ? E : l(Qa),\n        entries: l($a)\n      }, s) for (d in c) (Ja || u || !(d in p)) && Ka(p, d, c[d]);else Fa({\n        target: t,\n        proto: !0,\n        forced: Ja || u\n      }, c);\n      return s && p[Xa] !== E && Ka(p, Xa, E, {\n        name: r\n      }), Ya[t] = E, c;\n    },\n    ic = function (e, t) {\n      return {\n        value: e,\n        done: t\n      };\n    },\n    nc = Z,\n    rc = xo,\n    oc = ra;\n  Qt.f;\n  var sc = tc,\n    ac = ic,\n    cc = \"Array Iterator\",\n    dc = oc.set,\n    lc = oc.getterFor(cc);\n  sc(Array, \"Array\", function (e, t) {\n    dc(this, {\n      type: cc,\n      target: nc(e),\n      index: 0,\n      kind: t\n    });\n  }, function () {\n    var e = lc(this),\n      t = e.target,\n      i = e.kind,\n      n = e.index++;\n    return !t || n >= t.length ? (e.target = void 0, ac(void 0, !0)) : ac(\"keys\" == i ? n : \"values\" == i ? t[n] : [n, t[n]], !1);\n  }, \"values\"), rc.Arguments = rc.Array;\n  var hc = Qt,\n    uc = function (e, t, i) {\n      return hc.f(e, t, i);\n    },\n    pc = ae,\n    _c = uc,\n    Ec = N,\n    mc = ut(\"species\"),\n    fc = l,\n    Tc = TypeError,\n    Sc = function (e, t) {\n      if (fc(t, e)) return e;\n      throw Tc(\"Incorrect invocation\");\n    },\n    gc = w,\n    Rc = He,\n    Cc = d(Function.toString);\n  gc(Rc.inspectSource) || (Rc.inspectSource = function (e) {\n    return Cc(e);\n  });\n  var vc = Rc.inspectSource,\n    Ic = d,\n    yc = n,\n    Ac = w,\n    bc = pn,\n    wc = vc,\n    Oc = function () {},\n    Nc = [],\n    Dc = ae(\"Reflect\", \"construct\"),\n    Pc = /^\\s*(?:class|function)\\b/,\n    Lc = Ic(Pc.exec),\n    kc = !Pc.exec(Oc),\n    Mc = function (e) {\n      if (!Ac(e)) return !1;\n      try {\n        return Dc(Oc, Nc, e), !0;\n      } catch (e) {\n        return !1;\n      }\n    },\n    Uc = function (e) {\n      if (!Ac(e)) return !1;\n      switch (bc(e)) {\n        case \"AsyncFunction\":\n        case \"GeneratorFunction\":\n        case \"AsyncGeneratorFunction\":\n          return !1;\n      }\n      try {\n        return kc || !!Lc(Pc, wc(e));\n      } catch (e) {\n        return !0;\n      }\n    };\n  Uc.sham = !0;\n  var xc,\n    Vc,\n    Fc,\n    Bc,\n    jc = !Dc || yc(function () {\n      var e;\n      return Mc(Mc.call) || !Mc(Object) || !Mc(function () {\n        e = !0;\n      }) || e;\n    }) ? Uc : Mc,\n    Gc = jc,\n    Wc = be,\n    Hc = TypeError,\n    Kc = ii,\n    Yc = function (e) {\n      if (Gc(e)) return e;\n      throw Hc(Wc(e) + \" is not a constructor\");\n    },\n    qc = Y,\n    zc = ut(\"species\"),\n    Jc = function (e, t) {\n      var i,\n        n = Kc(e).constructor;\n      return void 0 === n || qc(i = Kc(n)[zc]) ? t : Yc(i);\n    },\n    Xc = d([].slice),\n    Qc = TypeError,\n    Zc = function (e, t) {\n      if (e < t) throw Qc(\"Not enough arguments\");\n      return e;\n    },\n    $c = /(?:ipad|iphone|ipod).*applewebkit/i.test(ce),\n    ed = u,\n    td = f,\n    id = Xt,\n    nd = w,\n    rd = Ze,\n    od = n,\n    sd = co,\n    ad = Xc,\n    cd = At,\n    dd = Zc,\n    ld = $c,\n    hd = jn,\n    ud = ed.setImmediate,\n    pd = ed.clearImmediate,\n    _d = ed.process,\n    Ed = ed.Dispatch,\n    md = ed.Function,\n    fd = ed.MessageChannel,\n    Td = ed.String,\n    Sd = 0,\n    gd = {},\n    Rd = \"onreadystatechange\";\n  od(function () {\n    xc = ed.location;\n  });\n  var Cd = function (e) {\n      if (rd(gd, e)) {\n        var t = gd[e];\n        delete gd[e], t();\n      }\n    },\n    vd = function (e) {\n      return function () {\n        Cd(e);\n      };\n    },\n    Id = function (e) {\n      Cd(e.data);\n    },\n    yd = function (e) {\n      ed.postMessage(Td(e), xc.protocol + \"//\" + xc.host);\n    };\n  ud && pd || (ud = function (e) {\n    dd(arguments.length, 1);\n    var t = nd(e) ? e : md(e),\n      i = ad(arguments, 1);\n    return gd[++Sd] = function () {\n      td(t, void 0, i);\n    }, Vc(Sd), Sd;\n  }, pd = function (e) {\n    delete gd[e];\n  }, hd ? Vc = function (e) {\n    _d.nextTick(vd(e));\n  } : Ed && Ed.now ? Vc = function (e) {\n    Ed.now(vd(e));\n  } : fd && !ld ? (Bc = (Fc = new fd()).port2, Fc.port1.onmessage = Id, Vc = id(Bc.postMessage, Bc)) : ed.addEventListener && nd(ed.postMessage) && !ed.importScripts && xc && \"file:\" !== xc.protocol && !od(yd) ? (Vc = yd, ed.addEventListener(\"message\", Id, !1)) : Vc = Rd in cd(\"script\") ? function (e) {\n    sd.appendChild(cd(\"script\"))[Rd] = function () {\n      sd.removeChild(this), Cd(e);\n    };\n  } : function (e) {\n    setTimeout(vd(e), 0);\n  });\n  var Ad = {\n      set: ud,\n      clear: pd\n    },\n    bd = function () {\n      this.head = null, this.tail = null;\n    };\n  bd.prototype = {\n    add: function (e) {\n      var t = {\n          item: e,\n          next: null\n        },\n        i = this.tail;\n      i ? i.next = t : this.head = t, this.tail = t;\n    },\n    get: function () {\n      var e = this.head;\n      if (e) return null === (this.head = e.next) && (this.tail = null), e.item;\n    }\n  };\n  var wd,\n    Od,\n    Nd,\n    Dd,\n    Pd,\n    Ld = bd,\n    kd = /ipad|iphone|ipod/i.test(ce) && \"undefined\" != typeof Pebble,\n    Md = /web0s(?!.*chrome)/i.test(ce),\n    Ud = u,\n    xd = Xt,\n    Vd = O.f,\n    Fd = Ad.set,\n    Bd = Ld,\n    jd = $c,\n    Gd = kd,\n    Wd = Md,\n    Hd = jn,\n    Kd = Ud.MutationObserver || Ud.WebKitMutationObserver,\n    Yd = Ud.document,\n    qd = Ud.process,\n    zd = Ud.Promise,\n    Jd = Vd(Ud, \"queueMicrotask\"),\n    Xd = Jd && Jd.value;\n  if (!Xd) {\n    var Qd = new Bd(),\n      Zd = function () {\n        var e, t;\n        for (Hd && (e = qd.domain) && e.exit(); t = Qd.get();) try {\n          t();\n        } catch (e) {\n          throw Qd.head && wd(), e;\n        }\n        e && e.enter();\n      };\n    jd || Hd || Wd || !Kd || !Yd ? !Gd && zd && zd.resolve ? ((Dd = zd.resolve(void 0)).constructor = zd, Pd = xd(Dd.then, Dd), wd = function () {\n      Pd(Zd);\n    }) : Hd ? wd = function () {\n      qd.nextTick(Zd);\n    } : (Fd = xd(Fd, Ud), wd = function () {\n      Fd(Zd);\n    }) : (Od = !0, Nd = Yd.createTextNode(\"\"), new Kd(Zd).observe(Nd, {\n      characterData: !0\n    }), wd = function () {\n      Nd.data = Od = !Od;\n    }), Xd = function (e) {\n      Qd.head || wd(), Qd.add(e);\n    };\n  }\n  var $d = Xd,\n    el = function (e) {\n      try {\n        return {\n          error: !1,\n          value: e()\n        };\n      } catch (e) {\n        return {\n          error: !0,\n          value: e\n        };\n      }\n    },\n    tl = u.Promise,\n    il = \"object\" == typeof Deno && Deno && \"object\" == typeof Deno.version,\n    nl = !il && !jn && \"object\" == typeof window && \"object\" == typeof document,\n    rl = u,\n    ol = tl,\n    sl = w,\n    al = Yt,\n    cl = vc,\n    dl = ut,\n    ll = nl,\n    hl = il,\n    ul = Ee,\n    pl = ol && ol.prototype,\n    _l = dl(\"species\"),\n    El = !1,\n    ml = sl(rl.PromiseRejectionEvent),\n    fl = al(\"Promise\", function () {\n      var e = cl(ol),\n        t = e !== String(ol);\n      if (!t && 66 === ul) return !0;\n      if (!pl.catch || !pl.finally) return !0;\n      if (!ul || ul < 51 || !/native code/.test(e)) {\n        var i = new ol(function (e) {\n            e(1);\n          }),\n          n = function (e) {\n            e(function () {}, function () {});\n          };\n        if ((i.constructor = {})[_l] = n, !(El = i.then(function () {}) instanceof n)) return !0;\n      }\n      return !t && (ll || hl) && !ml;\n    }),\n    Tl = {\n      CONSTRUCTOR: fl,\n      REJECTION_EVENT: ml,\n      SUBCLASSING: El\n    },\n    Sl = {},\n    gl = De,\n    Rl = TypeError,\n    Cl = function (e) {\n      var t, i;\n      this.promise = new e(function (e, n) {\n        if (void 0 !== t || void 0 !== i) throw Rl(\"Bad Promise constructor\");\n        t = e, i = n;\n      }), this.resolve = gl(t), this.reject = gl(i);\n    };\n  Sl.f = function (e) {\n    return new Cl(e);\n  };\n  var vl,\n    Il,\n    yl = wi,\n    Al = jn,\n    bl = u,\n    wl = L,\n    Ol = ua,\n    Nl = Da,\n    Dl = function (e) {\n      var t = pc(e);\n      Ec && t && !t[mc] && _c(t, mc, {\n        configurable: !0,\n        get: function () {\n          return this;\n        }\n      });\n    },\n    Pl = De,\n    Ll = w,\n    kl = te,\n    Ml = Sc,\n    Ul = Jc,\n    xl = Ad.set,\n    Vl = $d,\n    Fl = function (e, t) {\n      try {\n        1 == arguments.length ? console.error(e) : console.error(e, t);\n      } catch (e) {}\n    },\n    Bl = el,\n    jl = Ld,\n    Gl = ra,\n    Wl = tl,\n    Hl = Tl,\n    Kl = Sl,\n    Yl = \"Promise\",\n    ql = Hl.CONSTRUCTOR,\n    zl = Hl.REJECTION_EVENT,\n    Jl = Gl.getterFor(Yl),\n    Xl = Gl.set,\n    Ql = Wl && Wl.prototype,\n    Zl = Wl,\n    $l = Ql,\n    eh = bl.TypeError,\n    th = bl.document,\n    ih = bl.process,\n    nh = Kl.f,\n    rh = nh,\n    oh = !!(th && th.createEvent && bl.dispatchEvent),\n    sh = \"unhandledrejection\",\n    ah = function (e) {\n      var t;\n      return !(!kl(e) || !Ll(t = e.then)) && t;\n    },\n    ch = function (e, t) {\n      var i,\n        n,\n        r,\n        o = t.value,\n        s = 1 == t.state,\n        a = s ? e.ok : e.fail,\n        c = e.resolve,\n        d = e.reject,\n        l = e.domain;\n      try {\n        a ? (s || (2 === t.rejection && ph(t), t.rejection = 1), !0 === a ? i = o : (l && l.enter(), i = a(o), l && (l.exit(), r = !0)), i === e.promise ? d(eh(\"Promise-chain cycle\")) : (n = ah(i)) ? wl(n, i, c, d) : c(i)) : d(o);\n      } catch (e) {\n        l && !r && l.exit(), d(e);\n      }\n    },\n    dh = function (e, t) {\n      e.notified || (e.notified = !0, Vl(function () {\n        for (var i, n = e.reactions; i = n.get();) ch(i, e);\n        e.notified = !1, t && !e.rejection && hh(e);\n      }));\n    },\n    lh = function (e, t, i) {\n      var n, r;\n      oh ? ((n = th.createEvent(\"Event\")).promise = t, n.reason = i, n.initEvent(e, !1, !0), bl.dispatchEvent(n)) : n = {\n        promise: t,\n        reason: i\n      }, !zl && (r = bl[\"on\" + e]) ? r(n) : e === sh && Fl(\"Unhandled promise rejection\", i);\n    },\n    hh = function (e) {\n      wl(xl, bl, function () {\n        var t,\n          i = e.facade,\n          n = e.value;\n        if (uh(e) && (t = Bl(function () {\n          Al ? ih.emit(\"unhandledRejection\", n, i) : lh(sh, i, n);\n        }), e.rejection = Al || uh(e) ? 2 : 1, t.error)) throw t.value;\n      });\n    },\n    uh = function (e) {\n      return 1 !== e.rejection && !e.parent;\n    },\n    ph = function (e) {\n      wl(xl, bl, function () {\n        var t = e.facade;\n        Al ? ih.emit(\"rejectionHandled\", t) : lh(\"rejectionhandled\", t, e.value);\n      });\n    },\n    _h = function (e, t, i) {\n      return function (n) {\n        e(t, n, i);\n      };\n    },\n    Eh = function (e, t, i) {\n      e.done || (e.done = !0, i && (e = i), e.value = t, e.state = 2, dh(e, !0));\n    },\n    mh = function (e, t, i) {\n      if (!e.done) {\n        e.done = !0, i && (e = i);\n        try {\n          if (e.facade === t) throw eh(\"Promise can't be resolved itself\");\n          var n = ah(t);\n          n ? Vl(function () {\n            var i = {\n              done: !1\n            };\n            try {\n              wl(n, t, _h(mh, i, e), _h(Eh, i, e));\n            } catch (t) {\n              Eh(i, t, e);\n            }\n          }) : (e.value = t, e.state = 1, dh(e, !1));\n        } catch (t) {\n          Eh({\n            done: !1\n          }, t, e);\n        }\n      }\n    };\n  ql && ($l = (Zl = function (e) {\n    Ml(this, $l), Pl(e), wl(vl, this);\n    var t = Jl(this);\n    try {\n      e(_h(mh, t), _h(Eh, t));\n    } catch (e) {\n      Eh(t, e);\n    }\n  }).prototype, (vl = function (e) {\n    Xl(this, {\n      type: Yl,\n      done: !1,\n      notified: !1,\n      parent: !1,\n      reactions: new jl(),\n      rejection: !1,\n      state: 0,\n      value: void 0\n    });\n  }).prototype = Ol($l, \"then\", function (e, t) {\n    var i = Jl(this),\n      n = nh(Ul(this, Zl));\n    return i.parent = !0, n.ok = !Ll(e) || e, n.fail = Ll(t) && t, n.domain = Al ? ih.domain : void 0, 0 == i.state ? i.reactions.add(n) : Vl(function () {\n      ch(n, i);\n    }), n.promise;\n  }), Il = function () {\n    var e = new vl(),\n      t = Jl(e);\n    this.promise = e, this.resolve = _h(mh, t), this.reject = _h(Eh, t);\n  }, Kl.f = nh = function (e) {\n    return e === Zl || undefined === e ? new Il(e) : rh(e);\n  }), yl({\n    global: !0,\n    constructor: !0,\n    wrap: !0,\n    forced: ql\n  }, {\n    Promise: Zl\n  }), Nl(Zl, Yl, !1, !0), Dl(Yl);\n  var fh = ut(\"iterator\"),\n    Th = !1;\n  try {\n    var Sh = 0,\n      gh = {\n        next: function () {\n          return {\n            done: !!Sh++\n          };\n        },\n        return: function () {\n          Th = !0;\n        }\n      };\n    gh[fh] = function () {\n      return this;\n    }, Array.from(gh, function () {\n      throw 2;\n    });\n  } catch (e) {}\n  var Rh = tl,\n    Ch = function (e, t) {\n      if (!t && !Th) return !1;\n      var i = !1;\n      try {\n        var n = {};\n        n[fh] = function () {\n          return {\n            next: function () {\n              return {\n                done: i = !0\n              };\n            }\n          };\n        }, e(n);\n      } catch (e) {}\n      return i;\n    },\n    vh = Tl.CONSTRUCTOR || !Ch(function (e) {\n      Rh.all(e).then(void 0, function () {});\n    }),\n    Ih = L,\n    yh = De,\n    Ah = Sl,\n    bh = el,\n    wh = Ts;\n  wi({\n    target: \"Promise\",\n    stat: !0,\n    forced: vh\n  }, {\n    all: function (e) {\n      var t = this,\n        i = Ah.f(t),\n        n = i.resolve,\n        r = i.reject,\n        o = bh(function () {\n          var i = yh(t.resolve),\n            o = [],\n            s = 0,\n            a = 1;\n          wh(e, function (e) {\n            var c = s++,\n              d = !1;\n            a++, Ih(i, t, e).then(function (e) {\n              d || (d = !0, o[c] = e, --a || n(o));\n            }, r);\n          }), --a || n(o);\n        });\n      return o.error && r(o.value), i.promise;\n    }\n  });\n  var Oh = wi,\n    Nh = Tl.CONSTRUCTOR;\n  tl && tl.prototype, Oh({\n    target: \"Promise\",\n    proto: !0,\n    forced: Nh,\n    real: !0\n  }, {\n    catch: function (e) {\n      return this.then(void 0, e);\n    }\n  });\n  var Dh = L,\n    Ph = De,\n    Lh = Sl,\n    kh = el,\n    Mh = Ts;\n  wi({\n    target: \"Promise\",\n    stat: !0,\n    forced: vh\n  }, {\n    race: function (e) {\n      var t = this,\n        i = Lh.f(t),\n        n = i.reject,\n        r = kh(function () {\n          var r = Ph(t.resolve);\n          Mh(e, function (e) {\n            Dh(r, t, e).then(i.resolve, n);\n          });\n        });\n      return r.error && n(r.value), i.promise;\n    }\n  });\n  var Uh = L,\n    xh = Sl;\n  wi({\n    target: \"Promise\",\n    stat: !0,\n    forced: Tl.CONSTRUCTOR\n  }, {\n    reject: function (e) {\n      var t = xh.f(this);\n      return Uh(t.reject, void 0, e), t.promise;\n    }\n  });\n  var Vh = ii,\n    Fh = te,\n    Bh = Sl,\n    jh = function (e, t) {\n      if (Vh(e), Fh(t) && t.constructor === e) return t;\n      var i = Bh.f(e);\n      return (0, i.resolve)(t), i.promise;\n    },\n    Gh = wi,\n    Wh = tl,\n    Hh = Tl.CONSTRUCTOR,\n    Kh = jh,\n    Yh = ae(\"Promise\"),\n    qh = !Hh;\n  Gh({\n    target: \"Promise\",\n    stat: !0,\n    forced: true\n  }, {\n    resolve: function (e) {\n      return Kh(qh && this === Yh ? Wh : this, e);\n    }\n  });\n  var zh = L,\n    Jh = De,\n    Xh = Sl,\n    Qh = el,\n    Zh = Ts;\n  wi({\n    target: \"Promise\",\n    stat: !0,\n    forced: vh\n  }, {\n    allSettled: function (e) {\n      var t = this,\n        i = Xh.f(t),\n        n = i.resolve,\n        r = i.reject,\n        o = Qh(function () {\n          var i = Jh(t.resolve),\n            r = [],\n            o = 0,\n            s = 1;\n          Zh(e, function (e) {\n            var a = o++,\n              c = !1;\n            s++, zh(i, t, e).then(function (e) {\n              c || (c = !0, r[a] = {\n                status: \"fulfilled\",\n                value: e\n              }, --s || n(r));\n            }, function (e) {\n              c || (c = !0, r[a] = {\n                status: \"rejected\",\n                reason: e\n              }, --s || n(r));\n            });\n          }), --s || n(r);\n        });\n      return o.error && r(o.value), i.promise;\n    }\n  });\n  var $h = L,\n    eu = De,\n    tu = ae,\n    iu = Sl,\n    nu = el,\n    ru = Ts,\n    ou = \"No one promise resolved\";\n  wi({\n    target: \"Promise\",\n    stat: !0,\n    forced: vh\n  }, {\n    any: function (e) {\n      var t = this,\n        i = tu(\"AggregateError\"),\n        n = iu.f(t),\n        r = n.resolve,\n        o = n.reject,\n        s = nu(function () {\n          var n = eu(t.resolve),\n            s = [],\n            a = 0,\n            c = 1,\n            d = !1;\n          ru(e, function (e) {\n            var l = a++,\n              h = !1;\n            c++, $h(n, t, e).then(function (e) {\n              h || d || (d = !0, r(e));\n            }, function (e) {\n              h || d || (h = !0, s[l] = e, --c || o(new i(s, ou)));\n            });\n          }), --c || o(new i(s, ou));\n        });\n      return s.error && o(s.value), n.promise;\n    }\n  });\n  var su = wi,\n    au = tl,\n    cu = n,\n    du = ae,\n    lu = w,\n    hu = Jc,\n    uu = jh,\n    pu = au && au.prototype;\n  su({\n    target: \"Promise\",\n    proto: !0,\n    real: !0,\n    forced: !!au && cu(function () {\n      pu.finally.call({\n        then: function () {}\n      }, function () {});\n    })\n  }, {\n    finally: function (e) {\n      var t = hu(this, du(\"Promise\")),\n        i = lu(e);\n      return this.then(i ? function (i) {\n        return uu(t, e()).then(function () {\n          return i;\n        });\n      } : e, i ? function (i) {\n        return uu(t, e()).then(function () {\n          throw i;\n        });\n      } : e);\n    }\n  });\n  var _u = d,\n    Eu = Li,\n    mu = mn,\n    fu = J,\n    Tu = _u(\"\".charAt),\n    Su = _u(\"\".charCodeAt),\n    gu = _u(\"\".slice),\n    Ru = function (e) {\n      return function (t, i) {\n        var n,\n          r,\n          o = mu(fu(t)),\n          s = Eu(i),\n          a = o.length;\n        return s < 0 || s >= a ? e ? \"\" : void 0 : (n = Su(o, s)) < 55296 || n > 56319 || s + 1 === a || (r = Su(o, s + 1)) < 56320 || r > 57343 ? e ? Tu(o, s) : n : e ? gu(o, s, s + 2) : r - 56320 + (n - 55296 << 10) + 65536;\n      };\n    },\n    Cu = {\n      codeAt: Ru(!1),\n      charAt: Ru(!0)\n    },\n    vu = Cu.charAt,\n    Iu = mn,\n    yu = ra,\n    Au = tc,\n    bu = ic,\n    wu = \"String Iterator\",\n    Ou = yu.set,\n    Nu = yu.getterFor(wu);\n  Au(String, \"String\", function (e) {\n    Ou(this, {\n      type: wu,\n      string: Iu(e),\n      index: 0\n    });\n  }, function () {\n    var e,\n      t = Nu(this),\n      i = t.string,\n      n = t.index;\n    return n >= i.length ? bu(void 0, !0) : (e = vu(i, n), t.index += e.length, bu(e, !1));\n  });\n  var Du = ie.Promise,\n    Pu = {\n      CSSRuleList: 0,\n      CSSStyleDeclaration: 0,\n      CSSValueList: 0,\n      ClientRectList: 0,\n      DOMRectList: 0,\n      DOMStringList: 0,\n      DOMTokenList: 1,\n      DataTransferItemList: 0,\n      FileList: 0,\n      HTMLAllCollection: 0,\n      HTMLCollection: 0,\n      HTMLFormElement: 0,\n      HTMLSelectElement: 0,\n      MediaList: 0,\n      MimeTypeArray: 0,\n      NamedNodeMap: 0,\n      NodeList: 1,\n      PaintRequestList: 0,\n      Plugin: 0,\n      PluginArray: 0,\n      SVGLengthList: 0,\n      SVGNumberList: 0,\n      SVGPathSegList: 0,\n      SVGPointList: 0,\n      SVGStringList: 0,\n      SVGTransformList: 0,\n      SourceBufferList: 0,\n      StyleSheetList: 0,\n      TextTrackCueList: 0,\n      TextTrackList: 0,\n      TouchList: 0\n    },\n    Lu = u,\n    ku = pn,\n    Mu = mi,\n    Uu = xo,\n    xu = ut(\"toStringTag\");\n  for (var Vu in Pu) {\n    var Fu = Lu[Vu],\n      Bu = Fu && Fu.prototype;\n    Bu && ku(Bu) !== xu && Mu(Bu, xu, Vu), Uu[Vu] = Uu.Array;\n  }\n  var ju = Du,\n    Gu = i(ju);\n  const Wu = ir;\n  function Hu(e, t) {\n    const i = e && e.navigator;\n    if (!i.mediaDevices) return;\n    const n = function (e) {\n        if (\"object\" != typeof e || e.mandatory || e.optional) return e;\n        const t = {};\n        return Object.keys(e).forEach(i => {\n          if (\"require\" === i || \"advanced\" === i || \"mediaSource\" === i) return;\n          const n = \"object\" == typeof e[i] ? e[i] : {\n            ideal: e[i]\n          };\n          void 0 !== n.exact && \"number\" == typeof n.exact && (n.min = n.max = n.exact);\n          const r = function (e, t) {\n            return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : \"deviceId\" === t ? \"sourceId\" : t;\n          };\n          if (void 0 !== n.ideal) {\n            t.optional = t.optional || [];\n            let e = {};\n            \"number\" == typeof n.ideal ? (e[r(\"min\", i)] = n.ideal, t.optional.push(e), e = {}, e[r(\"max\", i)] = n.ideal, t.optional.push(e)) : (e[r(\"\", i)] = n.ideal, t.optional.push(e));\n          }\n          void 0 !== n.exact && \"number\" != typeof n.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[r(\"\", i)] = n.exact) : [\"min\", \"max\"].forEach(e => {\n            void 0 !== n[e] && (t.mandatory = t.mandatory || {}, t.mandatory[r(e, i)] = n[e]);\n          });\n        }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t;\n      },\n      r = function (e, r) {\n        if (t.version >= 61) return r(e);\n        if ((e = JSON.parse(JSON.stringify(e))) && \"object\" == typeof e.audio) {\n          const t = function (e, t, i) {\n            t in e && !(i in e) && (e[i] = e[t], delete e[t]);\n          };\n          t((e = JSON.parse(JSON.stringify(e))).audio, \"autoGainControl\", \"googAutoGainControl\"), t(e.audio, \"noiseSuppression\", \"googNoiseSuppression\"), e.audio = n(e.audio);\n        }\n        if (e && \"object\" == typeof e.video) {\n          let o = e.video.facingMode;\n          o = o && (\"object\" == typeof o ? o : {\n            ideal: o\n          });\n          const s = t.version < 66;\n          if (o && (\"user\" === o.exact || \"environment\" === o.exact || \"user\" === o.ideal || \"environment\" === o.ideal) && (!i.mediaDevices.getSupportedConstraints || !i.mediaDevices.getSupportedConstraints().facingMode || s)) {\n            let t;\n            if (delete e.video.facingMode, \"environment\" === o.exact || \"environment\" === o.ideal ? t = [\"back\", \"rear\"] : \"user\" !== o.exact && \"user\" !== o.ideal || (t = [\"front\"]), t) return i.mediaDevices.enumerateDevices().then(i => {\n              let s = (i = i.filter(e => \"videoinput\" === e.kind)).find(e => t.some(t => {\n                var i;\n                return Dn(i = e.label.toLowerCase()).call(i, t);\n              }));\n              return !s && i.length && Dn(t).call(t, \"back\") && (s = i[i.length - 1]), s && (e.video.deviceId = o.exact ? {\n                exact: s.deviceId\n              } : {\n                ideal: s.deviceId\n              }), e.video = n(e.video), Wu(\"chrome: \" + JSON.stringify(e)), r(e);\n            });\n          }\n          e.video = n(e.video);\n        }\n        return Wu(\"chrome: \" + JSON.stringify(e)), r(e);\n      },\n      o = function (e) {\n        return t.version >= 64 ? e : {\n          name: {\n            PermissionDeniedError: \"NotAllowedError\",\n            PermissionDismissedError: \"NotAllowedError\",\n            InvalidStateError: \"NotAllowedError\",\n            DevicesNotFoundError: \"NotFoundError\",\n            ConstraintNotSatisfiedError: \"OverconstrainedError\",\n            TrackStartError: \"NotReadableError\",\n            MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n            MediaDeviceKillSwitchOn: \"NotAllowedError\",\n            TabCaptureError: \"AbortError\",\n            ScreenCaptureError: \"AbortError\",\n            DeviceCaptureError: \"AbortError\"\n          }[e.name] || e.name,\n          message: e.message,\n          constraint: e.constraint || e.constraintName,\n          toString() {\n            return this.name + (this.message && \": \") + this.message;\n          }\n        };\n      };\n    if (i.getUserMedia = function (e, t, n) {\n      r(e, e => {\n        i.webkitGetUserMedia(e, t, e => {\n          n && n(o(e));\n        });\n      });\n    }.bind(i), i.mediaDevices.getUserMedia) {\n      const e = i.mediaDevices.getUserMedia.bind(i.mediaDevices);\n      i.mediaDevices.getUserMedia = function (t) {\n        return r(t, t => e(t).then(e => {\n          if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(e => {\n            e.stop();\n          }), new DOMException(\"\", \"NotFoundError\");\n          return e;\n        }, e => Gu.reject(o(e))));\n      };\n    }\n  }\n  function Ku(e) {\n    e.MediaStream = e.MediaStream || e.webkitMediaStream;\n  }\n  function Yu(e) {\n    if (\"object\" == typeof e && e.RTCPeerConnection && !(\"ontrack\" in e.RTCPeerConnection.prototype)) {\n      Object.defineProperty(e.RTCPeerConnection.prototype, \"ontrack\", {\n        get() {\n          return this._ontrack;\n        },\n        set(e) {\n          this._ontrack && this.removeEventListener(\"track\", this._ontrack), this.addEventListener(\"track\", this._ontrack = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      });\n      const t = e.RTCPeerConnection.prototype.setRemoteDescription;\n      e.RTCPeerConnection.prototype.setRemoteDescription = function () {\n        return this._ontrackpoly || (this._ontrackpoly = t => {\n          t.stream.addEventListener(\"addtrack\", i => {\n            let n;\n            n = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === i.track.id) : {\n              track: i.track\n            };\n            const r = new Event(\"track\");\n            r.track = i.track, r.receiver = n, r.transceiver = {\n              receiver: n\n            }, r.streams = [t.stream], this.dispatchEvent(r);\n          }), t.stream.getTracks().forEach(i => {\n            let n;\n            n = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === i.id) : {\n              track: i\n            };\n            const r = new Event(\"track\");\n            r.track = i, r.receiver = n, r.transceiver = {\n              receiver: n\n            }, r.streams = [t.stream], this.dispatchEvent(r);\n          });\n        }, this.addEventListener(\"addstream\", this._ontrackpoly)), t.apply(this, arguments);\n      };\n    } else $n(e, \"track\", e => (e.transceiver || Object.defineProperty(e, \"transceiver\", {\n      value: {\n        receiver: e.receiver\n      }\n    }), e));\n  }\n  function qu(e) {\n    if (\"object\" == typeof e && e.RTCPeerConnection && !(\"getSenders\" in e.RTCPeerConnection.prototype) && \"createDTMFSender\" in e.RTCPeerConnection.prototype) {\n      const t = function (e, t) {\n        return {\n          track: t,\n          get dtmf() {\n            return void 0 === this._dtmf && (\"audio\" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf;\n          },\n          _pc: e\n        };\n      };\n      if (!e.RTCPeerConnection.prototype.getSenders) {\n        e.RTCPeerConnection.prototype.getSenders = function () {\n          return this._senders = this._senders || [], this._senders.slice();\n        };\n        const i = e.RTCPeerConnection.prototype.addTrack;\n        e.RTCPeerConnection.prototype.addTrack = function (e, n) {\n          let r = i.apply(this, arguments);\n          return r || (r = t(this, e), this._senders.push(r)), r;\n        };\n        const n = e.RTCPeerConnection.prototype.removeTrack;\n        e.RTCPeerConnection.prototype.removeTrack = function (e) {\n          n.apply(this, arguments);\n          const t = this._senders.indexOf(e);\n          -1 !== t && this._senders.splice(t, 1);\n        };\n      }\n      const i = e.RTCPeerConnection.prototype.addStream;\n      e.RTCPeerConnection.prototype.addStream = function (e) {\n        this._senders = this._senders || [], i.apply(this, [e]), e.getTracks().forEach(e => {\n          this._senders.push(t(this, e));\n        });\n      };\n      const n = e.RTCPeerConnection.prototype.removeStream;\n      e.RTCPeerConnection.prototype.removeStream = function (e) {\n        this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach(e => {\n          const t = this._senders.find(t => t.track === e);\n          t && this._senders.splice(this._senders.indexOf(t), 1);\n        });\n      };\n    } else if (\"object\" == typeof e && e.RTCPeerConnection && \"getSenders\" in e.RTCPeerConnection.prototype && \"createDTMFSender\" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !(\"dtmf\" in e.RTCRtpSender.prototype)) {\n      const t = e.RTCPeerConnection.prototype.getSenders;\n      e.RTCPeerConnection.prototype.getSenders = function () {\n        const e = t.apply(this, []);\n        return e.forEach(e => e._pc = this), e;\n      }, Object.defineProperty(e.RTCRtpSender.prototype, \"dtmf\", {\n        get() {\n          return void 0 === this._dtmf && (\"audio\" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;\n        }\n      });\n    }\n  }\n  function zu(e) {\n    if (!e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection.prototype.getStats;\n    e.RTCPeerConnection.prototype.getStats = function () {\n      const _arguments = Array.prototype.slice.call(arguments),\n        e = _arguments[0],\n        i = _arguments[1],\n        n = _arguments[2];\n      if (arguments.length > 0 && \"function\" == typeof e) return t.apply(this, arguments);\n      if (0 === t.length && (0 === arguments.length || \"function\" != typeof e)) return t.apply(this, []);\n      const r = function (e) {\n          const t = {};\n          return e.result().forEach(e => {\n            const i = {\n              id: e.id,\n              timestamp: e.timestamp,\n              type: {\n                localcandidate: \"local-candidate\",\n                remotecandidate: \"remote-candidate\"\n              }[e.type] || e.type\n            };\n            e.names().forEach(t => {\n              i[t] = e.stat(t);\n            }), t[i.id] = i;\n          }), t;\n        },\n        o = function (e) {\n          return new Map(Object.keys(e).map(t => [t, e[t]]));\n        };\n      if (arguments.length >= 2) {\n        const n = function (e) {\n          i(o(r(e)));\n        };\n        return t.apply(this, [n, e]);\n      }\n      return new Gu((e, i) => {\n        t.apply(this, [function (t) {\n          e(o(r(t)));\n        }, i]);\n      }).then(i, n);\n    };\n  }\n  function Ju(e) {\n    if (!(\"object\" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;\n    if (!(\"getStats\" in e.RTCRtpSender.prototype)) {\n      const t = e.RTCPeerConnection.prototype.getSenders;\n      t && (e.RTCPeerConnection.prototype.getSenders = function () {\n        const e = t.apply(this, []);\n        return e.forEach(e => e._pc = this), e;\n      });\n      const i = e.RTCPeerConnection.prototype.addTrack;\n      i && (e.RTCPeerConnection.prototype.addTrack = function () {\n        const e = i.apply(this, arguments);\n        return e._pc = this, e;\n      }), e.RTCRtpSender.prototype.getStats = function () {\n        const e = this;\n        return this._pc.getStats().then(t => ar(t, e.track, !0));\n      };\n    }\n    if (!(\"getStats\" in e.RTCRtpReceiver.prototype)) {\n      const t = e.RTCPeerConnection.prototype.getReceivers;\n      t && (e.RTCPeerConnection.prototype.getReceivers = function () {\n        const e = t.apply(this, []);\n        return e.forEach(e => e._pc = this), e;\n      }), $n(e, \"track\", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function () {\n        const e = this;\n        return this._pc.getStats().then(t => ar(t, e.track, !1));\n      };\n    }\n    if (!(\"getStats\" in e.RTCRtpSender.prototype) || !(\"getStats\" in e.RTCRtpReceiver.prototype)) return;\n    const t = e.RTCPeerConnection.prototype.getStats;\n    e.RTCPeerConnection.prototype.getStats = function () {\n      if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {\n        const e = arguments[0];\n        let t, i, n;\n        return this.getSenders().forEach(i => {\n          i.track === e && (t ? n = !0 : t = i);\n        }), this.getReceivers().forEach(t => (t.track === e && (i ? n = !0 : i = t), t.track === e)), n || t && i ? Gu.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\")) : t ? t.getStats() : i ? i.getStats() : Gu.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n      }\n      return t.apply(this, arguments);\n    };\n  }\n  function Xu(e) {\n    e.RTCPeerConnection.prototype.getLocalStreams = function () {\n      return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(e => this._shimmedLocalStreams[e][0]);\n    };\n    const t = e.RTCPeerConnection.prototype.addTrack;\n    e.RTCPeerConnection.prototype.addTrack = function (e, i) {\n      if (!i) return t.apply(this, arguments);\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      const n = t.apply(this, arguments);\n      return this._shimmedLocalStreams[i.id] ? -1 === this._shimmedLocalStreams[i.id].indexOf(n) && this._shimmedLocalStreams[i.id].push(n) : this._shimmedLocalStreams[i.id] = [i, n], n;\n    };\n    const i = e.RTCPeerConnection.prototype.addStream;\n    e.RTCPeerConnection.prototype.addStream = function (e) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(e => {\n        const t = this.getSenders().find(t => t.track === e);\n        if (t) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      });\n      const t = this.getSenders();\n      i.apply(this, arguments);\n      const n = this.getSenders().filter(e => -1 === t.indexOf(e));\n      this._shimmedLocalStreams[e.id] = [e].concat(n);\n    };\n    const n = e.RTCPeerConnection.prototype.removeStream;\n    e.RTCPeerConnection.prototype.removeStream = function (e) {\n      return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], n.apply(this, arguments);\n    };\n    const r = e.RTCPeerConnection.prototype.removeTrack;\n    e.RTCPeerConnection.prototype.removeTrack = function (e) {\n      return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(t => {\n        const i = this._shimmedLocalStreams[t].indexOf(e);\n        -1 !== i && this._shimmedLocalStreams[t].splice(i, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t];\n      }), r.apply(this, arguments);\n    };\n  }\n  function Qu(e, t) {\n    if (!e.RTCPeerConnection) return;\n    if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return Xu(e);\n    const i = e.RTCPeerConnection.prototype.getLocalStreams;\n    e.RTCPeerConnection.prototype.getLocalStreams = function () {\n      const e = i.apply(this);\n      return this._reverseStreams = this._reverseStreams || {}, e.map(e => this._reverseStreams[e.id]);\n    };\n    const n = e.RTCPeerConnection.prototype.addStream;\n    e.RTCPeerConnection.prototype.addStream = function (t) {\n      if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(e => {\n        const t = this.getSenders().find(t => t.track === e);\n        if (t) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      }), !this._reverseStreams[t.id]) {\n        const i = new e.MediaStream(t.getTracks());\n        this._streams[t.id] = i, this._reverseStreams[i.id] = t, t = i;\n      }\n      n.apply(this, [t]);\n    };\n    const r = e.RTCPeerConnection.prototype.removeStream;\n    function o(e, t) {\n      let i = t.sdp;\n      return Object.keys(e._reverseStreams || []).forEach(t => {\n        const n = e._reverseStreams[t],\n          r = e._streams[n.id];\n        i = i.replace(new RegExp(r.id, \"g\"), n.id);\n      }), new RTCSessionDescription({\n        type: t.type,\n        sdp: i\n      });\n    }\n    e.RTCPeerConnection.prototype.removeStream = function (e) {\n      this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id];\n    }, e.RTCPeerConnection.prototype.addTrack = function (t, i) {\n      if (\"closed\" === this.signalingState) throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n      const n = [].slice.call(arguments, 1);\n      if (1 !== n.length || !n[0].getTracks().find(e => e === t)) throw new DOMException(\"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\", \"NotSupportedError\");\n      const r = this.getSenders().find(e => e.track === t);\n      if (r) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};\n      const o = this._streams[i.id];\n      if (o) o.addTrack(t), Gu.resolve().then(() => {\n        this.dispatchEvent(new Event(\"negotiationneeded\"));\n      });else {\n        const n = new e.MediaStream([t]);\n        this._streams[i.id] = n, this._reverseStreams[n.id] = i, this.addStream(n);\n      }\n      return this.getSenders().find(e => e.track === t);\n    }, [\"createOffer\", \"createAnswer\"].forEach(function (t) {\n      const i = e.RTCPeerConnection.prototype[t],\n        n = {\n          [t]() {\n            const e = arguments;\n            return arguments.length && \"function\" == typeof arguments[0] ? i.apply(this, [t => {\n              const i = o(this, t);\n              e[0].apply(null, [i]);\n            }, t => {\n              e[1] && e[1].apply(null, t);\n            }, arguments[2]]) : i.apply(this, arguments).then(e => o(this, e));\n          }\n        };\n      e.RTCPeerConnection.prototype[t] = n[t];\n    });\n    const s = e.RTCPeerConnection.prototype.setLocalDescription;\n    e.RTCPeerConnection.prototype.setLocalDescription = function () {\n      return arguments.length && arguments[0].type ? (arguments[0] = function (e, t) {\n        let i = t.sdp;\n        return Object.keys(e._reverseStreams || []).forEach(t => {\n          const n = e._reverseStreams[t],\n            r = e._streams[n.id];\n          i = i.replace(new RegExp(n.id, \"g\"), r.id);\n        }), new RTCSessionDescription({\n          type: t.type,\n          sdp: i\n        });\n      }(this, arguments[0]), s.apply(this, arguments)) : s.apply(this, arguments);\n    };\n    const a = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, \"localDescription\");\n    Object.defineProperty(e.RTCPeerConnection.prototype, \"localDescription\", {\n      get() {\n        const e = a.get.apply(this);\n        return \"\" === e.type ? e : o(this, e);\n      }\n    }), e.RTCPeerConnection.prototype.removeTrack = function (e) {\n      if (\"closed\" === this.signalingState) throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n      if (!e._pc) throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\", \"TypeError\");\n      if (!(e._pc === this)) throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n      let t;\n      this._streams = this._streams || {}, Object.keys(this._streams).forEach(i => {\n        this._streams[i].getTracks().find(t => e.track === t) && (t = this._streams[i]);\n      }), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event(\"negotiationneeded\")));\n    };\n  }\n  function Zu(e, t) {\n    !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function (t) {\n      const i = e.RTCPeerConnection.prototype[t],\n        n = {\n          [t]() {\n            return arguments[0] = new (\"addIceCandidate\" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments);\n          }\n        };\n      e.RTCPeerConnection.prototype[t] = n[t];\n    });\n  }\n  function $u(e, t) {\n    $n(e, \"negotiationneeded\", e => {\n      const i = e.target;\n      if (!(t.version < 72 || i.getConfiguration && \"plan-b\" === i.getConfiguration().sdpSemantics) || \"stable\" === i.signalingState) return e;\n    });\n  }\n  var ep = Object.freeze({\n    __proto__: null,\n    fixNegotiationNeeded: $u,\n    shimAddTrackRemoveTrack: Qu,\n    shimAddTrackRemoveTrackWithNative: Xu,\n    shimGetDisplayMedia: function (e, t) {\n      e.navigator.mediaDevices && \"getDisplayMedia\" in e.navigator.mediaDevices || e.navigator.mediaDevices && (\"function\" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function (i) {\n        return t(i).then(t => {\n          const n = i.video && i.video.width,\n            r = i.video && i.video.height,\n            o = i.video && i.video.frameRate;\n          return i.video = {\n            mandatory: {\n              chromeMediaSource: \"desktop\",\n              chromeMediaSourceId: t,\n              maxFrameRate: o || 3\n            }\n          }, n && (i.video.mandatory.maxWidth = n), r && (i.video.mandatory.maxHeight = r), e.navigator.mediaDevices.getUserMedia(i);\n        });\n      } : console.error(\"shimGetDisplayMedia: getSourceId argument is not a function\"));\n    },\n    shimGetSendersWithDtmf: qu,\n    shimGetStats: zu,\n    shimGetUserMedia: Hu,\n    shimMediaStream: Ku,\n    shimOnTrack: Yu,\n    shimPeerConnection: Zu,\n    shimSenderReceiverGetStats: Ju\n  });\n  function tp(e, t) {\n    const i = e && e.navigator,\n      n = e && e.MediaStreamTrack;\n    if (i.getUserMedia = function (e, t, n) {\n      nr(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\"), i.mediaDevices.getUserMedia(e).then(t, n);\n    }, !(t.version > 55 && \"autoGainControl\" in i.mediaDevices.getSupportedConstraints())) {\n      const e = function (e, t, i) {\n          t in e && !(i in e) && (e[i] = e[t], delete e[t]);\n        },\n        t = i.mediaDevices.getUserMedia.bind(i.mediaDevices);\n      if (i.mediaDevices.getUserMedia = function (i) {\n        return \"object\" == typeof i && \"object\" == typeof i.audio && (i = JSON.parse(JSON.stringify(i)), e(i.audio, \"autoGainControl\", \"mozAutoGainControl\"), e(i.audio, \"noiseSuppression\", \"mozNoiseSuppression\")), t(i);\n      }, n && n.prototype.getSettings) {\n        const t = n.prototype.getSettings;\n        n.prototype.getSettings = function () {\n          const i = t.apply(this, arguments);\n          return e(i, \"mozAutoGainControl\", \"autoGainControl\"), e(i, \"mozNoiseSuppression\", \"noiseSuppression\"), i;\n        };\n      }\n      if (n && n.prototype.applyConstraints) {\n        const t = n.prototype.applyConstraints;\n        n.prototype.applyConstraints = function (i) {\n          return \"audio\" === this.kind && \"object\" == typeof i && (i = JSON.parse(JSON.stringify(i)), e(i, \"autoGainControl\", \"mozAutoGainControl\"), e(i, \"noiseSuppression\", \"mozNoiseSuppression\")), t.apply(this, [i]);\n        };\n      }\n    }\n  }\n  function ip(e) {\n    \"object\" == typeof e && e.RTCTrackEvent && \"receiver\" in e.RTCTrackEvent.prototype && !(\"transceiver\" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, \"transceiver\", {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n  function np(e, t) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;\n    !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function (t) {\n      const i = e.RTCPeerConnection.prototype[t],\n        n = {\n          [t]() {\n            return arguments[0] = new (\"addIceCandidate\" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments);\n          }\n        };\n      e.RTCPeerConnection.prototype[t] = n[t];\n    });\n    const i = {\n        inboundrtp: \"inbound-rtp\",\n        outboundrtp: \"outbound-rtp\",\n        candidatepair: \"candidate-pair\",\n        localcandidate: \"local-candidate\",\n        remotecandidate: \"remote-candidate\"\n      },\n      n = e.RTCPeerConnection.prototype.getStats;\n    e.RTCPeerConnection.prototype.getStats = function () {\n      const _arguments2 = Array.prototype.slice.call(arguments),\n        e = _arguments2[0],\n        r = _arguments2[1],\n        o = _arguments2[2];\n      return n.apply(this, [e || null]).then(e => {\n        if (t.version < 53 && !r) try {\n          e.forEach(e => {\n            e.type = i[e.type] || e.type;\n          });\n        } catch (t) {\n          if (\"TypeError\" !== t.name) throw t;\n          e.forEach((t, n) => {\n            e.set(n, Object.assign({}, t, {\n              type: i[t.type] || t.type\n            }));\n          });\n        }\n        return e;\n      }).then(r, o);\n    };\n  }\n  function rp(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;\n    if (e.RTCRtpSender && \"getStats\" in e.RTCRtpSender.prototype) return;\n    const t = e.RTCPeerConnection.prototype.getSenders;\n    t && (e.RTCPeerConnection.prototype.getSenders = function () {\n      const e = t.apply(this, []);\n      return e.forEach(e => e._pc = this), e;\n    });\n    const i = e.RTCPeerConnection.prototype.addTrack;\n    i && (e.RTCPeerConnection.prototype.addTrack = function () {\n      const e = i.apply(this, arguments);\n      return e._pc = this, e;\n    }), e.RTCRtpSender.prototype.getStats = function () {\n      return this.track ? this._pc.getStats(this.track) : Gu.resolve(new Map());\n    };\n  }\n  function op(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;\n    if (e.RTCRtpSender && \"getStats\" in e.RTCRtpReceiver.prototype) return;\n    const t = e.RTCPeerConnection.prototype.getReceivers;\n    t && (e.RTCPeerConnection.prototype.getReceivers = function () {\n      const e = t.apply(this, []);\n      return e.forEach(e => e._pc = this), e;\n    }), $n(e, \"track\", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function () {\n      return this._pc.getStats(this.track);\n    };\n  }\n  function sp(e) {\n    e.RTCPeerConnection && !(\"removeStream\" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function (e) {\n      nr(\"removeStream\", \"removeTrack\"), this.getSenders().forEach(t => {\n        var i;\n        t.track && Dn(i = e.getTracks()).call(i, t.track) && this.removeTrack(t);\n      });\n    });\n  }\n  function ap(e) {\n    e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel);\n  }\n  function cp(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection.prototype.addTransceiver;\n    t && (e.RTCPeerConnection.prototype.addTransceiver = function () {\n      this.setParametersPromises = [];\n      let e = arguments[1] && arguments[1].sendEncodings;\n      void 0 === e && (e = []), e = [...e];\n      const i = e.length > 0;\n      i && e.forEach(e => {\n        if (\"rid\" in e) {\n          if (!/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError(\"Invalid RID value provided.\");\n        }\n        if (\"scaleResolutionDownBy\" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n        if (\"maxFramerate\" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError(\"max_framerate must be >= 0.0\");\n      });\n      const n = t.apply(this, arguments);\n      if (i) {\n        const t = n.sender,\n          i = t.getParameters();\n        (!(\"encodings\" in i) || 1 === i.encodings.length && 0 === Object.keys(i.encodings[0]).length) && (i.encodings = e, t.sendEncodings = e, this.setParametersPromises.push(t.setParameters(i).then(() => {\n          delete t.sendEncodings;\n        }).catch(() => {\n          delete t.sendEncodings;\n        })));\n      }\n      return n;\n    });\n  }\n  function dp(e) {\n    if (\"object\" != typeof e || !e.RTCRtpSender) return;\n    const t = e.RTCRtpSender.prototype.getParameters;\n    t && (e.RTCRtpSender.prototype.getParameters = function () {\n      const e = t.apply(this, arguments);\n      return \"encodings\" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e;\n    });\n  }\n  function lp(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection.prototype.createOffer;\n    e.RTCPeerConnection.prototype.createOffer = function () {\n      return this.setParametersPromises && this.setParametersPromises.length ? Gu.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {\n        this.setParametersPromises = [];\n      }) : t.apply(this, arguments);\n    };\n  }\n  function hp(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection.prototype.createAnswer;\n    e.RTCPeerConnection.prototype.createAnswer = function () {\n      return this.setParametersPromises && this.setParametersPromises.length ? Gu.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {\n        this.setParametersPromises = [];\n      }) : t.apply(this, arguments);\n    };\n  }\n  var up = Object.freeze({\n    __proto__: null,\n    shimAddTransceiver: cp,\n    shimCreateAnswer: hp,\n    shimCreateOffer: lp,\n    shimGetDisplayMedia: function (e, t) {\n      e.navigator.mediaDevices && \"getDisplayMedia\" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function (i) {\n        if (!i || !i.video) {\n          const e = new DOMException(\"getDisplayMedia without video constraints is undefined\");\n          return e.name = \"NotFoundError\", e.code = 8, Gu.reject(e);\n        }\n        return !0 === i.video ? i.video = {\n          mediaSource: t\n        } : i.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(i);\n      });\n    },\n    shimGetParameters: dp,\n    shimGetUserMedia: tp,\n    shimOnTrack: ip,\n    shimPeerConnection: np,\n    shimRTCDataChannel: ap,\n    shimReceiverGetStats: op,\n    shimRemoveStream: sp,\n    shimSenderGetStats: rp\n  });\n  function pp(e) {\n    if (\"object\" == typeof e && e.RTCPeerConnection) {\n      if (\"getLocalStreams\" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () {\n        return this._localStreams || (this._localStreams = []), this._localStreams;\n      }), !(\"addStream\" in e.RTCPeerConnection.prototype)) {\n        const t = e.RTCPeerConnection.prototype.addTrack;\n        e.RTCPeerConnection.prototype.addStream = function (e) {\n          var i;\n          this._localStreams || (this._localStreams = []), Dn(i = this._localStreams).call(i, e) || this._localStreams.push(e), e.getAudioTracks().forEach(i => t.call(this, i, e)), e.getVideoTracks().forEach(i => t.call(this, i, e));\n        }, e.RTCPeerConnection.prototype.addTrack = function (e) {\n          for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), r = 1; r < i; r++) n[r - 1] = arguments[r];\n          return n && n.forEach(e => {\n            var t;\n            this._localStreams ? Dn(t = this._localStreams).call(t, e) || this._localStreams.push(e) : this._localStreams = [e];\n          }), t.apply(this, arguments);\n        };\n      }\n      \"removeStream\" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) {\n        this._localStreams || (this._localStreams = []);\n        const t = this._localStreams.indexOf(e);\n        if (-1 === t) return;\n        this._localStreams.splice(t, 1);\n        const i = e.getTracks();\n        this.getSenders().forEach(e => {\n          Dn(i).call(i, e.track) && this.removeTrack(e);\n        });\n      });\n    }\n  }\n  function _p(e) {\n    if (\"object\" == typeof e && e.RTCPeerConnection && (\"getRemoteStreams\" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () {\n      return this._remoteStreams ? this._remoteStreams : [];\n    }), !(\"onaddstream\" in e.RTCPeerConnection.prototype))) {\n      Object.defineProperty(e.RTCPeerConnection.prototype, \"onaddstream\", {\n        get() {\n          return this._onaddstream;\n        },\n        set(e) {\n          this._onaddstream && (this.removeEventListener(\"addstream\", this._onaddstream), this.removeEventListener(\"track\", this._onaddstreampoly)), this.addEventListener(\"addstream\", this._onaddstream = e), this.addEventListener(\"track\", this._onaddstreampoly = e => {\n            e.streams.forEach(e => {\n              var t;\n              if (this._remoteStreams || (this._remoteStreams = []), Dn(t = this._remoteStreams).call(t, e)) return;\n              this._remoteStreams.push(e);\n              const i = new Event(\"addstream\");\n              i.stream = e, this.dispatchEvent(i);\n            });\n          });\n        }\n      });\n      const t = e.RTCPeerConnection.prototype.setRemoteDescription;\n      e.RTCPeerConnection.prototype.setRemoteDescription = function () {\n        const e = this;\n        return this._onaddstreampoly || this.addEventListener(\"track\", this._onaddstreampoly = function (t) {\n          t.streams.forEach(t => {\n            if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;\n            e._remoteStreams.push(t);\n            const i = new Event(\"addstream\");\n            i.stream = t, e.dispatchEvent(i);\n          });\n        }), t.apply(e, arguments);\n      };\n    }\n  }\n  function Ep(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection.prototype,\n      i = t.createOffer,\n      n = t.createAnswer,\n      r = t.setLocalDescription,\n      o = t.setRemoteDescription,\n      s = t.addIceCandidate;\n    t.createOffer = function (e, t) {\n      const n = arguments.length >= 2 ? arguments[2] : arguments[0],\n        r = i.apply(this, [n]);\n      return t ? (r.then(e, t), Gu.resolve()) : r;\n    }, t.createAnswer = function (e, t) {\n      const i = arguments.length >= 2 ? arguments[2] : arguments[0],\n        r = n.apply(this, [i]);\n      return t ? (r.then(e, t), Gu.resolve()) : r;\n    };\n    let a = function (e, t, i) {\n      const n = r.apply(this, [e]);\n      return i ? (n.then(t, i), Gu.resolve()) : n;\n    };\n    t.setLocalDescription = a, a = function (e, t, i) {\n      const n = o.apply(this, [e]);\n      return i ? (n.then(t, i), Gu.resolve()) : n;\n    }, t.setRemoteDescription = a, a = function (e, t, i) {\n      const n = s.apply(this, [e]);\n      return i ? (n.then(t, i), Gu.resolve()) : n;\n    }, t.addIceCandidate = a;\n  }\n  function mp(e) {\n    const t = e && e.navigator;\n    if (t.mediaDevices && t.mediaDevices.getUserMedia) {\n      const e = t.mediaDevices,\n        i = e.getUserMedia.bind(e);\n      t.mediaDevices.getUserMedia = e => i(fp(e));\n    }\n    !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, i, n) {\n      t.mediaDevices.getUserMedia(e).then(i, n);\n    }.bind(t));\n  }\n  function fp(e) {\n    return e && void 0 !== e.video ? Object.assign({}, e, {\n      video: or(e.video)\n    }) : e;\n  }\n  function Tp(e) {\n    if (!e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection;\n    e.RTCPeerConnection = function (e, i) {\n      if (e && e.iceServers) {\n        const t = [];\n        for (let i = 0; i < e.iceServers.length; i++) {\n          let n = e.iceServers[i];\n          !n.hasOwnProperty(\"urls\") && n.hasOwnProperty(\"url\") ? (nr(\"RTCIceServer.url\", \"RTCIceServer.urls\"), n = JSON.parse(JSON.stringify(n)), n.urls = n.url, delete n.url, t.push(n)) : t.push(e.iceServers[i]);\n        }\n        e.iceServers = t;\n      }\n      return new t(e, i);\n    }, e.RTCPeerConnection.prototype = t.prototype, \"generateCertificate\" in t && Object.defineProperty(e.RTCPeerConnection, \"generateCertificate\", {\n      get: () => t.generateCertificate\n    });\n  }\n  function Sp(e) {\n    \"object\" == typeof e && e.RTCTrackEvent && \"receiver\" in e.RTCTrackEvent.prototype && !(\"transceiver\" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, \"transceiver\", {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n  function gp(e) {\n    const t = e.RTCPeerConnection.prototype.createOffer;\n    e.RTCPeerConnection.prototype.createOffer = function (e) {\n      if (e) {\n        void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);\n        const t = this.getTransceivers().find(e => \"audio\" === e.receiver.track.kind);\n        !1 === e.offerToReceiveAudio && t ? \"sendrecv\" === t.direction ? t.setDirection ? t.setDirection(\"sendonly\") : t.direction = \"sendonly\" : \"recvonly\" === t.direction && (t.setDirection ? t.setDirection(\"inactive\") : t.direction = \"inactive\") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver(\"audio\", {\n          direction: \"recvonly\"\n        }), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);\n        const i = this.getTransceivers().find(e => \"video\" === e.receiver.track.kind);\n        !1 === e.offerToReceiveVideo && i ? \"sendrecv\" === i.direction ? i.setDirection ? i.setDirection(\"sendonly\") : i.direction = \"sendonly\" : \"recvonly\" === i.direction && (i.setDirection ? i.setDirection(\"inactive\") : i.direction = \"inactive\") : !0 !== e.offerToReceiveVideo || i || this.addTransceiver(\"video\", {\n          direction: \"recvonly\"\n        });\n      }\n      return t.apply(this, arguments);\n    };\n  }\n  function Rp(e) {\n    \"object\" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext);\n  }\n  var Cp = Object.freeze({\n      __proto__: null,\n      shimAudioContext: Rp,\n      shimCallbacksAPI: Ep,\n      shimConstraints: fp,\n      shimCreateOfferLegacy: gp,\n      shimGetUserMedia: mp,\n      shimLocalStreamsAPI: pp,\n      shimRTCIceServerUrls: Tp,\n      shimRemoteStreamsAPI: _p,\n      shimTrackEventTransceiver: Sp\n    }),\n    vp = \"\\t\\n\\v\\f\\r Â áââââââââââââ¯âã\\u2028\\u2029\\ufeff\",\n    Ip = J,\n    yp = mn,\n    Ap = vp,\n    bp = d(\"\".replace),\n    wp = RegExp(\"^[\" + Ap + \"]+\"),\n    Op = RegExp(\"(^|[^\" + Ap + \"])[\" + Ap + \"]+$\"),\n    Np = function (e) {\n      return function (t) {\n        var i = yp(Ip(t));\n        return 1 & e && (i = bp(i, wp, \"\")), 2 & e && (i = bp(i, Op, \"$1\")), i;\n      };\n    },\n    Dp = {\n      start: Np(1),\n      end: Np(2),\n      trim: Np(3)\n    },\n    Pp = la.PROPER,\n    Lp = n,\n    kp = vp,\n    Mp = Dp.trim;\n  wi({\n    target: \"String\",\n    proto: !0,\n    forced: function (e) {\n      return Lp(function () {\n        return !!kp[e]() || \"âÂá \" !== \"âÂá \"[e]() || Pp && kp[e].name !== e;\n      });\n    }(\"trim\")\n  }, {\n    trim: function () {\n      return Mp(this);\n    }\n  });\n  var Up = Xi(\"String\").trim,\n    xp = l,\n    Vp = Up,\n    Fp = String.prototype,\n    Bp = function (e) {\n      var t = e.trim;\n      return \"string\" == typeof e || e === Fp || xp(Fp, e) && t === Fp.trim ? Vp : t;\n    },\n    jp = i(Bp),\n    Gp = {\n      exports: {}\n    };\n  !function (e) {\n    const t = {\n      generateIdentifier: function () {\n        return Math.random().toString(36).substring(2, 12);\n      }\n    };\n    t.localCName = t.generateIdentifier(), t.splitLines = function (e) {\n      return e.trim().split(\"\\n\").map(e => e.trim());\n    }, t.splitSections = function (e) {\n      return e.split(\"\\nm=\").map((e, t) => (t > 0 ? \"m=\" + e : e).trim() + \"\\r\\n\");\n    }, t.getDescription = function (e) {\n      const i = t.splitSections(e);\n      return i && i[0];\n    }, t.getMediaSections = function (e) {\n      const i = t.splitSections(e);\n      return i.shift(), i;\n    }, t.matchPrefix = function (e, i) {\n      return t.splitLines(e).filter(e => 0 === e.indexOf(i));\n    }, t.parseCandidate = function (e) {\n      let t;\n      t = 0 === e.indexOf(\"a=candidate:\") ? e.substring(12).split(\" \") : e.substring(10).split(\" \");\n      const i = {\n        foundation: t[0],\n        component: {\n          1: \"rtp\",\n          2: \"rtcp\"\n        }[t[1]] || t[1],\n        protocol: t[2].toLowerCase(),\n        priority: parseInt(t[3], 10),\n        ip: t[4],\n        address: t[4],\n        port: parseInt(t[5], 10),\n        type: t[7]\n      };\n      for (let e = 8; e < t.length; e += 2) switch (t[e]) {\n        case \"raddr\":\n          i.relatedAddress = t[e + 1];\n          break;\n        case \"rport\":\n          i.relatedPort = parseInt(t[e + 1], 10);\n          break;\n        case \"tcptype\":\n          i.tcpType = t[e + 1];\n          break;\n        case \"ufrag\":\n          i.ufrag = t[e + 1], i.usernameFragment = t[e + 1];\n          break;\n        default:\n          void 0 === i[t[e]] && (i[t[e]] = t[e + 1]);\n      }\n      return i;\n    }, t.writeCandidate = function (e) {\n      const t = [];\n      t.push(e.foundation);\n      const i = e.component;\n      \"rtp\" === i ? t.push(1) : \"rtcp\" === i ? t.push(2) : t.push(i), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);\n      const n = e.type;\n      return t.push(\"typ\"), t.push(n), \"host\" !== n && e.relatedAddress && e.relatedPort && (t.push(\"raddr\"), t.push(e.relatedAddress), t.push(\"rport\"), t.push(e.relatedPort)), e.tcpType && \"tcp\" === e.protocol.toLowerCase() && (t.push(\"tcptype\"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push(\"ufrag\"), t.push(e.usernameFragment || e.ufrag)), \"candidate:\" + t.join(\" \");\n    }, t.parseIceOptions = function (e) {\n      return e.substring(14).split(\" \");\n    }, t.parseRtpMap = function (e) {\n      let t = e.substring(9).split(\" \");\n      const i = {\n        payloadType: parseInt(t.shift(), 10)\n      };\n      return t = t[0].split(\"/\"), i.name = t[0], i.clockRate = parseInt(t[1], 10), i.channels = 3 === t.length ? parseInt(t[2], 10) : 1, i.numChannels = i.channels, i;\n    }, t.writeRtpMap = function (e) {\n      let t = e.payloadType;\n      void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);\n      const i = e.channels || e.numChannels || 1;\n      return \"a=rtpmap:\" + t + \" \" + e.name + \"/\" + e.clockRate + (1 !== i ? \"/\" + i : \"\") + \"\\r\\n\";\n    }, t.parseExtmap = function (e) {\n      const t = e.substring(9).split(\" \");\n      return {\n        id: parseInt(t[0], 10),\n        direction: t[0].indexOf(\"/\") > 0 ? t[0].split(\"/\")[1] : \"sendrecv\",\n        uri: t[1],\n        attributes: t.slice(2).join(\" \")\n      };\n    }, t.writeExtmap = function (e) {\n      return \"a=extmap:\" + (e.id || e.preferredId) + (e.direction && \"sendrecv\" !== e.direction ? \"/\" + e.direction : \"\") + \" \" + e.uri + (e.attributes ? \" \" + e.attributes : \"\") + \"\\r\\n\";\n    }, t.parseFmtp = function (e) {\n      const t = {};\n      let i;\n      const n = e.substring(e.indexOf(\" \") + 1).split(\";\");\n      for (let e = 0; e < n.length; e++) i = n[e].trim().split(\"=\"), t[i[0].trim()] = i[1];\n      return t;\n    }, t.writeFmtp = function (e) {\n      let t = \"\",\n        i = e.payloadType;\n      if (void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {\n        const n = [];\n        Object.keys(e.parameters).forEach(t => {\n          void 0 !== e.parameters[t] ? n.push(t + \"=\" + e.parameters[t]) : n.push(t);\n        }), t += \"a=fmtp:\" + i + \" \" + n.join(\";\") + \"\\r\\n\";\n      }\n      return t;\n    }, t.parseRtcpFb = function (e) {\n      const t = e.substring(e.indexOf(\" \") + 1).split(\" \");\n      return {\n        type: t.shift(),\n        parameter: t.join(\" \")\n      };\n    }, t.writeRtcpFb = function (e) {\n      let t = \"\",\n        i = e.payloadType;\n      return void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(e => {\n        t += \"a=rtcp-fb:\" + i + \" \" + e.type + (e.parameter && e.parameter.length ? \" \" + e.parameter : \"\") + \"\\r\\n\";\n      }), t;\n    }, t.parseSsrcMedia = function (e) {\n      const t = e.indexOf(\" \"),\n        i = {\n          ssrc: parseInt(e.substring(7, t), 10)\n        },\n        n = e.indexOf(\":\", t);\n      return n > -1 ? (i.attribute = e.substring(t + 1, n), i.value = e.substring(n + 1)) : i.attribute = e.substring(t + 1), i;\n    }, t.parseSsrcGroup = function (e) {\n      const t = e.substring(13).split(\" \");\n      return {\n        semantics: t.shift(),\n        ssrcs: t.map(e => parseInt(e, 10))\n      };\n    }, t.getMid = function (e) {\n      const i = t.matchPrefix(e, \"a=mid:\")[0];\n      if (i) return i.substring(6);\n    }, t.parseFingerprint = function (e) {\n      const t = e.substring(14).split(\" \");\n      return {\n        algorithm: t[0].toLowerCase(),\n        value: t[1].toUpperCase()\n      };\n    }, t.getDtlsParameters = function (e, i) {\n      return {\n        role: \"auto\",\n        fingerprints: t.matchPrefix(e + i, \"a=fingerprint:\").map(t.parseFingerprint)\n      };\n    }, t.writeDtlsParameters = function (e, t) {\n      let i = \"a=setup:\" + t + \"\\r\\n\";\n      return e.fingerprints.forEach(e => {\n        i += \"a=fingerprint:\" + e.algorithm + \" \" + e.value + \"\\r\\n\";\n      }), i;\n    }, t.parseCryptoLine = function (e) {\n      const t = e.substring(9).split(\" \");\n      return {\n        tag: parseInt(t[0], 10),\n        cryptoSuite: t[1],\n        keyParams: t[2],\n        sessionParams: t.slice(3)\n      };\n    }, t.writeCryptoLine = function (e) {\n      return \"a=crypto:\" + e.tag + \" \" + e.cryptoSuite + \" \" + (\"object\" == typeof e.keyParams ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? \" \" + e.sessionParams.join(\" \") : \"\") + \"\\r\\n\";\n    }, t.parseCryptoKeyParams = function (e) {\n      if (0 !== e.indexOf(\"inline:\")) return null;\n      const t = e.substring(7).split(\"|\");\n      return {\n        keyMethod: \"inline\",\n        keySalt: t[0],\n        lifeTime: t[1],\n        mkiValue: t[2] ? t[2].split(\":\")[0] : void 0,\n        mkiLength: t[2] ? t[2].split(\":\")[1] : void 0\n      };\n    }, t.writeCryptoKeyParams = function (e) {\n      return e.keyMethod + \":\" + e.keySalt + (e.lifeTime ? \"|\" + e.lifeTime : \"\") + (e.mkiValue && e.mkiLength ? \"|\" + e.mkiValue + \":\" + e.mkiLength : \"\");\n    }, t.getCryptoParameters = function (e, i) {\n      return t.matchPrefix(e + i, \"a=crypto:\").map(t.parseCryptoLine);\n    }, t.getIceParameters = function (e, i) {\n      const n = t.matchPrefix(e + i, \"a=ice-ufrag:\")[0],\n        r = t.matchPrefix(e + i, \"a=ice-pwd:\")[0];\n      return n && r ? {\n        usernameFragment: n.substring(12),\n        password: r.substring(10)\n      } : null;\n    }, t.writeIceParameters = function (e) {\n      let t = \"a=ice-ufrag:\" + e.usernameFragment + \"\\r\\na=ice-pwd:\" + e.password + \"\\r\\n\";\n      return e.iceLite && (t += \"a=ice-lite\\r\\n\"), t;\n    }, t.parseRtpParameters = function (e) {\n      const i = {\n          codecs: [],\n          headerExtensions: [],\n          fecMechanisms: [],\n          rtcp: []\n        },\n        n = t.splitLines(e)[0].split(\" \");\n      i.profile = n[2];\n      for (let r = 3; r < n.length; r++) {\n        const o = n[r],\n          s = t.matchPrefix(e, \"a=rtpmap:\" + o + \" \")[0];\n        if (s) {\n          const n = t.parseRtpMap(s),\n            r = t.matchPrefix(e, \"a=fmtp:\" + o + \" \");\n          switch (n.parameters = r.length ? t.parseFmtp(r[0]) : {}, n.rtcpFeedback = t.matchPrefix(e, \"a=rtcp-fb:\" + o + \" \").map(t.parseRtcpFb), i.codecs.push(n), n.name.toUpperCase()) {\n            case \"RED\":\n            case \"ULPFEC\":\n              i.fecMechanisms.push(n.name.toUpperCase());\n          }\n        }\n      }\n      t.matchPrefix(e, \"a=extmap:\").forEach(e => {\n        i.headerExtensions.push(t.parseExtmap(e));\n      });\n      const r = t.matchPrefix(e, \"a=rtcp-fb:* \").map(t.parseRtcpFb);\n      return i.codecs.forEach(e => {\n        r.forEach(t => {\n          e.rtcpFeedback.find(e => e.type === t.type && e.parameter === t.parameter) || e.rtcpFeedback.push(t);\n        });\n      }), i;\n    }, t.writeRtpDescription = function (e, i) {\n      let n = \"\";\n      n += \"m=\" + e + \" \", n += i.codecs.length > 0 ? \"9\" : \"0\", n += \" \" + (i.profile || \"UDP/TLS/RTP/SAVPF\") + \" \", n += i.codecs.map(e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType).join(\" \") + \"\\r\\n\", n += \"c=IN IP4 0.0.0.0\\r\\n\", n += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\", i.codecs.forEach(e => {\n        n += t.writeRtpMap(e), n += t.writeFmtp(e), n += t.writeRtcpFb(e);\n      });\n      let r = 0;\n      return i.codecs.forEach(e => {\n        e.maxptime > r && (r = e.maxptime);\n      }), r > 0 && (n += \"a=maxptime:\" + r + \"\\r\\n\"), i.headerExtensions && i.headerExtensions.forEach(e => {\n        n += t.writeExtmap(e);\n      }), n;\n    }, t.parseRtpEncodingParameters = function (e) {\n      const i = [],\n        n = t.parseRtpParameters(e),\n        r = -1 !== n.fecMechanisms.indexOf(\"RED\"),\n        o = -1 !== n.fecMechanisms.indexOf(\"ULPFEC\"),\n        s = t.matchPrefix(e, \"a=ssrc:\").map(e => t.parseSsrcMedia(e)).filter(e => \"cname\" === e.attribute),\n        a = s.length > 0 && s[0].ssrc;\n      let c;\n      const d = t.matchPrefix(e, \"a=ssrc-group:FID\").map(e => e.substring(17).split(\" \").map(e => parseInt(e, 10)));\n      d.length > 0 && d[0].length > 1 && d[0][0] === a && (c = d[0][1]), n.codecs.forEach(e => {\n        if (\"RTX\" === e.name.toUpperCase() && e.parameters.apt) {\n          let t = {\n            ssrc: a,\n            codecPayloadType: parseInt(e.parameters.apt, 10)\n          };\n          a && c && (t.rtx = {\n            ssrc: c\n          }), i.push(t), r && (t = JSON.parse(JSON.stringify(t)), t.fec = {\n            ssrc: a,\n            mechanism: o ? \"red+ulpfec\" : \"red\"\n          }, i.push(t));\n        }\n      }), 0 === i.length && a && i.push({\n        ssrc: a\n      });\n      let l = t.matchPrefix(e, \"b=\");\n      return l.length && (l = 0 === l[0].indexOf(\"b=TIAS:\") ? parseInt(l[0].substring(7), 10) : 0 === l[0].indexOf(\"b=AS:\") ? 1e3 * parseInt(l[0].substring(5), 10) * .95 - 16e3 : void 0, i.forEach(e => {\n        e.maxBitrate = l;\n      })), i;\n    }, t.parseRtcpParameters = function (e) {\n      const i = {},\n        n = t.matchPrefix(e, \"a=ssrc:\").map(e => t.parseSsrcMedia(e)).filter(e => \"cname\" === e.attribute)[0];\n      n && (i.cname = n.value, i.ssrc = n.ssrc);\n      const r = t.matchPrefix(e, \"a=rtcp-rsize\");\n      i.reducedSize = r.length > 0, i.compound = 0 === r.length;\n      const o = t.matchPrefix(e, \"a=rtcp-mux\");\n      return i.mux = o.length > 0, i;\n    }, t.writeRtcpParameters = function (e) {\n      let t = \"\";\n      return e.reducedSize && (t += \"a=rtcp-rsize\\r\\n\"), e.mux && (t += \"a=rtcp-mux\\r\\n\"), void 0 !== e.ssrc && e.cname && (t += \"a=ssrc:\" + e.ssrc + \" cname:\" + e.cname + \"\\r\\n\"), t;\n    }, t.parseMsid = function (e) {\n      let i;\n      const n = t.matchPrefix(e, \"a=msid:\");\n      if (1 === n.length) return i = n[0].substring(7).split(\" \"), {\n        stream: i[0],\n        track: i[1]\n      };\n      const r = t.matchPrefix(e, \"a=ssrc:\").map(e => t.parseSsrcMedia(e)).filter(e => \"msid\" === e.attribute);\n      return r.length > 0 ? (i = r[0].value.split(\" \"), {\n        stream: i[0],\n        track: i[1]\n      }) : void 0;\n    }, t.parseSctpDescription = function (e) {\n      const i = t.parseMLine(e),\n        n = t.matchPrefix(e, \"a=max-message-size:\");\n      let r;\n      n.length > 0 && (r = parseInt(n[0].substring(19), 10)), isNaN(r) && (r = 65536);\n      const o = t.matchPrefix(e, \"a=sctp-port:\");\n      if (o.length > 0) return {\n        port: parseInt(o[0].substring(12), 10),\n        protocol: i.fmt,\n        maxMessageSize: r\n      };\n      const s = t.matchPrefix(e, \"a=sctpmap:\");\n      if (s.length > 0) {\n        const e = s[0].substring(10).split(\" \");\n        return {\n          port: parseInt(e[0], 10),\n          protocol: e[1],\n          maxMessageSize: r\n        };\n      }\n    }, t.writeSctpDescription = function (e, t) {\n      let i = [];\n      return i = \"DTLS/SCTP\" !== e.protocol ? [\"m=\" + e.kind + \" 9 \" + e.protocol + \" \" + t.protocol + \"\\r\\n\", \"c=IN IP4 0.0.0.0\\r\\n\", \"a=sctp-port:\" + t.port + \"\\r\\n\"] : [\"m=\" + e.kind + \" 9 \" + e.protocol + \" \" + t.port + \"\\r\\n\", \"c=IN IP4 0.0.0.0\\r\\n\", \"a=sctpmap:\" + t.port + \" \" + t.protocol + \" 65535\\r\\n\"], void 0 !== t.maxMessageSize && i.push(\"a=max-message-size:\" + t.maxMessageSize + \"\\r\\n\"), i.join(\"\");\n    }, t.generateSessionId = function () {\n      return Math.random().toString().substr(2, 22);\n    }, t.writeSessionBoilerplate = function (e, i, n) {\n      let r;\n      const o = void 0 !== i ? i : 2;\n      r = e || t.generateSessionId();\n      return \"v=0\\r\\no=\" + (n || \"thisisadapterortc\") + \" \" + r + \" \" + o + \" IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\n\";\n    }, t.getDirection = function (e, i) {\n      const n = t.splitLines(e);\n      for (let e = 0; e < n.length; e++) switch (n[e]) {\n        case \"a=sendrecv\":\n        case \"a=sendonly\":\n        case \"a=recvonly\":\n        case \"a=inactive\":\n          return n[e].substring(2);\n      }\n      return i ? t.getDirection(i) : \"sendrecv\";\n    }, t.getKind = function (e) {\n      return t.splitLines(e)[0].split(\" \")[0].substring(2);\n    }, t.isRejected = function (e) {\n      return \"0\" === e.split(\" \", 2)[1];\n    }, t.parseMLine = function (e) {\n      const i = t.splitLines(e)[0].substring(2).split(\" \");\n      return {\n        kind: i[0],\n        port: parseInt(i[1], 10),\n        protocol: i[2],\n        fmt: i.slice(3).join(\" \")\n      };\n    }, t.parseOLine = function (e) {\n      const i = t.matchPrefix(e, \"o=\")[0].substring(2).split(\" \");\n      return {\n        username: i[0],\n        sessionId: i[1],\n        sessionVersion: parseInt(i[2], 10),\n        netType: i[3],\n        addressType: i[4],\n        address: i[5]\n      };\n    }, t.isValidSDP = function (e) {\n      if (\"string\" != typeof e || 0 === e.length) return !1;\n      const i = t.splitLines(e);\n      for (let e = 0; e < i.length; e++) if (i[e].length < 2 || \"=\" !== i[e].charAt(1)) return !1;\n      return !0;\n    }, e.exports = t;\n  }(Gp);\n  var Wp = Gp.exports,\n    Hp = i(Wp),\n    Kp = e({\n      __proto__: null,\n      default: Hp\n    }, [Wp]);\n  function Yp(e) {\n    if (!e.RTCIceCandidate || e.RTCIceCandidate && \"foundation\" in e.RTCIceCandidate.prototype) return;\n    const t = e.RTCIceCandidate;\n    e.RTCIceCandidate = function (e) {\n      if (\"object\" == typeof e && e.candidate && 0 === e.candidate.indexOf(\"a=\") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {\n        const i = new t(e),\n          n = Hp.parseCandidate(e.candidate),\n          r = Object.assign(i, n);\n        return r.toJSON = function () {\n          return {\n            candidate: r.candidate,\n            sdpMid: r.sdpMid,\n            sdpMLineIndex: r.sdpMLineIndex,\n            usernameFragment: r.usernameFragment\n          };\n        }, r;\n      }\n      return new t(e);\n    }, e.RTCIceCandidate.prototype = t.prototype, $n(e, \"icecandidate\", t => (t.candidate && Object.defineProperty(t, \"candidate\", {\n      value: new e.RTCIceCandidate(t.candidate),\n      writable: \"false\"\n    }), t));\n  }\n  function qp(e) {\n    !e.RTCIceCandidate || e.RTCIceCandidate && \"relayProtocol\" in e.RTCIceCandidate.prototype || $n(e, \"icecandidate\", e => {\n      if (e.candidate) {\n        const t = Hp.parseCandidate(e.candidate.candidate);\n        \"relay\" === t.type && (e.candidate.relayProtocol = {\n          0: \"tls\",\n          1: \"tcp\",\n          2: \"udp\"\n        }[t.priority >> 24]);\n      }\n      return e;\n    });\n  }\n  function zp(e, t) {\n    if (!e.RTCPeerConnection) return;\n    \"sctp\" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, \"sctp\", {\n      get() {\n        return void 0 === this._sctp ? null : this._sctp;\n      }\n    });\n    const i = function (e) {\n        if (!e || !e.sdp) return !1;\n        const t = Hp.splitSections(e.sdp);\n        return t.shift(), t.some(e => {\n          const t = Hp.parseMLine(e);\n          return t && \"application\" === t.kind && -1 !== t.protocol.indexOf(\"SCTP\");\n        });\n      },\n      n = function (e) {\n        const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (null === t || t.length < 2) return -1;\n        const i = parseInt(t[1], 10);\n        return i != i ? -1 : i;\n      },\n      r = function (e) {\n        let i = 65536;\n        return \"firefox\" === t.browser && (i = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), i;\n      },\n      o = function (e, i) {\n        let n = 65536;\n        \"firefox\" === t.browser && 57 === t.version && (n = 65535);\n        const r = Hp.matchPrefix(e.sdp, \"a=max-message-size:\");\n        return r.length > 0 ? n = parseInt(r[0].substr(19), 10) : \"firefox\" === t.browser && -1 !== i && (n = 2147483637), n;\n      },\n      s = e.RTCPeerConnection.prototype.setRemoteDescription;\n    e.RTCPeerConnection.prototype.setRemoteDescription = function () {\n      if (this._sctp = null, \"chrome\" === t.browser && t.version >= 76) {\n        const _this$getConfiguratio = this.getConfiguration(),\n          e = _this$getConfiguratio.sdpSemantics;\n        \"plan-b\" === e && Object.defineProperty(this, \"sctp\", {\n          get() {\n            return void 0 === this._sctp ? null : this._sctp;\n          },\n          enumerable: !0,\n          configurable: !0\n        });\n      }\n      if (i(arguments[0])) {\n        const e = n(arguments[0]),\n          t = r(e),\n          i = o(arguments[0], e);\n        let s;\n        s = 0 === t && 0 === i ? Number.POSITIVE_INFINITY : 0 === t || 0 === i ? Math.max(t, i) : Math.min(t, i);\n        const a = {};\n        Object.defineProperty(a, \"maxMessageSize\", {\n          get: () => s\n        }), this._sctp = a;\n      }\n      return s.apply(this, arguments);\n    };\n  }\n  function Jp(e) {\n    if (!e.RTCPeerConnection || !(\"createDataChannel\" in e.RTCPeerConnection.prototype)) return;\n    function t(e, t) {\n      const i = e.send;\n      e.send = function () {\n        const n = arguments[0],\n          r = n.length || n.size || n.byteLength;\n        if (\"open\" === e.readyState && t.sctp && r > t.sctp.maxMessageSize) throw new TypeError(\"Message too large (can send a maximum of \" + t.sctp.maxMessageSize + \" bytes)\");\n        return i.apply(e, arguments);\n      };\n    }\n    const i = e.RTCPeerConnection.prototype.createDataChannel;\n    e.RTCPeerConnection.prototype.createDataChannel = function () {\n      const e = i.apply(this, arguments);\n      return t(e, this), e;\n    }, $n(e, \"datachannel\", e => (t(e.channel, e.target), e));\n  }\n  function Xp(e) {\n    if (!e.RTCPeerConnection || \"connectionState\" in e.RTCPeerConnection.prototype) return;\n    const t = e.RTCPeerConnection.prototype;\n    Object.defineProperty(t, \"connectionState\", {\n      get() {\n        return {\n          completed: \"connected\",\n          checking: \"connecting\"\n        }[this.iceConnectionState] || this.iceConnectionState;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t, \"onconnectionstatechange\", {\n      get() {\n        return this._onconnectionstatechange || null;\n      },\n      set(e) {\n        this._onconnectionstatechange && (this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), [\"setLocalDescription\", \"setRemoteDescription\"].forEach(e => {\n      const i = t[e];\n      t[e] = function () {\n        return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => {\n          const t = e.target;\n          if (t._lastConnectionState !== t.connectionState) {\n            t._lastConnectionState = t.connectionState;\n            const i = new Event(\"connectionstatechange\", e);\n            t.dispatchEvent(i);\n          }\n          return e;\n        }, this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly)), i.apply(this, arguments);\n      };\n    });\n  }\n  function Qp(e, t) {\n    if (!e.RTCPeerConnection) return;\n    if (\"chrome\" === t.browser && t.version >= 71) return;\n    if (\"safari\" === t.browser && t.version >= 605) return;\n    const i = e.RTCPeerConnection.prototype.setRemoteDescription;\n    e.RTCPeerConnection.prototype.setRemoteDescription = function (t) {\n      if (t && t.sdp && -1 !== t.sdp.indexOf(\"\\na=extmap-allow-mixed\")) {\n        const i = t.sdp.split(\"\\n\").filter(e => \"a=extmap-allow-mixed\" !== jp(e).call(e)).join(\"\\n\");\n        e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({\n          type: t.type,\n          sdp: i\n        }) : t.sdp = i;\n      }\n      return i.apply(this, arguments);\n    };\n  }\n  function Zp(e, t) {\n    if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;\n    const i = e.RTCPeerConnection.prototype.addIceCandidate;\n    i && 0 !== i.length && (e.RTCPeerConnection.prototype.addIceCandidate = function () {\n      return arguments[0] ? (\"chrome\" === t.browser && t.version < 78 || \"firefox\" === t.browser && t.version < 68 || \"safari\" === t.browser) && arguments[0] && \"\" === arguments[0].candidate ? Gu.resolve() : i.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Gu.resolve());\n    });\n  }\n  function $p(e, t) {\n    if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;\n    const i = e.RTCPeerConnection.prototype.setLocalDescription;\n    i && 0 !== i.length && (e.RTCPeerConnection.prototype.setLocalDescription = function () {\n      let e = arguments[0] || {};\n      if (\"object\" != typeof e || e.type && e.sdp) return i.apply(this, arguments);\n      if (e = {\n        type: e.type,\n        sdp: e.sdp\n      }, !e.type) switch (this.signalingState) {\n        case \"stable\":\n        case \"have-local-offer\":\n        case \"have-remote-pranswer\":\n          e.type = \"offer\";\n          break;\n        default:\n          e.type = \"answer\";\n      }\n      if (e.sdp || \"offer\" !== e.type && \"answer\" !== e.type) return i.apply(this, [e]);\n      return (\"offer\" === e.type ? this.createOffer : this.createAnswer).apply(this).then(e => i.apply(this, [e]));\n    });\n  }\n  var e_ = Object.freeze({\n    __proto__: null,\n    removeExtmapAllowMixed: Qp,\n    shimAddIceCandidateNullOrEmpty: Zp,\n    shimConnectionState: Xp,\n    shimMaxMessageSize: zp,\n    shimParameterlessSetLocalDescription: $p,\n    shimRTCIceCandidate: Yp,\n    shimRTCIceCandidateRelayProtocol: qp,\n    shimSendThrowTypeError: Jp\n  });\n  !function () {\n    let _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n      e = _ref.window,\n      t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {\n        shimChrome: !0,\n        shimFirefox: !0,\n        shimSafari: !0\n      };\n    const i = ir,\n      n = function (e) {\n        const t = {\n          browser: null,\n          version: null\n        };\n        if (void 0 === e || !e.navigator) return t.browser = \"Not a browser.\", t;\n        const i = e.navigator;\n        if (i.mozGetUserMedia) t.browser = \"firefox\", t.version = Zn(i.userAgent, /Firefox\\/(\\d+)\\./, 1);else if (i.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection) t.browser = \"chrome\", t.version = Zn(i.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);else {\n          if (!e.RTCPeerConnection || !i.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) return t.browser = \"Not a supported browser.\", t;\n          t.browser = \"safari\", t.version = Zn(i.userAgent, /AppleWebKit\\/(\\d+)\\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && \"currentDirection\" in e.RTCRtpTransceiver.prototype;\n        }\n        return t;\n      }(e),\n      r = {\n        browserDetails: n,\n        commonShim: e_,\n        extractVersion: Zn,\n        disableLog: er,\n        disableWarnings: tr,\n        sdp: Kp\n      };\n    switch (n.browser) {\n      case \"chrome\":\n        if (!ep || !Zu || !t.shimChrome) return i(\"Chrome shim is not included in this adapter release.\"), r;\n        if (null === n.version) return i(\"Chrome shim can not determine version, not shimming.\"), r;\n        i(\"adapter.js shimming chrome.\"), r.browserShim = ep, Zp(e, n), $p(e), Hu(e, n), Ku(e), Zu(e, n), Yu(e), Qu(e, n), qu(e), zu(e), Ju(e), $u(e, n), Yp(e), qp(e), Xp(e), zp(e, n), Jp(e), Qp(e, n);\n        break;\n      case \"firefox\":\n        if (!up || !np || !t.shimFirefox) return i(\"Firefox shim is not included in this adapter release.\"), r;\n        i(\"adapter.js shimming firefox.\"), r.browserShim = up, Zp(e, n), $p(e), tp(e, n), np(e, n), ip(e), sp(e), rp(e), op(e), ap(e), cp(e), dp(e), lp(e), hp(e), Yp(e), Xp(e), zp(e, n), Jp(e);\n        break;\n      case \"safari\":\n        if (!Cp || !t.shimSafari) return i(\"Safari shim is not included in this adapter release.\"), r;\n        i(\"adapter.js shimming safari.\"), r.browserShim = Cp, Zp(e, n), $p(e), Tp(e), gp(e), Ep(e), pp(e), _p(e), Sp(e), mp(e), Rp(e), Yp(e), qp(e), zp(e, n), Jp(e), Qp(e, n);\n        break;\n      default:\n        i(\"Unsupported browser!\");\n    }\n  }({\n    window: \"undefined\" == typeof window ? void 0 : window\n  });\n  var t_ = Xi(\"Array\").keys,\n    i_ = pn,\n    n_ = Ze,\n    r_ = l,\n    o_ = t_,\n    s_ = Array.prototype,\n    a_ = {\n      DOMTokenList: !0,\n      NodeList: !0\n    },\n    c_ = function (e) {\n      var t = e.keys;\n      return e === s_ || r_(s_, e) && t === s_.keys || n_(a_, i_(e)) ? o_ : t;\n    },\n    d_ = i(c_),\n    l_ = be,\n    h_ = TypeError,\n    u_ = Ct,\n    p_ = Qt,\n    __ = B,\n    E_ = function (e, t, i) {\n      var n = u_(t);\n      n in e ? p_.f(e, n, __(0, i)) : e[n] = i;\n    },\n    m_ = xi,\n    f_ = Gi,\n    T_ = E_,\n    S_ = Array,\n    g_ = Math.max,\n    R_ = function (e, t, i) {\n      for (var n = f_(e), r = m_(t, n), o = m_(void 0 === i ? n : i, n), s = S_(g_(o - r, 0)), a = 0; r < o; r++, a++) T_(s, a, e[r]);\n      return s.length = a, s;\n    },\n    C_ = R_,\n    v_ = Math.floor,\n    I_ = function (e, t) {\n      var i = e.length,\n        n = v_(i / 2);\n      return i < 8 ? y_(e, t) : A_(e, I_(C_(e, 0, n), t), I_(C_(e, n), t), t);\n    },\n    y_ = function (e, t) {\n      for (var i, n, r = e.length, o = 1; o < r;) {\n        for (n = o, i = e[o]; n && t(e[n - 1], i) > 0;) e[n] = e[--n];\n        n !== o++ && (e[n] = i);\n      }\n      return e;\n    },\n    A_ = function (e, t, i, n) {\n      for (var r = t.length, o = i.length, s = 0, a = 0; s < r || a < o;) e[s + a] = s < r && a < o ? n(t[s], i[a]) <= 0 ? t[s++] : i[a++] : s < r ? t[s++] : i[a++];\n      return e;\n    },\n    b_ = I_,\n    w_ = ce.match(/firefox\\/(\\d+)/i),\n    O_ = !!w_ && +w_[1],\n    N_ = /MSIE|Trident/.test(ce),\n    D_ = ce.match(/AppleWebKit\\/(\\d+)\\./),\n    P_ = !!D_ && +D_[1],\n    L_ = wi,\n    k_ = d,\n    M_ = De,\n    U_ = Je,\n    x_ = Gi,\n    V_ = function (e, t) {\n      if (!delete e[t]) throw h_(\"Cannot delete property \" + l_(t) + \" of \" + l_(e));\n    },\n    F_ = mn,\n    B_ = n,\n    j_ = b_,\n    G_ = Bn,\n    W_ = O_,\n    H_ = N_,\n    K_ = Ee,\n    Y_ = P_,\n    q_ = [],\n    z_ = k_(q_.sort),\n    J_ = k_(q_.push),\n    X_ = B_(function () {\n      q_.sort(void 0);\n    }),\n    Q_ = B_(function () {\n      q_.sort(null);\n    }),\n    Z_ = G_(\"sort\"),\n    $_ = !B_(function () {\n      if (K_) return K_ < 70;\n      if (!(W_ && W_ > 3)) {\n        if (H_) return !0;\n        if (Y_) return Y_ < 603;\n        var e,\n          t,\n          i,\n          n,\n          r = \"\";\n        for (e = 65; e < 76; e++) {\n          switch (t = String.fromCharCode(e), e) {\n            case 66:\n            case 69:\n            case 70:\n            case 72:\n              i = 3;\n              break;\n            case 68:\n            case 71:\n              i = 4;\n              break;\n            default:\n              i = 2;\n          }\n          for (n = 0; n < 47; n++) q_.push({\n            k: t + n,\n            v: i\n          });\n        }\n        for (q_.sort(function (e, t) {\n          return t.v - e.v;\n        }), n = 0; n < q_.length; n++) t = q_[n].k.charAt(0), r.charAt(r.length - 1) !== t && (r += t);\n        return \"DGBEFHACIJK\" !== r;\n      }\n    });\n  L_({\n    target: \"Array\",\n    proto: !0,\n    forced: X_ || !Q_ || !Z_ || !$_\n  }, {\n    sort: function (e) {\n      void 0 !== e && M_(e);\n      var t = U_(this);\n      if ($_) return void 0 === e ? z_(t) : z_(t, e);\n      var i,\n        n,\n        r = [],\n        o = x_(t);\n      for (n = 0; n < o; n++) n in t && J_(r, t[n]);\n      for (j_(r, function (e) {\n        return function (t, i) {\n          return void 0 === i ? -1 : void 0 === t ? 1 : void 0 !== e ? +e(t, i) || 0 : F_(t) > F_(i) ? 1 : -1;\n        };\n      }(e)), i = x_(r), n = 0; n < i;) t[n] = r[n++];\n      for (; n < o;) V_(t, n++);\n      return t;\n    }\n  });\n  var eE = Xi(\"Array\").sort,\n    tE = l,\n    iE = eE,\n    nE = Array.prototype,\n    rE = function (e) {\n      var t = e.sort;\n      return e === nE || tE(nE, e) && t === nE.sort ? iE : t;\n    },\n    oE = i(rE),\n    sE = {\n      exports: {}\n    };\n  !function (e, i) {\n    !function (t, n) {\n      var r = \"function\",\n        o = \"undefined\",\n        s = \"object\",\n        a = \"string\",\n        c = \"major\",\n        d = \"model\",\n        l = \"name\",\n        h = \"type\",\n        u = \"vendor\",\n        p = \"version\",\n        _ = \"architecture\",\n        E = \"console\",\n        m = \"mobile\",\n        f = \"tablet\",\n        T = \"smarttv\",\n        S = \"wearable\",\n        g = \"embedded\",\n        R = \"Amazon\",\n        C = \"Apple\",\n        v = \"ASUS\",\n        I = \"BlackBerry\",\n        y = \"Browser\",\n        A = \"Chrome\",\n        b = \"Firefox\",\n        w = \"Google\",\n        O = \"Huawei\",\n        N = \"LG\",\n        D = \"Microsoft\",\n        P = \"Motorola\",\n        L = \"Opera\",\n        k = \"Samsung\",\n        M = \"Sharp\",\n        U = \"Sony\",\n        x = \"Xiaomi\",\n        V = \"Zebra\",\n        F = \"Facebook\",\n        B = \"Chromium OS\",\n        j = \"Mac OS\",\n        G = function (e) {\n          for (var t = {}, i = 0; i < e.length; i++) t[e[i].toUpperCase()] = e[i];\n          return t;\n        },\n        W = function (e, t) {\n          return typeof e === a && -1 !== H(t).indexOf(H(e));\n        },\n        H = function (e) {\n          return e.toLowerCase();\n        },\n        K = function (e, t) {\n          if (typeof e === a) return e = e.replace(/^\\s\\s*/, \"\"), typeof t === o ? e : e.substring(0, 350);\n        },\n        Y = function (e, t) {\n          for (var i, o, a, c, d, l, h = 0; h < t.length && !d;) {\n            var u = t[h],\n              p = t[h + 1];\n            for (i = o = 0; i < u.length && !d && u[i];) if (d = u[i++].exec(e)) for (a = 0; a < p.length; a++) l = d[++o], typeof (c = p[a]) === s && c.length > 0 ? 2 === c.length ? typeof c[1] == r ? this[c[0]] = c[1].call(this, l) : this[c[0]] = c[1] : 3 === c.length ? typeof c[1] !== r || c[1].exec && c[1].test ? this[c[0]] = l ? l.replace(c[1], c[2]) : n : this[c[0]] = l ? c[1].call(this, l, c[2]) : n : 4 === c.length && (this[c[0]] = l ? c[3].call(this, l.replace(c[1], c[2])) : n) : this[c] = l || n;\n            h += 2;\n          }\n        },\n        q = function (e, t) {\n          for (var i in t) if (typeof t[i] === s && t[i].length > 0) {\n            for (var r = 0; r < t[i].length; r++) if (W(t[i][r], e)) return \"?\" === i ? n : i;\n          } else if (W(t[i], e)) return \"?\" === i ? n : i;\n          return e;\n        },\n        z = {\n          ME: \"4.90\",\n          \"NT 3.11\": \"NT3.51\",\n          \"NT 4.0\": \"NT4.0\",\n          2e3: \"NT 5.0\",\n          XP: [\"NT 5.1\", \"NT 5.2\"],\n          Vista: \"NT 6.0\",\n          7: \"NT 6.1\",\n          8: \"NT 6.2\",\n          8.1: \"NT 6.3\",\n          10: [\"NT 6.4\", \"NT 10.0\"],\n          RT: \"ARM\"\n        },\n        J = {\n          browser: [[/\\b(?:crmo|crios)\\/([\\w\\.]+)/i], [p, [l, \"Chrome\"]], [/edg(?:e|ios|a)?\\/([\\w\\.]+)/i], [p, [l, \"Edge\"]], [/(opera mini)\\/([-\\w\\.]+)/i, /(opera [mobiletab]{3,6})\\b.+version\\/([-\\w\\.]+)/i, /(opera)(?:.+version\\/|[\\/ ]+)([\\w\\.]+)/i], [l, p], [/opios[\\/ ]+([\\w\\.]+)/i], [p, [l, L + \" Mini\"]], [/\\bopr\\/([\\w\\.]+)/i], [p, [l, L]], [/(kindle)\\/([\\w\\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\\/ ]?([\\w\\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\\/ ]?([\\w\\.]*)/i, /(ba?idubrowser)[\\/ ]?([\\w\\.]+)/i, /(?:ms|\\()(ie) ([\\w\\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\\/([-\\w\\.]+)/i, /(weibo)__([\\d\\.]+)/i], [l, p], [/(?:\\buc? ?browser|(?:juc.+)ucweb)[\\/ ]?([\\w\\.]+)/i], [p, [l, \"UC\" + y]], [/microm.+\\bqbcore\\/([\\w\\.]+)/i, /\\bqbcore\\/([\\w\\.]+).+microm/i], [p, [l, \"WeChat(Win) Desktop\"]], [/micromessenger\\/([\\w\\.]+)/i], [p, [l, \"WeChat\"]], [/konqueror\\/([\\w\\.]+)/i], [p, [l, \"Konqueror\"]], [/trident.+rv[: ]([\\w\\.]{1,9})\\b.+like gecko/i], [p, [l, \"IE\"]], [/yabrowser\\/([\\w\\.]+)/i], [p, [l, \"Yandex\"]], [/(avast|avg)\\/([\\w\\.]+)/i], [[l, /(.+)/, \"$1 Secure \" + y], p], [/\\bfocus\\/([\\w\\.]+)/i], [p, [l, b + \" Focus\"]], [/\\bopt\\/([\\w\\.]+)/i], [p, [l, L + \" Touch\"]], [/coc_coc\\w+\\/([\\w\\.]+)/i], [p, [l, \"Coc Coc\"]], [/dolfin\\/([\\w\\.]+)/i], [p, [l, \"Dolphin\"]], [/coast\\/([\\w\\.]+)/i], [p, [l, L + \" Coast\"]], [/miuibrowser\\/([\\w\\.]+)/i], [p, [l, \"MIUI \" + y]], [/fxios\\/([-\\w\\.]+)/i], [p, [l, b]], [/\\bqihu|(qi?ho?o?|360)browser/i], [[l, \"360 \" + y]], [/(oculus|samsung|sailfish|huawei)browser\\/([\\w\\.]+)/i], [[l, /(.+)/, \"$1 \" + y], p], [/(comodo_dragon)\\/([\\w\\.]+)/i], [[l, /_/g, \" \"], p], [/(electron)\\/([\\w\\.]+) safari/i, /(tesla)(?: qtcarbrowser|\\/(20\\d\\d\\.[-\\w\\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\\/ ]?([\\w\\.]+)/i], [l, p], [/(metasr)[\\/ ]?([\\w\\.]+)/i, /(lbbrowser)/i, /\\[(linkedin)app\\]/i], [l], [/((?:fban\\/fbios|fb_iab\\/fb4a)(?!.+fbav)|;fbav\\/([\\w\\.]+);)/i], [[l, F], p], [/(kakao(?:talk|story))[\\/ ]([\\w\\.]+)/i, /(naver)\\(.*?(\\d+\\.[\\w\\.]+).*\\)/i, /safari (line)\\/([\\w\\.]+)/i, /\\b(line)\\/([\\w\\.]+)\\/iab/i, /(chromium|instagram)[\\/ ]([-\\w\\.]+)/i], [l, p], [/\\bgsa\\/([\\w\\.]+) .*safari\\//i], [p, [l, \"GSA\"]], [/headlesschrome(?:\\/([\\w\\.]+)| )/i], [p, [l, A + \" Headless\"]], [/ wv\\).+(chrome)\\/([\\w\\.]+)/i], [[l, A + \" WebView\"], p], [/droid.+ version\\/([\\w\\.]+)\\b.+(?:mobile safari|safari)/i], [p, [l, \"Android \" + y]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\\/v?([\\w\\.]+)/i], [l, p], [/version\\/([\\w\\.\\,]+) .*mobile\\/\\w+ (safari)/i], [p, [l, \"Mobile Safari\"]], [/version\\/([\\w(\\.|\\,)]+) .*(mobile ?safari|safari)/i], [p, l], [/webkit.+?(mobile ?safari|safari)(\\/[\\w\\.]+)/i], [l, [p, q, {\n            \"1.0\": \"/8\",\n            1.2: \"/1\",\n            1.3: \"/3\",\n            \"2.0\": \"/412\",\n            \"2.0.2\": \"/416\",\n            \"2.0.3\": \"/417\",\n            \"2.0.4\": \"/419\",\n            \"?\": \"/\"\n          }]], [/(webkit|khtml)\\/([\\w\\.]+)/i], [l, p], [/(navigator|netscape\\d?)\\/([-\\w\\.]+)/i], [[l, \"Netscape\"], p], [/mobile vr; rv:([\\w\\.]+)\\).+firefox/i], [p, [l, b + \" Reality\"]], [/ekiohf.+(flow)\\/([\\w\\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\\/ ]?([\\w\\.\\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([-\\w\\.]+)$/i, /(firefox)\\/([\\w\\.]+)/i, /(mozilla)\\/([\\w\\.]+) .+rv\\:.+gecko\\/\\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\\. ]?browser)[-\\/ ]?v?([\\w\\.]+)/i, /(links) \\(([\\w\\.]+)/i, /panasonic;(viera)/i], [l, p], [/(cobalt)\\/([\\w\\.]+)/i], [l, [p, /master.|lts./, \"\"]]],\n          cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\\)]/i], [[_, \"amd64\"]], [/(ia32(?=;))/i], [[_, H]], [/((?:i[346]|x)86)[;\\)]/i], [[_, \"ia32\"]], [/\\b(aarch64|arm(v?8e?l?|_?64))\\b/i], [[_, \"arm64\"]], [/\\b(arm(?:v[67])?ht?n?[fl]p?)\\b/i], [[_, \"armhf\"]], [/windows (ce|mobile); ppc;/i], [[_, \"arm\"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\\))/i], [[_, /ower/, \"\", H]], [/(sun4\\w)[;\\)]/i], [[_, \"sparc\"]], [/((?:avr32|ia64(?=;))|68k(?=\\))|\\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\\b|pa-risc)/i], [[_, H]]],\n          device: [[/\\b(sch-i[89]0\\d|shw-m380s|sm-[ptx]\\w{2,4}|gt-[pn]\\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d, [u, k], [h, f]], [/\\b((?:s[cgp]h|gt|sm)-\\w+|sc[g-]?[\\d]+a?|galaxy nexus)/i, /samsung[- ]([-\\w]+)/i, /sec-(sgh\\w+)/i], [d, [u, k], [h, m]], [/\\((ip(?:hone|od)[\\w ]*);/i], [d, [u, C], [h, m]], [/\\((ipad);[-\\w\\),; ]+apple/i, /applecoremedia\\/[\\w\\.]+ \\((ipad)/i, /\\b(ipad)\\d\\d?,\\d\\d?[;\\]].+ios/i], [d, [u, C], [h, f]], [/(macintosh);/i], [d, [u, C]], [/\\b(sh-?[altvz]?\\d\\d[a-ekm]?)/i], [d, [u, M], [h, m]], [/\\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\\d{2})\\b(?!.+d\\/s)/i], [d, [u, O], [h, f]], [/(?:huawei|honor)([-\\w ]+)[;\\)]/i, /\\b(nexus 6p|\\w{2,4}e?-[atu]?[ln][\\dx][012359c][adn]?)\\b(?!.+d\\/s)/i], [d, [u, O], [h, m]], [/\\b(poco[\\w ]+)(?: bui|\\))/i, /\\b; (\\w+) build\\/hm\\1/i, /\\b(hm[-_ ]?note?[_ ]?(?:\\d\\w)?) bui/i, /\\b(redmi[\\-_ ]?(?:note|k)?[\\w_ ]+)(?: bui|\\))/i, /\\b(mi[-_ ]?(?:a\\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\\d?\\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\\))/i], [[d, /_/g, \" \"], [u, x], [h, m]], [/\\b(mi[-_ ]?(?:pad)(?:[\\w_ ]+))(?: bui|\\))/i], [[d, /_/g, \" \"], [u, x], [h, f]], [/; (\\w+) bui.+ oppo/i, /\\b(cph[12]\\d{3}|p(?:af|c[al]|d\\w|e[ar])[mt]\\d0|x9007|a101op)\\b/i], [d, [u, \"OPPO\"], [h, m]], [/vivo (\\w+)(?: bui|\\))/i, /\\b(v[12]\\d{3}\\w?[at])(?: bui|;)/i], [d, [u, \"Vivo\"], [h, m]], [/\\b(rmx[12]\\d{3})(?: bui|;|\\))/i], [d, [u, \"Realme\"], [h, m]], [/\\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\\b[\\w ]+build\\//i, /\\bmot(?:orola)?[- ](\\w*)/i, /((?:moto[\\w\\(\\) ]+|xt\\d{3,4}|nexus 6)(?= bui|\\)))/i], [d, [u, P], [h, m]], [/\\b(mz60\\d|xoom[2 ]{0,2}) build\\//i], [d, [u, P], [h, f]], [/((?=lg)?[vl]k\\-?\\d{3}) bui| 3\\.[-\\w; ]{10}lg?-([06cv9]{3,4})/i], [d, [u, N], [h, f]], [/(lm(?:-?f100[nv]?|-[\\w\\.]+)(?= bui|\\))|nexus [45])/i, /\\blg[-e;\\/ ]+((?!browser|netcast|android tv)\\w+)/i, /\\blg-?([\\d\\w]+) bui/i], [d, [u, N], [h, m]], [/(ideatab[-\\w ]+)/i, /lenovo ?(s[56]000[-\\w]+|tab(?:[\\w ]+)|yt[-\\d\\w]{6}|tb[-\\d\\w]{6})/i], [d, [u, \"Lenovo\"], [h, f]], [/(?:maemo|nokia).*(n900|lumia \\d+)/i, /nokia[-_ ]?([-\\w\\.]*)/i], [[d, /_/g, \" \"], [u, \"Nokia\"], [h, m]], [/(pixel c)\\b/i], [d, [u, w], [h, f]], [/droid.+; (pixel[\\daxl ]{0,6})(?: bui|\\))/i], [d, [u, w], [h, m]], [/droid.+ (a?\\d[0-2]{2}so|[c-g]\\d{4}|so[-gl]\\w+|xq-a\\w[4-7][12])(?= bui|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i], [d, [u, U], [h, m]], [/sony tablet [ps]/i, /\\b(?:sony)?sgp\\w+(?: bui|\\))/i], [[d, \"Xperia Tablet\"], [u, U], [h, f]], [/ (kb2005|in20[12]5|be20[12][59])\\b/i, /(?:one)?(?:plus)? (a\\d0\\d\\d)(?: b|\\))/i], [d, [u, \"OnePlus\"], [h, m]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\\))/i, /(kf[a-z]+)( bui|\\)).+silk\\//i], [d, [u, R], [h, f]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\\)).+silk\\//i], [[d, /(.+)/g, \"Fire Phone $1\"], [u, R], [h, m]], [/(playbook);[-\\w\\),; ]+(rim)/i], [d, u, [h, f]], [/\\b((?:bb[a-f]|st[hv])100-\\d)/i, /\\(bb10; (\\w+)/i], [d, [u, I], [h, m]], [/(?:\\b|asus_)(transfo[prime ]{4,10} \\w+|eeepc|slider \\w+|nexus 7|padfone|p00[cj])/i], [d, [u, v], [h, f]], [/ (z[bes]6[027][012][km][ls]|zenfone \\d\\w?)\\b/i], [d, [u, v], [h, m]], [/(nexus 9)/i], [d, [u, \"HTC\"], [h, f]], [/(htc)[-;_ ]{1,2}([\\w ]+(?=\\)| bui)|\\w+)/i, /(zte)[- ]([\\w ]+?)(?: bui|\\/|\\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\\.))|sony(?!-bra))[-_ ]?([-\\w]*)/i], [u, [d, /_/g, \" \"], [h, m]], [/droid.+; ([ab][1-7]-?[0178a]\\d\\d?)/i], [d, [u, \"Acer\"], [h, f]], [/droid.+; (m[1-5] note) bui/i, /\\bmz-([-\\w]{2,})/i], [d, [u, \"Meizu\"], [h, m]], [/(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\\w]*)/i, /(hp) ([\\w ]+\\w)/i, /(asus)-?(\\w+)/i, /(microsoft); (lumia[\\w ]+)/i, /(lenovo)[-_ ]?([-\\w]+)/i, /(jolla)/i, /(oppo) ?([\\w ]+) bui/i], [u, d, [h, m]], [/(kobo)\\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\\/([\\w\\.]+)/i, /(nook)[\\w ]+build\\/(\\w+)/i, /(dell) (strea[kpr\\d ]*[\\dko])/i, /(le[- ]+pan)[- ]+(\\w{1,9}) bui/i, /(trinity)[- ]*(t\\d{3}) bui/i, /(gigaset)[- ]+(q\\w{1,9}) bui/i, /(vodafone) ([\\w ]+)(?:\\)| bui)/i], [u, d, [h, f]], [/(surface duo)/i], [d, [u, D], [h, f]], [/droid [\\d\\.]+; (fp\\du?)(?: b|\\))/i], [d, [u, \"Fairphone\"], [h, m]], [/(u304aa)/i], [d, [u, \"AT&T\"], [h, m]], [/\\bsie-(\\w*)/i], [d, [u, \"Siemens\"], [h, m]], [/\\b(rct\\w+) b/i], [d, [u, \"RCA\"], [h, f]], [/\\b(venue[\\d ]{2,7}) b/i], [d, [u, \"Dell\"], [h, f]], [/\\b(q(?:mv|ta)\\w+) b/i], [d, [u, \"Verizon\"], [h, f]], [/\\b(?:barnes[& ]+noble |bn[rt])([\\w\\+ ]*) b/i], [d, [u, \"Barnes & Noble\"], [h, f]], [/\\b(tm\\d{3}\\w+) b/i], [d, [u, \"NuVision\"], [h, f]], [/\\b(k88) b/i], [d, [u, \"ZTE\"], [h, f]], [/\\b(nx\\d{3}j) b/i], [d, [u, \"ZTE\"], [h, m]], [/\\b(gen\\d{3}) b.+49h/i], [d, [u, \"Swiss\"], [h, m]], [/\\b(zur\\d{3}) b/i], [d, [u, \"Swiss\"], [h, f]], [/\\b((zeki)?tb.*\\b) b/i], [d, [u, \"Zeki\"], [h, f]], [/\\b([yr]\\d{2}) b/i, /\\b(dragon[- ]+touch |dt)(\\w{5}) b/i], [[u, \"Dragon Touch\"], d, [h, f]], [/\\b(ns-?\\w{0,9}) b/i], [d, [u, \"Insignia\"], [h, f]], [/\\b((nxa|next)-?\\w{0,9}) b/i], [d, [u, \"NextBook\"], [h, f]], [/\\b(xtreme\\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[u, \"Voice\"], d, [h, m]], [/\\b(lvtel\\-)?(v1[12]) b/i], [[u, \"LvTel\"], d, [h, m]], [/\\b(ph-1) /i], [d, [u, \"Essential\"], [h, m]], [/\\b(v(100md|700na|7011|917g).*\\b) b/i], [d, [u, \"Envizen\"], [h, f]], [/\\b(trio[-\\w\\. ]+) b/i], [d, [u, \"MachSpeed\"], [h, f]], [/\\btu_(1491) b/i], [d, [u, \"Rotor\"], [h, f]], [/(shield[\\w ]+) b/i], [d, [u, \"Nvidia\"], [h, f]], [/(sprint) (\\w+)/i], [u, d, [h, m]], [/(kin\\.[onetw]{3})/i], [[d, /\\./g, \" \"], [u, D], [h, m]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\\)/i], [d, [u, V], [h, f]], [/droid.+; (ec30|ps20|tc[2-8]\\d[kx])\\)/i], [d, [u, V], [h, m]], [/smart-tv.+(samsung)/i], [u, [h, T]], [/hbbtv.+maple;(\\d+)/i], [[d, /^/, \"SmartTV\"], [u, k], [h, T]], [/(nux; netcast.+smarttv|lg (netcast\\.tv-201\\d|android tv))/i], [[u, N], [h, T]], [/(apple) ?tv/i], [u, [d, C + \" TV\"], [h, T]], [/crkey/i], [[d, A + \"cast\"], [u, w], [h, T]], [/droid.+aft(\\w)( bui|\\))/i], [d, [u, R], [h, T]], [/\\(dtv[\\);].+(aquos)/i, /(aquos-tv[\\w ]+)\\)/i], [d, [u, M], [h, T]], [/(bravia[\\w ]+)( bui|\\))/i], [d, [u, U], [h, T]], [/(mitv-\\w{5}) bui/i], [d, [u, x], [h, T]], [/Hbbtv.*(technisat) (.*);/i], [u, d, [h, T]], [/\\b(roku)[\\dx]*[\\)\\/]((?:dvp-)?[\\d\\.]*)/i, /hbbtv\\/\\d+\\.\\d+\\.\\d+ +\\([\\w\\+ ]*; *([\\w\\d][^;]*);([^;]*)/i], [[u, K], [d, K], [h, T]], [/\\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\\b/i], [[h, T]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [u, d, [h, E]], [/droid.+; (shield) bui/i], [d, [u, \"Nvidia\"], [h, E]], [/(playstation [345portablevi]+)/i], [d, [u, U], [h, E]], [/\\b(xbox(?: one)?(?!; xbox))[\\); ]/i], [d, [u, D], [h, E]], [/((pebble))app/i], [u, d, [h, S]], [/(watch)(?: ?os[,\\/]|\\d,\\d\\/)[\\d\\.]+/i], [d, [u, C], [h, S]], [/droid.+; (glass) \\d/i], [d, [u, w], [h, S]], [/droid.+; (wt63?0{2,3})\\)/i], [d, [u, V], [h, S]], [/(quest( 2| pro)?)/i], [d, [u, F], [h, S]], [/(tesla)(?: qtcarbrowser|\\/[-\\w\\.]+)/i], [u, [h, g]], [/droid .+?; ([^;]+?)(?: bui|\\) applew).+? mobile safari/i], [d, [h, m]], [/droid .+?; ([^;]+?)(?: bui|\\) applew).+?(?! mobile) safari/i], [d, [h, f]], [/\\b((tablet|tab)[;\\/]|focus\\/\\d(?!.+mobile))/i], [[h, f]], [/(phone|mobile(?:[;\\/]| [ \\w\\/\\.]*safari)|pda(?=.+windows ce))/i], [[h, m]], [/(android[-\\w\\. ]{0,9});.+buil/i], [d, [u, \"Generic\"]]],\n          engine: [[/windows.+ edge\\/([\\w\\.]+)/i], [p, [l, \"EdgeHTML\"]], [/webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i], [p, [l, \"Blink\"]], [/(presto)\\/([\\w\\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\\/([\\w\\.]+)/i, /ekioh(flow)\\/([\\w\\.]+)/i, /(khtml|tasman|links)[\\/ ]\\(?([\\w\\.]+)/i, /(icab)[\\/ ]([23]\\.[\\d\\.]+)/i], [l, p], [/rv\\:([\\w\\.]{1,9})\\b.+(gecko)/i], [p, l]],\n          os: [[/microsoft (windows) (vista|xp)/i], [l, p], [/(windows) nt 6\\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\\/ ]?([\\d\\.\\w ]*)/i, /(windows)[\\/ ]?([ntce\\d\\. ]+\\w)(?!.+xbox)/i], [l, [p, q, z]], [/(win(?=3|9|n)|win 9x )([nt\\d\\.]+)/i], [[l, \"Windows\"], [p, q, z]], [/ip[honead]{2,4}\\b(?:.*os ([\\w]+) like mac|; opera)/i, /cfnetwork\\/.+darwin/i], [[p, /_/g, \".\"], [l, \"iOS\"]], [/(mac os x) ?([\\w\\. ]*)/i, /(macintosh|mac_powerpc\\b)(?!.+haiku)/i], [[l, j], [p, /_/g, \".\"]], [/droid ([\\w\\.]+)\\b.+(android[- ]x86|harmonyos)/i], [p, l], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\\/ ]?([\\w\\.]*)/i, /(blackberry)\\w*\\/([\\w\\.]*)/i, /(tizen|kaios)[\\/ ]([\\w\\.]+)/i, /\\((series40);/i], [l, p], [/\\(bb(10);/i], [p, [l, I]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\\/ ]?([\\w\\.]*)/i], [p, [l, \"Symbian\"]], [/mozilla\\/[\\d\\.]+ \\((?:mobile|tablet|tv|mobile; [\\w ]+); rv:.+ gecko\\/([\\w\\.]+)/i], [p, [l, b + \" OS\"]], [/web0s;.+rt(tv)/i, /\\b(?:hp)?wos(?:browser)?\\/([\\w\\.]+)/i], [p, [l, \"webOS\"]], [/watch(?: ?os[,\\/]|\\d,\\d\\/)([\\d\\.]+)/i], [p, [l, \"watchOS\"]], [/crkey\\/([\\d\\.]+)/i], [p, [l, A + \"cast\"]], [/(cros) [\\w]+(?:\\)| ([\\w\\.]+)\\b)/i], [[l, B], p], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\\/(\\d+\\.[\\w\\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\\);]+)/i, /\\b(joli|palm)\\b ?(?:os)?\\/?([\\w\\.]*)/i, /(mint)[\\/\\(\\) ]?(\\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\\/ ]?(?!chrom|package)([-\\w\\.]*)/i, /(hurd|linux) ?([\\w\\.]*)/i, /(gnu) ?([\\w\\.]*)/i, /\\b([-frentopcghs]{0,5}bsd|dragonfly)[\\/ ]?(?!amd|[ix346]{1,2}86)([\\w\\.]*)/i, /(haiku) (\\w+)/i], [l, p], [/(sunos) ?([\\w\\.\\d]*)/i], [[l, \"Solaris\"], p], [/((?:open)?solaris)[-\\/ ]?([\\w\\.]*)/i, /(aix) ((\\d)(?=\\.|\\)| )[\\w\\.])*/i, /\\b(beos|os\\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\\w\\.]*)/i], [l, p]]\n        },\n        X = function (e, i) {\n          if (typeof e === s && (i = e, e = n), !(this instanceof X)) return new X(e, i).getResult();\n          var E = typeof t !== o && t.navigator ? t.navigator : n,\n            T = e || (E && E.userAgent ? E.userAgent : \"\"),\n            S = E && E.userAgentData ? E.userAgentData : n,\n            g = i ? function (e, t) {\n              var i = {};\n              for (var n in e) t[n] && t[n].length % 2 == 0 ? i[n] = t[n].concat(e[n]) : i[n] = e[n];\n              return i;\n            }(J, i) : J;\n          return this.getBrowser = function () {\n            var e = {};\n            return e[l] = n, e[p] = n, Y.call(e, T, g.browser), e[c] = function (e) {\n              return typeof e === a ? e.replace(/[^\\d\\.]/g, \"\").split(\".\")[0] : n;\n            }(e[p]), E && E.brave && typeof E.brave.isBrave == r && (e[l] = \"Brave\"), e;\n          }, this.getCPU = function () {\n            var e = {};\n            return e[_] = n, Y.call(e, T, g.cpu), e;\n          }, this.getDevice = function () {\n            var e = {};\n            return e[u] = n, e[d] = n, e[h] = n, Y.call(e, T, g.device), !e[h] && S && S.mobile && (e[h] = m), \"Macintosh\" == e[d] && E && typeof E.standalone !== o && E.maxTouchPoints && E.maxTouchPoints > 2 && (e[d] = \"iPad\", e[h] = f), e;\n          }, this.getEngine = function () {\n            var e = {};\n            return e[l] = n, e[p] = n, Y.call(e, T, g.engine), e;\n          }, this.getOS = function () {\n            var e = {};\n            return e[l] = n, e[p] = n, Y.call(e, T, g.os), !e[l] && S && \"Unknown\" != S.platform && (e[l] = S.platform.replace(/chrome os/i, B).replace(/macos/i, j)), e;\n          }, this.getResult = function () {\n            return {\n              ua: this.getUA(),\n              browser: this.getBrowser(),\n              engine: this.getEngine(),\n              os: this.getOS(),\n              device: this.getDevice(),\n              cpu: this.getCPU()\n            };\n          }, this.getUA = function () {\n            return T;\n          }, this.setUA = function (e) {\n            return T = typeof e === a && e.length > 350 ? K(e, 350) : e, this;\n          }, this.setUA(T), this;\n        };\n      X.VERSION = \"0.7.34\", X.BROWSER = G([l, p, c]), X.CPU = G([_]), X.DEVICE = G([d, u, h, E, m, T, f, S, g]), X.ENGINE = X.OS = G([l, p]), e.exports && (i = e.exports = X), i.UAParser = X;\n      var Q = typeof t !== o && (t.jQuery || t.Zepto);\n      if (Q && !Q.ua) {\n        var Z = new X();\n        Q.ua = Z.getResult(), Q.ua.get = function () {\n          return Z.getUA();\n        }, Q.ua.set = function (e) {\n          Z.setUA(e);\n          var t = Z.getResult();\n          for (var i in t) Q.ua[i] = t[i];\n        };\n      }\n    }(\"object\" == typeof window ? window : t);\n  }(sE, sE.exports);\n  var aE = i(sE.exports),\n    cE = pn,\n    dE = Ze,\n    lE = Y,\n    hE = xo,\n    uE = ut(\"iterator\"),\n    pE = Object,\n    _E = function (e) {\n      if (lE(e)) return !1;\n      var t = pE(e);\n      return void 0 !== t[uE] || \"@@iterator\" in t || dE(hE, cE(t));\n    },\n    EE = i(_E),\n    mE = u;\n  wi({\n    global: !0,\n    forced: mE.globalThis !== mE\n  }, {\n    globalThis: mE\n  });\n  var fE = i(u);\n  function TE(e, t) {\n    return function () {\n      return e.apply(t, arguments);\n    };\n  }\n  const SE = Object.prototype.toString,\n    gE = Object.getPrototypeOf,\n    RE = (CE = Object.create(null), e => {\n      const t = SE.call(e);\n      return CE[t] || (CE[t] = t.slice(8, -1).toLowerCase());\n    });\n  var CE;\n  const vE = e => (e = e.toLowerCase(), t => RE(t) === e),\n    IE = e => t => typeof t === e,\n    yE = Array.isArray,\n    AE = IE(\"undefined\");\n  const bE = vE(\"ArrayBuffer\");\n  const wE = IE(\"string\"),\n    OE = IE(\"function\"),\n    NE = IE(\"number\"),\n    DE = e => null !== e && \"object\" == typeof e,\n    PE = e => {\n      if (\"object\" !== RE(e)) return !1;\n      const t = gE(e);\n      return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || EE(e));\n    },\n    LE = vE(\"Date\"),\n    kE = vE(\"File\"),\n    ME = vE(\"Blob\"),\n    UE = vE(\"FileList\"),\n    xE = vE(\"URLSearchParams\");\n  function VE(e, t) {\n    let i,\n      n,\n      _ref2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n      _ref2$allOwnKeys = _ref2.allOwnKeys,\n      r = _ref2$allOwnKeys === void 0 ? !1 : _ref2$allOwnKeys;\n    if (null != e) if (\"object\" != typeof e && (e = [e]), yE(e)) for (i = 0, n = e.length; i < n; i++) t.call(null, e[i], i, e);else {\n      const n = r ? Object.getOwnPropertyNames(e) : Object.keys(e),\n        o = n.length;\n      let s;\n      for (i = 0; i < o; i++) s = n[i], t.call(null, e[s], s, e);\n    }\n  }\n  function FE(e, t) {\n    t = t.toLowerCase();\n    const i = Object.keys(e);\n    let n,\n      r = i.length;\n    for (; r-- > 0;) if (n = i[r], t === n.toLowerCase()) return n;\n    return null;\n  }\n  const BE = void 0 !== fE ? fE : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : global,\n    jE = e => !AE(e) && e !== BE;\n  const GE = (WE = \"undefined\" != typeof Uint8Array && gE(Uint8Array), e => WE && e instanceof WE);\n  var WE;\n  const HE = vE(\"HTMLFormElement\"),\n    KE = (e => {\n      let t = e.hasOwnProperty;\n      return (e, i) => t.call(e, i);\n    })(Object.prototype),\n    YE = vE(\"RegExp\"),\n    qE = (e, t) => {\n      const i = Object.getOwnPropertyDescriptors(e),\n        n = {};\n      VE(i, (i, r) => {\n        let o;\n        !1 !== (o = t(i, r, e)) && (n[r] = o || i);\n      }), Object.defineProperties(e, n);\n    },\n    zE = \"abcdefghijklmnopqrstuvwxyz\",\n    JE = \"0123456789\",\n    XE = {\n      DIGIT: JE,\n      ALPHA: zE,\n      ALPHA_DIGIT: zE + zE.toUpperCase() + JE\n    };\n  const QE = vE(\"AsyncFunction\");\n  var ZE = {\n    isArray: yE,\n    isArrayBuffer: bE,\n    isBuffer: function (e) {\n      return null !== e && !AE(e) && null !== e.constructor && !AE(e.constructor) && OE(e.constructor.isBuffer) && e.constructor.isBuffer(e);\n    },\n    isFormData: e => {\n      let t;\n      return e && (\"function\" == typeof FormData && e instanceof FormData || OE(e.append) && (\"formdata\" === (t = RE(e)) || \"object\" === t && OE(e.toString) && \"[object FormData]\" === e.toString()));\n    },\n    isArrayBufferView: function (e) {\n      let t;\n      return t = \"undefined\" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && bE(e.buffer), t;\n    },\n    isString: wE,\n    isNumber: NE,\n    isBoolean: e => !0 === e || !1 === e,\n    isObject: DE,\n    isPlainObject: PE,\n    isUndefined: AE,\n    isDate: LE,\n    isFile: kE,\n    isBlob: ME,\n    isRegExp: YE,\n    isFunction: OE,\n    isStream: e => DE(e) && OE(e.pipe),\n    isURLSearchParams: xE,\n    isTypedArray: GE,\n    isFileList: UE,\n    forEach: VE,\n    merge: function e() {\n      const _ref3 = jE(this) && this || {},\n        t = _ref3.caseless,\n        i = {},\n        n = (n, r) => {\n          const o = t && FE(i, r) || r;\n          PE(i[o]) && PE(n) ? i[o] = e(i[o], n) : PE(n) ? i[o] = e({}, n) : yE(n) ? i[o] = n.slice() : i[o] = n;\n        };\n      for (let e = 0, t = arguments.length; e < t; e++) arguments[e] && VE(arguments[e], n);\n      return i;\n    },\n    extend: function (e, t, i) {\n      let _ref4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},\n        n = _ref4.allOwnKeys;\n      return VE(t, (t, n) => {\n        i && OE(t) ? e[n] = TE(t, i) : e[n] = t;\n      }, {\n        allOwnKeys: n\n      }), e;\n    },\n    trim: e => jp(e) ? jp(e).call(e) : e.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\"),\n    stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e),\n    inherits: (e, t, i, n) => {\n      e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, \"super\", {\n        value: t.prototype\n      }), i && Object.assign(e.prototype, i);\n    },\n    toFlatObject: (e, t, i, n) => {\n      let r, o, s;\n      const a = {};\n      if (t = t || {}, null == e) return t;\n      do {\n        for (r = Object.getOwnPropertyNames(e), o = r.length; o-- > 0;) s = r[o], n && !n(s, e, t) || a[s] || (t[s] = e[s], a[s] = !0);\n        e = !1 !== i && gE(e);\n      } while (e && (!i || i(e, t)) && e !== Object.prototype);\n      return t;\n    },\n    kindOf: RE,\n    kindOfTest: vE,\n    endsWith: (e, t, i) => {\n      e = String(e), (void 0 === i || i > e.length) && (i = e.length), i -= t.length;\n      const n = e.indexOf(t, i);\n      return -1 !== n && n === i;\n    },\n    toArray: e => {\n      if (!e) return null;\n      if (yE(e)) return e;\n      let t = e.length;\n      if (!NE(t)) return null;\n      const i = new Array(t);\n      for (; t-- > 0;) i[t] = e[t];\n      return i;\n    },\n    forEachEntry: (e, t) => {\n      const i = (e && e[Symbol.iterator]).call(e);\n      let n;\n      for (; (n = i.next()) && !n.done;) {\n        const i = n.value;\n        t.call(e, i[0], i[1]);\n      }\n    },\n    matchAll: (e, t) => {\n      let i;\n      const n = [];\n      for (; null !== (i = e.exec(t));) n.push(i);\n      return n;\n    },\n    isHTMLForm: HE,\n    hasOwnProperty: KE,\n    hasOwnProp: KE,\n    reduceDescriptors: qE,\n    freezeMethods: e => {\n      qE(e, (t, i) => {\n        if (OE(e) && -1 !== [\"arguments\", \"caller\", \"callee\"].indexOf(i)) return !1;\n        const n = e[i];\n        OE(n) && (t.enumerable = !1, \"writable\" in t ? t.writable = !1 : t.set || (t.set = () => {\n          throw Error(\"Can not rewrite read-only method '\" + i + \"'\");\n        }));\n      });\n    },\n    toObjectSet: (e, t) => {\n      const i = {},\n        n = e => {\n          e.forEach(e => {\n            i[e] = !0;\n          });\n        };\n      return yE(e) ? n(e) : n(String(e).split(t)), i;\n    },\n    toCamelCase: e => e.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g, function (e, t, i) {\n      return t.toUpperCase() + i;\n    }),\n    noop: () => {},\n    toFiniteNumber: (e, t) => (e = +e, Number.isFinite(e) ? e : t),\n    findKey: FE,\n    global: BE,\n    isContextDefined: jE,\n    ALPHABET: XE,\n    generateString: function () {\n      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16,\n        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : XE.ALPHA_DIGIT,\n        i = \"\";\n      const n = t.length;\n      for (; e--;) i += t[Math.random() * n | 0];\n      return i;\n    },\n    isSpecCompliantForm: function (e) {\n      return !!(e && OE(e.append) && \"FormData\" === e[Symbol.toStringTag] && e[Symbol.iterator]);\n    },\n    toJSONObject: e => {\n      const t = new Array(10),\n        i = (e, n) => {\n          if (DE(e)) {\n            if (t.indexOf(e) >= 0) return;\n            if (!(\"toJSON\" in e)) {\n              t[n] = e;\n              const r = yE(e) ? [] : {};\n              return VE(e, (e, t) => {\n                const o = i(e, n + 1);\n                !AE(o) && (r[t] = o);\n              }), t[n] = void 0, r;\n            }\n          }\n          return e;\n        };\n      return i(e, 0);\n    },\n    isAsyncFn: QE,\n    isThenable: e => e && (DE(e) || OE(e)) && OE(e.then) && OE(e.catch)\n  };\n  function $E(e, t, i, n, r) {\n    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = \"AxiosError\", t && (this.code = t), i && (this.config = i), n && (this.request = n), r && (this.response = r);\n  }\n  ZE.inherits($E, Error, {\n    toJSON: function () {\n      return {\n        message: this.message,\n        name: this.name,\n        description: this.description,\n        number: this.number,\n        fileName: this.fileName,\n        lineNumber: this.lineNumber,\n        columnNumber: this.columnNumber,\n        stack: this.stack,\n        config: ZE.toJSONObject(this.config),\n        code: this.code,\n        status: this.response && this.response.status ? this.response.status : null\n      };\n    }\n  });\n  const em = $E.prototype,\n    tm = {};\n  [\"ERR_BAD_OPTION_VALUE\", \"ERR_BAD_OPTION\", \"ECONNABORTED\", \"ETIMEDOUT\", \"ERR_NETWORK\", \"ERR_FR_TOO_MANY_REDIRECTS\", \"ERR_DEPRECATED\", \"ERR_BAD_RESPONSE\", \"ERR_BAD_REQUEST\", \"ERR_CANCELED\", \"ERR_NOT_SUPPORT\", \"ERR_INVALID_URL\"].forEach(e => {\n    tm[e] = {\n      value: e\n    };\n  }), Object.defineProperties($E, tm), Object.defineProperty(em, \"isAxiosError\", {\n    value: !0\n  }), $E.from = (e, t, i, n, r, o) => {\n    const s = Object.create(em);\n    return ZE.toFlatObject(e, s, function (e) {\n      return e !== Error.prototype;\n    }, e => \"isAxiosError\" !== e), $E.call(s, e.message, t, i, n, r), s.cause = e, s.name = e.name, o && Object.assign(s, o), s;\n  };\n  function im(e) {\n    return ZE.isPlainObject(e) || ZE.isArray(e);\n  }\n  function nm(e) {\n    return ZE.endsWith(e, \"[]\") ? e.slice(0, -2) : e;\n  }\n  function rm(e, t, i) {\n    return e ? e.concat(t).map(function (e, t) {\n      return e = nm(e), !i && t ? \"[\" + e + \"]\" : e;\n    }).join(i ? \".\" : \"\") : t;\n  }\n  const om = ZE.toFlatObject(ZE, {}, null, function (e) {\n    return /^is[A-Z]/.test(e);\n  });\n  function sm(e, t, i) {\n    if (!ZE.isObject(e)) throw new TypeError(\"target must be an object\");\n    t = t || new FormData();\n    const n = (i = ZE.toFlatObject(i, {\n        metaTokens: !0,\n        dots: !1,\n        indexes: !1\n      }, !1, function (e, t) {\n        return !ZE.isUndefined(t[e]);\n      })).metaTokens,\n      r = i.visitor || d,\n      o = i.dots,\n      s = i.indexes,\n      a = (i.Blob || \"undefined\" != typeof Blob && Blob) && ZE.isSpecCompliantForm(t);\n    if (!ZE.isFunction(r)) throw new TypeError(\"visitor must be a function\");\n    function c(e) {\n      if (null === e) return \"\";\n      if (ZE.isDate(e)) return e.toISOString();\n      if (!a && ZE.isBlob(e)) throw new $E(\"Blob is not supported. Use a Buffer instead.\");\n      return ZE.isArrayBuffer(e) || ZE.isTypedArray(e) ? a && \"function\" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e;\n    }\n    function d(e, i, r) {\n      let a = e;\n      if (e && !r && \"object\" == typeof e) if (ZE.endsWith(i, \"{}\")) i = n ? i : i.slice(0, -2), e = JSON.stringify(e);else if (ZE.isArray(e) && function (e) {\n        return ZE.isArray(e) && !e.some(im);\n      }(e) || (ZE.isFileList(e) || ZE.endsWith(i, \"[]\")) && (a = ZE.toArray(e))) return i = nm(i), a.forEach(function (e, n) {\n        !ZE.isUndefined(e) && null !== e && t.append(!0 === s ? rm([i], n, o) : null === s ? i : i + \"[]\", c(e));\n      }), !1;\n      return !!im(e) || (t.append(rm(r, i, o), c(e)), !1);\n    }\n    const l = [],\n      h = Object.assign(om, {\n        defaultVisitor: d,\n        convertValue: c,\n        isVisitable: im\n      });\n    if (!ZE.isObject(e)) throw new TypeError(\"data must be an object\");\n    return function e(i, n) {\n      if (!ZE.isUndefined(i)) {\n        if (-1 !== l.indexOf(i)) throw Error(\"Circular reference detected in \" + n.join(\".\"));\n        l.push(i), ZE.forEach(i, function (i, o) {\n          !0 === (!(ZE.isUndefined(i) || null === i) && r.call(t, i, ZE.isString(o) ? jp(o).call(o) : o, n, h)) && e(i, n ? n.concat(o) : [o]);\n        }), l.pop();\n      }\n    }(e), t;\n  }\n  function am(e) {\n    const t = {\n      \"!\": \"%21\",\n      \"'\": \"%27\",\n      \"(\": \"%28\",\n      \")\": \"%29\",\n      \"~\": \"%7E\",\n      \"%20\": \"+\",\n      \"%00\": \"\\0\"\n    };\n    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (e) {\n      return t[e];\n    });\n  }\n  function cm(e, t) {\n    this._pairs = [], e && sm(e, this, t);\n  }\n  const dm = cm.prototype;\n  function lm(e) {\n    return encodeURIComponent(e).replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\").replace(/%5B/gi, \"[\").replace(/%5D/gi, \"]\");\n  }\n  function hm(e, t, i) {\n    if (!t) return e;\n    const n = i && i.encode || lm,\n      r = i && i.serialize;\n    let o;\n    if (o = r ? r(t, i) : ZE.isURLSearchParams(t) ? t.toString() : new cm(t, i).toString(n), o) {\n      const t = e.indexOf(\"#\");\n      -1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf(\"?\") ? \"?\" : \"&\") + o;\n    }\n    return e;\n  }\n  dm.append = function (e, t) {\n    this._pairs.push([e, t]);\n  }, dm.toString = function (e) {\n    const t = e ? function (t) {\n      return e.call(this, t, am);\n    } : am;\n    return this._pairs.map(function (e) {\n      return t(e[0]) + \"=\" + t(e[1]);\n    }, \"\").join(\"&\");\n  };\n  var um = class {\n      constructor() {\n        this.handlers = [];\n      }\n      use(e, t, i) {\n        return this.handlers.push({\n          fulfilled: e,\n          rejected: t,\n          synchronous: !!i && i.synchronous,\n          runWhen: i ? i.runWhen : null\n        }), this.handlers.length - 1;\n      }\n      eject(e) {\n        this.handlers[e] && (this.handlers[e] = null);\n      }\n      clear() {\n        this.handlers && (this.handlers = []);\n      }\n      forEach(e) {\n        ZE.forEach(this.handlers, function (t) {\n          null !== t && e(t);\n        });\n      }\n    },\n    pm = {\n      silentJSONParsing: !0,\n      forcedJSONParsing: !0,\n      clarifyTimeoutError: !1\n    },\n    _m = {\n      exports: {}\n    },\n    Em = wi,\n    mm = N,\n    fm = Qt.f;\n  Em({\n    target: \"Object\",\n    stat: !0,\n    forced: Object.defineProperty !== fm,\n    sham: !mm\n  }, {\n    defineProperty: fm\n  });\n  var Tm = ie.Object,\n    Sm = _m.exports = function (e, t, i) {\n      return Tm.defineProperty(e, t, i);\n    };\n  Tm.defineProperty.sham && (Sm.sham = !0);\n  var gm = i(_m.exports),\n    Rm = R,\n    Cm = Array.isArray || function (e) {\n      return \"Array\" == Rm(e);\n    },\n    vm = TypeError,\n    Im = Cm,\n    ym = jc,\n    Am = te,\n    bm = ut(\"species\"),\n    wm = Array,\n    Om = function (e) {\n      var t;\n      return Im(e) && (t = e.constructor, (ym(t) && (t === wm || Im(t.prototype)) || Am(t) && null === (t = t[bm])) && (t = void 0)), void 0 === t ? wm : t;\n    },\n    Nm = function (e, t) {\n      return new (Om(e))(0 === t ? 0 : t);\n    },\n    Dm = n,\n    Pm = Ee,\n    Lm = ut(\"species\"),\n    km = function (e) {\n      return Pm >= 51 || !Dm(function () {\n        var t = [];\n        return (t.constructor = {})[Lm] = function () {\n          return {\n            foo: 1\n          };\n        }, 1 !== t[e](Boolean).foo;\n      });\n    },\n    Mm = wi,\n    Um = n,\n    xm = Cm,\n    Vm = te,\n    Fm = Je,\n    Bm = Gi,\n    jm = function (e) {\n      if (e > 9007199254740991) throw vm(\"Maximum allowed index exceeded\");\n      return e;\n    },\n    Gm = E_,\n    Wm = Nm,\n    Hm = km,\n    Km = Ee,\n    Ym = ut(\"isConcatSpreadable\"),\n    qm = Km >= 51 || !Um(function () {\n      var e = [];\n      return e[Ym] = !1, e.concat()[0] !== e;\n    }),\n    zm = function (e) {\n      if (!Vm(e)) return !1;\n      var t = e[Ym];\n      return void 0 !== t ? !!t : xm(e);\n    };\n  Mm({\n    target: \"Array\",\n    proto: !0,\n    arity: 1,\n    forced: !qm || !Hm(\"concat\")\n  }, {\n    concat: function (e) {\n      var t,\n        i,\n        n,\n        r,\n        o,\n        s = Fm(this),\n        a = Wm(s, 0),\n        c = 0;\n      for (t = -1, n = arguments.length; t < n; t++) if (zm(o = -1 === t ? s : arguments[t])) for (r = Bm(o), jm(c + r), i = 0; i < r; i++, c++) i in o && Gm(a, c, o[i]);else jm(c + 1), Gm(a, c++, o);\n      return a.length = c, a;\n    }\n  });\n  var Jm = {},\n    Xm = R,\n    Qm = Z,\n    Zm = Or.f,\n    $m = R_,\n    ef = \"object\" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\n  Jm.f = function (e) {\n    return ef && \"Window\" == Xm(e) ? function (e) {\n      try {\n        return Zm(e);\n      } catch (e) {\n        return $m(ef);\n      }\n    }(e) : Zm(Qm(e));\n  };\n  var tf = {},\n    nf = ut;\n  tf.f = nf;\n  var rf = ie,\n    of = Ze,\n    sf = tf,\n    af = Qt.f,\n    cf = function (e) {\n      var t = rf.Symbol || (rf.Symbol = {});\n      of(t, e) || af(t, e, {\n        value: sf.f(e)\n      });\n    },\n    df = L,\n    lf = ae,\n    hf = ut,\n    uf = ua,\n    pf = function () {\n      var e = lf(\"Symbol\"),\n        t = e && e.prototype,\n        i = t && t.valueOf,\n        n = hf(\"toPrimitive\");\n      t && !t[n] && uf(t, n, function (e) {\n        return df(i, this);\n      }, {\n        arity: 1\n      });\n    },\n    _f = Xt,\n    Ef = K,\n    mf = Je,\n    ff = Gi,\n    Tf = Nm,\n    Sf = d([].push),\n    gf = function (e) {\n      var t = 1 == e,\n        i = 2 == e,\n        n = 3 == e,\n        r = 4 == e,\n        o = 6 == e,\n        s = 7 == e,\n        a = 5 == e || o;\n      return function (c, d, l, h) {\n        for (var u, p, _ = mf(c), E = Ef(_), m = _f(d, l), f = ff(E), T = 0, S = h || Tf, g = t ? S(c, f) : i || s ? S(c, 0) : void 0; f > T; T++) if ((a || T in E) && (p = m(u = E[T], T, _), e)) if (t) g[T] = p;else if (p) switch (e) {\n          case 3:\n            return !0;\n          case 5:\n            return u;\n          case 6:\n            return T;\n          case 2:\n            Sf(g, u);\n        } else switch (e) {\n          case 4:\n            return !1;\n          case 7:\n            Sf(g, u);\n        }\n        return o ? -1 : n || r ? r : g;\n      };\n    },\n    Rf = {\n      forEach: gf(0),\n      map: gf(1),\n      filter: gf(2),\n      some: gf(3),\n      every: gf(4),\n      find: gf(5),\n      findIndex: gf(6),\n      filterReject: gf(7)\n    },\n    Cf = wi,\n    vf = u,\n    If = L,\n    yf = d,\n    Af = N,\n    bf = Se,\n    wf = n,\n    Of = Ze,\n    Nf = l,\n    Df = ii,\n    Pf = Z,\n    Lf = Ct,\n    kf = mn,\n    Mf = B,\n    Uf = vo,\n    xf = eo,\n    Vf = Or,\n    Ff = Jm,\n    Bf = Br,\n    jf = O,\n    Gf = Qt,\n    Wf = Qr,\n    Hf = k,\n    Kf = ua,\n    Yf = uc,\n    qf = Ye,\n    zf = Nr,\n    Jf = nt,\n    Xf = ut,\n    Qf = tf,\n    Zf = cf,\n    $f = pf,\n    eT = Da,\n    tT = ra,\n    iT = Rf.forEach,\n    nT = lr(\"hidden\"),\n    rT = \"Symbol\",\n    oT = \"prototype\",\n    sT = tT.set,\n    aT = tT.getterFor(rT),\n    cT = Object[oT],\n    dT = vf.Symbol,\n    lT = dT && dT[oT],\n    hT = vf.TypeError,\n    uT = vf.QObject,\n    pT = jf.f,\n    _T = Gf.f,\n    ET = Ff.f,\n    mT = Hf.f,\n    fT = yf([].push),\n    TT = qf(\"symbols\"),\n    ST = qf(\"op-symbols\"),\n    gT = qf(\"wks\"),\n    RT = !uT || !uT[oT] || !uT[oT].findChild,\n    CT = Af && wf(function () {\n      return 7 != Uf(_T({}, \"a\", {\n        get: function () {\n          return _T(this, \"a\", {\n            value: 7\n          }).a;\n        }\n      })).a;\n    }) ? function (e, t, i) {\n      var n = pT(cT, t);\n      n && delete cT[t], _T(e, t, i), n && e !== cT && _T(cT, t, n);\n    } : _T,\n    vT = function (e, t) {\n      var i = TT[e] = Uf(lT);\n      return sT(i, {\n        type: rT,\n        tag: e,\n        description: t\n      }), Af || (i.description = t), i;\n    },\n    IT = function (e, t, i) {\n      e === cT && IT(ST, t, i), Df(e);\n      var n = Lf(t);\n      return Df(i), Of(TT, n) ? (i.enumerable ? (Of(e, nT) && e[nT][n] && (e[nT][n] = !1), i = Uf(i, {\n        enumerable: Mf(0, !1)\n      })) : (Of(e, nT) || _T(e, nT, Mf(1, {})), e[nT][n] = !0), CT(e, n, i)) : _T(e, n, i);\n    },\n    yT = function (e, t) {\n      Df(e);\n      var i = Pf(t),\n        n = xf(i).concat(OT(i));\n      return iT(n, function (t) {\n        Af && !If(AT, i, t) || IT(e, t, i[t]);\n      }), e;\n    },\n    AT = function (e) {\n      var t = Lf(e),\n        i = If(mT, this, t);\n      return !(this === cT && Of(TT, t) && !Of(ST, t)) && (!(i || !Of(this, t) || !Of(TT, t) || Of(this, nT) && this[nT][t]) || i);\n    },\n    bT = function (e, t) {\n      var i = Pf(e),\n        n = Lf(t);\n      if (i !== cT || !Of(TT, n) || Of(ST, n)) {\n        var r = pT(i, n);\n        return !r || !Of(TT, n) || Of(i, nT) && i[nT][n] || (r.enumerable = !0), r;\n      }\n    },\n    wT = function (e) {\n      var t = ET(Pf(e)),\n        i = [];\n      return iT(t, function (e) {\n        Of(TT, e) || Of(zf, e) || fT(i, e);\n      }), i;\n    },\n    OT = function (e) {\n      var t = e === cT,\n        i = ET(t ? ST : Pf(e)),\n        n = [];\n      return iT(i, function (e) {\n        !Of(TT, e) || t && !Of(cT, e) || fT(n, TT[e]);\n      }), n;\n    };\n  bf || (dT = function () {\n    if (Nf(lT, this)) throw hT(\"Symbol is not a constructor\");\n    var e = arguments.length && void 0 !== arguments[0] ? kf(arguments[0]) : void 0,\n      t = Jf(e),\n      i = function (e) {\n        this === cT && If(i, ST, e), Of(this, nT) && Of(this[nT], t) && (this[nT][t] = !1), CT(this, t, Mf(1, e));\n      };\n    return Af && RT && CT(cT, t, {\n      configurable: !0,\n      set: i\n    }), vT(t, e);\n  }, Kf(lT = dT[oT], \"toString\", function () {\n    return aT(this).tag;\n  }), Kf(dT, \"withoutSetter\", function (e) {\n    return vT(Jf(e), e);\n  }), Hf.f = AT, Gf.f = IT, Wf.f = yT, jf.f = bT, Vf.f = Ff.f = wT, Bf.f = OT, Qf.f = function (e) {\n    return vT(Xf(e), e);\n  }, Af && Yf(lT, \"description\", {\n    configurable: !0,\n    get: function () {\n      return aT(this).description;\n    }\n  })), Cf({\n    global: !0,\n    constructor: !0,\n    wrap: !0,\n    forced: !bf,\n    sham: !bf\n  }, {\n    Symbol: dT\n  }), iT(xf(gT), function (e) {\n    Zf(e);\n  }), Cf({\n    target: rT,\n    stat: !0,\n    forced: !bf\n  }, {\n    useSetter: function () {\n      RT = !0;\n    },\n    useSimple: function () {\n      RT = !1;\n    }\n  }), Cf({\n    target: \"Object\",\n    stat: !0,\n    forced: !bf,\n    sham: !Af\n  }, {\n    create: function (e, t) {\n      return void 0 === t ? Uf(e) : yT(Uf(e), t);\n    },\n    defineProperty: IT,\n    defineProperties: yT,\n    getOwnPropertyDescriptor: bT\n  }), Cf({\n    target: \"Object\",\n    stat: !0,\n    forced: !bf\n  }, {\n    getOwnPropertyNames: wT\n  }), $f(), eT(dT, rT), zf[nT] = !0;\n  var NT = Se && !!Symbol.for && !!Symbol.keyFor,\n    DT = wi,\n    PT = ae,\n    LT = Ze,\n    kT = mn,\n    MT = Ye,\n    UT = NT,\n    xT = MT(\"string-to-symbol-registry\"),\n    VT = MT(\"symbol-to-string-registry\");\n  DT({\n    target: \"Symbol\",\n    stat: !0,\n    forced: !UT\n  }, {\n    for: function (e) {\n      var t = kT(e);\n      if (LT(xT, t)) return xT[t];\n      var i = PT(\"Symbol\")(t);\n      return xT[t] = i, VT[i] = t, i;\n    }\n  });\n  var FT = wi,\n    BT = Ze,\n    jT = ye,\n    GT = be,\n    WT = NT,\n    HT = Ye(\"symbol-to-string-registry\");\n  FT({\n    target: \"Symbol\",\n    stat: !0,\n    forced: !WT\n  }, {\n    keyFor: function (e) {\n      if (!jT(e)) throw TypeError(GT(e) + \" is not a symbol\");\n      if (BT(HT, e)) return HT[e];\n    }\n  });\n  var KT = Cm,\n    YT = w,\n    qT = R,\n    zT = mn,\n    JT = d([].push),\n    XT = wi,\n    QT = ae,\n    ZT = f,\n    $T = L,\n    eS = d,\n    tS = n,\n    iS = w,\n    nS = ye,\n    rS = Xc,\n    oS = function (e) {\n      if (YT(e)) return e;\n      if (KT(e)) {\n        for (var t = e.length, i = [], n = 0; n < t; n++) {\n          var r = e[n];\n          \"string\" == typeof r ? JT(i, r) : \"number\" != typeof r && \"Number\" != qT(r) && \"String\" != qT(r) || JT(i, zT(r));\n        }\n        var o = i.length,\n          s = !0;\n        return function (e, t) {\n          if (s) return s = !1, t;\n          if (KT(this)) return t;\n          for (var n = 0; n < o; n++) if (i[n] === e) return t;\n        };\n      }\n    },\n    sS = Se,\n    aS = String,\n    cS = QT(\"JSON\", \"stringify\"),\n    dS = eS(/./.exec),\n    lS = eS(\"\".charAt),\n    hS = eS(\"\".charCodeAt),\n    uS = eS(\"\".replace),\n    pS = eS(1..toString),\n    _S = /[\\uD800-\\uDFFF]/g,\n    ES = /^[\\uD800-\\uDBFF]$/,\n    mS = /^[\\uDC00-\\uDFFF]$/,\n    fS = !sS || tS(function () {\n      var e = QT(\"Symbol\")();\n      return \"[null]\" != cS([e]) || \"{}\" != cS({\n        a: e\n      }) || \"{}\" != cS(Object(e));\n    }),\n    TS = tS(function () {\n      return '\"\\\\udf06\\\\ud834\"' !== cS(\"\\udf06\\ud834\") || '\"\\\\udead\"' !== cS(\"\\udead\");\n    }),\n    SS = function (e, t) {\n      var i = rS(arguments),\n        n = oS(t);\n      if (iS(n) || void 0 !== e && !nS(e)) return i[1] = function (e, t) {\n        if (iS(n) && (t = $T(n, this, aS(e), t)), !nS(t)) return t;\n      }, ZT(cS, null, i);\n    },\n    gS = function (e, t, i) {\n      var n = lS(i, t - 1),\n        r = lS(i, t + 1);\n      return dS(ES, e) && !dS(mS, r) || dS(mS, e) && !dS(ES, n) ? \"\\\\u\" + pS(hS(e, 0), 16) : e;\n    };\n  cS && XT({\n    target: \"JSON\",\n    stat: !0,\n    arity: 3,\n    forced: fS || TS\n  }, {\n    stringify: function (e, t, i) {\n      var n = rS(arguments),\n        r = ZT(fS ? SS : cS, null, n);\n      return TS && \"string\" == typeof r ? uS(r, _S, gS) : r;\n    }\n  });\n  var RS = Br,\n    CS = Je;\n  wi({\n    target: \"Object\",\n    stat: !0,\n    forced: !Se || n(function () {\n      RS.f(1);\n    })\n  }, {\n    getOwnPropertySymbols: function (e) {\n      var t = RS.f;\n      return t ? t(CS(e)) : [];\n    }\n  }), cf(\"asyncIterator\"), cf(\"hasInstance\"), cf(\"isConcatSpreadable\"), cf(\"iterator\"), cf(\"match\"), cf(\"matchAll\"), cf(\"replace\"), cf(\"search\"), cf(\"species\"), cf(\"split\");\n  var vS = pf;\n  cf(\"toPrimitive\"), vS();\n  var IS = ae,\n    yS = Da;\n  cf(\"toStringTag\"), yS(IS(\"Symbol\"), \"Symbol\"), cf(\"unscopables\"), Da(u.JSON, \"JSON\", !0);\n  var AS = ie.Symbol,\n    bS = ut,\n    wS = Qt.f,\n    OS = bS(\"metadata\"),\n    NS = Function.prototype;\n  void 0 === NS[OS] && wS(NS, OS, {\n    value: null\n  }), cf(\"dispose\"), cf(\"metadata\");\n  var DS = AS;\n  cf(\"asyncDispose\");\n  var PS = d,\n    LS = ae(\"Symbol\"),\n    kS = LS.keyFor,\n    MS = PS(LS.prototype.valueOf),\n    US = LS.isRegisteredSymbol || function (e) {\n      try {\n        return void 0 !== kS(MS(e));\n      } catch (e) {\n        return !1;\n      }\n    };\n  wi({\n    target: \"Symbol\",\n    stat: !0\n  }, {\n    isRegisteredSymbol: US\n  });\n  for (var xS = Ye, VS = ae, FS = d, BS = ye, jS = ut, GS = VS(\"Symbol\"), WS = GS.isWellKnownSymbol, HS = VS(\"Object\", \"getOwnPropertyNames\"), KS = FS(GS.prototype.valueOf), YS = xS(\"wks\"), qS = 0, zS = HS(GS), JS = zS.length; qS < JS; qS++) try {\n    var XS = zS[qS];\n    BS(GS[XS]) && jS(XS);\n  } catch (e) {}\n  var QS = function (e) {\n    if (WS && WS(e)) return !0;\n    try {\n      for (var t = KS(e), i = 0, n = HS(YS), r = n.length; i < r; i++) if (YS[n[i]] == t) return !0;\n    } catch (e) {}\n    return !1;\n  };\n  wi({\n    target: \"Symbol\",\n    stat: !0,\n    forced: !0\n  }, {\n    isWellKnownSymbol: QS\n  }), cf(\"matcher\"), cf(\"observable\"), wi({\n    target: \"Symbol\",\n    stat: !0,\n    name: \"isRegisteredSymbol\"\n  }, {\n    isRegistered: US\n  }), wi({\n    target: \"Symbol\",\n    stat: !0,\n    name: \"isWellKnownSymbol\",\n    forced: !0\n  }, {\n    isWellKnown: QS\n  }), cf(\"metadataKey\"), cf(\"patternMatch\"), cf(\"replaceAll\");\n  var ZS = i(DS),\n    $S = i(tf.f(\"iterator\"));\n  function eg(e) {\n    return eg = \"function\" == typeof ZS && \"symbol\" == typeof $S ? function (e) {\n      return typeof e;\n    } : function (e) {\n      return e && \"function\" == typeof ZS && e.constructor === ZS && e !== ZS.prototype ? \"symbol\" : typeof e;\n    }, eg(e);\n  }\n  var tg = i(tf.f(\"toPrimitive\"));\n  function ig(e) {\n    var t = function (e, t) {\n      if (\"object\" !== eg(e) || null === e) return e;\n      var i = e[tg];\n      if (void 0 !== i) {\n        var n = i.call(e, t || \"default\");\n        if (\"object\" !== eg(n)) return n;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return (\"string\" === t ? String : Number)(e);\n    }(e, \"string\");\n    return \"symbol\" === eg(t) ? t : String(t);\n  }\n  function ng(e, t, i) {\n    return (t = ig(t)) in e ? gm(e, t, {\n      value: i,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = i, e;\n  }\n  var rg = n,\n    og = ut(\"iterator\"),\n    sg = !rg(function () {\n      var e = new URL(\"b?a=1&b=2&c=3\", \"http://a\"),\n        t = e.searchParams,\n        i = new URLSearchParams(\"a=1&a=2\"),\n        n = \"\";\n      return e.pathname = \"c%20d\", t.forEach(function (e, i) {\n        t.delete(\"b\"), n += i + e;\n      }), i.delete(\"a\", 2), !e.toJSON || !i.has(\"a\", 1) || i.has(\"a\", 2) || !t.size && true || !t.sort || \"http://a/c%20d?a=1&c=3\" !== e.href || \"3\" !== t.get(\"c\") || \"a=1\" !== String(new URLSearchParams(\"?a=1\")) || !t[og] || \"a\" !== new URL(\"https://a@b\").username || \"b\" !== new URLSearchParams(new URLSearchParams(\"a=b\")).get(\"a\") || \"xn--e1aybc\" !== new URL(\"http://ÑÐµÑÑ\").host || \"#%D0%B1\" !== new URL(\"http://a#Ð±\").hash || \"a1c3\" !== n || \"x\" !== new URL(\"http://x\", void 0).host;\n    }),\n    ag = ua,\n    cg = wi,\n    dg = u,\n    lg = L,\n    hg = d,\n    ug = N,\n    pg = sg,\n    _g = ua,\n    Eg = uc,\n    mg = function (e, t, i) {\n      for (var n in t) i && i.unsafe && e[n] ? e[n] = t[n] : ag(e, n, t[n], i);\n      return e;\n    },\n    fg = Da,\n    Tg = Va,\n    Sg = ra,\n    gg = Sc,\n    Rg = w,\n    Cg = Ze,\n    vg = Xt,\n    Ig = pn,\n    yg = ii,\n    Ag = te,\n    bg = mn,\n    wg = vo,\n    Og = B,\n    Ng = es,\n    Dg = qo,\n    Pg = Zc,\n    Lg = b_,\n    kg = ut(\"iterator\"),\n    Mg = \"URLSearchParams\",\n    Ug = Mg + \"Iterator\",\n    xg = Sg.set,\n    Vg = Sg.getterFor(Mg),\n    Fg = Sg.getterFor(Ug),\n    Bg = Object.getOwnPropertyDescriptor,\n    jg = function (e) {\n      if (!ug) return dg[e];\n      var t = Bg(dg, e);\n      return t && t.value;\n    },\n    Gg = jg(\"fetch\"),\n    Wg = jg(\"Request\"),\n    Hg = jg(\"Headers\"),\n    Kg = Wg && Wg.prototype,\n    Yg = Hg && Hg.prototype,\n    qg = dg.RegExp,\n    zg = dg.TypeError,\n    Jg = dg.decodeURIComponent,\n    Xg = dg.encodeURIComponent,\n    Qg = hg(\"\".charAt),\n    Zg = hg([].join),\n    $g = hg([].push),\n    eR = hg(\"\".replace),\n    tR = hg([].shift),\n    iR = hg([].splice),\n    nR = hg(\"\".split),\n    rR = hg(\"\".slice),\n    oR = /\\+/g,\n    sR = Array(4),\n    aR = function (e) {\n      return sR[e - 1] || (sR[e - 1] = qg(\"((?:%[\\\\da-f]{2}){\" + e + \"})\", \"gi\"));\n    },\n    cR = function (e) {\n      try {\n        return Jg(e);\n      } catch (t) {\n        return e;\n      }\n    },\n    dR = function (e) {\n      var t = eR(e, oR, \" \"),\n        i = 4;\n      try {\n        return Jg(t);\n      } catch (e) {\n        for (; i;) t = eR(t, aR(i--), cR);\n        return t;\n      }\n    },\n    lR = /[!'()~]|%20/g,\n    hR = {\n      \"!\": \"%21\",\n      \"'\": \"%27\",\n      \"(\": \"%28\",\n      \")\": \"%29\",\n      \"~\": \"%7E\",\n      \"%20\": \"+\"\n    },\n    uR = function (e) {\n      return hR[e];\n    },\n    pR = function (e) {\n      return eR(Xg(e), lR, uR);\n    },\n    _R = Tg(function (e, t) {\n      xg(this, {\n        type: Ug,\n        iterator: Ng(Vg(e).entries),\n        kind: t\n      });\n    }, \"Iterator\", function () {\n      var e = Fg(this),\n        t = e.kind,\n        i = e.iterator.next(),\n        n = i.value;\n      return i.done || (i.value = \"keys\" === t ? n.key : \"values\" === t ? n.value : [n.key, n.value]), i;\n    }, !0),\n    ER = function (e) {\n      this.entries = [], this.url = null, void 0 !== e && (Ag(e) ? this.parseObject(e) : this.parseQuery(\"string\" == typeof e ? \"?\" === Qg(e, 0) ? rR(e, 1) : e : bg(e)));\n    };\n  ER.prototype = {\n    type: Mg,\n    bindURL: function (e) {\n      this.url = e, this.update();\n    },\n    parseObject: function (e) {\n      var t,\n        i,\n        n,\n        r,\n        o,\n        s,\n        a,\n        c = Dg(e);\n      if (c) for (i = (t = Ng(e, c)).next; !(n = lg(i, t)).done;) {\n        if (o = (r = Ng(yg(n.value))).next, (s = lg(o, r)).done || (a = lg(o, r)).done || !lg(o, r).done) throw zg(\"Expected sequence with length 2\");\n        $g(this.entries, {\n          key: bg(s.value),\n          value: bg(a.value)\n        });\n      } else for (var d in e) Cg(e, d) && $g(this.entries, {\n        key: d,\n        value: bg(e[d])\n      });\n    },\n    parseQuery: function (e) {\n      if (e) for (var t, i, n = nR(e, \"&\"), r = 0; r < n.length;) (t = n[r++]).length && (i = nR(t, \"=\"), $g(this.entries, {\n        key: dR(tR(i)),\n        value: dR(Zg(i, \"=\"))\n      }));\n    },\n    serialize: function () {\n      for (var e, t = this.entries, i = [], n = 0; n < t.length;) e = t[n++], $g(i, pR(e.key) + \"=\" + pR(e.value));\n      return Zg(i, \"&\");\n    },\n    update: function () {\n      this.entries.length = 0, this.parseQuery(this.url.query);\n    },\n    updateURL: function () {\n      this.url && this.url.update();\n    }\n  };\n  var mR = function () {\n      gg(this, fR);\n      var e = xg(this, new ER(arguments.length > 0 ? arguments[0] : void 0));\n      ug || (this.size = e.entries.length);\n    },\n    fR = mR.prototype;\n  if (mg(fR, {\n    append: function (e, t) {\n      var i = Vg(this);\n      Pg(arguments.length, 2), $g(i.entries, {\n        key: bg(e),\n        value: bg(t)\n      }), ug || this.length++, i.updateURL();\n    },\n    delete: function (e) {\n      for (var t = Vg(this), i = Pg(arguments.length, 1), n = t.entries, r = bg(e), o = i < 2 ? void 0 : arguments[1], s = void 0 === o ? o : bg(o), a = 0; a < n.length;) {\n        var c = n[a];\n        if (c.key !== r || void 0 !== s && c.value !== s) a++;else if (iR(n, a, 1), void 0 !== s) break;\n      }\n      ug || (this.size = n.length), t.updateURL();\n    },\n    get: function (e) {\n      var t = Vg(this).entries;\n      Pg(arguments.length, 1);\n      for (var i = bg(e), n = 0; n < t.length; n++) if (t[n].key === i) return t[n].value;\n      return null;\n    },\n    getAll: function (e) {\n      var t = Vg(this).entries;\n      Pg(arguments.length, 1);\n      for (var i = bg(e), n = [], r = 0; r < t.length; r++) t[r].key === i && $g(n, t[r].value);\n      return n;\n    },\n    has: function (e) {\n      for (var t = Vg(this).entries, i = Pg(arguments.length, 1), n = bg(e), r = i < 2 ? void 0 : arguments[1], o = void 0 === r ? r : bg(r), s = 0; s < t.length;) {\n        var a = t[s++];\n        if (a.key === n && (void 0 === o || a.value === o)) return !0;\n      }\n      return !1;\n    },\n    set: function (e, t) {\n      var i = Vg(this);\n      Pg(arguments.length, 1);\n      for (var n, r = i.entries, o = !1, s = bg(e), a = bg(t), c = 0; c < r.length; c++) (n = r[c]).key === s && (o ? iR(r, c--, 1) : (o = !0, n.value = a));\n      o || $g(r, {\n        key: s,\n        value: a\n      }), ug || (this.size = r.length), i.updateURL();\n    },\n    sort: function () {\n      var e = Vg(this);\n      Lg(e.entries, function (e, t) {\n        return e.key > t.key ? 1 : -1;\n      }), e.updateURL();\n    },\n    forEach: function (e) {\n      for (var t, i = Vg(this).entries, n = vg(e, arguments.length > 1 ? arguments[1] : void 0), r = 0; r < i.length;) n((t = i[r++]).value, t.key, this);\n    },\n    keys: function () {\n      return new _R(this, \"keys\");\n    },\n    values: function () {\n      return new _R(this, \"values\");\n    },\n    entries: function () {\n      return new _R(this, \"entries\");\n    }\n  }, {\n    enumerable: !0\n  }), _g(fR, kg, fR.entries, {\n    name: \"entries\"\n  }), _g(fR, \"toString\", function () {\n    return Vg(this).serialize();\n  }, {\n    enumerable: !0\n  }), ug && Eg(fR, \"size\", {\n    get: function () {\n      return Vg(this).entries.length;\n    },\n    configurable: !0,\n    enumerable: !0\n  }), fg(mR, Mg), cg({\n    global: !0,\n    constructor: !0,\n    forced: !pg\n  }, {\n    URLSearchParams: mR\n  }), !pg && Rg(Hg)) {\n    var TR = hg(Yg.has),\n      SR = hg(Yg.set),\n      gR = function (e) {\n        if (Ag(e)) {\n          var t,\n            i = e.body;\n          if (Ig(i) === Mg) return t = e.headers ? new Hg(e.headers) : new Hg(), TR(t, \"content-type\") || SR(t, \"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"), wg(e, {\n            body: Og(0, bg(i)),\n            headers: Og(0, t)\n          });\n        }\n        return e;\n      };\n    if (Rg(Gg) && cg({\n      global: !0,\n      enumerable: !0,\n      dontCallGetSet: !0,\n      forced: !0\n    }, {\n      fetch: function (e) {\n        return Gg(e, arguments.length > 1 ? gR(arguments[1]) : {});\n      }\n    }), Rg(Wg)) {\n      var RR = function (e) {\n        return gg(this, Kg), new Wg(e, arguments.length > 1 ? gR(arguments[1]) : {});\n      };\n      Kg.constructor = RR, RR.prototype = Kg, cg({\n        global: !0,\n        constructor: !0,\n        dontCallGetSet: !0,\n        forced: !0\n      }, {\n        Request: RR\n      });\n    }\n  }\n  var CR = {\n      URLSearchParams: mR,\n      getState: Vg\n    },\n    vR = i(ie.URLSearchParams),\n    IR = {\n      isBrowser: !0,\n      classes: {\n        URLSearchParams: void 0 !== vR ? vR : cm,\n        FormData: \"undefined\" != typeof FormData ? FormData : null,\n        Blob: \"undefined\" != typeof Blob ? Blob : null\n      },\n      protocols: [\"http\", \"https\", \"file\", \"blob\", \"url\", \"data\"]\n    };\n  const yR = \"undefined\" != typeof window && \"undefined\" != typeof document,\n    AR = (bR = \"undefined\" != typeof navigator && navigator.product, yR && [\"ReactNative\", \"NativeScript\", \"NS\"].indexOf(bR) < 0);\n  var bR;\n  const wR = \"undefined\" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && \"function\" == typeof self.importScripts;\n  function OR(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function NR(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? OR(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : OR(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  var DR = NR(NR({}, Object.freeze({\n    __proto__: null,\n    hasBrowserEnv: yR,\n    hasStandardBrowserEnv: AR,\n    hasStandardBrowserWebWorkerEnv: wR\n  })), IR);\n  var PR = ii,\n    LR = L,\n    kR = Ze,\n    MR = l,\n    UR = function () {\n      var e = PR(this),\n        t = \"\";\n      return e.hasIndices && (t += \"d\"), e.global && (t += \"g\"), e.ignoreCase && (t += \"i\"), e.multiline && (t += \"m\"), e.dotAll && (t += \"s\"), e.unicode && (t += \"u\"), e.unicodeSets && (t += \"v\"), e.sticky && (t += \"y\"), t;\n    },\n    xR = RegExp.prototype,\n    VR = function (e) {\n      var t = e.flags;\n      return void 0 !== t || \"flags\" in xR || kR(e, \"flags\") || !MR(xR, e) ? t : LR(UR, e);\n    },\n    FR = Cu.charAt,\n    BR = L,\n    jR = ii,\n    GR = w,\n    WR = R,\n    HR = /./.exec,\n    KR = TypeError,\n    YR = wi,\n    qR = L,\n    zR = I,\n    JR = Va,\n    XR = ic,\n    QR = J,\n    ZR = Bi,\n    $R = mn,\n    eC = ii,\n    tC = Y,\n    iC = R,\n    nC = tn,\n    rC = VR,\n    oC = ke,\n    sC = n,\n    aC = Jc,\n    cC = function (e, t, i) {\n      return t + (i ? FR(e, t).length : 1);\n    },\n    dC = function (e, t) {\n      var i = e.exec;\n      if (GR(i)) {\n        var n = BR(i, e, t);\n        return null !== n && jR(n), n;\n      }\n      if (\"RegExp\" === WR(e)) return BR(HR, e, t);\n      throw KR(\"RegExp#exec called on incompatible receiver\");\n    },\n    lC = ra,\n    hC = ut(\"matchAll\"),\n    uC = \"RegExp String\",\n    pC = uC + \" Iterator\",\n    _C = lC.set,\n    EC = lC.getterFor(pC),\n    mC = TypeError,\n    fC = zR(\"\".indexOf),\n    TC = zR(\"\".matchAll),\n    SC = !!TC && !sC(function () {\n      TC(\"a\", /./);\n    }),\n    gC = JR(function (e, t, i, n) {\n      _C(this, {\n        type: pC,\n        regexp: e,\n        string: t,\n        global: i,\n        unicode: n,\n        done: !1\n      });\n    }, uC, function () {\n      var e = EC(this);\n      if (e.done) return XR(void 0, !0);\n      var t = e.regexp,\n        i = e.string,\n        n = dC(t, i);\n      return null === n ? (e.done = !0, XR(void 0, !0)) : e.global ? (\"\" === $R(n[0]) && (t.lastIndex = cC(i, ZR(t.lastIndex), e.unicode)), XR(n, !1)) : (e.done = !0, XR(n, !1));\n    }),\n    RC = function (e) {\n      var t,\n        i,\n        n,\n        r = eC(this),\n        o = $R(e),\n        s = aC(r, RegExp),\n        a = $R(rC(r));\n      return t = new s(s === RegExp ? r.source : r, a), i = !!~fC(a, \"g\"), n = !!~fC(a, \"u\"), t.lastIndex = ZR(r.lastIndex), new gC(t, o, i, n);\n    };\n  YR({\n    target: \"String\",\n    proto: !0,\n    forced: SC\n  }, {\n    matchAll: function (e) {\n      var t,\n        i,\n        n,\n        r,\n        o = QR(this);\n      if (tC(e)) {\n        if (SC) return TC(o, e);\n      } else {\n        if (nC(e) && (t = $R(QR(rC(e))), !~fC(t, \"g\"))) throw mC(\"`.matchAll` does not allow non-global regexes\");\n        if (SC) return TC(o, e);\n        if (void 0 === (n = oC(e, hC)) && \"RegExp\" == iC(e) && (n = RC), n) return qR(n, e, o);\n      }\n      return i = $R(o), r = new RegExp(e, \"g\"), qR(RC, r, i);\n    }\n  });\n  var CC = Xi(\"String\").matchAll,\n    vC = l,\n    IC = CC,\n    yC = String.prototype,\n    AC = function (e) {\n      var t = e.matchAll;\n      return \"string\" == typeof e || e === yC || vC(yC, e) && t === yC.matchAll ? IC : t;\n    },\n    bC = i(AC);\n  function wC(e) {\n    function t(e, i, n, r) {\n      let o = e[r++];\n      if (\"__proto__\" === o) return !0;\n      const s = Number.isFinite(+o),\n        a = r >= e.length;\n      if (o = !o && ZE.isArray(n) ? n.length : o, a) return ZE.hasOwnProp(n, o) ? n[o] = [n[o], i] : n[o] = i, !s;\n      n[o] && ZE.isObject(n[o]) || (n[o] = []);\n      return t(e, i, n[o], r) && ZE.isArray(n[o]) && (n[o] = function (e) {\n        const t = {},\n          i = Object.keys(e);\n        let n;\n        const r = i.length;\n        let o;\n        for (n = 0; n < r; n++) o = i[n], t[o] = e[o];\n        return t;\n      }(n[o])), !s;\n    }\n    if (ZE.isFormData(e) && ZE.isFunction(e.entries)) {\n      const i = {};\n      return ZE.forEachEntry(e, (e, n) => {\n        t(function (e) {\n          return bC(ZE).call(ZE, /\\w+|\\[(\\w*)]/g, e).map(e => \"[]\" === e[0] ? \"\" : e[1] || e[0]);\n        }(e), n, i, 0);\n      }), i;\n    }\n    return null;\n  }\n  const OC = {\n    transitional: pm,\n    adapter: [\"xhr\", \"http\"],\n    transformRequest: [function (e, t) {\n      const i = t.getContentType() || \"\",\n        n = i.indexOf(\"application/json\") > -1,\n        r = ZE.isObject(e);\n      r && ZE.isHTMLForm(e) && (e = new FormData(e));\n      if (ZE.isFormData(e)) return n ? JSON.stringify(wC(e)) : e;\n      if (ZE.isArrayBuffer(e) || ZE.isBuffer(e) || ZE.isStream(e) || ZE.isFile(e) || ZE.isBlob(e)) return e;\n      if (ZE.isArrayBufferView(e)) return e.buffer;\n      if (ZE.isURLSearchParams(e)) return t.setContentType(\"application/x-www-form-urlencoded;charset=utf-8\", !1), e.toString();\n      let o;\n      if (r) {\n        if (i.indexOf(\"application/x-www-form-urlencoded\") > -1) return function (e, t) {\n          return sm(e, new DR.classes.URLSearchParams(), Object.assign({\n            visitor: function (e, t, i, n) {\n              return DR.isNode && ZE.isBuffer(e) ? (this.append(t, e.toString(\"base64\")), !1) : n.defaultVisitor.apply(this, arguments);\n            }\n          }, t));\n        }(e, this.formSerializer).toString();\n        if ((o = ZE.isFileList(e)) || i.indexOf(\"multipart/form-data\") > -1) {\n          const t = this.env && this.env.FormData;\n          return sm(o ? {\n            \"files[]\": e\n          } : e, t && new t(), this.formSerializer);\n        }\n      }\n      return r || n ? (t.setContentType(\"application/json\", !1), function (e, t, i) {\n        if (ZE.isString(e)) try {\n          return (t || JSON.parse)(e), jp(ZE).call(ZE, e);\n        } catch (e) {\n          if (\"SyntaxError\" !== e.name) throw e;\n        }\n        return (i || JSON.stringify)(e);\n      }(e)) : e;\n    }],\n    transformResponse: [function (e) {\n      const t = this.transitional || OC.transitional,\n        i = t && t.forcedJSONParsing,\n        n = \"json\" === this.responseType;\n      if (e && ZE.isString(e) && (i && !this.responseType || n)) {\n        const i = !(t && t.silentJSONParsing) && n;\n        try {\n          return JSON.parse(e);\n        } catch (e) {\n          if (i) {\n            if (\"SyntaxError\" === e.name) throw $E.from(e, $E.ERR_BAD_RESPONSE, this, null, this.response);\n            throw e;\n          }\n        }\n      }\n      return e;\n    }],\n    timeout: 0,\n    xsrfCookieName: \"XSRF-TOKEN\",\n    xsrfHeaderName: \"X-XSRF-TOKEN\",\n    maxContentLength: -1,\n    maxBodyLength: -1,\n    env: {\n      FormData: DR.classes.FormData,\n      Blob: DR.classes.Blob\n    },\n    validateStatus: function (e) {\n      return e >= 200 && e < 300;\n    },\n    headers: {\n      common: {\n        Accept: \"application/json, text/plain, */*\",\n        \"Content-Type\": void 0\n      }\n    }\n  };\n  ZE.forEach([\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\"], e => {\n    OC.headers[e] = {};\n  });\n  var NC = OC;\n  const DC = ZE.toObjectSet([\"age\", \"authorization\", \"content-length\", \"content-type\", \"etag\", \"expires\", \"from\", \"host\", \"if-modified-since\", \"if-unmodified-since\", \"last-modified\", \"location\", \"max-forwards\", \"proxy-authorization\", \"referer\", \"retry-after\", \"user-agent\"]);\n  const PC = Symbol(\"internals\");\n  function LC(e) {\n    var t;\n    return e && jp(t = String(e)).call(t).toLowerCase();\n  }\n  function kC(e) {\n    return !1 === e || null == e ? e : ZE.isArray(e) ? e.map(kC) : String(e);\n  }\n  function MC(e, t, i, n, r) {\n    return ZE.isFunction(n) ? n.call(this, t, i) : (r && (t = i), ZE.isString(t) ? ZE.isString(n) ? -1 !== t.indexOf(n) : ZE.isRegExp(n) ? n.test(t) : void 0 : void 0);\n  }\n  class UC {\n    constructor(e) {\n      e && this.set(e);\n    }\n    set(e, t, i) {\n      const n = this;\n      function r(e, t, i) {\n        const r = LC(t);\n        if (!r) throw new Error(\"header name must be a non-empty string\");\n        const o = ZE.findKey(n, r);\n        (!o || void 0 === n[o] || !0 === i || void 0 === i && !1 !== n[o]) && (n[o || t] = kC(e));\n      }\n      const o = (e, t) => ZE.forEach(e, (e, i) => r(e, i, t));\n      var s;\n      return ZE.isPlainObject(e) || e instanceof this.constructor ? o(e, t) : ZE.isString(e) && (e = jp(e).call(e)) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(jp(s = e).call(s)) ? o((e => {\n        const t = {};\n        let i, n, r;\n        return e && e.split(\"\\n\").forEach(function (e) {\n          var o, s;\n          r = e.indexOf(\":\"), i = jp(o = e.substring(0, r)).call(o).toLowerCase(), n = jp(s = e.substring(r + 1)).call(s), !i || t[i] && DC[i] || (\"set-cookie\" === i ? t[i] ? t[i].push(n) : t[i] = [n] : t[i] = t[i] ? t[i] + \", \" + n : n);\n        }), t;\n      })(e), t) : null != e && r(t, e, i), this;\n    }\n    get(e, t) {\n      if (e = LC(e)) {\n        const i = ZE.findKey(this, e);\n        if (i) {\n          const e = this[i];\n          if (!t) return e;\n          if (!0 === t) return function (e) {\n            const t = Object.create(null),\n              i = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n            let n;\n            for (; n = i.exec(e);) t[n[1]] = n[2];\n            return t;\n          }(e);\n          if (ZE.isFunction(t)) return t.call(this, e, i);\n          if (ZE.isRegExp(t)) return t.exec(e);\n          throw new TypeError(\"parser must be boolean|regexp|function\");\n        }\n      }\n    }\n    has(e, t) {\n      if (e = LC(e)) {\n        const i = ZE.findKey(this, e);\n        return !(!i || void 0 === this[i] || t && !MC(0, this[i], i, t));\n      }\n      return !1;\n    }\n    delete(e, t) {\n      const i = this;\n      let n = !1;\n      function r(e) {\n        if (e = LC(e)) {\n          const r = ZE.findKey(i, e);\n          !r || t && !MC(0, i[r], r, t) || (delete i[r], n = !0);\n        }\n      }\n      return ZE.isArray(e) ? e.forEach(r) : r(e), n;\n    }\n    clear(e) {\n      const t = Object.keys(this);\n      let i = t.length,\n        n = !1;\n      for (; i--;) {\n        const r = t[i];\n        e && !MC(0, this[r], r, e, !0) || (delete this[r], n = !0);\n      }\n      return n;\n    }\n    normalize(e) {\n      const t = this,\n        i = {};\n      return ZE.forEach(this, (n, r) => {\n        var o;\n        const s = ZE.findKey(i, r);\n        if (s) return t[s] = kC(n), void delete t[r];\n        const a = e ? function (e) {\n          return jp(e).call(e).toLowerCase().replace(/([a-z\\d])(\\w*)/g, (e, t, i) => t.toUpperCase() + i);\n        }(r) : jp(o = String(r)).call(o);\n        a !== r && delete t[r], t[a] = kC(n), i[a] = !0;\n      }), this;\n    }\n    concat() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      return this.constructor.concat(this, ...t);\n    }\n    toJSON(e) {\n      const t = Object.create(null);\n      return ZE.forEach(this, (i, n) => {\n        null != i && !1 !== i && (t[n] = e && ZE.isArray(i) ? i.join(\", \") : i);\n      }), t;\n    }\n    [Symbol.iterator]() {\n      return Object.entries(this.toJSON())[Symbol.iterator]();\n    }\n    toString() {\n      return Object.entries(this.toJSON()).map(e => {\n        let _e2 = _slicedToArray(e, 2),\n          t = _e2[0],\n          i = _e2[1];\n        return t + \": \" + i;\n      }).join(\"\\n\");\n    }\n    get [Symbol.toStringTag]() {\n      return \"AxiosHeaders\";\n    }\n    static from(e) {\n      return e instanceof this ? e : new this(e);\n    }\n    static concat(e) {\n      const t = new this(e);\n      for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), r = 1; r < i; r++) n[r - 1] = arguments[r];\n      return n.forEach(e => t.set(e)), t;\n    }\n    static accessor(e) {\n      const t = (this[PC] = this[PC] = {\n          accessors: {}\n        }).accessors,\n        i = this.prototype;\n      function n(e) {\n        const n = LC(e);\n        t[n] || (!function (e, t) {\n          const i = ZE.toCamelCase(\" \" + t);\n          [\"get\", \"set\", \"has\"].forEach(n => {\n            Object.defineProperty(e, n + i, {\n              value: function (e, i, r) {\n                return this[n].call(this, t, e, i, r);\n              },\n              configurable: !0\n            });\n          });\n        }(i, e), t[n] = !0);\n      }\n      return ZE.isArray(e) ? e.forEach(n) : n(e), this;\n    }\n  }\n  UC.accessor([\"Content-Type\", \"Content-Length\", \"Accept\", \"Accept-Encoding\", \"User-Agent\", \"Authorization\"]), ZE.reduceDescriptors(UC.prototype, (e, t) => {\n    let i = e.value,\n      n = t[0].toUpperCase() + t.slice(1);\n    return {\n      get: () => i,\n      set(e) {\n        this[n] = e;\n      }\n    };\n  }), ZE.freezeMethods(UC);\n  var xC = UC;\n  function VC(e, t) {\n    const i = this || NC,\n      n = t || i,\n      r = xC.from(n.headers);\n    let o = n.data;\n    return ZE.forEach(e, function (e) {\n      o = e.call(i, o, r.normalize(), t ? t.status : void 0);\n    }), r.normalize(), o;\n  }\n  function FC(e) {\n    return !(!e || !e.__CANCEL__);\n  }\n  function BC(e, t, i) {\n    $E.call(this, null == e ? \"canceled\" : e, $E.ERR_CANCELED, t, i), this.name = \"CanceledError\";\n  }\n  ZE.inherits(BC, $E, {\n    __CANCEL__: !0\n  });\n  var jC = DR.hasStandardBrowserEnv ? {\n    write(e, t, i, n, r, o) {\n      const s = [e + \"=\" + encodeURIComponent(t)];\n      ZE.isNumber(i) && s.push(\"expires=\" + new Date(i).toGMTString()), ZE.isString(n) && s.push(\"path=\" + n), ZE.isString(r) && s.push(\"domain=\" + r), !0 === o && s.push(\"secure\"), document.cookie = s.join(\"; \");\n    },\n    read(e) {\n      const t = document.cookie.match(new RegExp(\"(^|;\\\\s*)(\" + e + \")=([^;]*)\"));\n      return t ? decodeURIComponent(t[3]) : null;\n    },\n    remove(e) {\n      this.write(e, \"\", Date.now() - 864e5);\n    }\n  } : {\n    write() {},\n    read: () => null,\n    remove() {}\n  };\n  function GC(e, t) {\n    return e && !function (e) {\n      return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(e);\n    }(t) ? function (e, t) {\n      return t ? e.replace(/\\/?\\/$/, \"\") + \"/\" + t.replace(/^\\/+/, \"\") : e;\n    }(e, t) : t;\n  }\n  var WC = DR.hasStandardBrowserEnv ? function () {\n    const e = /(msie|trident)/i.test(navigator.userAgent),\n      t = document.createElement(\"a\");\n    let i;\n    function n(i) {\n      let n = i;\n      return e && (t.setAttribute(\"href\", n), n = t.href), t.setAttribute(\"href\", n), {\n        href: t.href,\n        protocol: t.protocol ? t.protocol.replace(/:$/, \"\") : \"\",\n        host: t.host,\n        search: t.search ? t.search.replace(/^\\?/, \"\") : \"\",\n        hash: t.hash ? t.hash.replace(/^#/, \"\") : \"\",\n        hostname: t.hostname,\n        port: t.port,\n        pathname: \"/\" === t.pathname.charAt(0) ? t.pathname : \"/\" + t.pathname\n      };\n    }\n    return i = n(window.location.href), function (e) {\n      const t = ZE.isString(e) ? n(e) : e;\n      return t.protocol === i.protocol && t.host === i.host;\n    };\n  }() : function () {\n    return !0;\n  };\n  function HC(e, t) {\n    let i = 0;\n    const n = function (e, t) {\n      e = e || 10;\n      const i = new Array(e),\n        n = new Array(e);\n      let r,\n        o = 0,\n        s = 0;\n      return t = void 0 !== t ? t : 1e3, function (a) {\n        const c = Date.now(),\n          d = n[s];\n        r || (r = c), i[o] = a, n[o] = c;\n        let l = s,\n          h = 0;\n        for (; l !== o;) h += i[l++], l %= e;\n        if (o = (o + 1) % e, o === s && (s = (s + 1) % e), c - r < t) return;\n        const u = d && c - d;\n        return u ? Math.round(1e3 * h / u) : void 0;\n      };\n    }(50, 250);\n    return r => {\n      const o = r.loaded,\n        s = r.lengthComputable ? r.total : void 0,\n        a = o - i,\n        c = n(a);\n      i = o;\n      const d = {\n        loaded: o,\n        total: s,\n        progress: s ? o / s : void 0,\n        bytes: a,\n        rate: c || void 0,\n        estimated: c && s && o <= s ? (s - o) / c : void 0,\n        event: r\n      };\n      d[t ? \"download\" : \"upload\"] = !0, e(d);\n    };\n  }\n  var KC = \"undefined\" != typeof XMLHttpRequest && function (e) {\n    return new Gu(function (t, i) {\n      let n = e.data;\n      const r = xC.from(e.headers).normalize();\n      let o,\n        s,\n        a = e.responseType,\n        c = e.withXSRFToken;\n      function d() {\n        e.cancelToken && e.cancelToken.unsubscribe(o), e.signal && e.signal.removeEventListener(\"abort\", o);\n      }\n      if (ZE.isFormData(n)) if (DR.hasStandardBrowserEnv || DR.hasStandardBrowserWebWorkerEnv) r.setContentType(!1);else if (!1 !== (s = r.getContentType())) {\n        const _ref5 = s ? s.split(\";\").map(e => jp(e).call(e)).filter(Boolean) : [],\n          _ref6 = _toArray(_ref5),\n          e = _ref6[0],\n          t = _ref6.slice(1);\n        r.setContentType([e || \"multipart/form-data\", ...t].join(\"; \"));\n      }\n      let l = new XMLHttpRequest();\n      if (e.auth) {\n        const t = e.auth.username || \"\",\n          i = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : \"\";\n        r.set(\"Authorization\", \"Basic \" + btoa(t + \":\" + i));\n      }\n      const h = GC(e.baseURL, e.url);\n      function u() {\n        if (!l) return;\n        const n = xC.from(\"getAllResponseHeaders\" in l && l.getAllResponseHeaders());\n        !function (e, t, i) {\n          const n = i.config.validateStatus;\n          i.status && n && !n(i.status) ? t(new $E(\"Request failed with status code \" + i.status, [$E.ERR_BAD_REQUEST, $E.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4], i.config, i.request, i)) : e(i);\n        }(function (e) {\n          t(e), d();\n        }, function (e) {\n          i(e), d();\n        }, {\n          data: a && \"text\" !== a && \"json\" !== a ? l.response : l.responseText,\n          status: l.status,\n          statusText: l.statusText,\n          headers: n,\n          config: e,\n          request: l\n        }), l = null;\n      }\n      if (l.open(e.method.toUpperCase(), hm(h, e.params, e.paramsSerializer), !0), l.timeout = e.timeout, \"onloadend\" in l ? l.onloadend = u : l.onreadystatechange = function () {\n        l && 4 === l.readyState && (0 !== l.status || l.responseURL && 0 === l.responseURL.indexOf(\"file:\")) && setTimeout(u);\n      }, l.onabort = function () {\n        l && (i(new $E(\"Request aborted\", $E.ECONNABORTED, e, l)), l = null);\n      }, l.onerror = function () {\n        i(new $E(\"Network Error\", $E.ERR_NETWORK, e, l)), l = null;\n      }, l.ontimeout = function () {\n        let t = e.timeout ? \"timeout of \" + e.timeout + \"ms exceeded\" : \"timeout exceeded\";\n        const n = e.transitional || pm;\n        e.timeoutErrorMessage && (t = e.timeoutErrorMessage), i(new $E(t, n.clarifyTimeoutError ? $E.ETIMEDOUT : $E.ECONNABORTED, e, l)), l = null;\n      }, DR.hasStandardBrowserEnv && (c && ZE.isFunction(c) && (c = c(e)), c || !1 !== c && WC(h))) {\n        const t = e.xsrfHeaderName && e.xsrfCookieName && jC.read(e.xsrfCookieName);\n        t && r.set(e.xsrfHeaderName, t);\n      }\n      void 0 === n && r.setContentType(null), \"setRequestHeader\" in l && ZE.forEach(r.toJSON(), function (e, t) {\n        l.setRequestHeader(t, e);\n      }), ZE.isUndefined(e.withCredentials) || (l.withCredentials = !!e.withCredentials), a && \"json\" !== a && (l.responseType = e.responseType), \"function\" == typeof e.onDownloadProgress && l.addEventListener(\"progress\", HC(e.onDownloadProgress, !0)), \"function\" == typeof e.onUploadProgress && l.upload && l.upload.addEventListener(\"progress\", HC(e.onUploadProgress)), (e.cancelToken || e.signal) && (o = t => {\n        l && (i(!t || t.type ? new BC(null, e, l) : t), l.abort(), l = null);\n      }, e.cancelToken && e.cancelToken.subscribe(o), e.signal && (e.signal.aborted ? o() : e.signal.addEventListener(\"abort\", o)));\n      const p = function (e) {\n        const t = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(e);\n        return t && t[1] || \"\";\n      }(h);\n      p && -1 === DR.protocols.indexOf(p) ? i(new $E(\"Unsupported protocol \" + p + \":\", $E.ERR_BAD_REQUEST, e)) : l.send(n || null);\n    });\n  };\n  const YC = {\n    http: null,\n    xhr: KC\n  };\n  ZE.forEach(YC, (e, t) => {\n    if (e) {\n      try {\n        Object.defineProperty(e, \"name\", {\n          value: t\n        });\n      } catch (e) {}\n      Object.defineProperty(e, \"adapterName\", {\n        value: t\n      });\n    }\n  });\n  const qC = e => \"- \".concat(e),\n    zC = e => ZE.isFunction(e) || null === e || !1 === e;\n  var JC = {\n    getAdapter: e => {\n      e = ZE.isArray(e) ? e : [e];\n      const _e3 = e,\n        t = _e3.length;\n      let i, n;\n      const r = {};\n      for (let o = 0; o < t; o++) {\n        let t;\n        if (i = e[o], n = i, !zC(i) && (n = YC[(t = String(i)).toLowerCase()], void 0 === n)) throw new $E(\"Unknown adapter '\".concat(t, \"'\"));\n        if (n) break;\n        r[t || \"#\" + o] = n;\n      }\n      if (!n) {\n        const e = Object.entries(r).map(e => {\n          let _e4 = _slicedToArray(e, 2),\n            t = _e4[0],\n            i = _e4[1];\n          return \"adapter \".concat(t, \" \") + (!1 === i ? \"is not supported by the environment\" : \"is not available in the build\");\n        });\n        throw new $E(\"There is no suitable adapter to dispatch the request \" + (t ? e.length > 1 ? \"since :\\n\" + e.map(qC).join(\"\\n\") : \" \" + qC(e[0]) : \"as no adapter specified\"), \"ERR_NOT_SUPPORT\");\n      }\n      return n;\n    },\n    adapters: YC\n  };\n  function XC(e) {\n    if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new BC(null, e);\n  }\n  function QC(e) {\n    XC(e), e.headers = xC.from(e.headers), e.data = VC.call(e, e.transformRequest), -1 !== [\"post\", \"put\", \"patch\"].indexOf(e.method) && e.headers.setContentType(\"application/x-www-form-urlencoded\", !1);\n    return JC.getAdapter(e.adapter || NC.adapter)(e).then(function (t) {\n      return XC(e), t.data = VC.call(e, e.transformResponse, t), t.headers = xC.from(t.headers), t;\n    }, function (t) {\n      return FC(t) || (XC(e), t && t.response && (t.response.data = VC.call(e, e.transformResponse, t.response), t.response.headers = xC.from(t.response.headers))), Gu.reject(t);\n    });\n  }\n  function ZC(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  const $C = e => e instanceof xC ? function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? ZC(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : ZC(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }({}, e) : e;\n  function ev(e, t) {\n    t = t || {};\n    const i = {};\n    function n(e, t, i) {\n      return ZE.isPlainObject(e) && ZE.isPlainObject(t) ? ZE.merge.call({\n        caseless: i\n      }, e, t) : ZE.isPlainObject(t) ? ZE.merge({}, t) : ZE.isArray(t) ? t.slice() : t;\n    }\n    function r(e, t, i) {\n      return ZE.isUndefined(t) ? ZE.isUndefined(e) ? void 0 : n(void 0, e, i) : n(e, t, i);\n    }\n    function o(e, t) {\n      if (!ZE.isUndefined(t)) return n(void 0, t);\n    }\n    function s(e, t) {\n      return ZE.isUndefined(t) ? ZE.isUndefined(e) ? void 0 : n(void 0, e) : n(void 0, t);\n    }\n    function a(i, r, o) {\n      return o in t ? n(i, r) : o in e ? n(void 0, i) : void 0;\n    }\n    const c = {\n      url: o,\n      method: o,\n      data: o,\n      baseURL: s,\n      transformRequest: s,\n      transformResponse: s,\n      paramsSerializer: s,\n      timeout: s,\n      timeoutMessage: s,\n      withCredentials: s,\n      withXSRFToken: s,\n      adapter: s,\n      responseType: s,\n      xsrfCookieName: s,\n      xsrfHeaderName: s,\n      onUploadProgress: s,\n      onDownloadProgress: s,\n      decompress: s,\n      maxContentLength: s,\n      maxBodyLength: s,\n      beforeRedirect: s,\n      transport: s,\n      httpAgent: s,\n      httpsAgent: s,\n      cancelToken: s,\n      socketPath: s,\n      responseEncoding: s,\n      validateStatus: a,\n      headers: (e, t) => r($C(e), $C(t), !0)\n    };\n    return ZE.forEach(Object.keys(Object.assign({}, e, t)), function (n) {\n      const o = c[n] || r,\n        s = o(e[n], t[n], n);\n      ZE.isUndefined(s) && o !== a || (i[n] = s);\n    }), i;\n  }\n  const tv = \"1.6.8\",\n    iv = {};\n  [\"object\", \"boolean\", \"number\", \"function\", \"string\", \"symbol\"].forEach((e, t) => {\n    iv[e] = function (i) {\n      return typeof i === e || \"a\" + (t < 1 ? \"n \" : \" \") + e;\n    };\n  });\n  const nv = {};\n  iv.transitional = function (e, t, i) {\n    function n(e, t) {\n      return \"[Axios v\" + tv + \"] Transitional option '\" + e + \"'\" + t + (i ? \". \" + i : \"\");\n    }\n    return (i, r, o) => {\n      if (!1 === e) throw new $E(n(r, \" has been removed\" + (t ? \" in \" + t : \"\")), $E.ERR_DEPRECATED);\n      return t && !nv[r] && (nv[r] = !0, console.warn(n(r, \" has been deprecated since v\" + t + \" and will be removed in the near future\"))), !e || e(i, r, o);\n    };\n  };\n  var rv = {\n    assertOptions: function (e, t, i) {\n      if (\"object\" != typeof e) throw new $E(\"options must be an object\", $E.ERR_BAD_OPTION_VALUE);\n      const n = Object.keys(e);\n      let r = n.length;\n      for (; r-- > 0;) {\n        const o = n[r],\n          s = t[o];\n        if (s) {\n          const t = e[o],\n            i = void 0 === t || s(t, o, e);\n          if (!0 !== i) throw new $E(\"option \" + o + \" must be \" + i, $E.ERR_BAD_OPTION_VALUE);\n        } else if (!0 !== i) throw new $E(\"Unknown option \" + o, $E.ERR_BAD_OPTION);\n      }\n    },\n    validators: iv\n  };\n  const ov = rv.validators;\n  let sv = class {\n    constructor(e) {\n      this.defaults = e, this.interceptors = {\n        request: new um(),\n        response: new um()\n      };\n    }\n    async request(e, t) {\n      try {\n        return await this._request(e, t);\n      } catch (e) {\n        if (e instanceof Error) {\n          let t;\n          Error.captureStackTrace ? Error.captureStackTrace(t = {}) : t = new Error();\n          const i = t.stack ? t.stack.replace(/^.+\\n/, \"\") : \"\";\n          e.stack ? i && !String(e.stack).endsWith(i.replace(/^.+\\n.+\\n/, \"\")) && (e.stack += \"\\n\" + i) : e.stack = i;\n        }\n        throw e;\n      }\n    }\n    _request(e, t) {\n      \"string\" == typeof e ? (t = t || {}).url = e : t = e || {}, t = ev(this.defaults, t);\n      const _t2 = t,\n        i = _t2.transitional,\n        n = _t2.paramsSerializer,\n        r = _t2.headers;\n      void 0 !== i && rv.assertOptions(i, {\n        silentJSONParsing: ov.transitional(ov.boolean),\n        forcedJSONParsing: ov.transitional(ov.boolean),\n        clarifyTimeoutError: ov.transitional(ov.boolean)\n      }, !1), null != n && (ZE.isFunction(n) ? t.paramsSerializer = {\n        serialize: n\n      } : rv.assertOptions(n, {\n        encode: ov.function,\n        serialize: ov.function\n      }, !0)), t.method = (t.method || this.defaults.method || \"get\").toLowerCase();\n      let o = r && ZE.merge(r.common, r[t.method]);\n      r && ZE.forEach([\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\", \"common\"], e => {\n        delete r[e];\n      }), t.headers = xC.concat(o, r);\n      const s = [];\n      let a = !0;\n      this.interceptors.request.forEach(function (e) {\n        \"function\" == typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous, s.unshift(e.fulfilled, e.rejected));\n      });\n      const c = [];\n      let d;\n      this.interceptors.response.forEach(function (e) {\n        c.push(e.fulfilled, e.rejected);\n      });\n      let l,\n        h = 0;\n      if (!a) {\n        const e = [QC.bind(this), void 0];\n        for (e.unshift.apply(e, s), e.push.apply(e, c), l = e.length, d = Gu.resolve(t); h < l;) d = d.then(e[h++], e[h++]);\n        return d;\n      }\n      l = s.length;\n      let u = t;\n      for (h = 0; h < l;) {\n        const e = s[h++],\n          t = s[h++];\n        try {\n          u = e(u);\n        } catch (e) {\n          t.call(this, e);\n          break;\n        }\n      }\n      try {\n        d = QC.call(this, u);\n      } catch (e) {\n        return Gu.reject(e);\n      }\n      for (h = 0, l = c.length; h < l;) d = d.then(c[h++], c[h++]);\n      return d;\n    }\n    getUri(e) {\n      return hm(GC((e = ev(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer);\n    }\n  };\n  ZE.forEach([\"delete\", \"get\", \"head\", \"options\"], function (e) {\n    sv.prototype[e] = function (t, i) {\n      return this.request(ev(i || {}, {\n        method: e,\n        url: t,\n        data: (i || {}).data\n      }));\n    };\n  }), ZE.forEach([\"post\", \"put\", \"patch\"], function (e) {\n    function t(t) {\n      return function (i, n, r) {\n        return this.request(ev(r || {}, {\n          method: e,\n          headers: t ? {\n            \"Content-Type\": \"multipart/form-data\"\n          } : {},\n          url: i,\n          data: n\n        }));\n      };\n    }\n    sv.prototype[e] = t(), sv.prototype[e + \"Form\"] = t(!0);\n  });\n  var av = sv;\n  class cv {\n    constructor(e) {\n      if (\"function\" != typeof e) throw new TypeError(\"executor must be a function.\");\n      let t;\n      this.promise = new Gu(function (e) {\n        t = e;\n      });\n      const i = this;\n      this.promise.then(e => {\n        if (!i._listeners) return;\n        let t = i._listeners.length;\n        for (; t-- > 0;) i._listeners[t](e);\n        i._listeners = null;\n      }), this.promise.then = e => {\n        let t;\n        const n = new Gu(e => {\n          i.subscribe(e), t = e;\n        }).then(e);\n        return n.cancel = function () {\n          i.unsubscribe(t);\n        }, n;\n      }, e(function (e, n, r) {\n        i.reason || (i.reason = new BC(e, n, r), t(i.reason));\n      });\n    }\n    throwIfRequested() {\n      if (this.reason) throw this.reason;\n    }\n    subscribe(e) {\n      this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e];\n    }\n    unsubscribe(e) {\n      if (!this._listeners) return;\n      const t = this._listeners.indexOf(e);\n      -1 !== t && this._listeners.splice(t, 1);\n    }\n    static source() {\n      let e;\n      return {\n        token: new cv(function (t) {\n          e = t;\n        }),\n        cancel: e\n      };\n    }\n  }\n  var dv = cv;\n  const lv = {\n    Continue: 100,\n    SwitchingProtocols: 101,\n    Processing: 102,\n    EarlyHints: 103,\n    Ok: 200,\n    Created: 201,\n    Accepted: 202,\n    NonAuthoritativeInformation: 203,\n    NoContent: 204,\n    ResetContent: 205,\n    PartialContent: 206,\n    MultiStatus: 207,\n    AlreadyReported: 208,\n    ImUsed: 226,\n    MultipleChoices: 300,\n    MovedPermanently: 301,\n    Found: 302,\n    SeeOther: 303,\n    NotModified: 304,\n    UseProxy: 305,\n    Unused: 306,\n    TemporaryRedirect: 307,\n    PermanentRedirect: 308,\n    BadRequest: 400,\n    Unauthorized: 401,\n    PaymentRequired: 402,\n    Forbidden: 403,\n    NotFound: 404,\n    MethodNotAllowed: 405,\n    NotAcceptable: 406,\n    ProxyAuthenticationRequired: 407,\n    RequestTimeout: 408,\n    Conflict: 409,\n    Gone: 410,\n    LengthRequired: 411,\n    PreconditionFailed: 412,\n    PayloadTooLarge: 413,\n    UriTooLong: 414,\n    UnsupportedMediaType: 415,\n    RangeNotSatisfiable: 416,\n    ExpectationFailed: 417,\n    ImATeapot: 418,\n    MisdirectedRequest: 421,\n    UnprocessableEntity: 422,\n    Locked: 423,\n    FailedDependency: 424,\n    TooEarly: 425,\n    UpgradeRequired: 426,\n    PreconditionRequired: 428,\n    TooManyRequests: 429,\n    RequestHeaderFieldsTooLarge: 431,\n    UnavailableForLegalReasons: 451,\n    InternalServerError: 500,\n    NotImplemented: 501,\n    BadGateway: 502,\n    ServiceUnavailable: 503,\n    GatewayTimeout: 504,\n    HttpVersionNotSupported: 505,\n    VariantAlsoNegotiates: 506,\n    InsufficientStorage: 507,\n    LoopDetected: 508,\n    NotExtended: 510,\n    NetworkAuthenticationRequired: 511\n  };\n  Object.entries(lv).forEach(e => {\n    let _e5 = _slicedToArray(e, 2),\n      t = _e5[0],\n      i = _e5[1];\n    lv[i] = t;\n  });\n  var hv = lv;\n  const uv = function e(t) {\n    const i = new av(t),\n      n = TE(av.prototype.request, i);\n    return ZE.extend(n, av.prototype, i, {\n      allOwnKeys: !0\n    }), ZE.extend(n, i, null, {\n      allOwnKeys: !0\n    }), n.create = function (i) {\n      return e(ev(t, i));\n    }, n;\n  }(NC);\n  uv.Axios = av, uv.CanceledError = BC, uv.CancelToken = dv, uv.isCancel = FC, uv.VERSION = tv, uv.toFormData = sm, uv.AxiosError = $E, uv.Cancel = uv.CanceledError, uv.all = function (e) {\n    return Gu.all(e);\n  }, uv.spread = function (e) {\n    return function (t) {\n      return e.apply(null, t);\n    };\n  }, uv.isAxiosError = function (e) {\n    return ZE.isObject(e) && !0 === e.isAxiosError;\n  }, uv.mergeConfig = ev, uv.AxiosHeaders = xC, uv.formToJSON = e => wC(ZE.isHTMLForm(e) ? new FormData(e) : e), uv.getAdapter = JC.getAdapter, uv.HttpStatusCode = hv, uv.default = uv;\n  var pv = uv;\n  const _v = () => {};\n  function Ev() {\n    const e = {\n      promise: void 0,\n      isResolved: !1,\n      isRejected: !1,\n      isFinished: !1,\n      resolve: void 0,\n      reject: void 0,\n      cancel: _v\n    };\n    return e.promise = new Gu((t, i) => {\n      e.resolve = i => {\n        e.isFinished || (e.isResolved = !0, e.isFinished = !0, t(i), e.value = i);\n      }, e.reject = t => {\n        e.isFinished || (e.isRejected = !0, e.isFinished = !0, i(t));\n      };\n    }), e;\n  }\n  const mv = new Map(),\n    fv = new Map(),\n    Tv = new Map();\n  let Sv = function (e) {\n      return e.WIN_10 = \"Windows 10\", e.WIN_81 = \"Windows 8.1\", e.WIN_8 = \"Windows 8\", e.WIN_7 = \"Windows 7\", e.WIN_VISTA = \"Windows Vista\", e.WIN_SERVER_2003 = \"Windows Server 2003\", e.WIN_XP = \"Windows XP\", e.WIN_2000 = \"Windows 2000\", e.ANDROID = \"Android\", e.HARMONY_OS = \"HarmonyOS\", e.OPEN_BSD = \"Open BSD\", e.SUN_OS = \"Sun OS\", e.LINUX = \"Linux\", e.IOS = \"iOS\", e.MAC_OS = \"Mac OS\", e.CHROMIUM_OS = \"Chromium OS\", e.QNX = \"QNX\", e.UNIX = \"UNIX\", e.BEOS = \"BeOS\", e.OS_2 = \"OS/2\", e.SEARCH_BOT = \"Search Bot\", e;\n    }({}),\n    gv = function (e) {\n      return e.CHROME = \"Chrome\", e.SAFARI = \"Safari\", e.EDGE = \"Edge\", e.FIREFOX = \"Firefox\", e.OPERA = \"OPR\", e.QQ = \"QQBrowser\", e.WECHAT = \"MicroMessenger\", e;\n    }({});\n  const Rv = new aE();\n  let Cv = Rv.getResult(),\n    vv = null;\n  function Iv(e) {\n    if (!vv) {\n      e && Rv.setUA(e), Cv = Rv.getResult();\n      const t = function (e) {\n          if (\"Blink\" === e.engine.name && \"WeChat\" !== e.browser.name) return gv.CHROME;\n          switch (e.browser.name) {\n            case \"Chrome Headless\":\n            case \"Chrome\":\n            case \"Chromium\":\n              return gv.CHROME;\n            case \"Safari\":\n            case \"Mobile Safari\":\n              return gv.SAFARI;\n            case \"Edge\":\n              return gv.EDGE;\n            case \"Firefox\":\n              return gv.FIREFOX;\n            case \"QQ\":\n            case \"QQBrowser\":\n              return gv.QQ;\n            case \"Opera\":\n              return gv.OPERA;\n            case \"WeChat\":\n              return gv.WECHAT;\n            default:\n              return e.browser.name || \"\";\n          }\n        }(Cv),\n        i = yv(Cv),\n        n = function (e) {\n          return \"Windows\" === e.os.name ? e.os.version ? e.os.name + \" \" + e.os.version : e.os.name : e.os.name || \"\";\n        }(Cv),\n        r = Cv.os.version,\n        o = yv(Cv, !1),\n        s = Cv.device.type;\n      if (!(t && i && n && r)) return {\n        name: t,\n        version: i,\n        os: n,\n        osVersion: r,\n        browserVersion: o,\n        deviceType: s\n      };\n      vv = {\n        name: t,\n        version: i,\n        os: n,\n        osVersion: r,\n        browserVersion: o,\n        deviceType: s\n      };\n    }\n    return vv;\n  }\n  function yv(e) {\n    let t,\n      i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n    return t = \"Blink\" === e.engine.name ? e.engine.version || \"\" : e.browser.version || \"\", i ? t.split(\".\")[0] : t;\n  }\n  function Av() {\n    return Iv().os;\n  }\n  function bv() {\n    const e = Iv();\n    return \"\".concat(e.os, \" \").concat(e.osVersion);\n  }\n  function wv() {\n    const e = Iv();\n    return !!(\"WebKit\" === Cv.engine.name && e.os === Sv.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e.name !== gv.SAFARI || Lv() && e.name !== gv.SAFARI);\n  }\n  function Ov() {\n    return Iv().name === gv.CHROME;\n  }\n  function Nv() {\n    return Iv().name === gv.SAFARI;\n  }\n  function Dv() {\n    return Iv().name === gv.EDGE;\n  }\n  function Pv() {\n    return Iv().name === gv.FIREFOX;\n  }\n  function Lv() {\n    return Iv().os === Sv.IOS;\n  }\n  function kv(e) {\n    const t = Iv();\n    return !(t.name !== gv.CHROME || !t.osVersion) && Number(t.version) >= e;\n  }\n  function Mv(e) {\n    const t = Iv();\n    return !(t.name !== gv.EDGE || !t.osVersion) && Number(t.version) >= e;\n  }\n  function Uv(e) {\n    const t = Iv();\n    return !(t.name !== gv.SAFARI || !t.osVersion) && Number(t.version) >= e;\n  }\n  function xv(e, t, i) {\n    const n = Iv();\n    if (n.os !== Sv.IOS || !n.osVersion) return !1;\n    const r = n.osVersion.split(\".\");\n    return i ? t && Number(r[0]) === e && Number(r[1]) < t || Number(r[0]) < e : t ? Number(r[0]) === e && Number(r[1]) <= t || Number(r[0]) < e : Number(r[0]) <= e;\n  }\n  function Vv(e, t, i) {\n    const n = Iv();\n    if (n.name !== gv.SAFARI || !n.osVersion || !n.browserVersion) return !1;\n    const r = n.browserVersion.split(\".\");\n    return i ? t && Number(r[0]) === e && Number(r[1]) < t || Number(r[0]) < e : t ? Number(r[0]) === e && Number(r[1]) <= t || Number(r[0]) < e : Number(r[0]) <= e;\n  }\n  function Fv(e) {\n    const t = Iv();\n    return !(t.name !== gv.OPERA || !t.osVersion) && Number(t.version) >= e;\n  }\n  function Bv() {\n    const e = Iv();\n    return !(e.name !== gv.CHROME || !e.osVersion) && Number(e.version) <= 90;\n  }\n  function jv() {\n    const e = Iv();\n    if (e.os !== Sv.IOS || !e.osVersion) return !1;\n    const t = e.osVersion.split(\".\");\n    return Number(t[0]) < 14 || 14 === Number(t[0]) && Number(t[1]) <= 6;\n  }\n  function Gv() {\n    const e = Iv();\n    if (e.os !== Sv.IOS || !e.osVersion) return !1;\n    const t = e.osVersion.split(\".\");\n    return 15 === Number(t[0]);\n  }\n  function Wv() {\n    const e = Iv();\n    if (e.os !== Sv.IOS || !e.osVersion) return !1;\n    const t = e.osVersion.split(\".\");\n    return 16 === Number(t[0]);\n  }\n  function Hv() {\n    const e = Iv();\n    if (e.os !== Sv.IOS || !e.osVersion) return !1;\n    const t = e.osVersion.split(\".\");\n    return 15 === Number(t[0]) && Number(t[1]) >= 1;\n  }\n  function Kv() {\n    return Nv() && navigator.maxTouchPoints > 0;\n  }\n  function Yv() {\n    return Iv().name === gv.WECHAT;\n  }\n  function qv() {\n    return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\\/([\\w\\W]*?)\\./) && window.navigator.appVersion.match(/Chrome\\/([\\w\\W]*?)\\./)[1] <= 35;\n  }\n  function zv() {\n    const e = Av();\n    return function () {\n      const _Iv = Iv(),\n        e = _Iv.deviceType;\n      return \"mobile\" === e || \"tablet\" === e;\n    }() || e === Sv.ANDROID || e === Sv.IOS || e === Sv.HARMONY_OS;\n  }\n  function Jv() {\n    const e = Iv();\n    return e.name !== gv.EDGE && e.name !== gv.SAFARI && !!navigator.userAgent.toLocaleLowerCase().match(/chrome\\/[\\d]./i);\n  }\n  function Xv() {\n    return Av() === Sv.ANDROID;\n  }\n  function Qv() {\n    const e = Iv();\n    return Xv() && (e.name === gv.CHROME || e.name === gv.WECHAT || /chrome|chromium/i.test(navigator.userAgent));\n  }\n  function Zv(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function $v(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? Zv(Object(i), !0).forEach(function (t) {\n        eI(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Zv(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function eI(e, t, i) {\n    return (t = function (e) {\n      var t = function (e, t) {\n        if (\"object\" != typeof e || null === e) return e;\n        var i = e[Symbol.toPrimitive];\n        if (void 0 !== i) {\n          var n = i.call(e, \"string\");\n          if (\"object\" != typeof n) return n;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return String(e);\n      }(e);\n      return \"symbol\" == typeof t ? t : String(t);\n    }(t)) in e ? Object.defineProperty(e, t, {\n      value: i,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = i, e;\n  }\n  let tI = function (e) {\n    return e.UNEXPECTED_ERROR = \"UNEXPECTED_ERROR\", e.UNEXPECTED_RESPONSE = \"UNEXPECTED_RESPONSE\", e.TIMEOUT = \"TIMEOUT\", e.INVALID_PARAMS = \"INVALID_PARAMS\", e.NOT_READABLE = \"NOT_READABLE\", e.NOT_SUPPORTED = \"NOT_SUPPORTED\", e.INVALID_OPERATION = \"INVALID_OPERATION\", e.OPERATION_ABORTED = \"OPERATION_ABORTED\", e.WEB_SECURITY_RESTRICT = \"WEB_SECURITY_RESTRICT\", e.EXCHANGE_SDP_FAILED = \"EXCHANGE_SDP_FAILED\", e.ADD_CANDIDATE_FAILED = \"ADD_CANDIDATE_FAILED\", e.DATACHANNEL_FAILED = \"DATACHANNEL_FAILED\", e.NETWORK_ERROR = \"NETWORK_ERROR\", e.NETWORK_TIMEOUT = \"NETWORK_TIMEOUT\", e.NETWORK_RESPONSE_ERROR = \"NETWORK_RESPONSE_ERROR\", e.API_INVOKE_TIMEOUT = \"API_INVOKE_TIMEOUT\", e.ENUMERATE_DEVICES_FAILED = \"ENUMERATE_DEVICES_FAILED\", e.DEVICE_NOT_FOUND = \"DEVICE_NOT_FOUND\", e.ELECTRON_IS_NULL = \"ELECTRON_IS_NULL\", e.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = \"ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR\", e.CHROME_PLUGIN_NO_RESPONSE = \"CHROME_PLUGIN_NO_RESPONSE\", e.CHROME_PLUGIN_NOT_INSTALL = \"CHROME_PLUGIN_NOT_INSTALL\", e.MEDIA_OPTION_INVALID = \"MEDIA_OPTION_INVALID\", e.PERMISSION_DENIED = \"PERMISSION_DENIED\", e.CONSTRAINT_NOT_SATISFIED = \"CONSTRAINT_NOT_SATISFIED\", e.TRACK_IS_DISABLED = \"TRACK_IS_DISABLED\", e.GET_VIDEO_ELEMENT_VISIBLE_ERROR = \"GET_VIDEO_ELEMENT_VISIBLE_ERROR\", e.SHARE_AUDIO_NOT_ALLOWED = \"SHARE_AUDIO_NOT_ALLOWED\", e.LOW_STREAM_ENCODING_ERROR = \"LOW_STREAM_ENCODING_ERROR\", e.SET_ENCODING_PARAMETER_ERROR = \"SET_ENCODING_PARAMETER_ERROR\", e.TRACK_STATE_UNREACHABLE = \"TRACK_STATE_UNREACHABLE\", e.INVALID_UINT_UID_FROM_STRING_UID = \"INVALID_UINT_UID_FROM_STRING_UID\", e.CAN_NOT_GET_PROXY_SERVER = \"CAN_NOT_GET_PROXY_SERVER\", e.CAN_NOT_GET_GATEWAY_SERVER = \"CAN_NOT_GET_GATEWAY_SERVER\", e.VOID_GATEWAY_ADDRESS = \"VOID_GATEWAY_ADDRESS\", e.UID_CONFLICT = \"UID_CONFLICT\", e.MULTI_UNILBS_RESPONSE_ERROR = \"MULTI_UNILBS_RESPONSE_ERROR\", e.UPDATE_TICKET_FAILED = \"UPDATE_TICKET_FAILED\", e.INVALID_LOCAL_TRACK = \"INVALID_LOCAL_TRACK\", e.INVALID_TRACK = \"INVALID_TRACK\", e.SENDER_NOT_FOUND = \"SENDER_NOT_FOUND\", e.CREATE_OFFER_FAILED = \"CREATE_OFFER_FAILED\", e.SET_ANSWER_FAILED = \"SET_ANSWER_FAILED\", e.ICE_FAILED = \"ICE_FAILED\", e.PC_CLOSED = \"PC_CLOSED\", e.SENDER_REPLACE_FAILED = \"SENDER_REPLACE_FAILED\", e.GET_LOCAL_CAPABILITIES_FAILED = \"GET_LOCAL_CAPABILITIES_FAILED\", e.GET_LOCAL_CONNECTION_PARAMS_FAILED = \"GET_LOCAL_CONNECTION_PARAMS_FAILED\", e.SUBSCRIBE_FAILED = \"SUBSCRIBE_FAILED\", e.UNSUBSCRIBE_FAILED = \"UNSUBSCRIBE_FAILED\", e.GATEWAY_P2P_LOST = \"GATEWAY_P2P_LOST\", e.NO_ICE_CANDIDATE = \"NO_ICE_CANDIDATE\", e.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = \"CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS\", e.EXIST_DISABLED_VIDEO_TRACK = \"EXIST_DISABLED_VIDEO_TRACK\", e.INVALID_REMOTE_USER = \"INVALID_REMOTE_USER\", e.REMOTE_USER_IS_NOT_PUBLISHED = \"REMOTE_USER_IS_NOT_PUBLISHED\", e.CUSTOM_REPORT_SEND_FAILED = \"CUSTOM_REPORT_SEND_FAILED\", e.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = \"CUSTOM_REPORT_FREQUENCY_TOO_HIGH\", e.FETCH_AUDIO_FILE_FAILED = \"FETCH_AUDIO_FILE_FAILED\", e.READ_LOCAL_AUDIO_FILE_ERROR = \"READ_LOCAL_AUDIO_FILE_ERROR\", e.DECODE_AUDIO_FILE_FAILED = \"DECODE_AUDIO_FILE_FAILED\", e.WS_ABORT = \"WS_ABORT\", e.WS_DISCONNECT = \"WS_DISCONNECT\", e.WS_ERR = \"WS_ERR\", e.EXTERNAL_SIGNAL_ABORT = \"EXTERNAL_SIGNAL_ABORT\", e.LIVE_STREAMING_TASK_CONFLICT = \"LIVE_STREAMING_TASK_CONFLICT\", e.LIVE_STREAMING_INVALID_ARGUMENT = \"LIVE_STREAMING_INVALID_ARGUMENT\", e.LIVE_STREAMING_INTERNAL_SERVER_ERROR = \"LIVE_STREAMING_INTERNAL_SERVER_ERROR\", e.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = \"LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED\", e.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = \"LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED\", e.LIVE_STREAMING_CDN_ERROR = \"LIVE_STREAMING_CDN_ERROR\", e.LIVE_STREAMING_INVALID_RAW_STREAM = \"LIVE_STREAMING_INVALID_RAW_STREAM\", e.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = \"LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT\", e.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = \"LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE\", e.LIVE_STREAMING_WARN_FREQUENT_REQUEST = \"LIVE_STREAMING_WARN_FREQUENT_REQUEST\", e.WEBGL_INTERNAL_ERROR = \"WEBGL_INTERNAL_ERROR\", e.BEAUTY_PROCESSOR_INTERNAL_ERROR = \"BEAUTY_PROCESSOR_INTERNAL_ERROR\", e.CROSS_CHANNEL_WAIT_STATUS_ERROR = \"CROSS_CHANNEL_WAIT_STATUS_ERROR\", e.CROSS_CHANNEL_FAILED_JOIN_SRC = \"CROSS_CHANNEL_FAILED_JOIN_SEC\", e.CROSS_CHANNEL_FAILED_JOIN_DEST = \"CROSS_CHANNEL_FAILED_JOIN_DEST\", e.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = \"CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST\", e.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = \"CROSS_CHANNEL_SERVER_ERROR_RESPONSE\", e.METADATA_OUT_OF_RANGE = \"METADATA_OUT_OF_RANGE\", e.LOCAL_AEC_ERROR = \"LOCAL_AEC_ERROR\", e.INVALID_PLUGIN = \"INVALID_PLUGIN\", e.DISCONNECT_P2P = \"DISCONNECT_P2P\", e.INIT_WEBSOCKET_TIMEOUT = \"INIT_WEBSOCKET_TIMEOUT\", e.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = \"CONVERTING_IMAGEDATA_TO_BLOB_FAILED\", e.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = \"CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED\", e.INIT_DATACHANNEL_TIMEOUT = \"INIT_DATACHANNEL_TIMEOUT\", e.CREATE_DATACHANNEL_ERROR = \"CREATE_DATACHANNEL_ERROR\", e.DATACHANNEL_CONNECTION_TIMEOUT = \"DATACHANNEL_CONNECTION_TIMEOUT\", e.PROHIBITED_OPERATION = \"PROHIBITED_OPERATION\", e.IMAGE_MODERATION_UPLOAD_FAILED = \"IMAGE_MODERATION_UPLOAD_FAILED\", e.P2P_MESSAGE_FAILED = \"P2P_MESSAGE_FAILED\", e;\n  }({});\n  class iI extends Error {\n    constructor(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"\",\n        i = arguments.length > 2 ? arguments[2] : void 0;\n      super(t), eI(this, \"code\", void 0), eI(this, \"message\", void 0), eI(this, \"data\", void 0), eI(this, \"name\", \"AgoraRTCException\"), this.code = e, this.message = \"AgoraRTCError \".concat(this.code, \": \").concat(t), this.data = i;\n    }\n    toString() {\n      return this.data ? \"data: \".concat(JSON.stringify(this.data), \"\\n\").concat(this.stack) : \"\".concat(this.stack);\n    }\n    print() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"error\",\n        t = arguments.length > 1 ? arguments[1] : void 0;\n      return \"error\" === e && (t || console).error(this.toString()), \"warning\" === e && (t || console).warn(this.toString()), this;\n    }\n    throw(e) {\n      throw this.print(\"error\", e), this;\n    }\n  }\n  function nI(e, t) {\n    if (\"boolean\" != typeof e) throw new iI(tI.INVALID_PARAMS, \"Invalid \".concat(t, \": The value is of the boolean type.\"));\n  }\n  function rI(e, t, i) {\n    if (!Dn(i).call(i, e)) throw new iI(tI.INVALID_PARAMS, \"\".concat(t, \" can only be set as \").concat(JSON.stringify(i)));\n  }\n  function oI(e, t) {\n    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,\n      n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4;\n    if (e < i || e > n || (!(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]) && !function (e) {\n      return \"number\" == typeof e && e % 1 == 0;\n    }(e)) throw new iI(tI.INVALID_PARAMS, \"invalid \".concat(t, \": the value range is [\").concat(i, \", \").concat(n, \"]. integer only\"));\n  }\n  function sI(e, t) {\n    if (\"number\" != typeof e) {\n      if (!(e.min || e.max || e.ideal || e.exact)) throw new iI(tI.INVALID_PARAMS, \"\".concat(t, \" is not a valid ConstrainLong\"));\n      void 0 !== e.min && oI(e.min, \"\".concat(t, \".min\"), 0, 1 / 0), void 0 !== e.max && oI(e.max, \"\".concat(t, \".max\"), 1, 1 / 0), void 0 !== e.exact && oI(e.exact, \"\".concat(t, \".exact\"), 1, 1 / 0), void 0 !== e.ideal && oI(e.ideal, \"\".concat(t, \".ideal\"), 1, 1 / 0);\n    } else oI(e, t, 1, 1 / 0);\n  }\n  function aI(e, t) {\n    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,\n      n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255,\n      r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];\n    if (null == e) throw new iI(tI.INVALID_PARAMS, \"\".concat(t || \"param\", \" cannot be empty\"));\n    if (!lI(e, i, n, r)) throw new iI(tI.INVALID_PARAMS, \"Invalid \".concat(t || \"string param\", \": Length of the string: [\").concat(i, \",\").concat(n, \"].\").concat(r ? \" ASCII characters only.\" : \"\"));\n  }\n  function cI(e, t) {\n    if (!Array.isArray(e)) throw new iI(tI.INVALID_PARAMS, \"\".concat(t, \" should be an array\"));\n  }\n  function dI(e) {\n    return null == e;\n  }\n  function lI(e) {\n    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,\n      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255,\n      n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];\n    return \"string\" == typeof e && e.length <= i && e.length >= t && (!n || function (e) {\n      if (\"string\" != typeof e) return !1;\n      for (let t = 0; t < e.length; t += 1) {\n        const i = e.charCodeAt(t);\n        if (i < 0 || i > 255) return !1;\n      }\n      return !0;\n    }(e));\n  }\n  function hI(e, t, i) {\n    if (\"getBigUint64\" in DataView.prototype) return e.getBigUint64(t, i);\n    const n = e.getUint32(t, i),\n      r = e.getUint32(t + 4, i),\n      o = Number(!!i),\n      s = Number(!i);\n    return BigInt(n * s + r * o) << BigInt(32) | BigInt(n * o + r * s);\n  }\n  function uI(e, t, i, n) {\n    if (\"setBigUint64\" in DataView.prototype) return e.setBigUint64(t, i, n);\n    const r = Number(i >> BigInt(32)),\n      o = Number(i & BigInt(4294967295));\n    n ? (e.setUint32(t + 4, r, n), e.setUint32(t, o, n)) : (e.setUint32(t, r, n), e.setUint32(t + 4, o, n));\n  }\n  var pI = function (e) {\n      return e.COVERED = \"COVERED\", e.POSITION = \"POSITION\", e.SIZE = \"SIZE\", e.STYLE = \"STYLE\", e;\n    }(pI || {}),\n    _I = function (e) {\n      return e.UNMOUNTED = \"UNMOUNTED\", e.INVALID_HTML_ELEMENT = \"INVALID_HTML_ELEMENT\", e;\n    }(_I || {});\n  const EI = new class {\n    constructor() {\n      eI(this, \"_clientSize\", null), eI(this, \"getClientWidth\", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), eI(this, \"getClientHeight\", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), eI(this, \"getStyle\", e => window.getComputedStyle(e, null)), eI(this, \"checkCssVisibleProperty\", e => {\n        var t;\n        let i = !0;\n        const n = this.getStyle(e),\n          r = n.display,\n          o = n.visibility,\n          s = n.opacity,\n          a = n.filter;\n        return (\"none\" === r || Dn(t = [\"hidden\", \"collapse\"]).call(t, o) || Number(s) < .1) && (i = !1), !!i && (a && a.split(\" \").filter(e => {\n          var t;\n          const i = e.split(\"(\")[0];\n          return Dn(t = [\"brightness\", \"blur\", \"opacity\"]).call(t, i);\n        }).map(e => {\n          const _e$split = e.split(/\\(|\\)/),\n            _e$split2 = _slicedToArray(_e$split, 2),\n            t = _e$split2[0],\n            i = _e$split2[1];\n          return [t, Number(i.match(/^[0-9\\.]+/))];\n        }).forEach(e => {\n          const _e6 = _slicedToArray(e, 2),\n            t = _e6[0],\n            n = _e6[1];\n          switch (t) {\n            case \"brightness\":\n              (n < .1 || n > 3) && (i = !1);\n              break;\n            case \"blur\":\n              n > 3 && (i = !1);\n              break;\n            case \"opacity\":\n              n < .1 && (i = !1);\n          }\n        }), i);\n      }), eI(this, \"checkPropertyUpToAllParentNodes\", (e, t) => {\n        let i = !0,\n          n = !0;\n        const r = e => t(e);\n        let o = e;\n        for (; o && n;) r(o) || (i = !1, n = !1), o = o.parentElement, o || (n = !1);\n        return i;\n      }), eI(this, \"checkActualCssVisibleIncludeInherit\", e => this.checkPropertyUpToAllParentNodes(e, this.checkCssVisibleProperty)), eI(this, \"getSizeAboutClient\", e => {\n        const _e$getBoundingClientR = e.getBoundingClientRect(),\n          t = _e$getBoundingClientR.width,\n          i = _e$getBoundingClientR.height,\n          n = _e$getBoundingClientR.left,\n          r = _e$getBoundingClientR.right,\n          o = _e$getBoundingClientR.top,\n          s = _e$getBoundingClientR.bottom,\n          a = this.getClientWidth(),\n          c = this.getClientHeight();\n        return {\n          width: t,\n          height: i,\n          left: n,\n          right: r,\n          top: o,\n          bottom: s,\n          clientWidth: a,\n          clientHeight: c,\n          clientMin: Math.min(a, c)\n        };\n      }), eI(this, \"checkActualSize\", () => {\n        const _this$_clientSize = this._clientSize,\n          e = _this$_clientSize.width,\n          t = _this$_clientSize.height,\n          i = _this$_clientSize.clientMin;\n        return this.checkSizeIsVisible(e, t, i);\n      }), eI(this, \"elementFromPoint\", (e, t) => document.elementFromPoint ? document.elementFromPoint(e, t) : null), eI(this, \"checkCoverForAPoint\", (e, t, i) => {\n        const n = this.elementFromPoint(e, t);\n        return null !== n && n !== i;\n      }), eI(this, \"getPointPositionList\", () => {\n        const _this$_clientSize2 = this._clientSize,\n          e = _this$_clientSize2.width,\n          t = _this$_clientSize2.height,\n          i = _this$_clientSize2.left,\n          n = _this$_clientSize2.top,\n          r = e / 6,\n          o = t / 6,\n          s = [],\n          a = 10 ** 6;\n        for (let e = 0; e < 5; e++) for (let t = 0; t < 5; t++) {\n          const c = (i * a + (0 === e ? .1 : 4 === e ? (r * e * a - 1e5) / a : r * e) * a) / a,\n            d = (n * a + (0 === t ? .1 : 4 === t ? (o * t * a - 1e5) / a : o * t) * a) / a;\n          s.push({\n            x: c,\n            y: d\n          });\n        }\n        return [...s];\n      }), eI(this, \"checkElementCover\", e => this.getPointPositionList().map(t => this.checkCoverForAPoint(t.x, t.y, e)).filter(e => !!e).length > 6), eI(this, \"checkSizeIsVisible\", (e, t, i) => (e > 50 || i / e <= 10) && (t > 50 || i / t <= 10)), eI(this, \"checkSizeOfPartInClient\", () => {\n        const _this$_clientSize3 = this._clientSize,\n          e = _this$_clientSize3.left,\n          t = _this$_clientSize3.right,\n          i = _this$_clientSize3.top,\n          n = _this$_clientSize3.bottom,\n          r = _this$_clientSize3.clientHeight,\n          o = _this$_clientSize3.clientWidth,\n          s = _this$_clientSize3.clientMin;\n        let a, c, d, l;\n        if (e < 0) a = 0;else {\n          if (!(e < o)) return !1;\n          a = e;\n        }\n        if (t < 0) return !1;\n        if (c = t < o ? t : o, i < 0) d = 0;else {\n          if (!(i < r)) return !1;\n          d = i;\n        }\n        if (n < 0) return !1;\n        l = n < r ? n : r;\n        const h = c - a,\n          u = l - d;\n        return this.checkSizeIsVisible(h, u, s);\n      }), eI(this, \"returnHiddenResult\", e => (this._clientSize = null, {\n        visible: !1,\n        reason: e\n      })), eI(this, \"checkOneElementVisible\", e => {\n        if (e instanceof HTMLElement) {\n          if (this.checkElementIsMountedOnDom(e)) {\n            if (this.checkActualCssVisibleIncludeInherit(e)) {\n              if (this._clientSize = this.getSizeAboutClient(e), this.checkElementCover(e)) return this.returnHiddenResult(pI.COVERED);\n              {\n                const e = this.checkActualSize(),\n                  t = this.checkSizeOfPartInClient();\n                return e && !t ? this.returnHiddenResult(pI.POSITION) : e ? (this._clientSize = null, {\n                  visible: !0\n                }) : this.returnHiddenResult(pI.SIZE);\n              }\n            }\n            return this.returnHiddenResult(pI.STYLE);\n          }\n          return this.returnHiddenResult(_I.UNMOUNTED);\n        }\n        return this.returnHiddenResult(_I.INVALID_HTML_ELEMENT);\n      }), eI(this, \"checkElementIsMountedOnDom\", e => this.checkPropertyUpToAllParentNodes(e, e => \"HTML\" !== e.nodeName.toUpperCase() ? null !== e.parentElement : !!document.documentElement));\n    }\n  }();\n  function mI(e) {\n    return new TextEncoder().encode(e);\n  }\n  const fI = function (e, t) {\n    const i = new Uint8Array(e.byteLength + t.byteLength);\n    return i.set(new Uint8Array(e), 0), i.set(new Uint8Array(t), e.byteLength), i;\n  };\n  const TI = async e => function (e, t) {\n    let i = \"\";\n    return new Uint8Array(e).forEach(e => {\n      i += e.toString(t).padStart(2, \"0\");\n    }), i;\n  }(await crypto.subtle.digest(\"SHA-256\", mI(e)), 16);\n  let SI = class {\n    constructor() {\n      eI(this, \"_events\", {}), eI(this, \"addListener\", this.on);\n    }\n    getListeners(e) {\n      return this._events[e] ? this._events[e].map(e => e.listener) : [];\n    }\n    on(e, t) {\n      this._events[e] || (this._events[e] = []);\n      const i = this._events[e];\n      -1 === this._indexOfListener(i, t) && i.push({\n        listener: t,\n        once: !1\n      });\n    }\n    once(e, t) {\n      this._events[e] || (this._events[e] = []);\n      const i = this._events[e];\n      -1 === this._indexOfListener(i, t) && i.push({\n        listener: t,\n        once: !0\n      });\n    }\n    off(e, t) {\n      if (!this._events[e]) return;\n      const i = this._events[e],\n        n = this._indexOfListener(i, t);\n      -1 !== n && i.splice(n, 1), 0 === this._events[e].length && delete this._events[e];\n    }\n    removeAllListeners(e) {\n      e ? delete this._events[e] : this._events = {};\n    }\n    emit(e) {\n      this._events[e] || (this._events[e] = []);\n      const t = this._events[e].map(e => e);\n      for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), r = 1; r < i; r++) n[r - 1] = arguments[r];\n      for (let i = 0; i < t.length; i += 1) {\n        const r = t[i];\n        r.once && this.off(e, r.listener), r.listener.apply(this, n || []);\n      }\n    }\n    safeEmit(e) {\n      for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];\n      [...(this._events[e] || [])].forEach(t => {\n        t.once && this.off(e, t.listener);\n        try {\n          t.listener.apply(this, i);\n        } catch (t) {\n          console.error(\"safeEmit event:\".concat(e, \" error \").concat(null == t ? void 0 : t.toString()));\n        }\n      });\n    }\n    _indexOfListener(e, t) {\n      let i = e.length;\n      for (; i--;) if (e[i].listener === t) return i;\n      return -1;\n    }\n  };\n  let gI = null;\n  function RI() {\n    if (gI) return gI;\n    if (window.electron) return gI = window.electron;\n    if (!window.require) return null;\n    try {\n      return gI = window.require(\"electron\"), gI;\n    } catch (e) {\n      return null;\n    }\n  }\n  let CI = function (e) {\n      return e.CREATE_CLIENT = \"createClient\", e.CHECK_SYSTEM_REQUIREMENTS = \"checkSystemRequirements\", e.SET_AREA = \"setArea\", e.PRELOAD = \"PRELOAD\", e.CHECK_VIDEO_TRACK_IS_ACTIVE = \"checkVideoTrackIsActive\", e.CHECK_AUDIO_TRACK_IS_ACTIVE = \"checkAudioTrackIsActive\", e.CREATE_MIC_AUDIO_TRACK = \"createMicrophoneAudioTrack\", e.CREATE_CUSTOM_AUDIO_TRACK = \"createCustomAudioTrack\", e.CREATE_BUFFER_AUDIO_TRACK = \"createBufferSourceAudioTrack\", e.CREATE_CAM_VIDEO_TRACK = \"createCameraVideoTrack\", e.CREATE_CUSTOM_VIDEO_TRACK = \"createCustomVideoTrack\", e.CREATE_MIC_AND_CAM_TRACKS = \"createMicrophoneAndCameraTracks\", e.CREATE_SCREEN_VIDEO_TRACK = \"createScreenVideoTrack\", e.SET_ENCRYPTION_CONFIG = \"Client.setEncryptionConfig\", e.START_PROXY_SERVER = \"Client.startProxyServer\", e.STOP_PROXY_SERVER = \"Client.stopProxyServer\", e.SET_PROXY_SERVER = \"Client.setProxyServer\", e.SET_TURN_SERVER = \"Client.setTurnServer\", e.SET_CLIENT_ROLE = \"Client.setClientRole\", e.SET_LOW_STREAM_PARAMETER = \"Client.setLowStreamParameter\", e.ENABLE_DUAL_STREAM = \"Client.enableDualStream\", e.DISABLE_DUAL_STREAM = \"Client.disableDualStream\", e.JOIN = \"Client.join\", e.LEAVE = \"Client.leave\", e.PUBLISH = \"Client.publish\", e.UNPUBLISH = \"Client.unpublish\", e.SUBSCRIBE = \"Client.subscribe\", e.MASS_SUBSCRIBE = \"Client.massSubscribe\", e.MASS_UNSUBSCRIBE = \"Client.massUnsubscribe\", e.UNSUBSCRIBE = \"Client.unsubscribe\", e.RENEW_TOKEN = \"Client.renewToken\", e.SET_REMOTE_VIDEO_STREAM_TYPE = \"Client.setRemoteVideoStreamType\", e.SET_STREAM_FALLBACK_OPTION = \"Client.setStreamFallbackOption\", e.ENABLE_AUDIO_VOLUME_INDICATOR = \"Client.enableAudioVolumeIndicator\", e.SEND_CUSTOM_REPORT_MESSAGE = \"Client.sendCustomReportMessage\", e.INSPECT_VIDEO_CONTENT = \"Client.inspectVideoContent\", e.STOP_INSPECT_VIDEO_CONTENT = \"Client.stopInspectVideoContent\", e.JOIN_FALLBACK_TO_PROXY = \"Client._joinFallbackToProxy\", e.DATACHANNEL_FAILBACK = \"Client._datachannelFailback\", e.ON_LIVE_STREAM_WARNING = \"Client.onLiveStreamWarning\", e.ON_LIVE_STREAM_ERROR = \"Client.onLiveStreamingError\", e.START_LIVE_STREAMING = \"Client.startLiveStreaming\", e.SET_LIVE_TRANSCODING = \"Client.setLiveTranscoding\", e.STOP_LIVE_STREAMING = \"Client.stopLiveStreaming\", e.START_CHANNEL_MEDIA_RELAY = \"Client.startChannelMediaRelay\", e.UPDATE_CHANNEL_MEDIA_RELAY = \"Client.updateChannelMediaRelay\", e.STOP_CHANNEL_MEDIA_RELAY = \"Client.stopChannelMediaRelay\", e.REQUEST_CONFIG_DISTRIBUTE = \"_config-distribute-request\", e.SET_CONFIG_DISTRIBUTE = \"_configDistribute\", e.LOCAL_TRACK_SET_MUTED = \"LocalTrack.setMute\", e.LOCAL_AUDIO_TRACK_PLAY = \"LocalAudioTrack.play\", e.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = \"LocalAudioTrack.playInElement\", e.LOCAL_AUDIO_TRACK_STOP = \"LocalAudioTrack.stop\", e.LOCAL_AUDIO_TRACK_SET_VOLUME = \"LocalAudioTrack.setVolume\", e.MIC_AUDIO_TRACK_SET_DEVICE = \"MicrophoneAudioTrack.setDevice\", e.BUFFER_AUDIO_TRACK_START = \"BufferSourceAudioTrack.startProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_STOP = \"BufferSourceAudioTrack.stopProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_PAUSE = \"BufferSourceAudioTrack.pauseProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_RESUME = \"BufferSourceAudioTrack.resumeProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_SEEK = \"BufferSourceAudioTrack.seekAudioBuffer\", e.LOCAL_VIDEO_TRACK_PLAY = \"LocalVideoTrack.play\", e.LOCAL_VIDEO_TRACK_STOP = \"LocalVideoTrack.stop\", e.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = \"LocalVideoTrack.getVideoElementVisibleStatus\", e.LOCAL_VIDEO_TRACK_BEAUTY = \"LocalVideoTrack.setBeautyEffect\", e.LOCAL_VIDEO_SEND_SEI_DATA = \"LocalVideoTrack.sendSeiData\", e.CAM_VIDEO_TRACK_SET_DEVICE = \"CameraVideoTrack.setDevice\", e.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = \"CameraVideoTrack.setEncoderConfiguration\", e.REMOTE_VIDEO_TRACK_PLAY = \"RemoteVideoTrack.play\", e.REMOTE_VIDEO_TRACK_STOP = \"RemoteVideoTrack.stop\", e.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = \"RemoteVideoTrack.getVideoElementVisibleStatus\", e.REMOTE_AUDIO_TRACK_PLAY = \"RemoteAudioTrack.play\", e.REMOTE_AUDIO_TRACK_STOP = \"RemoteAudioTrack.stop\", e.REMOTE_AUDIO_SET_VOLUME = \"RemoteAudioTrack.setVolume\", e.REMOTE_AUDIO_SET_OUTPUT_DEVICE = \"RemoteAudioTrack.setOutputDevice\", e.GET_MEDIA_STREAM_TRACK = \"Track.getMediaStreamTrack\", e.STREAM_TYPE_CHANGE = \"streamTypeChange\", e.CONNECTION_STATE_CHANGE = \"connectionStateChange\", e.LOAD_CONFIG_FROM_LOCALSTORAGE = \"loadConfigFromLocalStorage\", e.IMAGE_MODERATION_UPLOAD = \"imageModerationUpload\", e;\n    }({}),\n    vI = function (e) {\n      return e.TRACER = \"tracer\", e;\n    }({});\n  function II(e) {\n    return oI(e.timeout, \"config.timeout\", 0, 1e5), oI(e.timeoutFactor, \"config.timeoutFactor\", 0, 100, !1), oI(e.maxRetryCount, \"config.maxRetryConfig\", 0, 1 / 0), oI(e.maxRetryTimeout, \"config.maxRetryTimeout\", 0, 1 / 0), !0;\n  }\n  let yI = function (e) {\n      return e[e.AUDIENCE_LEVEL_LOW_LATENCY = 1] = \"AUDIENCE_LEVEL_LOW_LATENCY\", e[e.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = \"AUDIENCE_LEVEL_ULTRA_LOW_LATENCY\", e[e.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = \"AUDIENCE_LEVEL_SYNC_LATENCY\", e;\n    }({}),\n    AI = function (e) {\n      return e.LEAVE = \"LEAVE\", e.NETWORK_ERROR = \"NETWORK_ERROR\", e.SERVER_ERROR = \"SERVER_ERROR\", e.UID_BANNED = \"UID_BANNED\", e.IP_BANNED = \"IP_BANNED\", e.CHANNEL_BANNED = \"CHANNEL_BANNED\", e.FALLBACK = \"FALLBACK\", e.LICENSE_MISSING = \"LICENSE_MISSING\", e.LICENSE_EXPIRED = \"LICENSE_EXPIRED\", e.LICENSE_MINUTES_EXCEEDED = \"LICENSE_MINUTES_EXCEEDED\", e.LICENSE_PERIOD_INVALID = \"LICENSE_PERIOD_INVALID\", e.LICENSE_MULTIPLE_SDK_SERVICE = \"LICENSE_MULTIPLE_SDK_SERVICE\", e.LICENSE_ILLEGAL = \"LICENSE_ILLEGAL\", e.TOKEN_EXPIRE = \"TOKEN_EXPIRE\", e;\n    }({});\n  function bI(e) {\n    if (!Array.isArray(e) || e.length < 1) return !1;\n    try {\n      e.forEach(e => {\n        if (!e.urls) throw Error();\n      });\n    } catch (e) {\n      return !1;\n    }\n    return !0;\n  }\n  function wI(e) {\n    return aI(e.turnServerURL, \"turnServerURL\"), aI(e.username, \"username\"), aI(e.password, \"password\"), e.udpport && oI(e.udpport, \"udpport\", 1, 99999, !0), e.forceturn && nI(e.forceturn, \"forceturn\"), e.security && nI(e.security, \"security\"), e.tcpport && oI(e.tcpport, \"tcpport\", 1, 99999, !0), !0;\n  }\n  function OI(e) {\n    return void 0 !== e.level && rI(e.level, \"level\", [1, 2, 3]), void 0 !== e.delay && oI(e.delay, \"delay\", 0, 3e3, !0), !0;\n  }\n  let NI = function (e) {\n      return e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.MEDIA_RECONNECT_START = \"media-reconnect-start\", e.MEDIA_RECONNECT_END = \"media-reconnect-end\", e.IS_USING_CLOUD_PROXY = \"is-using-cloud-proxy\", e.USER_JOINED = \"user-joined\", e.USER_LEAVED = \"user-left\", e.USER_PUBLISHED = \"user-published\", e.USER_UNPUBLISHED = \"user-unpublished\", e.USER_INFO_UPDATED = \"user-info-updated\", e.CLIENT_BANNED = \"client-banned\", e.CHANNEL_MEDIA_RELAY_STATE = \"channel-media-relay-state\", e.CHANNEL_MEDIA_RELAY_EVENT = \"channel-media-relay-event\", e.VOLUME_INDICATOR = \"volume-indicator\", e.CRYPT_ERROR = \"crypt-error\", e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = \"token-privilege-will-expire\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"token-privilege-did-expire\", e.NETWORK_QUALITY = \"network-quality\", e.STREAM_TYPE_CHANGED = \"stream-type-changed\", e.STREAM_FALLBACK = \"stream-fallback\", e.RECEIVE_METADATA = \"receive-metadata\", e.STREAM_MESSAGE = \"stream-message\", e.LIVE_STREAMING_ERROR = \"live-streaming-error\", e.LIVE_STREAMING_WARNING = \"live-streaming-warning\", e.INJECT_STREAM_STATUS = \"stream-inject-status\", e.EXCEPTION = \"exception\", e.ERROR = \"error\", e.P2P_LOST = \"p2p_lost\", e.JOIN_FALLBACK_TO_PROXY = \"join-fallback-to-proxy\", e.CHANNEL_FALLBACK_TO_WEBSOCKET = \"channel-fallback-to-websocket\", e.MEDIA_CONNECTION_TYPE_CHANGE = \"media-connection-type-change\", e.PUBLISHED_USER_LIST = \"published-user-list\", e.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = \"content-inspect-connection-state-change\", e.CONTENT_INSPECT_ERROR = \"content-inspect-error\", e.CONTENT_INSPECT_RESULT = \"content-inspect-result\", e.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = \"image-moderation-connection-state-change\", e;\n    }({}),\n    DI = function (e) {\n      return e.NETWORK_ERROR = \"NETWORK_ERROR\", e.SERVER_ERROR = \"SERVER_ERROR\", e.MULTI_IP = \"MULTI_IP\", e.TIMEOUT = \"TIMEOUT\", e.OFFLINE = \"OFFLINE\", e.LEAVE = \"LEAVE\", e.P2P_FAILED = \"P2P_FAILED\", e.FALLBACK = \"FALLBACK\", e;\n    }({}),\n    PI = function (e) {\n      return e.ONLINE = \"ONLINE\", e.OFFLINE = \"OFFLINE\", e;\n    }({}),\n    LI = function (e) {\n      return e.NETWORK_STATE_CHANGE = \"NETWORK_STATE_CHANGE\", e.ONLINE = \"ONLINE\", e.OFFLINE = \"OFFLINE\", e;\n    }({});\n  function kI(e, t) {\n    for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), r = 2; r < i; r++) n[r - 2] = arguments[r];\n    return 0 === e.getListeners(t).length ? Gu.reject(new iI(tI.UNEXPECTED_ERROR, \"can not emit promise\")) : new Gu((i, r) => {\n      e.emit(t, ...n, i, r);\n    });\n  }\n  function MI(e, t) {\n    if (0 === e.getListeners(t).length) return Gu.resolve();\n    for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), r = 2; r < i; r++) n[r - 2] = arguments[r];\n    return kI(e, t, ...n);\n  }\n  function UI(e, t) {\n    if (0 === e.getListeners(t).length) return null;\n    for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), r = 2; r < i; r++) n[r - 2] = arguments[r];\n    return xI(e, t, ...n);\n  }\n  function xI(e, t) {\n    let i = null,\n      n = null;\n    for (var r = arguments.length, o = new Array(r > 2 ? r - 2 : 0), s = 2; s < r; s++) o[s - 2] = arguments[s];\n    if (e.emit(t, ...o, e => {\n      i = e;\n    }, e => {\n      n = e;\n    }), null !== n) throw n;\n    if (null === i) throw new iI(tI.UNEXPECTED_ERROR, \"handler is not sync\");\n    return i;\n  }\n  const VI = new class extends SI {\n    set networkState(e) {\n      this.emit(LI.NETWORK_STATE_CHANGE, e, this._networkState), e === PI.ONLINE ? this.emit(LI.ONLINE) : e === PI.OFFLINE && (this.onlineWaiter = new Gu(e => {\n        this.once(LI.ONLINE, () => {\n          this.onlineWaiter = void 0, e(PI.ONLINE);\n        });\n      }), this.emit(LI.OFFLINE)), this._networkState = e;\n    }\n    get networkState() {\n      return this._networkState;\n    }\n    get isOnline() {\n      return this._networkState === PI.ONLINE;\n    }\n    constructor() {\n      super(), eI(this, \"_moduleName\", \"network-indicator\"), eI(this, \"_networkState\", PI.ONLINE), eI(this, \"onlineWaiter\", void 0), window.addEventListener(\"online\", () => {\n        this.networkState = PI.ONLINE;\n      }), window.addEventListener(\"offline\", () => {\n        this.networkState = PI.OFFLINE;\n      });\n    }\n  }();\n  function FI(e, t) {\n    const i = e.indexOf(t);\n    -1 !== i && e.splice(i, 1);\n  }\n  function BI(e) {\n    const t = [];\n    return e.forEach(e => {\n      -1 === t.indexOf(e) && t.push(e);\n    }), t;\n  }\n  function jI(e) {\n    void 0 !== Gu ? Gu.resolve().then(e) : setTimeout(e, 0);\n  }\n  function GI(e) {\n    return JSON.parse(JSON.stringify(e));\n  }\n  function WI(e) {\n    try {\n      return GI(e);\n    } catch (t) {\n      return e;\n    }\n  }\n  const HI = {};\n  function KI(e, t) {\n    HI[t] || (HI[t] = !0, e());\n  }\n  function YI(e) {\n    const t = window.atob(e),\n      i = new Uint8Array(new ArrayBuffer(t.length));\n    for (let e = 0; e < t.length; e += 1) i[e] = t.charCodeAt(e);\n    return i;\n  }\n  function qI(e) {\n    let t = \"\";\n    for (let i = 0; i < e.length; i += 1) t += String.fromCharCode(e[i]);\n    return window.btoa(t);\n  }\n  function zI(e) {\n    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16,\n      i = new TextEncoder().encode(e);\n    if (i.length > t) i = i.slice(0, t);else if (i.length < t) {\n      const e = new Uint8Array(t);\n      e.set(i), i = e;\n    }\n    return i;\n  }\n  function JI() {\n    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n    const n = Jn(t).call(t, (e, t) => e + t.length, 0),\n      r = new Uint8Array(new ArrayBuffer(n));\n    let o = 0;\n    return t.forEach(e => {\n      r.set(e, o), o += e.length;\n    }), r;\n  }\n  function XI(e) {\n    return window.TextEncoder ? new TextEncoder().encode(e).length : e.length;\n  }\n  function QI(e) {\n    let t = 0;\n    return (/DingTalk/i.test(navigator.userAgent) || /AliApp/i.test(navigator.userAgent)) && e.realFormData && (e = e.realFormData), e.forEach(e => {\n      t += \"string\" == typeof e ? XI(e) : e.size;\n    }), t + 138;\n  }\n  function ZI(e) {\n    const t = new iI(tI.TIMEOUT, \"timeout\");\n    return new Gu((i, n) => {\n      window.setTimeout(() => n(t), e);\n    });\n  }\n  function $I(e) {\n    return new Gu(t => {\n      window.setTimeout(t, e);\n    });\n  }\n  function ey() {\n    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7,\n      t = arguments.length > 1 ? arguments[1] : void 0;\n    const i = Math.random().toString(16).substr(2, e).toLowerCase();\n    return i.length === e ? \"\".concat(t).concat(i) : \"\".concat(t).concat(i) + ey(e - i.length, \"\");\n  }\n  function ty() {\n    return ey(32, \"\").toUpperCase();\n  }\n  const iy = () => {},\n    ny = new class {\n      constructor() {\n        eI(this, \"fnMap\", new Map());\n      }\n      throttleByKey(e, t, i, n) {\n        for (var r = arguments.length, o = new Array(r > 4 ? r - 4 : 0), s = 4; s < r; s++) o[s - 4] = arguments[s];\n        if (this.fnMap.has(t)) {\n          const r = this.fnMap.get(t);\n          if (r.threshold !== i) {\n            r.fn(...r.args), clearTimeout(r.timer);\n            const s = window.setTimeout(() => {\n              const e = this.fnMap.get(t);\n              e && e.fn(...e.args), this.fnMap.delete(t);\n            }, i);\n            this.fnMap.set(t, {\n              fn: e,\n              threshold: i,\n              timer: s,\n              args: o,\n              skipFn: n\n            });\n          } else r.skipFn && r.skipFn(...r.args), this.fnMap.set(t, $v($v({}, r), {}, {\n            fn: e,\n            args: o,\n            skipFn: n\n          }));\n        } else {\n          const r = window.setTimeout(() => {\n            const e = this.fnMap.get(t);\n            e && e.fn(...e.args), this.fnMap.delete(t);\n          }, i);\n          this.fnMap.set(t, {\n            fn: e,\n            threshold: i,\n            timer: r,\n            args: o,\n            skipFn: n\n          });\n        }\n      }\n    }(),\n    ry = ny.throttleByKey.bind(ny);\n  function oy(e) {\n    return \"object\" == typeof e && null !== e && !(e instanceof RegExp);\n  }\n  function sy(e, t) {\n    if (!oy(e) || !oy(t)) return t;\n    if (Array.isArray(e) && !Array.isArray(t) || !Array.isArray(e) && Array.isArray(t)) return t;\n    if (Array.isArray(t) && Array.isArray(e)) {\n      const i = [...e];\n      for (let n = 0; n < t.length; n++) i[n] = sy(e[n], t[n]);\n      return i;\n    }\n    {\n      const i = $v({}, e);\n      for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (Object.prototype.hasOwnProperty.call(e, n) ? i[n] = sy(e[n], t[n]) : i[n] = t[n]);\n      return i;\n    }\n  }\n  function ay(e, t) {\n    let i = [0];\n    if (t && (i = new Array(t).fill(0)), 0 === e) return i;\n    let n = 0;\n    for (; e > 0 && (i[n] = 255 & e, e >>= 8, n++, !t || n !== t););\n    return i;\n  }\n  function cy(e) {\n    return \"number\" == typeof e ? e : e.exact || e.ideal || e.max || e.min || 0;\n  }\n  function dy(e) {\n    const t = \"0123456789abcdef\";\n    function i(e) {\n      let i,\n        n = \"\";\n      for (i = 0; i <= 3; i++) n += t.charAt(e >> 8 * i + 4 & 15) + t.charAt(e >> 8 * i & 15);\n      return n;\n    }\n    function n(e, t) {\n      const i = (65535 & e) + (65535 & t);\n      return (e >> 16) + (t >> 16) + (i >> 16) << 16 | 65535 & i;\n    }\n    function r(e, t, i, r, o, s) {\n      return n(function (e, t) {\n        return e << t | e >>> 32 - t;\n      }(n(n(t, e), n(r, s)), o), i);\n    }\n    function o(e, t, i, n, o, s, a) {\n      return r(t & i | ~t & n, e, t, o, s, a);\n    }\n    function s(e, t, i, n, o, s, a) {\n      return r(t & n | i & ~n, e, t, o, s, a);\n    }\n    function a(e, t, i, n, o, s, a) {\n      return r(t ^ i ^ n, e, t, o, s, a);\n    }\n    function c(e, t, i, n, o, s, a) {\n      return r(i ^ (t | ~n), e, t, o, s, a);\n    }\n    const d = function (e) {\n      let t;\n      const i = 1 + (e.length + 8 >> 6),\n        n = new Array(16 * i);\n      for (t = 0; t < 16 * i; t++) n[t] = 0;\n      for (t = 0; t < e.length; t++) n[t >> 2] |= e.charCodeAt(t) << t % 4 * 8;\n      return n[t >> 2] |= 128 << t % 4 * 8, n[16 * i - 2] = 8 * e.length, n;\n    }(e);\n    let l,\n      h,\n      u,\n      p,\n      _,\n      E = 1732584193,\n      m = -271733879,\n      f = -1732584194,\n      T = 271733878;\n    for (l = 0; l < d.length; l += 16) h = E, u = m, p = f, _ = T, E = o(E, m, f, T, d[l + 0], 7, -680876936), T = o(T, E, m, f, d[l + 1], 12, -389564586), f = o(f, T, E, m, d[l + 2], 17, 606105819), m = o(m, f, T, E, d[l + 3], 22, -1044525330), E = o(E, m, f, T, d[l + 4], 7, -176418897), T = o(T, E, m, f, d[l + 5], 12, 1200080426), f = o(f, T, E, m, d[l + 6], 17, -1473231341), m = o(m, f, T, E, d[l + 7], 22, -45705983), E = o(E, m, f, T, d[l + 8], 7, 1770035416), T = o(T, E, m, f, d[l + 9], 12, -1958414417), f = o(f, T, E, m, d[l + 10], 17, -42063), m = o(m, f, T, E, d[l + 11], 22, -1990404162), E = o(E, m, f, T, d[l + 12], 7, 1804603682), T = o(T, E, m, f, d[l + 13], 12, -40341101), f = o(f, T, E, m, d[l + 14], 17, -1502002290), m = o(m, f, T, E, d[l + 15], 22, 1236535329), E = s(E, m, f, T, d[l + 1], 5, -165796510), T = s(T, E, m, f, d[l + 6], 9, -1069501632), f = s(f, T, E, m, d[l + 11], 14, 643717713), m = s(m, f, T, E, d[l + 0], 20, -373897302), E = s(E, m, f, T, d[l + 5], 5, -701558691), T = s(T, E, m, f, d[l + 10], 9, 38016083), f = s(f, T, E, m, d[l + 15], 14, -660478335), m = s(m, f, T, E, d[l + 4], 20, -405537848), E = s(E, m, f, T, d[l + 9], 5, 568446438), T = s(T, E, m, f, d[l + 14], 9, -1019803690), f = s(f, T, E, m, d[l + 3], 14, -187363961), m = s(m, f, T, E, d[l + 8], 20, 1163531501), E = s(E, m, f, T, d[l + 13], 5, -1444681467), T = s(T, E, m, f, d[l + 2], 9, -51403784), f = s(f, T, E, m, d[l + 7], 14, 1735328473), m = s(m, f, T, E, d[l + 12], 20, -1926607734), E = a(E, m, f, T, d[l + 5], 4, -378558), T = a(T, E, m, f, d[l + 8], 11, -2022574463), f = a(f, T, E, m, d[l + 11], 16, 1839030562), m = a(m, f, T, E, d[l + 14], 23, -35309556), E = a(E, m, f, T, d[l + 1], 4, -1530992060), T = a(T, E, m, f, d[l + 4], 11, 1272893353), f = a(f, T, E, m, d[l + 7], 16, -155497632), m = a(m, f, T, E, d[l + 10], 23, -1094730640), E = a(E, m, f, T, d[l + 13], 4, 681279174), T = a(T, E, m, f, d[l + 0], 11, -358537222), f = a(f, T, E, m, d[l + 3], 16, -722521979), m = a(m, f, T, E, d[l + 6], 23, 76029189), E = a(E, m, f, T, d[l + 9], 4, -640364487), T = a(T, E, m, f, d[l + 12], 11, -421815835), f = a(f, T, E, m, d[l + 15], 16, 530742520), m = a(m, f, T, E, d[l + 2], 23, -995338651), E = c(E, m, f, T, d[l + 0], 6, -198630844), T = c(T, E, m, f, d[l + 7], 10, 1126891415), f = c(f, T, E, m, d[l + 14], 15, -1416354905), m = c(m, f, T, E, d[l + 5], 21, -57434055), E = c(E, m, f, T, d[l + 12], 6, 1700485571), T = c(T, E, m, f, d[l + 3], 10, -1894986606), f = c(f, T, E, m, d[l + 10], 15, -1051523), m = c(m, f, T, E, d[l + 1], 21, -2054922799), E = c(E, m, f, T, d[l + 8], 6, 1873313359), T = c(T, E, m, f, d[l + 15], 10, -30611744), f = c(f, T, E, m, d[l + 6], 15, -1560198380), m = c(m, f, T, E, d[l + 13], 21, 1309151649), E = c(E, m, f, T, d[l + 4], 6, -145523070), T = c(T, E, m, f, d[l + 11], 10, -1120210379), f = c(f, T, E, m, d[l + 2], 15, 718787259), m = c(m, f, T, E, d[l + 9], 21, -343485551), E = n(E, h), m = n(m, u), f = n(f, p), T = n(T, _);\n    return i(E) + i(m) + i(f) + i(T);\n  }\n  let ly = 1,\n    hy = console,\n    uy = class {\n      static setLogger(e) {\n        hy = e;\n      }\n      constructor(e) {\n        eI(this, \"lockingPromise\", Gu.resolve()), eI(this, \"locks\", 0), eI(this, \"name\", \"\"), eI(this, \"lockId\", void 0), this.lockId = ly++, e && (this.name = e), hy.debug(\"[lock-\".concat(this.name, \"-\").concat(this.lockId, \"] is created.\"));\n      }\n      get isLocked() {\n        return this.locks > 0;\n      }\n      lock(e) {\n        let t;\n        this.locks += 1, hy.debug(\"[lock-\".concat(this.name, \"-\").concat(this.lockId, \"] is locked, current queue \").concat(this.locks, \". \").concat(\"string\" == typeof e ? e : \"\"));\n        const i = new Gu(i => {\n            t = () => {\n              this.locks -= 1, hy.debug(\"[lock-\".concat(this.name, \"-\").concat(this.lockId, \"] is not locked, current queue \").concat(this.locks, \". \").concat(\"string\" == typeof e ? e : \"\")), i();\n            };\n          }),\n          n = this.lockingPromise.then(() => t);\n        return this.lockingPromise = this.lockingPromise.then(() => i), n;\n      }\n    };\n  function py(e, t) {\n    return function (i, n, r) {\n      const o = r.value;\n      if (\"function\" != typeof o) throw new Error(\"Cannot use mutex on object property.\");\n      return r.value = async function () {\n        const i = this[t];\n        if (!i) throw new Error(\"mutex property key \".concat(t, \" doesn't exist on \").concat(e));\n        const r = await i.lock(\"From \".concat(e, \".\").concat(n));\n        try {\n          for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];\n          return await o.apply(this, a);\n        } finally {\n          r();\n        }\n      }, r;\n    };\n  }\n  const _y = {\n    timeout: 500,\n    timeoutFactor: 1.5,\n    maxRetryCount: 1 / 0,\n    maxRetryTimeout: 1e4\n  };\n  function Ey(e, t) {\n    const i = Math.floor(t.timeout * Math.pow(t.timeoutFactor, e));\n    return Math.min(t.maxRetryTimeout, i);\n  }\n  function my(e, t, i, n) {\n    const r = Object.assign({}, _y, n);\n    let o = r.timeout;\n    const s = async () => {\n      await function (e) {\n        return new Gu(t => {\n          window.setTimeout(t, e);\n        });\n      }(o), o *= r.timeoutFactor, o = Math.min(r.maxRetryTimeout, o);\n    };\n    let a = !1;\n    const c = new Gu(async (n, o) => {\n      t = t || (() => !1), i = i || (() => !0);\n      for (let c = 0; c < r.maxRetryCount; c += 1) {\n        if (a) return o(new iI(tI.OPERATION_ABORTED));\n        try {\n          const i = await e();\n          if (!t(i, c)) return n(i);\n          if (c + 1 === r.maxRetryCount) return n(i);\n          await s();\n        } catch (e) {\n          if (!i(e, c)) return o(e);\n          if (c + 1 === r.maxRetryCount) return o(e);\n          await s();\n        }\n      }\n    });\n    return c.cancel = () => a = !0, c;\n  }\n  class fy {\n    constructor(e) {\n      eI(this, \"input\", []), eI(this, \"size\", void 0), this.size = e;\n    }\n    add(e) {\n      this.input.push(e), this.input.length > this.size && this.input.splice(0, 1);\n    }\n    mean() {\n      var e;\n      return 0 === this.input.length ? 0 : Jn(e = this.input).call(e, (e, t) => e + t) / this.input.length;\n    }\n  }\n  let Ty,\n    Sy = 0,\n    gy = 0;\n  function Ry(e, t, i, n) {\n    return new Gu((r, o) => {\n      t.responseType = t.responseType || \"json\", t.data && !i ? (t.data = JSON.stringify(t.data), Sy += XI(t.data)) : i && (t.data.size ? Sy += t.data.size : t.data instanceof FormData ? Sy += QI(t.data) : Sy += XI(JSON.stringify(t.data))), t.headers = t.headers || {}, t.headers[\"Content-Type\"] = t.headers[\"Content-Type\"] || \"application/json\", t.method = \"POST\", t.url = e, pv.request(t).then(e => {\n        \"string\" == typeof e.data ? gy += XI(e.data) : e.data instanceof ArrayBuffer || e.data instanceof Uint8Array ? gy += e.data.byteLength : gy += XI(JSON.stringify(e.data)), n && r({\n          data: e.data,\n          headers: e.headers\n        }), r(e.data);\n      }).catch(e => {\n        pv.isCancel(e) ? o(new iI(tI.OPERATION_ABORTED, \"cancel token canceled\")) : \"ECONNABORTED\" === e.code ? o(new iI(tI.NETWORK_TIMEOUT, e.message)) : e.response ? o(new iI(tI.NETWORK_RESPONSE_ERROR, e.response.status)) : o(new iI(tI.NETWORK_ERROR, e.message));\n      });\n    });\n  }\n  async function Cy(e, t) {\n    const i = new Blob([t.data], {\n      type: \"buffer\"\n    });\n    return await Ry(e, $v($v({}, t), {}, {\n      data: i,\n      headers: {\n        \"Content-Type\": \"application/octet-stream\"\n      }\n    }), !0);\n  }\n  const vy = () => void 0 !== window.isSecureContext;\n  const Iy = function (e) {\n      if (e.match(/[0-9]+\\.[0-9]+\\.[0-9]+$/)) return e;\n      const t = e.match(/([0-9]+\\.[0-9]+\\.[0-9]+)\\-alpha\\.([0-9]+)/);\n      if (t && t[1] && t[2]) {\n        const e = t[1],\n          i = t[2];\n        return \"\".concat(e, \".\").concat(i);\n      }\n      const i = e.match(/([0-9]+\\.[0-9]+\\.[0-9]+)\\-special\\.([0-9]+)/);\n      if (i && i[1] && i[2]) {\n        const e = i[1],\n          t = i[2];\n        return \"\".concat(e, \".\").concat(100 * (Number(t) + 1));\n      }\n      return \"4.0.0.999\";\n    }(\"4.21.0\"),\n    yy = function () {\n      try {\n        return !0 === JSON.parse(\"true\");\n      } catch (e) {\n        return !0;\n      }\n    }();\n  let Ay = function (e) {\n    return e.Default = \"default\", e.Auto = \"auto\", e.Relay = \"relay\", e.SdRtn = \"sd-rtn\", e;\n  }({});\n  const by = {\n      MIN_FRAME_RATE: 1,\n      MAX_FRAME_RATE: 30,\n      MAX_THRESHOLD_FRAMERATE: 30,\n      BITRATE_MIN_THRESHOLD: 100,\n      BITRATE_MAX_THRESHOLD: 100,\n      MAX_SCALE: 5,\n      BWE_SCALE_UP_THRESHOLD: .6,\n      BWE_SCALE_DOWN_THRESHOLD: .6,\n      PERF_SCALE_UP_THRESHOLD: .7,\n      PERF_SCALE_DOWN_THRESHOLD: .6,\n      MOTION_RESOLUTION_FACTOR: .8,\n      MOTION_BITRATE_FACTOR: .6,\n      DETAIL_FRAMERATE_FACTOR: .8,\n      DETAIL_BITRATE_FACTOR: .6,\n      BALANCE_RESOLUTION_FACTOR: .9,\n      BALANCE_FRAMERATE_FACTOR: .9,\n      BALANCE_BITRATE_FACTOR: .6,\n      OVERUSE_TIMES_THRESHOLD: 10,\n      UNDERUSE_TIMES_THRESHOLD: 40\n    },\n    wy = \"v4.21.0-0-g16fdae2c-dirty(6/3/2024, 2:55:18 PM)\",\n    Oy = {\n      PROCESS_ID: \"\",\n      ENCRYPT_AES: !0,\n      AREAS: [\"CHINA\", \"GLOBAL\"],\n      WEBCS_DOMAIN: [\"webrtc2-ap-web-1.agora.io\", \"webrtc2-2.ap.sd-rtn.com\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-ap-web-3.agora.io\", \"webrtc2-4.ap.sd-rtn.com\"],\n      PROXY_CS: [\"ap-proxy-1.agora.io\", \"ap-proxy-2.agora.io\"],\n      CDS_AP: [\"cds-ap-web-1.agora.io\", \"cds-web-2.ap.sd-rtn.com\", \"cds-ap-web-3.agora.io\", \"cds-web-4.ap.sd-rtn.com\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-1.agora.io\", \"sua-web-2.ap.sd-rtn.com\", \"sua-ap-web-3.agora.io\", \"sua-web-4.ap.sd-rtn.com\"],\n      UAP_AP: [\"uap-ap-web-1.agora.io\", \"uap-web-2.ap.sd-rtn.com\", \"uap-ap-web-3.agora.io\", \"uap-web-4.ap.sd-rtn.com\"],\n      LOG_UPLOAD_SERVER: \"logservice.agora.io\",\n      EVENT_REPORT_DOMAIN: \"statscollector-1.agora.io\",\n      EVENT_REPORT_BACKUP_DOMAIN: \"web-2.statscollector.sd-rtn.com\",\n      ENABLE_EVENT_REPORT: !0,\n      GATEWAY_ADDRESS: [],\n      GATEWAY_WSS_ADDRESS: \"\",\n      LIVE_STREAMING_ADDRESS: \"\",\n      HTTP_CONNECT_TIMEOUT: 5e3,\n      SIGNAL_REQUEST_TIMEOUT: 1e4,\n      REPORT_STATS: !0,\n      UPLOAD_LOG: !1,\n      NOT_REPORT_EVENT: [],\n      SUBSCRIBE_TWCC: !0,\n      PUBLISH_TWCC: !1,\n      PING_PONG_TIME_OUT: 10,\n      WEBSOCKET_TIMEOUT_MIN: 1e4,\n      EVENT_REPORT_SEND_INTERVAL: 3e3,\n      CONFIG_DISTRIBUTE_INTERVAL: 3e5,\n      ENABLE_CONFIG_DISTRIBUTE: !0,\n      CANDIDATE_TIMEOUT: 5e3,\n      SHOW_REPORT_INVOKER_LOG: !1,\n      JOIN_EXTEND: \"\",\n      PUB_EXTEND: \"\",\n      SUB_EXTEND: \"\",\n      FORCE_TURN: !1,\n      TURN_ENABLE_TCP: !0,\n      TURN_ENABLE_UDP: !0,\n      MAX_UPLOAD_CACHE: 50,\n      UPLOAD_CACHE_INTERVAL: 2e3,\n      AJAX_REQUEST_CONCURRENT: 3,\n      REPORT_APP_SCENARIO: void 0,\n      GATEWAY_DOMAINS: [\"edge.agora.io\", \"edge.sd-rtn.com\"],\n      CONNECT_GATEWAY_WITHOUT_DOMAIN: !1,\n      WORKER_DOMAIN: \"edge.agora.io\",\n      TURN_DOMAIN: \"edge.agora.io\",\n      EVENT_REPORT_RETRY: !0,\n      CHROME_FORCE_PLAN_B: !1,\n      AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400,\n      AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3,\n      AUDIO_VOLUME_INDICATION_INTERVAL: 2e3,\n      VOLUME_VOICE_WEIGHT: 10,\n      GET_VOLUME_OF_MUTED_AUDIO_TRACK: !1,\n      STATS_UPDATE_INTERVAL: 250,\n      NORMAL_EVENT_QUEUE_CAPACITY: 100,\n      CUSTOM_REPORT: !0,\n      CUSTOM_REPORT_LIMIT: 20,\n      PROXY_SERVER_TYPE2: \"webnginx-proxy.agora.io\",\n      PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.sd-rtn.com\", \"webrtc-cloud-proxy.agora.io\"],\n      CUSTOM_PUB_ANSWER_MODIFIER: null,\n      CUSTOM_SUB_ANSWER_MODIFIER: null,\n      CUSTOM_PUB_OFFER_MODIFIER: null,\n      CUSTOM_SUB_OFFER_MODIFIER: null,\n      DSCP_TYPE: \"high\",\n      REMOVE_NEW_CODECS: !0,\n      FRAGEMENT_LENGTH: 3,\n      WEBSOCKET_COMPRESS: !1,\n      SIMULCAST: !1,\n      PRELOAD_MEDIA_COUNT: 0,\n      USE_PUB_RTX: !0,\n      USE_SUB_RTX: !0,\n      USE_XR: !0,\n      ENABLE_LOSSBASED_BWE: !0,\n      ENABLE_AUT_CC: void 0,\n      ENABLE_CC_FALLBACK: void 0,\n      CHECK_VIDEO_VISIBLE_INTERVAL: 3e4,\n      CHECK_LOCAL_STATS_INTERVAL: 250,\n      PROFILE_SWITCH_INTERVAL: 2e3,\n      UNSUPPORTED_VIDEO_CODEC: [],\n      ENUMERATE_DEVICES_INTERVAL: !1,\n      ENUMERATE_DEVICES_INTERVAL_TIME: 1e4,\n      USE_NEW_TOKEN: !1,\n      CLOSE_AFB_FOR_LOCAL_AP: !0,\n      JOIN_MAX_CONCURRENCY: 6,\n      JOIN_WITH_FALLBACK_SIGNAL_PROXY: !0,\n      JOIN_WITH_FALLBACK_MEDIA_PROXY: !0,\n      JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: !1,\n      JOIN_GATEWAY_TRY_443PORT_DURATION: 2e3,\n      JOIN_GATEWAY_USE_443PORT_ONLY: !1,\n      JOIN_GATEWAY_USE_DUAL_DOMAIN: !0,\n      JOIN_GATEWAY_FALLBACK_PORT: 443,\n      USE_TURN_SERVER_OF_GATEWAY: !1,\n      H264_PROFILE_LEVEL_ID: \"\",\n      USE_NEW_LOG: !1,\n      LOG_VERSION: 3,\n      MEDIA_DEVICE_CONSTRAINTS: null,\n      ENCRYPT_PROXY_USERNAME_AND_PSW: !0,\n      SDP_LOGGING: !1,\n      CSP_DETECTED_HOSTNAME_LIST: [\"agora.io\", \"sd-rtn.com\"],\n      REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: !1,\n      LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: !1,\n      BITRATE_ADAPTER_TYPE: \"STANDARD_BITRATE\",\n      AI_DENOISER_PARAMETERS: {\n        excludedLinks: []\n      },\n      ADJUST_3A_FROM_PLUGINS: !0,\n      RAISE_H264_BASELINE_PRIORITY: !0,\n      FILTER_SEND_H264_BASELINE: !1,\n      ENABLE_PUBLISHED_USER_LIST: !0,\n      MAX_SUBSCRIPTION: 50,\n      X_GOOGLE_START_BITRATE: void 0,\n      NEW_REPORT_SERVER: !1,\n      NEW_REPORT_SERVER_DOMAINS: [\"data-reporting.agora.io\", \"data-reporting.agora.io\"],\n      VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5,\n      VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3,\n      VIDEO_INSPECT_QUALITY_RATIO: .9,\n      VIDEO_INSPECT_WORKER_MANAGER_HOST: \"edge.agora.io\",\n      VIDEO_INSPECT_WORKER_MANAGER_PORT: \"\",\n      VIDEO_INSPECT_WORKER_PORT: \"\",\n      SHOW_VIDEO_INSPECT_WORKER_MESSAGE: !1,\n      STATS_COLLECTOR_PORT: 443,\n      FORCE_TURN_TCP: !1,\n      SUBSCRIBE_AUDIO_FILTER_TOPN: void 0,\n      ENABLE_PUBLISH_AUDIO_FILTER: void 0,\n      DISABLE_FEC: void 0,\n      WEBAUDIO_INIT_OPTIONS: void 0,\n      FILTER_VIDEO_FEC: !0,\n      FILTER_AUDIO_FEC: !1,\n      CHROME_DUAL_STREAM_USE_ENCODING: !0,\n      DISABLE_DUAL_STREAM_USE_ENCODING: !1,\n      EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4,\n      ICE_RESTART: !0,\n      ICE_RESTART_INTERVAL: 1e4,\n      NEW_ICE_RESTART: !1,\n      ENABLE_USER_LICENSE_CHECK: !0,\n      SIGNAL_CHANNEL: 0,\n      TRANSMITTER_INITIAL_RTT: 30,\n      TRANSMITTER_INITIAL_RTO: 30,\n      TRANSMITTER_MAX_BATCH_ACK_COUNT: 2,\n      TRANSMITTER_MAX_RTO: 500,\n      DATACHANNEL_COMPRESS: !1,\n      FINGERPRINT: null,\n      DC_JOIN_WITH_FAILBACK: 5e3,\n      ENABLE_VIDEO_FRAME_CALLBACK: !0,\n      VIDEO_FREEZE_DURATION: 500,\n      SPATIALIZER_PARAMETERS: {},\n      UPLOAD_LOG_INTERVAL: 3e3,\n      UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3,\n      UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4,\n      UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3,\n      UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4,\n      UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200,\n      UPLOAD_LOG_LENGTH_EACH_TIME: 10,\n      APP_TYPE: 0,\n      DISABLE_WEBAUDIO: !1,\n      CHANNEL_MEDIA_RELAY_SERVERS: void 0,\n      KEEP_LAST_FRAME: !0,\n      FORWARD_P2P_CREATION: !0,\n      SYNC_GROUP: !0,\n      BLOCK_LOCAL_CLIENT: !1,\n      AP_AREA: !0,\n      SVC: [],\n      ENABLE_ENCODED_TRANSFORM: !1,\n      ENABLE_VIDEO_SEI: !1,\n      IMAGE_MODERATION_WORKER_HOST: \"edge.agora.io\",\n      IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5,\n      IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3,\n      SHOW_IMAGE_MODERATION_WORKER_MESSAGE: !1,\n      IMAGE_MODERATION_QUALITY_RATIO: .9,\n      IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3,\n      SHOW_GLOBAL_CLIENT_LIST: !1,\n      ENABLE_DATASTREAM_2: !1,\n      DATASTREAM_MAX_RETRANSMITS: 10,\n      ENABLE_USER_AUTO_REBALANCE_CHECK: !0,\n      ENABLE_INSTANT_VIDEO: !1,\n      ENABLE_NTP_REPORT: !1,\n      TCP_CANDIDATE_ONLY: !1,\n      EXTERNAL_SIGNAL_REQUEST_TIMEOUT: 3e3,\n      SHOW_P2P_LOG: !1,\n      MAX_P2P_TIMEOUT: 3e4,\n      P2P_TOKEN_INTERVAL: 1e3,\n      SHOW_DATASTREAM2_LOG: !1,\n      RESTRICTION_SET_PLAYBACK_DEVICE: !0,\n      USE_PURE_ENCRYPTION_MASTER_KEY: !1,\n      ACCOUNT_REGISTER_RETRY_TIMEOUT: 1,\n      ACCOUNT_REGISTER_RETRY_RATIO: 2,\n      ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4,\n      ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5,\n      AUDIO_CONTEXT: null,\n      WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3,\n      PLAYER_STATE_DEFER: 2e3,\n      SIGNAL_REQUEST_WATCH_INTERVAL: 1e3,\n      FILEPATH_LENMAX: 255,\n      DUALSTREAM_OPERATION_CHECK: !0,\n      MEDIA_ELEMENT_EXISTS_DEPTH: 3,\n      SHIM_CANDIDATE: !1,\n      LEAVE_MSG_TIMEOUT: 2e3,\n      STATS_FILTER: {\n        transportId: !0,\n        googTrackId: !0\n      },\n      FILTER_VIDEO_CODEC: [],\n      USE_NEW_NETWORK_CONFIG: !1,\n      AUTO_RESET_AUDIO_ROUTE: !1,\n      PLUGIN_INFO: [],\n      OVERUSE_DETECTOR_PARAMS: by,\n      ENABLE_AG_ADAPTATION: !0,\n      FORCE_AG_HIGH_FRAMERATE: !1,\n      FORCE_SUPPORT_AG_ADAPTATION: !1,\n      CUSTOM_ADAPTATION_DEFAULT_MODE: \"\",\n      ENCODER_CONFIG_LIMIT: {},\n      CAMERA_CAPTURE_CONFIG: void 0,\n      HIDE_NO_POSTER: !1,\n      AP_CACHE_NUM: 10,\n      AP_UPDATE_INTERVAL: 12e4,\n      AP_CACHE_LIFETIME: 12e4,\n      MAX_PRELOAD_ASYNC_LENGTH: 3,\n      ENABLE_PRELOAD: !0\n    };\n  function Ny(e, t, i) {\n    var n, r, o;\n    Dn(n = Object.keys(Oy)).call(n, e) && (!i && Dn(r = Object.keys(Py)).call(r, e) || (Oy[e] = t, \"ENABLE_VIDEO_SEI\" === e && !0 === t && (Oy.ENABLE_ENCODED_TRANSFORM = !0), \"USE_NEW_NETWORK_CONFIG\" === e && t && (o = !!t, Oy.USE_NEW_NETWORK_CONFIG = o, o && (Oy.WEBCS_DOMAIN = [\"webrtc2-2.ap.sd-rtn.com\"], Oy.WEBCS_DOMAIN_BACKUP_LIST = [\"webrtc2-4.ap.sd-rtn.com\"], Oy.CDS_AP = [\"cds-web-2.ap.sd-rtn.com\", \"cds-web-4.ap.sd-rtn.com\"], Oy.ACCOUNT_REGISTER = [\"sua-web-2.ap.sd-rtn.com\", \"sua-web-4.ap.sd-rtn.com\"], Oy.EVENT_REPORT_DOMAIN = \"web-2.statscollector.sd-rtn.com\", Oy.EVENT_REPORT_BACKUP_DOMAIN = \"statscollector-1.agora.io\", Oy.GATEWAY_DOMAINS = [\"edge.sd-rtn.com\"]))));\n  }\n  function Dy(e) {\n    return Oy[e];\n  }\n  const Py = {};\n  var Ly = function (e) {\n    return e.SET_SESSION_ID = \"SET_SESSION_ID\", e.SET_P2P_ID = \"SET_P2P_id\", e.SET_DC_ID = \"SET_DC_id\", e.SET_UID = \"SET_UID\", e.SET_INT_UID = \"SET_INT_UID\", e.SET_PUB_ID = \"SET_PUB_ID\", e.SET_CLOUD_PROXY_SERVER_MODE = \"SET_CLOUD_PROXY_SERVER_MODE\", e.KEY_METRIC_CLIENT_CREATED = \"KEY_METRIC_CLIENT_CREATED\", e.KEY_METRIC_JOIN_START = \"KEY_METRIC_JOIN_START\", e.AVOID_JOIN_START = \"AVOID_JOIN_START\", e.KEY_METRIC_JOIN_END = \"KEY_METRIC_JOIN_END\", e.KEY_METRIC_REQUEST_AP_START = \"KEY_METRIC_REQUEST_AP_START\", e.KEY_METRIC_REQUEST_AP_END = \"KEY_METRIC_REQUEST_AP_END\", e.KEY_METRIC_JOIN_GATEWAY_START = \"KEY_METRIC_JOIN_GATEWAY_START\", e.KEY_METRIC_JOIN_GATEWAY_END = \"KEY_METRIC_JOIN_GATEWAY_END\", e.KEY_METRIC_PEER_CONNECTION_START = \"KEY_METRIC_PEER_CONNECTION_START\", e.KEY_METRIC_PEER_CONNECTION_END = \"KEY_METRIC_PEER_CONNECTION_END\", e.KEY_METRIC_DESCRIPTION_START = \"KEY_METRIC_DESCRIPTION_START\", e.KEY_METRIC_ICE_CONNECTION_END = \"KEY_METRIC_ICE_CONNECTION_END\", e.KEY_METRIC_SIGNAL_CHANNEL_OPEN = \"KEY_METRIC_SIGNAL_CHANNEL_OPEN\", e.KEY_METRIC_PUBLISH = \"KEY_METRIC_PUBLISH\", e.KEY_METRIC_SUBSCRIBE = \"KEY_METRIC_SUBSCRIBE\", e.RECORD_JOIN_CHANNEL_SERVICE = \"RECORD_JOIN_CHANNEL_SERVICE\", e.RESET_JOIN_CHANNEL_SERVICE_RECORDS = \"RESET_JOIN_CHANNEL_SERVICE_RECORDS\", e.RESET_KEY_METRICS = \"RESET_KEY_METRICS\", e.SET_USE_DATACHANNEL = \"SET_USE_DATACHANNEL\", e.SET_USE_P2P = \"SET_USE_P2P\", e.SET_TRANSPORT_TYPE = \"SET_TRANSPORT_TYPE\", e;\n  }(Ly || {});\n  class ky {\n    constructor(e, t, i, n) {\n      eI(this, \"state\", void 0), this.state = {\n        codec: e,\n        audioCodec: t,\n        mode: i,\n        clientId: n,\n        sessionId: null,\n        p2pId: 0,\n        dcId: 0,\n        pubId: 0,\n        subId: 0,\n        avoidJoinStart: 0,\n        keyMetrics: {\n          publish: [],\n          subscribe: []\n        },\n        joinChannelServiceRecords: [],\n        cloudProxyServerMode: \"disabled\",\n        useDataChannel: !1,\n        useP2P: !1,\n        p2pTransport: Ay.Default\n      };\n    }\n    dispatch(e) {\n      this.state = function (e, t) {\n        switch (t.type) {\n          case Ly.SET_SESSION_ID:\n            return $v($v({}, e), {}, {\n              sessionId: t.sessionId\n            });\n          case Ly.SET_P2P_ID:\n            return $v($v({}, e), {}, {\n              p2pId: t.p2pId\n            });\n          case Ly.SET_UID:\n            return $v($v({}, e), {}, {\n              uid: t.uid\n            });\n          case Ly.SET_INT_UID:\n            return $v($v({}, e), {}, {\n              intUid: t.intUid\n            });\n          case Ly.SET_PUB_ID:\n            return $v($v({}, e), {}, {\n              pubId: t.pubId\n            });\n          case Ly.KEY_METRIC_CLIENT_CREATED:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                clientCreated: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_JOIN_START:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                joinStart: t.metric\n              })\n            });\n          case Ly.AVOID_JOIN_START:\n            return $v($v({}, e), {}, {\n              avoidJoinStart: t.avoidJoinStart\n            });\n          case Ly.KEY_METRIC_JOIN_END:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                joinEnd: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_REQUEST_AP_START:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                requestAPStart: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_REQUEST_AP_END:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                requestAPEnd: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_JOIN_GATEWAY_START:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                joinGatewayStart: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_JOIN_GATEWAY_END:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                joinGatewayEnd: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_PEER_CONNECTION_START:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                peerConnectionStart: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_PEER_CONNECTION_END:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                peerConnectionEnd: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_DESCRIPTION_START:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                descriptionStart: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_SIGNAL_CHANNEL_OPEN:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                signalChannelOpen: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_ICE_CONNECTION_END:\n            return $v($v({}, e), {}, {\n              keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                iceConnectionEnd: t.metric\n              })\n            });\n          case Ly.KEY_METRIC_PUBLISH:\n            {\n              const i = e.keyMetrics.publish,\n                n = i.findIndex(e => e.trackId === t.metric.trackId);\n              return -1 !== n ? (i[n] = $v($v({}, i[n]), t.metric), $v($v({}, e), {}, {\n                keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                  publish: [...i]\n                })\n              })) : $v($v({}, e), {}, {\n                keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                  publish: [...e.keyMetrics.publish, t.metric]\n                })\n              });\n            }\n          case Ly.KEY_METRIC_SUBSCRIBE:\n            {\n              const i = e.keyMetrics.subscribe,\n                n = i.findIndex(e => e.userId === t.metric.userId && e.type === t.metric.type);\n              return -1 !== n ? (i[n] = $v($v({}, i[n]), t.metric), $v($v({}, e), {}, {\n                keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                  subscribe: [...i]\n                })\n              })) : $v($v({}, e), {}, {\n                keyMetrics: $v($v({}, e.keyMetrics), {}, {\n                  subscribe: [...e.keyMetrics.subscribe, t.metric]\n                })\n              });\n            }\n          case Ly.SET_CLOUD_PROXY_SERVER_MODE:\n            return e.cloudProxyServerMode = t.mode, e;\n          case Ly.RECORD_JOIN_CHANNEL_SERVICE:\n            return \"number\" != typeof t.index ? e.joinChannelServiceRecords = [...e.joinChannelServiceRecords, t.record] : (e.joinChannelServiceRecords[t.index] = $v($v({}, e.joinChannelServiceRecords[t.index]), t.record), e.joinChannelServiceRecords = [...e.joinChannelServiceRecords]), e;\n          case Ly.RESET_JOIN_CHANNEL_SERVICE_RECORDS:\n            return e.joinChannelServiceRecords = [], e;\n          case Ly.RESET_KEY_METRICS:\n            return e.keyMetrics = {\n              publish: [],\n              subscribe: []\n            }, e;\n          case Ly.SET_USE_DATACHANNEL:\n            return $v($v({}, e), {}, {\n              useDataChannel: t.val\n            });\n          case Ly.SET_USE_P2P:\n            return $v($v({}, e), {}, {\n              useP2P: t.val\n            });\n          case Ly.SET_TRANSPORT_TYPE:\n            return $v($v({}, e), {}, {\n              p2pTransport: t.val\n            });\n          default:\n            return e;\n        }\n      }(this.state, e);\n    }\n    set sessionId(e) {\n      this.dispatch({\n        type: Ly.SET_SESSION_ID,\n        sessionId: e\n      });\n    }\n    get sessionId() {\n      return this.state.sessionId;\n    }\n    set codec(e) {\n      this.state.codec = e;\n    }\n    get codec() {\n      return this.state.codec;\n    }\n    get mode() {\n      return this.state.mode;\n    }\n    get audioCodec() {\n      return this.state.audioCodec;\n    }\n    get clientId() {\n      return this.state.clientId;\n    }\n    set p2pId(e) {\n      this.dispatch({\n        type: Ly.SET_P2P_ID,\n        p2pId: e\n      });\n    }\n    get p2pId() {\n      return this.state.p2pId;\n    }\n    set dcId(e) {\n      this.dispatch({\n        type: Ly.SET_DC_ID,\n        dcId: e\n      });\n    }\n    get dcId() {\n      return this.state.dcId;\n    }\n    set uid(e) {\n      this.dispatch({\n        type: Ly.SET_UID,\n        uid: e\n      });\n    }\n    get uid() {\n      return this.state.uid;\n    }\n    set intUid(e) {\n      this.dispatch({\n        type: Ly.SET_INT_UID,\n        intUid: e\n      });\n    }\n    get intUid() {\n      return this.state.intUid;\n    }\n    set pubId(e) {\n      this.dispatch({\n        type: Ly.SET_PUB_ID,\n        pubId: e\n      });\n    }\n    get pubId() {\n      return this.state.pubId;\n    }\n    set cloudProxyServerMode(e) {\n      this.dispatch({\n        type: Ly.SET_CLOUD_PROXY_SERVER_MODE,\n        mode: e\n      });\n    }\n    get cloudProxyServerMode() {\n      return this.state.cloudProxyServerMode;\n    }\n    set useDataChannel(e) {\n      this.dispatch({\n        type: Ly.SET_USE_DATACHANNEL,\n        val: e\n      });\n    }\n    get useDataChannel() {\n      return this.state.useDataChannel;\n    }\n    set useP2P(e) {\n      this.dispatch({\n        type: Ly.SET_USE_P2P,\n        val: e\n      });\n    }\n    get useP2P() {\n      return this.state.useP2P;\n    }\n    set p2pTransport(e) {\n      this.dispatch({\n        type: Ly.SET_TRANSPORT_TYPE,\n        val: e\n      });\n    }\n    get p2pTransport() {\n      return this.state.p2pTransport;\n    }\n    clientCreated() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_CLIENT_CREATED,\n        metric: Date.now()\n      });\n    }\n    joinStart() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_JOIN_START,\n        metric: Date.now()\n      });\n    }\n    joinEnd() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_JOIN_END,\n        metric: Date.now()\n      });\n    }\n    requestAPStart() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_REQUEST_AP_START,\n        metric: Date.now()\n      });\n    }\n    requestAPEnd() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_REQUEST_AP_END,\n        metric: Date.now()\n      });\n    }\n    joinGatewayStart() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_JOIN_GATEWAY_START,\n        metric: Date.now()\n      });\n    }\n    joinGatewayEnd() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_JOIN_GATEWAY_END,\n        metric: Date.now()\n      });\n    }\n    peerConnectionStart() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_PEER_CONNECTION_START,\n        metric: Date.now()\n      });\n    }\n    peerConnectionEnd() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_PEER_CONNECTION_END,\n        metric: Date.now()\n      });\n    }\n    descriptionStart() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_DESCRIPTION_START,\n        metric: Date.now()\n      });\n    }\n    signalChannelOpen() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_SIGNAL_CHANNEL_OPEN,\n        metric: Date.now()\n      });\n    }\n    iceConnectionEnd() {\n      this.dispatch({\n        type: Ly.KEY_METRIC_ICE_CONNECTION_END,\n        metric: Date.now()\n      });\n    }\n    publish(e, t, i, n) {\n      this.dispatch({\n        type: Ly.KEY_METRIC_PUBLISH,\n        metric: $v($v({\n          trackId: e,\n          type: t\n        }, i && {\n          publishStart: i\n        }), n && {\n          publishEnd: n\n        })\n      });\n    }\n    subscribe(e, t, i, n, r, o, s) {\n      this.dispatch({\n        type: Ly.KEY_METRIC_SUBSCRIBE,\n        metric: $v($v($v($v($v({\n          userId: e,\n          type: t\n        }, i && {\n          subscribeStart: i\n        }), n && {\n          subscribeEnd: n\n        }), r && {\n          firstFrame: r\n        }), o && {\n          streamAdded: o\n        }), s && {\n          firstDecoded: s\n        })\n      });\n    }\n    massSubscribe(e, t, i, n) {\n      e.forEach(e => {\n        this.dispatch({\n          type: Ly.KEY_METRIC_SUBSCRIBE,\n          metric: $v($v($v({\n            userId: e.userId,\n            type: e.type\n          }, t && {\n            subscribeStart: t\n          }), i && {\n            subscribeEnd: i\n          }), n && {\n            firstFrame: n\n          })\n        });\n      });\n    }\n    get keyMetrics() {\n      return this.state.keyMetrics;\n    }\n    recordJoinChannelService(e, t) {\n      \"gateway\" === e.service && Array.isArray(e.urls) && (e.urls = e.urls.map(e => e.replace(/(\\d+)-\\d+-\\d+-(\\d+)/, \"$1-*-*-$2\")));\n      try {\n        return \"number\" != typeof t ? (this.dispatch({\n          type: Ly.RECORD_JOIN_CHANNEL_SERVICE,\n          record: $v($v({}, e), {}, {\n            sessionId: this.sessionId,\n            cloudProxyMode: this.cloudProxyServerMode,\n            uid: this.uid\n          })\n        }), this.state.joinChannelServiceRecords.length - 1) : (t < 0 || t >= this.state.joinChannelServiceRecords.length || this.dispatch({\n          type: Ly.RECORD_JOIN_CHANNEL_SERVICE,\n          record: e,\n          index: t\n        }), t);\n      } catch (e) {\n        return 0;\n      }\n    }\n    resetJoinChannelServiceRecords() {\n      this.dispatch({\n        type: Ly.RESET_JOIN_CHANNEL_SERVICE_RECORDS\n      });\n    }\n    resetKeyMetrics() {\n      this.dispatch({\n        type: Ly.RESET_KEY_METRICS\n      });\n    }\n    get joinChannelServiceRecords() {\n      try {\n        return this.state.joinChannelServiceRecords;\n      } catch (e) {\n        return [];\n      }\n    }\n    get avoidJoinStart() {\n      return this.state.avoidJoinStart;\n    }\n    set avoidJoinStart(e) {\n      this.dispatch({\n        type: Ly.AVOID_JOIN_START,\n        avoidJoinStart: e\n      });\n    }\n  }\n  let My = function (e) {\n    return e.h264 = \"h264\", e.h265 = \"h265\", e.vp8 = \"vp8\", e.vp9 = \"vp9\", e.av1 = \"av1\", e;\n  }({});\n  !function (e) {\n    e.opus = \"opus\", e.pcma = \"pcma\", e.pcmu = \"pcmu\", e.g722 = \"g722\";\n  }({});\n  const Uy = 128,\n    xy = 96,\n    Vy = 1e3,\n    Fy = 10;\n  let By = 0;\n  function jy(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function Gy(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? jy(Object(i), !0).forEach(function (t) {\n        Wy(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : jy(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function Wy(e, t, i) {\n    return (t = function (e) {\n      var t = function (e, t) {\n        if (\"object\" != typeof e || null === e) return e;\n        var i = e[Symbol.toPrimitive];\n        if (void 0 !== i) {\n          var n = i.call(e, \"string\");\n          if (\"object\" != typeof n) return n;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return String(e);\n      }(e);\n      return \"symbol\" == typeof t ? t : String(t);\n    }(t)) in e ? Object.defineProperty(e, t, {\n      value: i,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = i, e;\n  }\n  const Hy = new class extends SI {\n    constructor() {\n      super(...arguments), Wy(this, \"currentUploadLogID\", 0);\n    }\n    reportLogUploadError(e) {\n      const t = e.errorRange;\n      t[t.length - 1] && t[t.length - 1] > this.currentUploadLogID && (this.currentUploadLogID = t[t.length - 1], this.emit(\"REPORT_LOG_UPLOAD\", e));\n    }\n  }();\n  class Ky {\n    constructor(e) {\n      Wy(this, \"logger\", void 0), Wy(this, \"prefixLists\", []), this.logger = e;\n    }\n    debug() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      this.logger.debug(...this.prefixLists, ...t);\n    }\n    info() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      this.logger.info(...this.prefixLists, ...t);\n    }\n    warning() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      this.logger.warning(...this.prefixLists, ...t);\n    }\n    error() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      this.logger.error(...this.prefixLists, ...t);\n    }\n    prefix(e) {\n      return this.prefixLists.push(e), this;\n    }\n    popPrefix() {\n      return this.prefixLists.pop(), this;\n    }\n  }\n  function Yy() {\n    const e = new Date();\n    return e.toTimeString().split(\" \")[0] + \":\" + e.getMilliseconds();\n  }\n  function qy() {\n    const e = new Date(),\n      t = /((\\d+:){2}\\d+)/.exec(new Date().toUTCString());\n    return t ? (null == t ? void 0 : t[0]) + \":\" + e.getUTCMilliseconds() : e.toTimeString().split(\" \")[0] + \":\" + e.getMilliseconds();\n  }\n  const zy = {\n      DEBUG: 0,\n      INFO: 1,\n      WARNING: 2,\n      ERROR: 3,\n      NONE: 4\n    },\n    Jy = Date.now(),\n    Xy = e => {\n      for (const t in zy) if (Object.prototype.hasOwnProperty.call(zy, t) && zy[t] === e) return t;\n      return \"DEFAULT\";\n    };\n  const Qy = new class {\n    constructor() {\n      Wy(this, \"proxyServerURL\", void 0), Wy(this, \"logLevel\", zy.DEBUG), Wy(this, \"uploadState\", \"collecting\"), Wy(this, \"uploadLogWaitingList\", []), Wy(this, \"uploadLogUploadingList\", []), Wy(this, \"uploadErrorCount\", 0), Wy(this, \"currentLogID\", 0), Wy(this, \"url\", void 0), Wy(this, \"extLog\", (e, t) => {\n        this.appendLogToWaitingList(e, ...t);\n      });\n    }\n    debug() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      const n = [zy.DEBUG].concat(t);\n      this.log.apply(this, n);\n    }\n    info() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      const n = [zy.INFO].concat(t);\n      this.log.apply(this, n);\n    }\n    warning() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      const n = [zy.WARNING].concat(t);\n      this.log.apply(this, n);\n    }\n    warn() {\n      this.warning(...arguments);\n    }\n    error() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      const n = [zy.ERROR].concat(t);\n      this.log.apply(this, n);\n    }\n    upload() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      const n = [zy.DEBUG].concat(t);\n      this.uploadLog.apply(this, n);\n    }\n    setLogLevel(e) {\n      e = Math.min(Math.max(0, e), 4), this.logLevel = e;\n    }\n    enableLogUpload() {\n      Ny(\"UPLOAD_LOG\", !0);\n    }\n    disableLogUpload() {\n      Ny(\"UPLOAD_LOG\", !1), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];\n    }\n    setProxyServer(e) {\n      this.proxyServerURL = e;\n    }\n    prefix(e) {\n      return new Ky(this).prefix(e);\n    }\n    log() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      if (Date.now() - Jy < 100) return void setTimeout(() => {\n        this.log(...t);\n      }, Date.now() - Jy);\n      const n = Math.max(0, Math.min(4, t[0]));\n      if (t[0] = Yy() + \" Agora-SDK [\".concat(Xy(n), \"]:\"), this.appendLogToWaitingList(n, ...t), n < this.logLevel) return;\n      const r = Yy() + \" %cAgora-SDK [\".concat(Xy(n), \"]:\");\n      let o = [];\n      if (!Dy(\"USE_NEW_LOG\")) switch (n) {\n        case zy.DEBUG:\n          o = [r, \"color: #64B5F6;\"].concat(t.slice(1)), console.log.apply(console, o);\n          break;\n        case zy.INFO:\n          o = [r, \"color: #1E88E5; font-weight: bold;\"].concat(t.slice(1)), console.log.apply(console, o);\n          break;\n        case zy.WARNING:\n          o = [r, \"color: #FB8C00; font-weight: bold;\"].concat(t.slice(1)), console.warn.apply(console, o);\n          break;\n        case zy.ERROR:\n          o = [r, \"color: #B00020; font-weight: bold;\"].concat(t.slice(1)), console.error.apply(console, o);\n      }\n    }\n    uploadLog() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      if (Date.now() - Jy < 100) return void setTimeout(() => {\n        this.uploadLog(...t);\n      }, Date.now() - Jy);\n      const n = Math.max(0, Math.min(4, t[0]));\n      t[0] = Yy() + \" Agora-SDK [\".concat(Xy(n), \"]:\"), this.appendLogToWaitingList(n, ...t);\n    }\n    appendLogToWaitingList(e) {\n      if (!Dy(\"UPLOAD_LOG\")) return;\n      for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];\n      Array.isArray(i[0]) ? i[0][0] = qy() + \" Agora-SDK [\".concat(Xy(e), \"]:\") : i[0] = qy() + \" Agora-SDK [\".concat(Xy(e), \"]:\");\n      let r = \"\";\n      i.forEach(e => {\n        \"object\" == typeof e && (e = JSON.stringify(e)), r += \"\".concat(e, \" \");\n      }), this.uploadLogWaitingList.push({\n        payload_str: r,\n        log_level: e,\n        log_item_id: this.currentLogID++\n      }), \"uploading\" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();\n    }\n    startUpload() {\n      this.uploadState = \"uploading\", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();\n    }\n    async uploadLogs() {\n      const e = this.uploadLogUploadingList,\n        t = {\n          sdk_version: Iy,\n          process_id: Dy(\"PROCESS_ID\"),\n          payload: JSON.stringify(e)\n        };\n      return my(async () => {\n        const e = await pv.post(this.url || (this.proxyServerURL ? \"https://\".concat(this.proxyServerURL, \"/ls/?h=\").concat(Dy(\"LOG_UPLOAD_SERVER\"), \"&p=443&d=upload/v1\") : \"https://\".concat(Dy(\"LOG_UPLOAD_SERVER\"), \"/upload/v1\")), t, {\n          responseType: \"text\"\n        });\n        if (\"OK\" !== e.data) {\n          const t = new Error(\"unexpected upload log response\");\n          throw t.response = e, t;\n        }\n      }, () => (this.uploadLogUploadingList = [], !1), t => {\n        const i = {\n          status: -1,\n          message: t.message,\n          errorRange: e.map(e => e.log_item_id)\n        };\n        return t.response ? (i.status = t.response.status, i.data = t.response.data, i.headers = t.response.headers) : t.request && (i.status = t.request.status), Hy.reportLogUploadError(i), !0;\n      }, {\n        timeout: Dy(\"UPLOAD_LOG_REQUEST_RETRY_INTERVAL\"),\n        maxRetryTimeout: Dy(\"UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL\")\n      });\n    }\n    uploadLogInterval() {\n      0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, Dy(\"UPLOAD_LOG_LENGTH_EACH_TIME\"))), this.uploadLogs().then(() => {\n        this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), Dy(\"UPLOAD_LOG_INTERVAL\"));\n      }).catch(e => {\n        this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), Dy(\"UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1\")) : window.setTimeout(() => this.uploadLogInterval(), Dy(\"UPLOAD_LOG_RETRY_INTERVAL_V1\"));\n      }));\n    }\n  }();\n  var Zy;\n  function $y(e) {\n    return aI(e.reportId, \"params.reportId\", 0, 100, !1), aI(e.category, \"params.category\", 0, 100, !1), aI(e.event, \"params.event\", 0, 100, !1), aI(e.label, \"params.label\", 0, 100, !1), oI(e.value, \"params.value\", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, !1), !0;\n  }\n  (Zy = {}).FREE = \"free\", Zy.UPLOADING = \"uploading\", function (e) {\n    e[e.MISC = 0] = \"MISC\", e[e.INTERNAL_EVENT = 1] = \"INTERNAL_EVENT\", e[e.PUBLIC_EVENT = 2] = \"PUBLIC_EVENT\", e[e.WEB_EVENT = 3] = \"WEB_EVENT\", e[e.INTERNAL_API = 4] = \"INTERNAL_API\", e[e.WEB_API = 5] = \"WEB_API\", e[e.PUBLIC_API = 6] = \"PUBLIC_API\";\n  }({});\n  const eA = {\n    sid: \"\",\n    lts: 0,\n    success: null,\n    cname: null,\n    uid: null,\n    peer: null,\n    cid: null,\n    elapse: null,\n    extend: null,\n    vid: 0\n  };\n  let tA = function (e) {\n      return e.PUBLISH = \"publish\", e.SUBSCRIBE = \"subscribe\", e.WS_COMPRESSOR_INIT = \"ws_compressor_init\", e.SESSION_INIT = \"session_init\", e.JOIN_CHOOSE_SERVER = \"join_choose_server\", e.REQ_USER_ACCOUNT = \"req_user_account\", e.JOIN_GATEWAY = \"join_gateway\", e.REJOIN_GATEWAY = \"rejoin_gateway\", e.STREAM_SWITCH = \"stream_switch\", e.REQUEST_PROXY_WORKER_MANAGER = \"request_proxy_worker_manager\", e.REQUEST_PROXY_APPCENTER = \"request_proxy_appcenter\", e.FIRST_VIDEO_RECEIVED = \"first_video_received\", e.FIRST_AUDIO_RECEIVED = \"first_audio_received\", e.FIRST_VIDEO_DECODE = \"first_video_decode\", e.FIRST_AUDIO_DECODE = \"first_audio_decode\", e.ON_ADD_AUDIO_STREAM = \"on_add_audio_stream\", e.ON_ADD_VIDEO_STREAM = \"on_add_video_stream\", e.ON_UPDATE_STREAM = \"on_update_stream\", e.ON_REMOVE_STREAM = \"on_remove_stream\", e.USER_ANALYTICS = \"req_user_analytics\", e.PC_STATS = \"pc_stats\", e.UPDATE_REMOTE_RTPCAPABILITIES = \"update_remote_rtpCapabilities\", e;\n    }({}),\n    iA = function (e) {\n      return e.SESSION = \"io.agora.pb.Wrtc.Session\", e.JOIN_CHOOSE_SERVER = \"io.agora.pb.Wrtc.JoinChooseServer\", e.REQ_USER_ACCOUNT = \"io.agora.pb.Wrtc.ReqUserAccount\", e.JOIN_GATEWAY = \"io.agora.pb.Wrtc.JoinGateway\", e.RE_JOIN_GATEWAY = \"io.agora.pb.Wrtc.ReJoinGateway\", e.PUBLISH = \"io.agora.pb.Wrtc.Publish\", e.SUBSCRIBE = \"io.agora.pb.Wrtc.Subscribe\", e.WS_COMPRESSOR_INIT = \"io.agora.pb.Wrtc.WsCompressorInit\", e.STREAM_SWITCH = \"io.agora.pb.Wrtc.StreamSwitch\", e.AUDIO_SENDING_STOPPED = \"io.agora.pb.Wrtc.AudioSendingStopped\", e.VIDEO_SENDING_STOPPED = \"io.agora.pb.Wrtc.VideoSendingStopped\", e.REQUEST_PROXY_APPCENTER = \"io.agora.pb.Wrtc.RequestProxyAppCenter\", e.REQUEST_PROXY_WORKER_MANAGER = \"io.agora.pb.Wrtc.RequestProxyWorkerManager\", e.API_INVOKE = \"io.agora.pb.Wrtc.ApiInvoke\", e.FIRST_VIDEO_RECEIVED = \"io.agora.pb.Wrtc.FirstVideoReceived\", e.FIRST_AUDIO_RECEIVED = \"io.agora.pb.Wrtc.FirstAudioReceived\", e.FIRST_VIDEO_DECODE = \"io.agora.pb.Wrtc.FirstVideoDecode\", e.FIRST_AUDIO_DECODE = \"io.agora.pb.Wrtc.FirstAudioDecode\", e.ON_ADD_AUDIO_STREAM = \"io.agora.pb.Wrtc.OnAddAudioStream\", e.ON_ADD_VIDEO_STREAM = \"io.agora.pb.Wrtc.OnAddVideoStream\", e.ON_UPDATE_STREAM = \"io.agora.pb.Wrtc.OnUpdateStream\", e.ON_REMOVE_STREAM = \"io.agora.pb.Wrtc.OnRemoveStream\", e.JOIN_CHANNEL_TIMEOUT = \"io.agora.pb.Wrtc.JoinChannelTimeout\", e.PEER_PUBLISH_STATUS = \"io.agora.pb.Wrtc.PeerPublishStatus\", e.WORKER_EVENT = \"io.agora.pb.Wrtc.WorkerEvent\", e.AP_WORKER_EVENT = \"io.agora.pb.Wrtc.APWorkerEvent\", e.JOIN_WEB_PROXY_AP = \"io.agora.pb.Wrtc.JoinWebProxyAP\", e.WEBSOCKET_QUIT = \"io.agora.pb.Wrtc.WebSocketQuit\", e.USER_ANALYTICS = \"io.agora.pb.Wrtc.UserAnalytics\", e.AUTOPLAY_FAILED = \"io.agora.pb.Wrtc.AutoplayFailed\", e.PC_STATS = \"io.agora.pb.Wrtc.PCStats\", e.UPDATE_REMOTE_RTPCAPABILITIES = \"io.agora.pb.Wrtc.UpdateRemoteRTPCapabilities\", e;\n    }({});\n  !function (e) {\n    e[e.WORKER_EVENT = 156] = \"WORKER_EVENT\", e[e.AP_WORKER_EVENT = 160] = \"AP_WORKER_EVENT\";\n  }({}), function (e) {\n    e[e.SESSION = 26] = \"SESSION\", e[e.JOIN_CHOOSE_SERVER = 27] = \"JOIN_CHOOSE_SERVER\", e[e.REQ_USER_ACCOUNT = 196] = \"REQ_USER_ACCOUNT\", e[e.JOIN_GATEWAY = 28] = \"JOIN_GATEWAY\", e[e.PUBLISH = 30] = \"PUBLISH\", e[e.SUBSCRIBE = 29] = \"SUBSCRIBE\", e[e.WS_COMPRESSOR_INIT = 9430] = \"WS_COMPRESSOR_INIT\", e[e.STREAM_SWITCH = 32] = \"STREAM_SWITCH\", e[e.AUDIO_SENDING_STOPPED = 33] = \"AUDIO_SENDING_STOPPED\", e[e.VIDEO_SENDING_STOPPED = 34] = \"VIDEO_SENDING_STOPPED\", e[e.REQUEST_PROXY_APPCENTER = 35] = \"REQUEST_PROXY_APPCENTER\", e[e.REQUEST_PROXY_WORKER_MANAGER = 36] = \"REQUEST_PROXY_WORKER_MANAGER\", e[e.API_INVOKE = 41] = \"API_INVOKE\", e[e.FIRST_VIDEO_RECEIVED = 348] = \"FIRST_VIDEO_RECEIVED\", e[e.FIRST_AUDIO_RECEIVED = 349] = \"FIRST_AUDIO_RECEIVED\", e[e.FIRST_VIDEO_DECODE = 350] = \"FIRST_VIDEO_DECODE\", e[e.FIRST_AUDIO_DECODE = 351] = \"FIRST_AUDIO_DECODE\", e[e.ON_ADD_AUDIO_STREAM = 352] = \"ON_ADD_AUDIO_STREAM\", e[e.ON_ADD_VIDEO_STREAM = 353] = \"ON_ADD_VIDEO_STREAM\", e[e.ON_UPDATE_STREAM = 356] = \"ON_UPDATE_STREAM\", e[e.ON_REMOVE_STREAM = 355] = \"ON_REMOVE_STREAM\", e[e.JOIN_CHANNEL_TIMEOUT = 407] = \"JOIN_CHANNEL_TIMEOUT\", e[e.PEER_PUBLISH_STATUS = 408] = \"PEER_PUBLISH_STATUS\", e[e.WORKER_EVENT = 156] = \"WORKER_EVENT\", e[e.AP_WORKER_EVENT = 160] = \"AP_WORKER_EVENT\", e[e.JOIN_WEB_PROXY_AP = 700] = \"JOIN_WEB_PROXY_AP\", e[e.WEBSOCKET_QUIT = 671] = \"WEBSOCKET_QUIT\", e[e.USER_ANALYTICS = 1e4] = \"USER_ANALYTICS\", e[e.AUTOPLAY_FAILED = 9178] = \"AUTOPLAY_FAILED\";\n  }({});\n  class nA {\n    constructor() {\n      Wy(this, \"baseInfoMap\", new Map()), Wy(this, \"proxyServer\", void 0), Wy(this, \"eventUploadTimer\", void 0), Wy(this, \"setSessionIdTimer\", void 0), Wy(this, \"url\", void 0), Wy(this, \"backupUrl\", void 0), Wy(this, \"_appId\", void 0), Wy(this, \"keyEventUploadPendingItems\", []), Wy(this, \"normalEventUploadPendingItems\", []), Wy(this, \"apiInvokeUploadPendingItems\", []), Wy(this, \"apiInvokeCount\", 0), Wy(this, \"ltsList\", []), Wy(this, \"lastSendNormalEventTime\", Date.now()), Wy(this, \"customReportCounterTimer\", void 0), Wy(this, \"customReportCount\", 0), Wy(this, \"extApiInvoke\", async e => {\n        for (const t of e) {\n          const e = Gy(Gy({}, t), {}, {\n            sid: null,\n            invokeId: ++this.apiInvokeCount,\n            tag: vI.TRACER\n          });\n          this.sendApiInvoke(e);\n        }\n      }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), Dy(\"EVENT_REPORT_SEND_INTERVAL\")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), Dy(\"EVENT_REPORT_SEND_INTERVAL\"));\n    }\n    getBaseInfoBySessionId(e) {\n      return this.baseInfoMap.get(e);\n    }\n    adjustSessionStartTime(e) {\n      if (!this.baseInfoMap.has(e) && !this.baseInfoMap.get(e)) return void Qy.error(\"adjust session \".concat(e, \" start time, sid is not exist or info is undefined\"));\n      const t = this.baseInfoMap.get(e),\n        i = Date.now(),\n        n = t.startTime;\n      t.startTime = i, Qy.debug(\"rewrite session \".concat(e, \" startTime: \").concat(i, \" , \").concat(i - n, \"ms\")), this.baseInfoMap.set(e, t);\n    }\n    setAppId(e) {\n      this._appId = e;\n    }\n    reportApiInvoke(e, t, i) {\n      t.timeout = t.timeout || 6e4, t.reportResult = void 0 === t.reportResult || t.reportResult;\n      const n = Date.now();\n      this.apiInvokeCount += 1;\n      const r = this.apiInvokeCount,\n        o = () => ({\n          tag: t.tag,\n          invokeId: r,\n          sid: e,\n          name: t.name,\n          apiInvokeTime: n,\n          options: t.options,\n          states: t.states || null\n        }),\n        s = !!Dy(\"SHOW_REPORT_INVOKER_LOG\");\n      s && Qy.info(\"\".concat(t.name, \" start\"), t.options);\n      let a = !1;\n      $I(t.timeout).then(() => {\n        a || (this.sendApiInvoke(Gy(Gy({}, o()), {}, {\n          error: tI.API_INVOKE_TIMEOUT,\n          success: !1\n        })), Qy.debug(\"\".concat(t.name, \" timeout\")));\n      });\n      const c = new iI(tI.UNEXPECTED_ERROR, \"\".concat(t.name, \": this api invoke is end\"));\n      return {\n        onSuccess: e => {\n          const n = () => {\n            if (a) throw c;\n            return a = !0, this.sendApiInvoke(Gy(Gy({}, o()), {}, {\n              success: !0\n            }, t.reportResult && {\n              result: e\n            })), s && Qy.info(\"\".concat(t.name, \" onSuccess\")), e;\n          };\n          return i ? ry(n, t.name + \"Success\", i, () => a = !0) : n();\n        },\n        onError: e => {\n          const n = () => {\n            if (a) throw e;\n            a = !0, this.sendApiInvoke(Gy(Gy({}, o()), {}, {\n              success: !1,\n              error: e\n            })), s && Qy.info(\"\".concat(t.name, \" onFailure\"), e.toString());\n          };\n          return i ? ry(n, t.name + \"Error\", i, () => a = !0) : n();\n        }\n      };\n    }\n    sessionInit(e, t) {\n      if (this.baseInfoMap.has(e)) return;\n      const i = Date.now(),\n        n = this.createBaseInfo(e, i);\n      n.cname = t.cname;\n      const r = Object.assign({}, {\n          willUploadConsoleLog: Dy(\"UPLOAD_LOG\"),\n          maxTouchPoints: navigator.maxTouchPoints,\n          areaVersion: yy ? \"global\" : \"oversea\",\n          areas: Dy(\"AREAS\") && Dy(\"AREAS\").join(\",\")\n        }, t.extend),\n        o = t.stringUid,\n        s = t.channelProfile,\n        a = t.channelMode,\n        c = t.isABTestSuccess,\n        d = t.lsid,\n        l = t.clientRole,\n        h = Date.now(),\n        u = Gy(Gy({}, n), {}, {\n          eventType: tA.SESSION_INIT,\n          appid: t.appid,\n          browser: navigator.userAgent,\n          buildFormat: t.buildFormat,\n          build: wy,\n          lts: h,\n          elapse: h - i,\n          extend: JSON.stringify(r),\n          mode: t.mode,\n          process: Dy(\"PROCESS_ID\"),\n          appType: Dy(\"APP_TYPE\"),\n          success: !0,\n          version: Iy,\n          stringUid: o,\n          channelProfile: s,\n          channelMode: a,\n          isABTestSuccess: c,\n          lsid: d,\n          clientType: 20,\n          clientRole: l,\n          serviceId: Dy(\"PROCESS_ID\"),\n          extensionID: Dy(\"PLUGIN_INFO\").join(\",\") || \"\",\n          preload: t.preload ? 1 : 0\n        });\n      this.send({\n        type: iA.SESSION,\n        data: u\n      }, !0);\n    }\n    joinChooseServer(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy({}, n), {}, {\n          eventType: tA.JOIN_CHOOSE_SERVER,\n          lts: r,\n          eventElapse: t.elapse || r - t.lts,\n          chooseServerAddr: t.csAddr,\n          errorCode: t.ec,\n          elapse: r - i.startTime,\n          success: t.succ,\n          chooseServerAddrList: JSON.stringify(t.serverList),\n          uid: t.uid ? parseInt(t.uid) : null,\n          cid: t.cid ? parseInt(t.cid) : null,\n          chooseServerIp: t.csIp || \"\",\n          opid: t.opid,\n          unilbsServerIds: t.unilbsServerIds,\n          extend: t.extend || void 0,\n          isHttp3: t.isHttp3\n        });\n      this.send({\n        type: iA.JOIN_CHOOSE_SERVER,\n        data: o\n      }, !0);\n    }\n    reqUserAccount(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy({}, n), {}, {\n          eventType: tA.REQ_USER_ACCOUNT,\n          lts: r,\n          success: t.success,\n          serverAddress: t.serverAddr,\n          stringUid: t.stringUid,\n          uid: t.uid,\n          errorCode: t.errorCode,\n          elapse: t.elapse || r - i.startTime,\n          eventElapse: r - t.lts,\n          extend: JSON.stringify(t.extend)\n        });\n      this.send({\n        type: iA.REQ_USER_ACCOUNT,\n        data: o\n      }, !0);\n    }\n    joinGateway(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info;\n      t.vid && (n.vid = t.vid), n.uid = t.uid, n.cid = t.cid;\n      const r = Date.now(),\n        o = t.firstSuccess,\n        s = t.avoidJoinStartTime,\n        a = t.isProxy,\n        c = t.addr,\n        d = r - (o && s ? s : i.startTime),\n        l = Gy(Gy({}, n), {}, {\n          eventType: tA.JOIN_GATEWAY,\n          lts: r,\n          gatewayAddr: t.addr,\n          success: t.succ,\n          errorCode: t.ec,\n          elapse: d,\n          eventElapse: r - t.lts,\n          firstSuccess: o,\n          signalChannel: t.signalChannel\n        }),\n        h = l.success ? 1 : 0;\n      if (t.succ && (i.lastJoinSuccessTime = r), o) this.send({\n        type: iA.JOIN_GATEWAY,\n        data: l\n      }, !0);else {\n        let e;\n        if (c) {\n          if (a) {\n            const t = c.match(/h=(\\d{1,3}-){3}\\d{1,3}/g),\n              i = c.match(/p=[0-9]{1,6}/g);\n            e = {\n              isSuccess: h,\n              gatewayIp: t && t.length ? t[0].split(\"=\")[1].replace(/-/g, \".\") : \"\",\n              port: i && i.length ? i[0].split(\"=\")[1] : \"\",\n              isProxy: a ? 1 : 0\n            };\n          } else {\n            const t = c.match(/wss:\\/\\/(\\d{1,3}-){3}\\d{1,3}/g),\n              i = c.match(/(:|p=)[0-9]{1,6}/g);\n            e = {\n              isSuccess: h,\n              gatewayIp: t && t.length ? t[0].split(\"//\")[1].replace(/-/g, \".\") : \"\",\n              port: i && i.length ? i[0].split(/:|p=/g)[1] : \"\",\n              isProxy: a ? 1 : 0\n            };\n          }\n        } else e = {\n          isSuccess: h,\n          gatewayIp: \"\",\n          port: \"\",\n          isProxy: a ? 1 : 0\n        };\n        delete l.success, delete l.eventType, delete l.firstSuccess, l.vid = Number(l.vid);\n        const t = Object.assign({}, l, e, {\n          eventType: tA.REJOIN_GATEWAY\n        });\n        this.send({\n          type: iA.RE_JOIN_GATEWAY,\n          data: t\n        }, !0);\n      }\n    }\n    joinChannelTimeout(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = Date.now(),\n        r = Gy(Gy({}, i.info), {}, {\n          lts: n,\n          timeout: t,\n          elapse: n - i.startTime\n        });\n      this.send({\n        type: iA.JOIN_CHANNEL_TIMEOUT,\n        data: r\n      }, !0);\n    }\n    publish(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy({}, n), {}, {\n          eventType: tA.PUBLISH,\n          lts: r,\n          eventElapse: t.eventElapse,\n          elapse: r - i.startTime,\n          success: t.succ,\n          errorCode: t.ec,\n          videoName: t.videoName,\n          audioName: t.audioName,\n          screenName: t.screenName,\n          screenshare: t.screenshare,\n          audio: t.audio,\n          video: t.video,\n          p2pid: t.p2pid,\n          publishRequestid: t.publishRequestid\n        });\n      this.send({\n        type: iA.PUBLISH,\n        data: o\n      }, !0);\n    }\n    subscribe(e, t, i) {\n      const n = this.baseInfoMap.get(e);\n      if (!n) return;\n      const r = n.info,\n        o = Date.now(),\n        s = Gy(Gy({}, r), {}, {\n          eventType: tA.SUBSCRIBE,\n          lts: o,\n          eventElapse: t.eventElapse,\n          elapse: o - n.startTime,\n          success: t.succ,\n          errorCode: t.ec,\n          video: t.video,\n          audio: t.audio,\n          subscribeRequestid: t.subscribeRequestid,\n          p2pid: t.p2pid\n        }, i && {\n          extend: JSON.stringify({\n            isMassSubscribe: !0\n          })\n        });\n      \"string\" == typeof t.peerid ? s.peerSuid = t.peerid : s.peer = t.peerid, this.send({\n        type: iA.SUBSCRIBE,\n        data: s\n      }, !0);\n    }\n    wsCompressorInit(e) {\n      var t;\n      const i = [...d_(t = this.baseInfoMap).call(t)],\n        n = i.length ? i[0] : \"UnableToGetSid\",\n        r = this.baseInfoMap.get(n);\n      if (!r) return;\n      const o = r.info,\n        s = Date.now(),\n        a = Gy(Gy({}, o), {}, {\n          eventType: tA.WS_COMPRESSOR_INIT,\n          lts: s,\n          eventElapse: e.eventElapse,\n          elapse: s - r.startTime,\n          status: e.status ? 1 : 2\n        });\n      this.send({\n        type: iA.WS_COMPRESSOR_INIT,\n        data: a\n      }, !0);\n    }\n    firstRemoteVideoDecode(e, t, i, n) {\n      const r = this.baseInfoMap.get(e);\n      if (!r) return;\n      const o = r.info,\n        s = Date.now(),\n        a = Gy(Gy(Gy({}, o), n), {}, {\n          elapse: s - r.startTime,\n          eventType: t,\n          lts: s,\n          firstDecodeFrame: Math.max(s - r.startTime, 0),\n          apEnd: Math.max(n.apEnd - r.startTime, 0),\n          apStart: Math.max(n.apStart - r.startTime, 0),\n          joinGwEnd: Math.max(n.joinGwEnd - r.startTime, 0),\n          joinGwStart: Math.max(n.joinGwStart - r.startTime, 0),\n          pcEnd: Math.max(n.pcEnd - r.startTime, 0),\n          pcStart: Math.max(n.pcStart - r.startTime, 0),\n          subscriberEnd: Math.max(n.subscriberEnd - r.startTime, 0),\n          subscriberStart: Math.max(n.subscriberStart - r.startTime, 0),\n          videoAddNotify: Math.max(n.videoAddNotify - r.startTime, 0)\n        });\n      this.send({\n        type: i,\n        data: a\n      }, !0);\n    }\n    firstRemoteFrame(e, t, i, n) {\n      const r = this.baseInfoMap.get(e);\n      if (!r) return;\n      const o = r.info,\n        s = Date.now(),\n        a = Gy(Gy(Gy({}, o), n), {}, {\n          elapse: s - r.startTime,\n          eventType: t,\n          lts: s\n        });\n      this.send({\n        type: i,\n        data: a\n      }, !0);\n    }\n    pcStats(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy(Gy({}, n), t), {}, {\n          vid: void 0 === n.vid ? 0 : Number(n.vid),\n          elapse: r - i.startTime,\n          eventType: tA.PC_STATS,\n          lts: r\n        });\n      this.send({\n        type: iA.PC_STATS,\n        data: o\n      }, !0);\n    }\n    updateRemoteRTPCapabilities(e, t) {\n      if (e) {\n        const i = this.baseInfoMap.get(e);\n        if (!i) return;\n        const n = i.info,\n          r = Date.now(),\n          o = Gy(Gy(Gy({}, n), t), {}, {\n            vid: void 0 === n.vid ? 0 : Number(n.vid),\n            eventType: tA.UPDATE_REMOTE_RTPCAPABILITIES,\n            lts: r\n          });\n        this.send({\n          type: iA.UPDATE_REMOTE_RTPCAPABILITIES,\n          data: o\n        }, !0);\n      }\n    }\n    onGatewayStream(e, t, i, n) {\n      const r = this.baseInfoMap.get(e);\n      if (!r) return;\n      const o = r.info,\n        s = Date.now(),\n        a = Gy(Gy(Gy({}, o), n), {}, {\n          eventType: t,\n          lts: s\n        });\n      this.send({\n        type: i,\n        data: a\n      }, !0);\n    }\n    streamSwitch(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy({}, n), {}, {\n          eventType: tA.STREAM_SWITCH,\n          lts: r,\n          isDual: t.isdual,\n          elapse: r - i.startTime,\n          success: t.succ\n        });\n      this.send({\n        type: iA.STREAM_SWITCH,\n        data: o\n      }, !0);\n    }\n    requestProxyAppCenter(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy({}, n), {}, {\n          eventType: tA.REQUEST_PROXY_APPCENTER,\n          lts: r,\n          eventElapse: r - t.lts,\n          elapse: r - i.startTime,\n          APAddr: t.APAddr,\n          workerManagerList: t.workerManagerList,\n          response: t.response,\n          errorCode: t.ec,\n          success: t.succ\n        });\n      this.send({\n        type: iA.REQUEST_PROXY_APPCENTER,\n        data: o\n      }, !0);\n    }\n    requestProxyWorkerManager(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy({}, n), {}, {\n          eventType: tA.REQUEST_PROXY_WORKER_MANAGER,\n          lts: r,\n          eventElapse: r - t.lts,\n          elapse: r - i.startTime,\n          workerManagerAddr: t.workerManagerAddr,\n          response: t.response,\n          errorCode: t.ec,\n          success: t.succ\n        });\n      this.send({\n        type: iA.REQUEST_PROXY_WORKER_MANAGER,\n        data: o\n      }, !0);\n    }\n    setProxyServer(e) {\n      this.proxyServer = e, e ? Qy.debug(\"reportProxyServerurl: \".concat(e)) : Qy.debug(\"disable reportProxyServerurl: \".concat(e));\n    }\n    peerPublishStatus(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy({}, n), {}, {\n          subscribeElapse: t.subscribeElapse,\n          peer: t.peer,\n          peerPublishDuration: Math.max(t.audioPublishDuration, t.videoPublishDuration),\n          audiotag: t.audioPublishDuration > 0 ? 1 : -1,\n          videotag: t.videoPublishDuration > 0 ? 1 : -1,\n          lts: r,\n          elapse: r - i.startTime,\n          joinChannelSuccessElapse: r - (i.lastJoinSuccessTime || r),\n          peerPublishDurationVideo: t.videoPublishDuration,\n          peerPublishDurationAudio: t.audioPublishDuration\n        });\n      this.send({\n        type: iA.PEER_PUBLISH_STATUS,\n        data: o\n      }, !0);\n    }\n    workerEvent(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now();\n      (function (e, t, i) {\n        const n = e[t];\n        if (!n || \"string\" != typeof n) return [e];\n        e[t] = \"\";\n        const r = XI(JSON.stringify(e));\n        let o = 0;\n        const s = [];\n        let a = 0;\n        for (let c = 0; c < n.length; c++) a += n.charCodeAt(c) <= 127 ? 1 : 3, a <= i - r || (s[s.length] = $v($v({}, e), {}, {\n          [t]: n.substring(o, c)\n        }), o = c, a = n.charCodeAt(c) <= 127 ? 1 : 3);\n        return o !== n.length - 1 && (s[s.length] = $v($v({}, e), {}, {\n          [t]: n.substring(o)\n        })), s;\n      })(Gy(Gy(Gy({}, n), t), {}, {\n        elapse: r - i.startTime,\n        lts: r,\n        productType: \"WebRTC\"\n      }), \"payload\", 1300).forEach(e => this.send({\n        type: iA.WORKER_EVENT,\n        data: e\n      }, !0));\n    }\n    apworkerEvent(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy(Gy({}, n), t), {}, {\n          elapse: r - i.startTime,\n          lts: r\n        });\n      this.send({\n        type: iA.AP_WORKER_EVENT,\n        data: o\n      }, !0);\n    }\n    joinWebProxyAP(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy(Gy({}, n), t), {}, {\n          elapse: r - i.startTime,\n          lts: r,\n          extend: t.extend || void 0\n        });\n      this.send({\n        type: iA.JOIN_WEB_PROXY_AP,\n        data: o\n      }, !0);\n    }\n    WebSocketQuit(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const n = i.info,\n        r = Date.now(),\n        o = Gy(Gy(Gy({}, n), t), {}, {\n          elapse: r - i.startTime,\n          lts: r\n        });\n      this.send({\n        type: iA.WEBSOCKET_QUIT,\n        data: o\n      }, !0);\n    }\n    async sendCustomReportMessage(e, t) {\n      if (this.customReportCount += t.length, this.customReportCount > Dy(\"CUSTOM_REPORT_LIMIT\")) throw new iI(tI.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);\n      this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {\n        this.customReportCount = 0;\n      }, 5e3));\n      const i = Date.now(),\n        n = t.map(t => ({\n          type: iA.USER_ANALYTICS,\n          data: Gy(Gy({\n            sid: e\n          }, t), {}, {\n            lts: i\n          })\n        }));\n      try {\n        Dy(\"NEW_REPORT_SERVER\") ? await this.postDataToStatsCollector2(n) : await this.postDataToStatsCollector(n);\n      } catch (e) {\n        throw Qy.error(\"send custom report message failed\", e.toString()), new iI(tI.CUSTOM_REPORT_SEND_FAILED, e.message);\n      }\n    }\n    sendApiInvoke(e) {\n      const t = Dy(\"NOT_REPORT_EVENT\");\n      if (e.tag && Dn(t) && Dn(t).call(t, e.tag)) return !1;\n      if (null === e.sid) return this.apiInvokeUploadPendingItems.push(e), !1;\n      const i = this.baseInfoMap.get(e.sid);\n      if (!i) return this.apiInvokeUploadPendingItems.push(e), !1;\n      const _i$info = i.info,\n        n = _i$info.cname,\n        r = _i$info.uid,\n        o = _i$info.cid;\n      let s;\n      if (e.lts = e.lts || Date.now(), e.error) if (e.error instanceof iI) {\n        const _e$error = e.error,\n          t = _e$error.code,\n          i = _e$error.message;\n        s = t || i || e.error.toString();\n      } else s = e.error.toString();\n      const a = {\n        invokeId: e.invokeId,\n        sid: e.sid,\n        cname: n,\n        cid: o,\n        uid: r,\n        lts: e.lts,\n        success: e.success,\n        elapse: e.lts - i.startTime,\n        execElapse: e.lts - e.apiInvokeTime,\n        apiName: e.name,\n        options: e.options ? JSON.stringify(e.options) : void 0,\n        execStates: e.states ? JSON.stringify(e.states) : void 0,\n        execResult: e.result ? JSON.stringify(e.result) : void 0,\n        errorCode: e.error ? s : void 0,\n        errorMsg: e.error ? JSON.stringify(e.error) : void 0\n      };\n      return this.send({\n        type: iA.API_INVOKE,\n        data: a\n      }, !1), !0;\n    }\n    appendSessionId() {\n      nA.__CLIENT_LIST__.forEach(e => {\n        if (e._sessionId) {\n          const t = this.apiInvokeUploadPendingItems.length;\n          for (let i = 0; i < t; i++) {\n            const t = this.apiInvokeUploadPendingItems.shift();\n            t && (t.sid = e._sessionId, this.sendApiInvoke(Object.assign({}, t)));\n          }\n        }\n      });\n    }\n    send(e, t) {\n      if (t) return this.keyEventUploadPendingItems.push(e), void this.sendItems(this.keyEventUploadPendingItems, !0);\n      this.normalEventUploadPendingItems.push(e), this.normalEventUploadPendingItems.length > Dy(\"NORMAL_EVENT_QUEUE_CAPACITY\") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, !1);\n    }\n    doSend() {\n      this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, !0), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, !1);\n    }\n    sendItems(e, t) {\n      const i = [],\n        n = [];\n      for (; e.length;) {\n        const t = e.shift();\n        i.length < 20 ? i.push(t) : n.push(t);\n      }\n      e.push(...n);\n      for (const e of [...i]) {\n        var r;\n        -1 !== this.ltsList.indexOf(e.data.lts) ? (e.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e.data.lts)) : (this.ltsList.push(e.data.lts), oE(r = this.ltsList).call(r, (e, t) => e - t));\n      }\n      return t || (this.lastSendNormalEventTime = Date.now()), Dy(\"ENABLE_EVENT_REPORT\") ? (i.length && (Dy(\"NEW_REPORT_SERVER\") ? this.postDataToStatsCollector2(i) : this.postDataToStatsCollector(i)).catch((e => i => {\n        Dy(\"EVENT_REPORT_RETRY\") && (t ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e), this.normalEventUploadPendingItems.length > Dy(\"NORMAL_EVENT_QUEUE_CAPACITY\") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - Dy(\"NORMAL_EVENT_QUEUE_CAPACITY\")), Qy.warning(\"report: drop normal events\"))));\n      })(i)), e) : e;\n    }\n    async postDataToStatsCollector2(e) {\n      VI.networkState === PI.OFFLINE && (await Gu.race([VI.onlineWaiter, $I(2 * _y.maxRetryTimeout)]));\n      const t = e => {\n          let t = new Uint8Array();\n          return e.forEach(e => {\n            const i = mI(JSON.stringify(e.data)),\n              n = new ArrayBuffer(5),\n              r = (e => {\n                let t = 0;\n                return Object.entries(iA).forEach(i => {\n                  let _i2 = _slicedToArray(i, 2),\n                    n = _i2[0],\n                    r = _i2[1];\n                  r === e.type && (t = EventNameToID[n]);\n                }), t;\n              })(e),\n              o = new DataView(n);\n            o.setUint16(0, i.byteLength, !0), o.setUint8(2, 255 & r), o.setUint8(3, r >>> 8 & 255), o.setUint8(4, r >>> 16 & 255), t = fI(t, new Uint8Array(n)), t = fI(t, i);\n          }), t;\n        },\n        i = \"event\";\n      let n = this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(Dy(\"NEW_REPORT_SERVER_DOMAINS\")[0], \"&p=443&d=\").concat(i) : \"https://\".concat(Dy(\"NEW_REPORT_SERVER_DOMAINS\")[0], \"/\").concat(i);\n      for (let r = 0; r < 2; r += 1) {\n        1 === r && (n = this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(Dy(\"NEW_REPORT_SERVER_DOMAINS\")[1], \"&p=443&d=\").concat(i) : \"https://\".concat(Dy(\"NEW_REPORT_SERVER_DOMAINS\")[1], \"/\").concat(i));\n        try {\n          await Ry(n, {\n            timeout: 1e4,\n            data: t(e),\n            headers: Gy(Gy({\n              biz: \"webrtc\",\n              sendts: Math.round(Date.now() / 1e3),\n              debug: \"false\"\n            }, this._appId && {\n              appid: this._appId\n            }), {}, {\n              \"Content-Type\": \"application/octet-stream\"\n            })\n          }, !0);\n        } catch (e) {\n          if (1 === r) throw e;\n          continue;\n        }\n        return;\n      }\n    }\n    async postDataToStatsCollector(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      const i = {\n        msgType: \"EventMessages\",\n        sentTs: Math.round(Date.now() / 1e3),\n        payloads: e.map(e => JSON.stringify(e)),\n        vid: (e => {\n          const t = e && e.data.sid && this.baseInfoMap.get(e.data.sid);\n          return t && t.info.vid && +t.info.vid || 0;\n        })(e[0])\n      };\n      VI.networkState === PI.OFFLINE && (await Gu.race([VI.onlineWaiter, $I(2 * _y.maxRetryTimeout)]));\n      const n = t ? \"/events/proto-raws\" : \"/events/messages\";\n      let r = this.url || (this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(Dy(\"EVENT_REPORT_DOMAIN\"), \"&p=\").concat(Dy(\"STATS_COLLECTOR_PORT\"), \"&d=\").concat(n) : \"https://\".concat(Dy(\"EVENT_REPORT_DOMAIN\"), \":\").concat(Dy(\"STATS_COLLECTOR_PORT\")).concat(n));\n      for (let e = 0; e < 2; e += 1) {\n        1 === e && (r = this.backupUrl || (this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(Dy(\"EVENT_REPORT_BACKUP_DOMAIN\"), \"&p=\").concat(Dy(\"STATS_COLLECTOR_PORT\"), \"&d=\").concat(n) : \"https://\".concat(Dy(\"EVENT_REPORT_BACKUP_DOMAIN\"), \":\").concat(Dy(\"STATS_COLLECTOR_PORT\")).concat(n)));\n        try {\n          t ? await Cy(r, {\n            timeout: 1e4,\n            data: i\n          }) : await Ry(r, {\n            timeout: 1e4,\n            data: i\n          });\n        } catch (t) {\n          if (1 === e) throw t;\n          continue;\n        }\n        return;\n      }\n    }\n    createBaseInfo(e, t) {\n      const i = Object.assign({}, eA);\n      return i.sid = e, this.baseInfoMap.set(e, {\n        info: i,\n        startTime: t\n      }), i;\n    }\n    reportResourceTiming(e, t) {\n      const i = performance.getEntriesByName(e),\n        n = i[i.length - 1];\n      n && this.reportApiInvoke(t, {\n        name: \"Client.resourceTiming\",\n        options: n,\n        tag: vI.TRACER\n      }).onSuccess();\n    }\n  }\n  function rA() {\n    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n    return function (t, i, n) {\n      const r = n.value;\n      if (\"function\" == typeof r) {\n        const o = e.className || t.__className__ || (\"AgoraRTCClient\" === t.constructor.name ? \"Client\" : t.constructor.name);\n        n.value = function () {\n          for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++) n[s] = arguments[s];\n          let a = n;\n          if (e.argsMap) try {\n            a = e.argsMap(this, ...n);\n          } catch (e) {\n            Qy.warning(e), a = [];\n          }\n          try {\n            JSON.stringify(a);\n          } catch (e) {\n            Qy.warning(\"arguments for method \".concat(o, \".\").concat(String(i), \" not serializable for apiInvoke.\")), a = [];\n          }\n          const c = (e.report || oA).reportApiInvoke(this._sessionId || null, {\n            name: \"\".concat(o, \".\").concat(String(i)),\n            options: a,\n            tag: vI.TRACER,\n            reportResult: e.reportResult\n          }, e.throttleTime);\n          try {\n            const t = r.apply(this, n);\n            return t instanceof Gu ? t.then(t => (c.onSuccess(e.reportResult && t), t)).catch(e => {\n              throw c.onError(e), e;\n            }) : (c.onSuccess(e.reportResult && t), t);\n          } catch (e) {\n            throw c.onError(e), e;\n          }\n        };\n      }\n      return n;\n    };\n  }\n  Wy(nA, \"__CLIENT_LIST__\", []);\n  const oA = new nA();\n  Hy.on(\"REPORT_LOG_UPLOAD\", e => {\n    e.networkState = VI.networkState, oA.reportApiInvoke(null, {\n      name: \"logUploadError\",\n      options: e,\n      tag: vI.TRACER\n    }).onSuccess(\"logUploadError\");\n  });\n  const sA = [\"CHINA\", \"GLOBAL\"],\n    aA = function () {\n      const e = \"us\".concat(\"erna\", \"me\"),\n        t = \"pa\".concat(\"sswo\", \"rd\"),\n        i = [\"t\", \"s\", \"t\"];\n      i.splice(1, 0, \"e\");\n      const n = i.join(\"\"),\n        r = [];\n      for (let e = 0; e < 6; e++) r.push(\"1\");\n      const o = r.join(\"\"),\n        s = {};\n      return s[e] = n, s[t] = o, Object.assign(s, {\n        turnServerURL: \"\",\n        tcpport: 3433,\n        udpport: 3478,\n        forceturn: !1\n      });\n    }();\n  window.DEFAULT_TURN_CONFIG = aA, yy || (Oy.WEBCS_DOMAIN = [\"ap-web-1-oversea.agora.io\", \"ap-web-1-north-america.agora.io\"], Oy.WEBCS_DOMAIN_BACKUP_LIST = [\"ap-web-2-oversea.agora.io\", \"ap-web-2-north-america.agora.io\"], Oy.PROXY_CS = [\"proxy-ap-web-oversea.agora.io\", \"proxy-ap-web-america.agora.io\"], Oy.CDS_AP = [\"cds-ap-web-oversea.agora.io\", \"cds-ap-web-america.agora.io\", \"cds-ap-web-america2.agora.io\"], Oy.ACCOUNT_REGISTER = [\"sua-ap-web-oversea.agora.io\", \"sua-ap-web-america.agora.io\", \"sua-ap-web-america2.agora.io\"], Oy.UAP_AP = [\"uap-ap-web-oversea.agora.io\", \"uap-ap-web-america.agora.io\", \"uap-ap-web-america2.agora.io\"], Oy.LOG_UPLOAD_SERVER = \"logservice-oversea.agora.io\", Oy.EVENT_REPORT_DOMAIN = \"statscollector-1-oversea.agora.io\", Oy.EVENT_REPORT_BACKUP_DOMAIN = \"statscollector-2-oversea.agora.io\", Oy.PROXY_SERVER_TYPE3 = \"webrtc-cloud-proxy.agora.io\", Oy.AREAS = [\"NORTH_AMERICA\", \"OVERSEA\"]);\n  const cA = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]],\n    dA = [];\n  function lA(e, t) {\n    return !!t && dA.some(i => i.uid === e && i.channelName === t);\n  }\n  nA.__CLIENT_LIST__ = dA;\n  var hA = Rf.forEach,\n    uA = Bn(\"forEach\") ? [].forEach : function (e) {\n      return hA(this, e, arguments.length > 1 ? arguments[1] : void 0);\n    };\n  wi({\n    target: \"Array\",\n    proto: !0,\n    forced: [].forEach != uA\n  }, {\n    forEach: uA\n  });\n  var pA = Xi(\"Array\").forEach,\n    _A = pn,\n    EA = Ze,\n    mA = l,\n    fA = pA,\n    TA = Array.prototype,\n    SA = {\n      DOMTokenList: !0,\n      NodeList: !0\n    },\n    gA = function (e) {\n      var t = e.forEach;\n      return e === TA || mA(TA, e) && t === TA.forEach || EA(SA, _A(e)) ? fA : t;\n    },\n    RA = i(gA),\n    CA = Je,\n    vA = eo;\n  wi({\n    target: \"Object\",\n    stat: !0,\n    forced: n(function () {\n      vA(1);\n    })\n  }, {\n    keys: function (e) {\n      return vA(CA(e));\n    }\n  });\n  var IA = i(ie.Object.keys),\n    yA = i(zn),\n    AA = wi,\n    bA = Cm,\n    wA = d([].reverse),\n    OA = [1, 2];\n  AA({\n    target: \"Array\",\n    proto: !0,\n    forced: String(OA) === String(OA.reverse())\n  }, {\n    reverse: function () {\n      return bA(this) && (this.length = this.length), wA(this);\n    }\n  });\n  var NA = Xi(\"Array\").reverse,\n    DA = l,\n    PA = NA,\n    LA = Array.prototype,\n    kA = function (e) {\n      var t = e.reverse;\n      return e === LA || DA(LA, e) && t === LA.reverse ? PA : t;\n    },\n    MA = kA,\n    UA = i(MA),\n    xA = wi,\n    VA = Cm,\n    FA = jc,\n    BA = te,\n    jA = xi,\n    GA = Gi,\n    WA = Z,\n    HA = E_,\n    KA = ut,\n    YA = Xc,\n    qA = km(\"slice\"),\n    zA = KA(\"species\"),\n    JA = Array,\n    XA = Math.max;\n  xA({\n    target: \"Array\",\n    proto: !0,\n    forced: !qA\n  }, {\n    slice: function (e, t) {\n      var i,\n        n,\n        r,\n        o = WA(this),\n        s = GA(o),\n        a = jA(e, s),\n        c = jA(void 0 === t ? s : t, s);\n      if (VA(o) && (i = o.constructor, (FA(i) && (i === JA || VA(i.prototype)) || BA(i) && null === (i = i[zA])) && (i = void 0), i === JA || void 0 === i)) return YA(o, a, c);\n      for (n = new (void 0 === i ? JA : i)(XA(c - a, 0)), r = 0; a < c; a++, r++) a in o && HA(n, r, o[a]);\n      return n.length = r, n;\n    }\n  });\n  var QA = Xi(\"Array\").slice,\n    ZA = l,\n    $A = QA,\n    eb = Array.prototype,\n    tb = function (e) {\n      var t = e.slice;\n      return e === eb || ZA(eb, e) && t === eb.slice ? $A : t;\n    },\n    ib = i(tb);\n  function nb(e, t, i, n, r) {\n    var o,\n      s,\n      a,\n      c = {};\n    return RA(o = IA(n)).call(o, function (e) {\n      c[e] = n[e];\n    }), c.enumerable = !!c.enumerable, c.configurable = !!c.configurable, (\"value\" in c || c.initializer) && (c.writable = !0), c = yA(s = UA(a = ib(i).call(i)).call(a)).call(s, function (i, n) {\n      return n(e, t, i) || i;\n    }, c), r && void 0 !== c.initializer && (c.value = c.initializer ? c.initializer.call(r) : void 0, c.initializer = void 0), void 0 === c.initializer && (gm(e, t, c), c = null), c;\n  }\n  var rb = Xi(\"Array\").values,\n    ob = pn,\n    sb = Ze,\n    ab = l,\n    cb = rb,\n    db = Array.prototype,\n    lb = {\n      DOMTokenList: !0,\n      NodeList: !0\n    },\n    hb = function (e) {\n      var t = e.values;\n      return e === db || ab(db, e) && t === db.values || sb(lb, ob(e)) ? cb : t;\n    },\n    ub = i(hb);\n  let pb = function (e) {\n      return e.L1T1 = \"L1T1\", e.L1T2 = \"L1T2\", e.L1T3 = \"L1T3\", e.L2T1_KEY = \"L2T1_KEY\", e.L2T2_KEY = \"L2T2_KEY\", e.L2T3_KEY = \"L2T3_KEY\", e.L3T1_KEY = \"L3T1_KEY\", e.L3T2_KEY = \"L3T2_KEY\", e.L3T3_KEY = \"L3T3_KEY\", e;\n    }({}),\n    _b = function (e) {\n      return e.CERTIFICATE = \"certificate\", e.CODEC = \"codec\", e.CANDIDATE_PAIR = \"candidate-pair\", e.LOCAL_CANDIDATE = \"local-candidate\", e.REMOTE_CANDIDATE = \"remote-candidate\", e.INBOUND = \"inbound-rtp\", e.TRACK = \"track\", e.OUTBOUND = \"outbound-rtp\", e.PC = \"peer-connection\", e.REMOTE_INBOUND = \"remote-inbound-rtp\", e.REMOTE_OUTBOUND = \"remote-outbound-rtp\", e.TRANSPORT = \"transport\", e.CSRC = \"csrc\", e.DATA_CHANNEL = \"data-channel\", e.STREAM = \"stream\", e.SENDER = \"sender\", e.RECEIVER = \"receiver\", e;\n    }({}),\n    Eb = function (e) {\n      return e[e.ACCESS_POINT = 101] = \"ACCESS_POINT\", e[e.UNILBS = 201] = \"UNILBS\", e[e.STRING_UID_ALLOCATOR = 901] = \"STRING_UID_ALLOCATOR\", e;\n    }({}),\n    mb = function (e) {\n      return e[e.IIIEGAL_APPID = 1] = \"IIIEGAL_APPID\", e[e.IIIEGAL_UID = 2] = \"IIIEGAL_UID\", e[e.INTERNAL_ERROR = 3] = \"INTERNAL_ERROR\", e;\n    }({}),\n    fb = function (e) {\n      return e[e.INVALID_VENDOR_KEY = 5] = \"INVALID_VENDOR_KEY\", e[e.INVALID_CHANNEL_NAME = 7] = \"INVALID_CHANNEL_NAME\", e[e.INTERNAL_ERROR = 8] = \"INTERNAL_ERROR\", e[e.NO_AUTHORIZED = 9] = \"NO_AUTHORIZED\", e[e.DYNAMIC_KEY_TIMEOUT = 10] = \"DYNAMIC_KEY_TIMEOUT\", e[e.NO_ACTIVE_STATUS = 11] = \"NO_ACTIVE_STATUS\", e[e.DYNAMIC_KEY_EXPIRED = 13] = \"DYNAMIC_KEY_EXPIRED\", e[e.STATIC_USE_DYNAMIC_KEY = 14] = \"STATIC_USE_DYNAMIC_KEY\", e[e.DYNAMIC_USE_STATIC_KEY = 15] = \"DYNAMIC_USE_STATIC_KEY\", e[e.USER_OVERLOAD = 16] = \"USER_OVERLOAD\", e[e.FORBIDDEN_REGION = 18] = \"FORBIDDEN_REGION\", e[e.CANNOT_MEET_AREA_DEMAND = 19] = \"CANNOT_MEET_AREA_DEMAND\", e;\n    }({}),\n    Tb = function (e) {\n      return e[e.NO_FLAG_SET = 100] = \"NO_FLAG_SET\", e[e.FLAG_SET_BUT_EMPTY = 101] = \"FLAG_SET_BUT_EMPTY\", e[e.INVALID_FALG_SET = 102] = \"INVALID_FALG_SET\", e[e.FLAG_SET_BUT_NO_RE = 103] = \"FLAG_SET_BUT_NO_RE\", e[e.INVALID_SERVICE_ID = 104] = \"INVALID_SERVICE_ID\", e[e.NO_SERVICE_AVAILABLE = 200] = \"NO_SERVICE_AVAILABLE\", e[e.NO_SERVICE_AVAILABLE_P2P = 201] = \"NO_SERVICE_AVAILABLE_P2P\", e[e.NO_SERVICE_AVAILABLE_VOICE = 202] = \"NO_SERVICE_AVAILABLE_VOICE\", e[e.NO_SERVICE_AVAILABLE_WEBRTC = 203] = \"NO_SERVICE_AVAILABLE_WEBRTC\", e[e.NO_SERVICE_AVAILABLE_CDS = 204] = \"NO_SERVICE_AVAILABLE_CDS\", e[e.NO_SERVICE_AVAILABLE_CDN = 205] = \"NO_SERVICE_AVAILABLE_CDN\", e[e.NO_SERVICE_AVAILABLE_TDS = 206] = \"NO_SERVICE_AVAILABLE_TDS\", e[e.NO_SERVICE_AVAILABLE_REPORT = 207] = \"NO_SERVICE_AVAILABLE_REPORT\", e[e.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = \"NO_SERVICE_AVAILABLE_APP_CENTER\", e[e.NO_SERVICE_AVAILABLE_ENV0 = 209] = \"NO_SERVICE_AVAILABLE_ENV0\", e[e.NO_SERVICE_AVAILABLE_VOET = 210] = \"NO_SERVICE_AVAILABLE_VOET\", e[e.NO_SERVICE_AVAILABLE_STRING_UID = 211] = \"NO_SERVICE_AVAILABLE_STRING_UID\", e[e.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = \"NO_SERVICE_AVAILABLE_WEBRTC_UNILBS\", e[e.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = \"NO_SERVICE_AVAILABLE_UNILBS_FLV\", e;\n    }({}),\n    Sb = function (e) {\n      return e[e.K_TIMESTAMP_EXPIRED = 2] = \"K_TIMESTAMP_EXPIRED\", e[e.K_CHANNEL_PERMISSION_INVALID = 3] = \"K_CHANNEL_PERMISSION_INVALID\", e[e.K_CERTIFICATE_INVALID = 4] = \"K_CERTIFICATE_INVALID\", e[e.K_CHANNEL_NAME_EMPTY = 5] = \"K_CHANNEL_NAME_EMPTY\", e[e.K_CHANNEL_NOT_FOUND = 6] = \"K_CHANNEL_NOT_FOUND\", e[e.K_TICKET_INVALID = 7] = \"K_TICKET_INVALID\", e[e.K_CHANNEL_CONFLICTED = 8] = \"K_CHANNEL_CONFLICTED\", e[e.K_SERVICE_NOT_READY = 9] = \"K_SERVICE_NOT_READY\", e[e.K_SERVICE_TOO_HEAVY = 10] = \"K_SERVICE_TOO_HEAVY\", e[e.K_UID_BANNED = 14] = \"K_UID_BANNED\", e[e.K_IP_BANNED = 15] = \"K_IP_BANNED\", e[e.K_CHANNEL_BANNED = 16] = \"K_CHANNEL_BANNED\", e[e.K_AUTO_REBALANCE = 28] = \"K_AUTO_REBALANCE\", e[e.WARN_NO_AVAILABLE_CHANNEL = 103] = \"WARN_NO_AVAILABLE_CHANNEL\", e[e.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = \"WARN_LOOKUP_CHANNEL_TIMEOUT\", e[e.WARN_LOOKUP_CHANNEL_REJECTED = 105] = \"WARN_LOOKUP_CHANNEL_REJECTED\", e[e.WARN_OPEN_CHANNEL_TIMEOUT = 106] = \"WARN_OPEN_CHANNEL_TIMEOUT\", e[e.WARN_OPEN_CHANNEL_REJECTED = 107] = \"WARN_OPEN_CHANNEL_REJECTED\", e[e.WARN_REQUEST_DEFERRED = 108] = \"WARN_REQUEST_DEFERRED\", e[e.ERR_DYNAMIC_KEY_TIMEOUT = 109] = \"ERR_DYNAMIC_KEY_TIMEOUT\", e[e.ERR_NO_AUTHORIZED = 110] = \"ERR_NO_AUTHORIZED\", e[e.ERR_VOM_SERVICE_UNAVAILABLE = 111] = \"ERR_VOM_SERVICE_UNAVAILABLE\", e[e.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = \"ERR_NO_CHANNEL_AVAILABLE_CODE\", e[e.ERR_MASTER_VOCS_UNAVAILABLE = 114] = \"ERR_MASTER_VOCS_UNAVAILABLE\", e[e.ERR_INTERNAL_ERROR = 115] = \"ERR_INTERNAL_ERROR\", e[e.ERR_NO_ACTIVE_STATUS = 116] = \"ERR_NO_ACTIVE_STATUS\", e[e.ERR_INVALID_UID = 117] = \"ERR_INVALID_UID\", e[e.ERR_DYNAMIC_KEY_EXPIRED = 118] = \"ERR_DYNAMIC_KEY_EXPIRED\", e[e.ERR_STATIC_USE_DYANMIC_KE = 119] = \"ERR_STATIC_USE_DYANMIC_KE\", e[e.ERR_DYNAMIC_USE_STATIC_KE = 120] = \"ERR_DYNAMIC_USE_STATIC_KE\", e[e.ERR_NO_VOCS_AVAILABLE = 2e3] = \"ERR_NO_VOCS_AVAILABLE\", e[e.ERR_NO_VOS_AVAILABLE = 2001] = \"ERR_NO_VOS_AVAILABLE\", e[e.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = \"ERR_JOIN_CHANNEL_TIMEOUT\", e[e.ERR_REPEAT_JOIN_CHANNEL = 2003] = \"ERR_REPEAT_JOIN_CHANNEL\", e[e.ERR_JOIN_BY_MULTI_IP = 2004] = \"ERR_JOIN_BY_MULTI_IP\", e[e.ERR_NOT_JOINED = 2011] = \"ERR_NOT_JOINED\", e[e.ERR_REPEAT_JOIN_REQUEST = 2012] = \"ERR_REPEAT_JOIN_REQUEST\", e[e.ERR_INVALID_VENDOR_KEY = 2013] = \"ERR_INVALID_VENDOR_KEY\", e[e.ERR_INVALID_CHANNEL_NAME = 2014] = \"ERR_INVALID_CHANNEL_NAME\", e[e.ERR_INVALID_STRINGUID = 2015] = \"ERR_INVALID_STRINGUID\", e[e.ERR_TOO_MANY_USERS = 2016] = \"ERR_TOO_MANY_USERS\", e[e.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = \"ERR_SET_CLIENT_ROLE_TIMEOUT\", e[e.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = \"ERR_SET_CLIENT_ROLE_NO_PERMISSION\", e[e.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = \"ERR_SET_CLIENT_ROLE_ALREADY_IN_USE\", e[e.ERR_PUBLISH_REQUEST_INVALID = 2020] = \"ERR_PUBLISH_REQUEST_INVALID\", e[e.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = \"ERR_SUBSCRIBE_REQUEST_INVALID\", e[e.ERR_NOT_SUPPORTED_MESSAGE = 2022] = \"ERR_NOT_SUPPORTED_MESSAGE\", e[e.ERR_ILLEAGAL_PLUGIN = 2023] = \"ERR_ILLEAGAL_PLUGIN\", e[e.ERR_REJOIN_TOKEN_INVALID = 2024] = \"ERR_REJOIN_TOKEN_INVALID\", e[e.ERR_REJOIN_USER_NOT_JOINED = 2025] = \"ERR_REJOIN_USER_NOT_JOINED\", e[e.ERR_INVALID_OPTIONAL_INFO = 2027] = \"ERR_INVALID_OPTIONAL_INFO\", e[e.ILLEGAL_AES_PASSWORD = 2028] = \"ILLEGAL_AES_PASSWORD\", e[e.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = \"ILLEGAL_CLIENT_ROLE_LEVEL\", e[e.ERR_TOO_MANY_BROADCASTERS = 2031] = \"ERR_TOO_MANY_BROADCASTERS\", e[e.ERR_TOO_MANY_SUBSCRIBERS = 2032] = \"ERR_TOO_MANY_SUBSCRIBERS\", e[e.ERR_LICENSE_MISSING = 32769] = \"ERR_LICENSE_MISSING\", e[e.ERR_LICENSE_EXPIRED = 32771] = \"ERR_LICENSE_EXPIRED\", e[e.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = \"ERR_LICENSE_MINUTES_EXCEEDED\", e[e.ERR_LICENSE_PERIOD_INVALID = 32774] = \"ERR_LICENSE_PERIOD_INVALID\", e[e.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = \"ERR_LICENSE_MULTIPLE_SDK_SERVICE\", e[e.ERR_LICENSE_ILLEGAL = 32783] = \"ERR_LICENSE_ILLEGAL\", e[e.ERR_TEST_RECOVER = 9e3] = \"ERR_TEST_RECOVER\", e[e.ERR_TEST_TRYNEXT = 9001] = \"ERR_TEST_TRYNEXT\", e[e.ERR_TEST_RETRY = 9002] = \"ERR_TEST_RETRY\", e;\n    }({}),\n    gb = function (e) {\n      return e.CONNECTING = \"connecting\", e.CONNECTED = \"connected\", e.RECONNECTING = \"reconnecting\", e.CLOSED = \"closed\", e;\n    }({}),\n    Rb = function (e) {\n      return e.WS_CONNECTED = \"ws_connected\", e.WS_RECONNECTING = \"ws_reconnecting\", e.WS_CLOSED = \"ws_closed\", e.WS_RECONNECT_WAITTING_FINISH = \"ws_reconnect_waitting_finish\", e.WS_RECONNECT_CREATE_CONNECTION = \"ws_reconnect_create_connection\", e.ON_BINARY_DATA = \"on_binary_data\", e.REQUEST_RECOVER = \"request_recover\", e.REQUEST_JOIN_INFO = \"request_join_info\", e.REQUEST_REJOIN_INFO = \"req_rejoin_info\", e.IS_P2P_DISCONNECTED = \"is_p2p_dis\", e.DISCONNECT_P2P = \"dis_p2p\", e.ABORT_P2P_EXECUTION = \"abort_p2p_execution\", e.NEED_RENEW_SESSION = \"need-sid\", e.REPORT_JOIN_GATEWAY = \"report_join_gateway\", e.REQUEST_TIMEOUT = \"request_timeout\", e.REQUEST_SUCCESS = \"request_success\", e.JOIN_RESPONSE = \"join_response\", e.DATACHANNEL_PRECONNECT = \"datachannel_preconnect\", e.DATACHANNEL_CONNECTING = \"datachannel_connecting\", e.DATACHANNEL_FAILBACK = \"datachannel_failback\", e.P2P_CONNECTION = \"p2p_connection\", e.P2P_REMOTE_CANDIDATE_UPDATE = \"p2p_remote_candidate_update\", e.P2P_SUBSCRIBE = \"p2p_subscribe\", e.P2P_UNSUBSCRIBE = \"p2p_unsubscribe\", e.P2P_EXCHANGE_SDP = \"p2p_exchange_sdp\", e.P2P_ON_ADD_VIDEO_STREAM = \"p2p_on_add_video_stream\", e.P2P_ON_ADD_AUDIO_STREAM = \"p2p_on_add_audio_stream\", e;\n    }({}),\n    Cb = function (e) {\n      return e.PING = \"ping\", e.PING_BACK = \"ping_back\", e.JOIN = \"join_v3\", e.REJOIN = \"rejoin_v3\", e.LEAVE = \"leave\", e.SET_CLIENT_ROLE = \"set_client_role\", e.PUBLISH = \"publish\", e.PUBLISH_DATASTREAM = \"publish_datastream\", e.UNPUBLISH = \"unpublish\", e.UNPUBLISH_DATASTREAM = \"unpublish_datastream\", e.SUBSCRIBE = \"subscribe\", e.PRE_SUBSCRIBE = \"pre_subscribe\", e.SUBSCRIBE_DATASTREAM = \"subscribe_datastream\", e.SUBSCRIBE_STREAMS = \"subscribe_streams\", e.UNSUBSCRIBE = \"unsubscribe\", e.UNSUBSCRIBE_DATASTREAM = \"unsubscribe_datastream\", e.UNSUBSCRIBE_STREAMS = \"unsubscribe_streams\", e.SUBSCRIBE_CHANGE = \"subscribe_change\", e.TRAFFIC_STATS = \"traffic_stats\", e.RENEW_TOKEN = \"renew_token\", e.SWITCH_VIDEO_STREAM = \"switch_video_stream\", e.DEFAULT_VIDEO_STREAM = \"default_video_stream\", e.SET_FALLBACK_OPTION = \"set_fallback_option\", e.GATEWAY_INFO = \"gateway_info\", e.CONTROL = \"control\", e.SEND_METADATA = \"send_metadata\", e.DATA_STREAM = \"data_stream\", e.PICK_SVC_LAYER = \"pick_svc_layer\", e.RESTART_ICE = \"restart_ice\", e.CONNECT_PC = \"connect_pc\", e.SET_VIDEO_PROFILE = \"set_video_profile\", e.SET_PARAMETER = \"set_parameter\", e.SET_RTM2_FLAG = \"set_rtm2_flag\", e;\n    }({}),\n    vb = function (e) {\n      return e.WRTC_STATS = \"wrtc_stats\", e.WS_INFLATE_DATA_LENGTH = \"ws_inflate_data_length\", e.DENOISER_STATS = \"denoiser_stats\", e.EXTENSION_USAGE_STATS = \"extension_usage_stats\", e;\n    }({}),\n    Ib = function (e) {\n      return e.ON_USER_ONLINE = \"on_user_online\", e.ON_USER_OFFLINE = \"on_user_offline\", e.ON_STREAM_FALLBACK_UPDATE = \"on_stream_fallback_update\", e.ON_PUBLISH_STREAM = \"on_publish_stream\", e.ON_UPLINK_STATS = \"on_uplink_stats\", e.ON_P2P_LOST = \"on_p2p_lost\", e.ON_REMOVE_STREAM = \"on_remove_stream\", e.ON_ADD_AUDIO_STREAM = \"on_add_audio_stream\", e.ON_ADD_VIDEO_STREAM = \"on_add_video_stream\", e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = \"on_token_privilege_will_expire\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"on_token_privilege_did_expire\", e.ON_USER_BANNED = \"on_user_banned\", e.ON_USER_LICENSE_BANNED = \"on_user_license_banned\", e.ON_NOTIFICATION = \"on_notification\", e.ON_CRYPT_ERROR = \"on_crypt_error\", e.MUTE_AUDIO = \"mute_audio\", e.MUTE_VIDEO = \"mute_video\", e.UNMUTE_AUDIO = \"unmute_audio\", e.UNMUTE_VIDEO = \"unmute_video\", e.ON_P2P_OK = \"on_p2p_ok\", e.RECEIVE_METADATA = \"receive_metadata\", e.ON_DATA_STREAM = \"on_data_stream\", e.ON_RTP_CAPABILITY_CHANGE = \"on_rtp_capability_change\", e.ON_REMOTE_DATASTREAM_UPDATE = \"on_remote_datastream_update\", e.ON_REMOTE_FULL_DATASTREAM_INFO = \"on_remote_full_datastream_info\", e.ENABLE_LOCAL_VIDEO = \"enable_local_video\", e.DISABLE_LOCAL_VIDEO = \"disable_local_video\", e.ENABLE_LOCAL_AUDIO = \"enable_local_audio\", e.DISABLE_LOCAL_AUDIO = \"disable_local_audio\", e.ON_PUBLISHED_USER_LIST = \"on_published_user_list\", e;\n    }({}),\n    yb = function (e) {\n      return e.SEND_ONLY = \"SEND_ONLY\", e.RECEIVE_ONLY = \"RECEIVE_ONLY\", e;\n    }({}),\n    Ab = function (e) {\n      return e.CONNECTED = \"websocket:connected\", e.RECONNECTING = \"websocket:reconnecting\", e.WILL_RECONNECT = \"websocket:will_reconnect\", e.CLOSED = \"websocket:closed\", e.FAILED = \"websocket:failed\", e.ON_MESSAGE = \"websocket:on_message\", e.REQUEST_NEW_URLS = \"websocket:request_new_urls\", e.RECONNECT_WAITTING_FINISH = \"websocket:reconnect_waitting_finish\", e.RECONNECT_CREATE_CONNECTION = \"websocket:reconnect_create_connection\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"websocket:on_token_privilege_did_expire\", e;\n    }({});\n  class bb extends iI {\n    constructor(e) {\n      super(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"\", arguments.length > 2 ? arguments[2] : void 0), ng(this, \"name\", \"AgoraRTCException\");\n    }\n    print() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"error\";\n      return super.print(e, Qy);\n    }\n    throw() {\n      super.throw(Qy);\n    }\n  }\n  function wb(e) {\n    if (\"string\" != typeof e || !/^[a-zA-Z0-9 \\!\\#\\$\\%\\&\\(\\)\\+\\-\\:\\;\\<\\=\\.\\>\\?\\@\\[\\]\\^\\_\\{\\}\\|\\~\\,]{1,64}$/.test(e)) throw Qy.error(\"Invalid Channel Name \".concat(e)), new bb(tI.INVALID_PARAMS, \"The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,\");\n  }\n  function Ob(e) {\n    if (!function (e) {\n      return \"number\" == typeof e && Math.floor(e) === e && 0 <= e && e <= 4294967295;\n    }(e) && !lI(e, 1, 255)) throw new bb(tI.INVALID_PARAMS, \"[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]\");\n    \"string\" == typeof e && Qy.warn(\"You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.\");\n  }\n  let Nb = function (e) {\n      return e.TRANSCODE = \"mix_streaming\", e.RAW = \"raw_streaming\", e.INJECT = \"inject_streaming\", e;\n    }({}),\n    Db = function (e) {\n      return e[e.INJECT_STREAM_STATUS_START_SUCCESS = 0] = \"INJECT_STREAM_STATUS_START_SUCCESS\", e[e.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = \"INJECT_STREAM_STATUS_START_ALREADY_EXISTS\", e[e.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = \"INJECT_STREAM_STATUS_START_UNAUTHORIZED\", e[e.INJECT_STREAM_STATUS_START_TIMEOUT = 3] = \"INJECT_STREAM_STATUS_START_TIMEOUT\", e[e.INJECT_STREAM_STATUS_START_FAILED = 4] = \"INJECT_STREAM_STATUS_START_FAILED\", e[e.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = \"INJECT_STREAM_STATUS_STOP_SUCCESS\", e[e.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = \"INJECT_STREAM_STATUS_STOP_NOT_FOUND\", e[e.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = \"INJECT_STREAM_STATUS_STOP_UNAUTHORIZED\", e[e.INJECT_STREAM_STATUS_STOP_TIMEOUT = 8] = \"INJECT_STREAM_STATUS_STOP_TIMEOUT\", e[e.INJECT_STREAM_STATUS_STOP_FAILED = 9] = \"INJECT_STREAM_STATUS_STOP_FAILED\", e[e.INJECT_STREAM_STATUS_BROKEN = 10] = \"INJECT_STREAM_STATUS_BROKEN\", e;\n    }({});\n  const Pb = {\n      alpha: 1,\n      height: 640,\n      width: 360,\n      x: 0,\n      y: 0,\n      zOrder: 0,\n      audioChannel: 0\n    },\n    Lb = {\n      x: 0,\n      y: 0,\n      width: 160,\n      height: 160,\n      zOrder: 255,\n      alpha: 1\n    };\n  function kb(e, t) {\n    aI(e.url, \"\".concat(t, \".url\"), 1, 1e3, !1), dI(e.x) || oI(e.x, \"\".concat(t, \".x\"), 0, 1e4), dI(e.y) || oI(e.y, \"\".concat(t, \".y\"), 0, 1e4), dI(e.width) || oI(e.width, \"\".concat(t, \".width\"), 0, 1e4), dI(e.height) || oI(e.height, \"\".concat(t, \".height\"), 0, 1e4), dI(e.zOrder) || oI(e.zOrder, \"\".concat(t, \".zOrder\"), 0, 255), dI(e.alpha) || oI(e.alpha, \"\".concat(t, \".alpha\"), 0, 1, !1);\n  }\n  const Mb = {\n      audioBitrate: 48,\n      audioChannels: 1,\n      audioSampleRate: 48e3,\n      backgroundColor: 0,\n      height: 360,\n      lowLatency: !1,\n      videoBitrate: 400,\n      videoCodecProfile: 100,\n      videoCodecType: 1,\n      videoFrameRate: 15,\n      videoGop: 30,\n      width: 640,\n      images: [],\n      userConfigs: [],\n      userConfigExtraInfo: \"\"\n    },\n    Ub = {\n      audioBitrate: 48,\n      audioChannels: 2,\n      audioVolume: 100,\n      audioSampleRate: 48e3,\n      height: 0,\n      width: 0,\n      videoBitrate: 400,\n      videoFramerate: 15,\n      videoGop: 30\n    };\n  let xb = function (e) {\n      return e.WARNING = \"@live_uap-warning\", e.ERROR = \"@line_uap-error\", e.PUBLISH_STREAM_STATUS = \"@live_uap-publish-status\", e.INJECT_STREAM_STATUS = \"@live_uap-inject-status\", e.WORKER_STATUS = \"@live_uap-worker-status\", e.REQUEST_NEW_ADDRESS = \"@live_uap-request-address\", e;\n    }({}),\n    Vb = function (e) {\n      return e.REQUEST_WORKER_MANAGER_LIST = \"@live_req_worker_manager\", e;\n    }({}),\n    Fb = function (e) {\n      return e[e.LIVE_STREAM_RESPONSE_SUCCEED = 200] = \"LIVE_STREAM_RESPONSE_SUCCEED\", e[e.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = \"LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM\", e[e.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = \"LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR\", e[e.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = \"LIVE_STREAM_RESPONSE_BAD_STREAM\", e[e.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = \"LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR\", e[e.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = \"LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST\", e[e.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = \"LIVE_STREAM_RESPONSE_NOT_AUTHORIZED\", e[e.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = \"LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE\", e[e.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = \"LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN\", e[e.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = \"LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH\", e[e.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = \"LIVE_STREAM_RESPONSE_NOT_SUPPORTED\", e[e.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = \"LIVE_STREAM_RESPONSE_MAX_STREAM_NUM\", e[e.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = \"LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR\", e[e.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = \"LIVE_STREAM_RESPONSE_WORKER_LOST\", e[e.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = \"LIVE_STREAM_RESPONSE_RESOURCE_LIMIT\", e[e.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = \"LIVE_STREAM_RESPONSE_WORKER_QUIT\", e[e.ERROR_FAIL_SEND_MESSAGE = 504] = \"ERROR_FAIL_SEND_MESSAGE\", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE\", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT\", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH\", e[e.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = \"PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN\", e;\n    }({});\n  function Bb(e) {\n    if (!e.channelName) throw new bb(tI.INVALID_PARAMS, \"invalid channelName in info\");\n    if (\"number\" != typeof e.uid) throw new bb(tI.INVALID_PARAMS, \"invalid uid in info, uid must be a number\");\n    return e.token && aI(e.token, \"info.token\", 1, 2047), Ob(e.uid), wb(e.channelName), !0;\n  }\n  let jb = function (e) {\n      return e[e.SetSdkProfile = 0] = \"SetSdkProfile\", e[e.SetSourceChannel = 1] = \"SetSourceChannel\", e[e.SetSourceUserId = 2] = \"SetSourceUserId\", e[e.SetDestChannel = 3] = \"SetDestChannel\", e[e.StartPacketTransfer = 4] = \"StartPacketTransfer\", e[e.StopPacketTransfer = 5] = \"StopPacketTransfer\", e[e.UpdateDestChannel = 6] = \"UpdateDestChannel\", e[e.Reconnect = 7] = \"Reconnect\", e[e.SetVideoProfile = 8] = \"SetVideoProfile\", e;\n    }({}),\n    Gb = function (e) {\n      return e.NETWORK_DISCONNECTED = \"NETWORK_DISCONNECTED\", e.NETWORK_CONNECTED = \"NETWORK_CONNECTED\", e.PACKET_JOINED_SRC_CHANNEL = \"PACKET_JOINED_SRC_CHANNEL\", e.PACKET_JOINED_DEST_CHANNEL = \"PACKET_JOINED_DEST_CHANNEL\", e.PACKET_SENT_TO_DEST_CHANNEL = \"PACKET_SENT_TO_DEST_CHANNEL\", e.PACKET_RECEIVED_VIDEO_FROM_SRC = \"PACKET_RECEIVED_VIDEO_FROM_SRC\", e.PACKET_RECEIVED_AUDIO_FROM_SRC = \"PACKET_RECEIVED_AUDIO_FROM_SRC\", e.PACKET_UPDATE_DEST_CHANNEL = \"PACKET_UPDATE_DEST_CHANNEL\", e.PACKET_UPDATE_DEST_CHANNEL_REFUSED = \"PACKET_UPDATE_DEST_CHANNEL_REFUSED\", e.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = \"PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE\", e;\n    }({}),\n    Wb = function (e) {\n      return e.RELAY_STATE_IDLE = \"RELAY_STATE_IDLE\", e.RELAY_STATE_CONNECTING = \"RELAY_STATE_CONNECTING\", e.RELAY_STATE_RUNNING = \"RELAY_STATE_RUNNING\", e.RELAY_STATE_FAILURE = \"RELAY_STATE_FAILURE\", e;\n    }({}),\n    Hb = function (e) {\n      return e.RELAY_OK = \"RELAY_OK\", e.SERVER_CONNECTION_LOST = \"SERVER_CONNECTION_LOST\", e.SRC_TOKEN_EXPIRED = \"SRC_TOKEN_EXPIRED\", e.DEST_TOKEN_EXPIRED = \"DEST_TOKEN_EXPIRED\", e;\n    }({}),\n    Kb = function (e) {\n      return e.High = \"high\", e.Low = \"low\", e.Audio = \"audio\", e.Screen = \"screen\", e.ScreenLow = \"screen_low\", e;\n    }({}),\n    Yb = function (e) {\n      return e.DISCONNECT = \"disconnect\", e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.NETWORK_QUALITY = \"network-quality\", e.STREAM_TYPE_CHANGE = \"stream-type-change\", e.IS_P2P_DISCONNECTED = \"is-p2p-dis\", e.DISCONNECT_P2P = \"dis-p2p\", e.REQUEST_NEW_GATEWAY_LIST = \"req-gate-url\", e.NEED_RENEW_SESSION = \"need-sid\", e.REQUEST_P2P_CONNECTION_PARAMS = \"request-p2p-connection-params\", e.JOIN_RESPONSE = \"join-response\", e.REQUEST_DC_CONNECTION_PARAMS = \"request-dc-connection-params\", e.RESET_CONNECTION_EVENTS = \"reset-connection-events\", e.DATACHANNEL_PRECONNECT = \"datachannel_preconnect\", e.DATACHANNEL_FAILBACK = \"datachannel_failback\", e.RESET_SIGNAL = \"reset-signal\", e;\n    }({}),\n    qb = function (e) {\n      return e.P2P_DISCONNECTED = \"P2P_DISCONNECTED\", e.A_ROUND_WS_FAILED = \"A_ROUND_WS_FAILED\", e.TIMEOUT = \"TIMEOUT\", e.UNKNOWN_REASON = \"UNKNOWN_REASON\", e;\n    }({}),\n    zb = function (e) {\n      return e[e.Nothing = 0] = \"Nothing\", e[e.Audio = 1] = \"Audio\", e[e.LwoVideo = 2] = \"LwoVideo\", e[e.Video = 4] = \"Video\", e[e.Data = 8] = \"Data\", e[e.DataStream0 = 256] = \"DataStream0\", e[e.DataStream1 = 512] = \"DataStream1\", e[e.DataStream2 = 1024] = \"DataStream2\", e[e.DataStream3 = 2048] = \"DataStream3\", e[e.DataStream4 = 4096] = \"DataStream4\", e[e.DataStream5 = 8192] = \"DataStream5\", e[e.DataStream6 = 16384] = \"DataStream6\", e[e.DataStream7 = 32768] = \"DataStream7\", e;\n    }({}),\n    Jb = function (e) {\n      return e[e.websocket = 0] = \"websocket\", e[e.datachannel = 1] = \"datachannel\", e;\n    }({}),\n    Xb = function (e) {\n      return e.CHINA = \"CHINA\", e.ASIA = \"ASIA\", e.NORTH_AMERICA = \"NORTH_AMERICA\", e.EUROPE = \"EUROPE\", e.JAPAN = \"JAPAN\", e.INDIA = \"INDIA\", e.KOREA = \"KOREA\", e.HKMC = \"HKMC\", e.US = \"US\", e.OCEANIA = \"OCEANIA\", e.SOUTH_AMERICA = \"SOUTH_AMERICA\", e.AFRICA = \"AFRICA\", e.OVERSEA = \"OVERSEA\", e.GLOBAL = \"GLOBAL\", e.EXTENSIONS = \"EXTENSIONS\", e;\n    }({});\n  const Qb = [Xb.AFRICA, Xb.ASIA, Xb.CHINA, Xb.EUROPE, Xb.GLOBAL, Xb.INDIA, Xb.JAPAN, Xb.NORTH_AMERICA, Xb.OCEANIA, Xb.OVERSEA, Xb.SOUTH_AMERICA];\n  let Zb = function (e) {\n    return e.CHINA = \"CN\", e.ASIA = \"AS\", e.NORTH_AMERICA = \"NA\", e.EUROPE = \"EU\", e.JAPAN = \"JP\", e.INDIA = \"IN\", e.KOREA = \"KR\", e.HKMC = \"HK\", e.US = \"US\", e.OCEANIA = \"OC\", e.SOUTH_AMERICA = \"SA\", e.AFRICA = \"AF\", e.OVERSEA = \"OVERSEA\", e.GLOBAL = \"GLOBAL\", e.EXTENSIONS = \"GLOBAL\", e;\n  }({});\n  const $b = {\n    CHINA: {},\n    ASIA: {\n      CODE: Zb.ASIA,\n      WEBCS_DOMAIN: [\"ap-web-1-asia.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-asia.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-asia.agora.io\"],\n      CDS_AP: [\"cds-ap-web-asia.agora.io\", \"cds-ap-web-asia2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-asia.agora.io\", \"sua-ap-web-asia2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-asia.agora.io\", \"uap-ap-web-asia2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-asia.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-asia.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-asia.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"southeast-asia.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    NORTH_AMERICA: {\n      CODE: Zb.NORTH_AMERICA,\n      WEBCS_DOMAIN: [\"ap-web-1-north-america.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-north-america.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-america.agora.io\"],\n      CDS_AP: [\"cds-ap-web-america.agora.io\", \"cds-ap-web-america2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-america.agora.io\", \"sua-ap-web-america2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-america.agora.io\", \"uap-ap-web-america2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-north-america.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-north-america.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-north-america.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"east-usa.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    EUROPE: {\n      CODE: Zb.EUROPE,\n      WEBCS_DOMAIN: [\"ap-web-1-europe.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-europe.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-europe.agora.io\"],\n      CDS_AP: [\"cds-ap-web-europe.agora.io\", \"cds-ap-web-europe2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-europe.agora.io\", \"sua-ap-web-europe.agora.io\"],\n      UAP_AP: [\"uap-ap-web-europe.agora.io\", \"uap-ap-web-europe2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-europe.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-europe.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-europe.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"europe.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    JAPAN: {\n      CODE: Zb.JAPAN,\n      WEBCS_DOMAIN: [\"ap-web-1-japan.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-japan.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-japan.agora.io\"],\n      CDS_AP: [\"cds-ap-web-japan.agora.io\", \"cds-ap-web-japan2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-japan.agora.io\", \"sua-ap-web-japan2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-japan.agora.io\", \"uap-ap-web-japan2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-japan.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-japan.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-japan.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"japan.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    INDIA: {\n      CODE: Zb.INDIA,\n      WEBCS_DOMAIN: [\"ap-web-1-india.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-india.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-india.agora.io\"],\n      CDS_AP: [\"cds-ap-web-india.agora.io\", \"cds-ap-web-india2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-india.agora.io\", \"sua-ap-web-india2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-india.agora.io\", \"uap-ap-web-india2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-india.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-india.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-india.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"india.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    KOREA: {\n      CODE: Zb.KOREA,\n      WEBCS_DOMAIN: [\"ap-web-1-korea.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-korea.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-korea.agora.io\"],\n      CDS_AP: [\"cds-ap-web-korea.agora.io\", \"cds-ap-web-korea2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-korea.agora.io\", \"sua-ap-web-korea2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-korea.agora.io\", \"uap-ap-web-korea2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-korea.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-korea.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-korea.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"korea.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    HKMC: {\n      CODE: Zb.HKMC,\n      WEBCS_DOMAIN: [\"ap-web-1-hkmc.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-hkmc.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-hkmc.agora.io\"],\n      CDS_AP: [\"cds-ap-web-hkmc.agora.io\", \"cds-ap-web-hkmc2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-hkmc.agora.io\", \"sua-ap-web-hkmc2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-hkmc.agora.io\", \"uap-ap-web-hkmc2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-hkmc.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-hkmc.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-hkmc.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"hkmc.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    US: {\n      CODE: Zb.US,\n      WEBCS_DOMAIN: [\"ap-web-1-us.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-us.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-us.agora.io\"],\n      CDS_AP: [\"cds-ap-web-us.agora.io\", \"cds-ap-web-us2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-us.agora.io\", \"sua-ap-web-us2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-us.agora.io\", \"uap-ap-web-us2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-us.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-us.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-us.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"us.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    OVERSEA: {\n      CODE: Zb.OVERSEA,\n      WEBCS_DOMAIN: [\"ap-web-1-oversea.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-oversea.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-oversea.agora.io\"],\n      CDS_AP: [\"cds-ap-web-oversea.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-oversea.agora.io\"],\n      UAP_AP: [\"uap-ap-web-oversea.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-oversea.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-oversea.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-oversea.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.agora.io\"]\n    },\n    GLOBAL: {\n      CODE: Zb.GLOBAL,\n      WEBCS_DOMAIN: [\"webrtc2-ap-web-1.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-ap-web-3.agora.io\"],\n      PROXY_CS: [\"ap-proxy-1.agora.io\", \"ap-proxy-2.agora.io\"],\n      CDS_AP: [\"cds-ap-web-1.agora.io\", \"cds-ap-web-3.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-1.agora.io\", \"sua-ap-web-3.agora.io\"],\n      UAP_AP: [\"uap-ap-web-1.agora.io\", \"uap-ap-web-3.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    OCEANIA: {\n      CODE: Zb.OCEANIA,\n      WEBCS_DOMAIN: [\"ap-web-1-oceania.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-oceania.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-oceania.agora.io\"],\n      CDS_AP: [\"cds-ap-web-oceania.agora.io\", \"cds-ap-web-oceania2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-oceania.agora.io\", \"sua-ap-web-oceania2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-oceania.agora.io\", \"uap-ap-web-oceania2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-oceania.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-oceania.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-oceania.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"oceania.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    SOUTH_AMERICA: {\n      CODE: Zb.SOUTH_AMERICA,\n      WEBCS_DOMAIN: [\"ap-web-1-south-america.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-south-america.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-south-america.agora.io\"],\n      CDS_AP: [\"cds-ap-web-south-america.agora.io\", \"cds-ap-web-south-america2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-south-america.agora.io\", \"sua-ap-web-south-america2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-south-america.agora.io\", \"uap-ap-web-south-america2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-south-america.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-south-america.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-south-america.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"south-america.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    AFRICA: {\n      CODE: Zb.AFRICA,\n      WEBCS_DOMAIN: [\"ap-web-1-africa.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-africa.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-africa.agora.io\"],\n      CDS_AP: [\"cds-ap-web-africa.agora.io\", \"cds-ap-web-africa2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-africa.agora.io\", \"sua-ap-web-africa2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-africa.agora.io\", \"uap-ap-web-africa2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-africa.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-africa.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-south-africa.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"africa.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    EXTENSIONS: {}\n  };\n  yy && ($b.CHINA = {\n    CODE: Zb.CHINA,\n    WEBCS_DOMAIN: [\"webrtc2-2.ap.sd-rtn.com\"],\n    WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-4.ap.sd-rtn.com\"],\n    PROXY_CS: [\"proxy-web.ap.sd-rtn.com\"],\n    CDS_AP: [\"cds-web-2.ap.sd-rtn.com\", \"cds-web-4.ap.sd-rtn.com\"],\n    ACCOUNT_REGISTER: [\"sua-web-2.ap.sd-rtn.com\", \"sua-web-4.ap.sd-rtn.com\"],\n    UAP_AP: [\"uap-web-2.ap.sd-rtn.com\", \"uap-web-4.ap.sd-rtn.com\"],\n    EVENT_REPORT_DOMAIN: [\"web-3.statscollector.sd-rtn.com\"],\n    EVENT_REPORT_BACKUP_DOMAIN: [\"web-4.statscollector.sd-rtn.com\"],\n    LOG_UPLOAD_SERVER: [\"logservice-china.agora.io\"],\n    PROXY_SERVER_TYPE3: [\"east-cn.webrtc-cloud-proxy.sd-rtn.com\"]\n  });\n  let ew = function (e) {\n    return e.UPDATE_BITRATE_LIMIT = \"update_bitrate_limit\", e;\n  }({});\n  class tw extends SI {\n    constructor(e, t) {\n      super(), ng(this, \"onICEConnectionStateChange\", void 0), ng(this, \"onConnectionStateChange\", void 0), ng(this, \"onDTLSTransportStateChange\", void 0), ng(this, \"onDTLSTransportError\", void 0), ng(this, \"onICETransportStateChange\", void 0), ng(this, \"onFirstAudioReceived\", void 0), ng(this, \"onFirstVideoReceived\", void 0), ng(this, \"onFirstAudioDecoded\", void 0), ng(this, \"onFirstVideoDecoded\", void 0), ng(this, \"onFirstVideoDecodedTimeout\", void 0), ng(this, \"onSelectedLocalCandidateChanged\", void 0), ng(this, \"onSelectedRemoteCandidateChanged\", void 0), ng(this, \"getLocalVideoStats\", void 0);\n    }\n  }\n  class iw extends tw {\n    constructor(e, t) {\n      super(e, t), ng(this, \"establishPromise\", void 0);\n    }\n  }\n  let nw = function (e) {\n      return e.VIDEO = \"video\", e.AUDIO = \"audio\", e;\n    }({}),\n    rw = function (e) {\n      return e[e.UDP = 0] = \"UDP\", e[e.TCP = 1] = \"TCP\", e[e.RELAY = 2] = \"RELAY\", e;\n    }({}),\n    ow = function (e) {\n      return e[e.FIRST_CONNECTION = 0] = \"FIRST_CONNECTION\", e[e.TCP_RESTART = 1] = \"TCP_RESTART\", e[e.RELAY_RESTART = 2] = \"RELAY_RESTART\", e[e.OLD_FIRST_CONNECTION = 10] = \"OLD_FIRST_CONNECTION\", e[e.OLD_RESTART = 11] = \"OLD_RESTART\", e[e.DISCONNECTED_OR_FAILED = 20] = \"DISCONNECTED_OR_FAILED\", e;\n    }({}),\n    sw = function (e) {\n      return e.LocalVideoTrack = \"videoTrack\", e.LocalAudioTrack = \"audioTrack\", e.LocalVideoLowTrack = \"videoLowTrack\", e;\n    }({}),\n    aw = function (e) {\n      return e.New = \"new\", e.Connected = \"connected\", e.Reconnecting = \"reconnecting\", e.Disconnected = \"disconnected\", e;\n    }({}),\n    cw = function (e) {\n      return e.StateChange = \"stateChange\", e.IceConnectionStateChange = \"iceConnectionStateChange\", e.RequestMuteLocal = \"requestMuteLocal\", e.RequestUnmuteLocal = \"requestUnmuteLocal\", e.RequestRePublish = \"requestRePublish\", e.RequestRePublishDataChannel = \"requestRePublishDataChannel\", e.RequestReSubscribe = \"requestReSubscribe\", e.RequestUploadStats = \"requestUploadStats\", e.RequestUpload = \"requestUpload\", e.MediaReconnectStart = \"MediaReconnectStart\", e.MediaReconnectEnd = \"MediaReconnectEnd\", e.NeedSignalRTT = \"NeedSignalRTT\", e.RequestRestartICE = \"RequestRestartIce\", e.PeerConnectionStateChange = \"PeerConnectionStateChange\", e.RequestReconnect = \"RequestReconnect\", e.RequestReconnectPC = \"RequestReconnectPC\", e.RequestUnpublishForReconnectPC = \"RequestUnpublishForReconnectPC\", e.P2PLost = \"P2PLost\", e.UpdateVideoEncoder = \"UpdateVideoEncoder\", e.ConnectionTypeChange = \"ConnectionTypeChange\", e.RequestLowStreamParameter = \"RequestLowStreamParameter\", e.QueryClientConnectionState = \"QueryClientConnectionState\", e.LocalCandidate = \"LocalCandidate\", e.RequestP2PMuteLocal = \"requestP2PMuteLocal\", e.RequestP2PUnPublish = \"RequestP2PUnPublish\", e.RequestP2PUnmuteRemote = \"RequestP2PUnmuteRemote\", e.RequestP2PMuteRemote = \"RequestP2PMuteRemote\", e.RequestP2PRestartICE = \"RequestP2PRestartICE\", e;\n    }({}),\n    dw = function (e) {\n      return e.CONNECTING = \"CONNECTING\", e.RECONNECTING = \"RECONNECTING\", e.CONNECTED = \"CONNECTED\", e.CLOSED = \"CLOSED\", e;\n    }({}),\n    lw = function (e) {\n      return e[e.CONNECT_AP = 0] = \"CONNECT_AP\", e[e.AP_CONNECTED = 1] = \"AP_CONNECTED\", e[e.CONNECT_WORKER_MANAGER = 2] = \"CONNECT_WORKER_MANAGER\", e[e.WORKER_MANAGER_CONNECTED = 3] = \"WORKER_MANAGER_CONNECTED\", e[e.GET_WORKER_MANAGER_RESPONSE = 4] = \"GET_WORKER_MANAGER_RESPONSE\", e[e.CONNECT_WORKER = 5] = \"CONNECT_WORKER\", e[e.WORKER_CONNECTED = 6] = \"WORKER_CONNECTED\", e[e.CLOSED = 7] = \"CLOSED\", e;\n    }({}),\n    hw = function (e) {\n      return e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.STATE_CHANGE = \"state-change\", e.INSPECT_RESULT = \"inspect-result\", e.CLIENT_LOCAL_VIDEO_TRACK = \"client-local-video-track\", e.REQUEST_NEW_WORKER_URL = \"request-new-worker-url\", e;\n    }({}),\n    uw = function (e) {\n      return e.NETWORK_ERROR = \"NETWORK_ERROR\", e.SERVER_ERROR = \"SERVER_ERROR\", e.MULTI_IP = \"MULTI_IP\", e.TIMEOUT = \"TIMEOUT\", e.OFFLINE = \"OFFLINE\", e.LEAVE = \"LEAVE\", e.P2P_FAILED = \"P2P_FAILED\", e.FALLBACK = \"FALLBACK\", e;\n    }({}),\n    pw = function (e) {\n      return e.CONNECTED = \"transmitter:connected\", e.RECONNECTING = \"transmitter:reconnecting\", e.WILL_RECONNECT = \"transmitter:will_reconnect\", e.CLOSED = \"transmitter:closed\", e.FAILED = \"transmitter:failed\", e.ON_MESSAGE = \"transmitter:on_message\", e.REQUEST_NEW_URLS = \"transmitter:request_new_urls\", e.RECONNECT_WAITTING_FINISH = \"transmitter:reconnect_waitting_finish\", e.RECONNECT_CREATE_CONNECTION = \"transmitter:reconnect_create_connection\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"transmitter:on_token_privilege_did_expire\", e.TO_CONNECT_DATACHANNEL = \"transmitter:to_connect_datachannel\", e.FAILBACK = \"transmitter:failback\", e;\n    }({}),\n    _w = function (e) {\n      return e.CAMERA_CHANGED = \"camera-changed\", e.MICROPHONE_CHANGED = \"microphone-changed\", e.PLAYBACK_DEVICE_CHANGED = \"playback-device-changed\", e.AUDIO_AUTOPLAY_FAILED = \"audio-autoplay-failed\", e.AUTOPLAY_FAILED = \"autoplay-failed\", e.AUDIO_CONTEXT_STATE_CHANGED = \"audio-context-state-changed\", e.SECURITY_POLICY_VIOLATION = \"security-policy-violation\", e;\n    }({}),\n    Ew = function (e) {\n      return e.CONNECTING = \"CONNECTING\", e.RECONNECTING = \"RECONNECTING\", e.CONNECTED = \"CONNECTED\", e.CLOSED = \"CLOSED\", e;\n    }({}),\n    mw = function (e) {\n      return e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.STATE_CHANGE = \"state-change\", e.INSPECT_RESULT = \"inspect-result\", e.CLIENT_LOCAL_VIDEO_TRACK = \"client-local-video-track\", e.REQUEST_NEW_WORKER_URL = \"request-new-worker-url\", e;\n    }({}),\n    fw = function (e) {\n      return e[e.CONNECT_AP = 0] = \"CONNECT_AP\", e[e.AP_CONNECTED = 1] = \"AP_CONNECTED\", e[e.CONNECT_WORKER_MANAGER = 2] = \"CONNECT_WORKER_MANAGER\", e[e.WORKER_MANAGER_CONNECTED = 3] = \"WORKER_MANAGER_CONNECTED\", e[e.GET_WORKER_MANAGER_RESPONSE = 4] = \"GET_WORKER_MANAGER_RESPONSE\", e[e.CONNECT_WORKER = 5] = \"CONNECT_WORKER\", e[e.WORKER_CONNECTED = 6] = \"WORKER_CONNECTED\", e[e.CLOSED = 7] = \"CLOSED\", e;\n    }({}),\n    Tw = function (e) {\n      return e.CALL = \"call\", e.CANDIDATE = \"candidate\", e.PUBLISH = \"publish\", e.UNPUBLISH = \"unpublish\", e.CONTROL = \"control\", e.RESTART_ICE = \"restart_ice\", e.ACK = \"ack\", e.RESPONSE = \"response\", e.JOIN = \"join\", e.CHECK = \"check\", e;\n    }({}),\n    Sw = function (e) {\n      return e.ABORT = \"abort\", e;\n    }({}),\n    gw = function (e) {\n      return e.MUTE_LOCAL_AUDIO = \"mute_local_audio\", e.MUTE_LOCAL_VIDEO = \"mute_local_video\", e.UNMUTE_LOCAL_AUDIO = \"unmute_local_audio\", e.UNMUTE_LOCAL_VIDEO = \"unmute_local_video\", e;\n    }({}),\n    Rw = function (e) {\n      return e.P2P_TOKEN_TIMEOUT = \"p2p_token_timeout\", e.P2P_TOKEN_CHANGED = \"p2p_token_changed\", e;\n    }({});\n  const Cw = {\n    [Eb.ACCESS_POINT]: {\n      [Tb.NO_FLAG_SET]: {\n        desc: \"flag is zero\",\n        retry: !1\n      },\n      [Tb.FLAG_SET_BUT_EMPTY]: {\n        desc: \"flag is empty\",\n        retry: !1\n      },\n      [Tb.INVALID_FALG_SET]: {\n        desc: \"invalid flag\",\n        retry: !1\n      },\n      [Tb.FLAG_SET_BUT_NO_RE]: {\n        desc: \"flag set unilbs but no request\",\n        retry: !1\n      },\n      [Tb.INVALID_SERVICE_ID]: {\n        desc: \"invalid service id\",\n        retry: !1\n      },\n      [Tb.NO_SERVICE_AVAILABLE]: {\n        desc: \"no service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_P2P]: {\n        desc: \"no unilbs p2p service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_VOICE]: {\n        desc: \"no unilbs voice service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_WEBRTC]: {\n        desc: \"no unilbs webrtc service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_CDS]: {\n        desc: \"no cds service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_CDN]: {\n        desc: \"no cdn dispatcher service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_TDS]: {\n        desc: \"no tds service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_REPORT]: {\n        desc: \"no unilbs report service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_APP_CENTER]: {\n        desc: \"no app center service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_ENV0]: {\n        desc: \"no unilbs sig env0 service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_VOET]: {\n        desc: \"no unilbs voet service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_STRING_UID]: {\n        desc: \"no string uid service available\",\n        retry: !0\n      },\n      [Tb.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: {\n        desc: \"no webrtc unilbs service available\",\n        retry: !0\n      }\n    },\n    [Eb.UNILBS]: {\n      [fb.INVALID_VENDOR_KEY]: {\n        desc: \"invalid vendor key, can not find appid\",\n        retry: !1\n      },\n      [fb.INVALID_CHANNEL_NAME]: {\n        desc: \"invalid channel name\",\n        retry: !1\n      },\n      [fb.INTERNAL_ERROR]: {\n        desc: \"unilbs internal error\",\n        retry: !1\n      },\n      [fb.NO_AUTHORIZED]: {\n        desc: \"invalid token, authorized failed\",\n        retry: !1\n      },\n      [fb.DYNAMIC_KEY_TIMEOUT]: {\n        desc: \"dynamic key or token timeout\",\n        retry: !1\n      },\n      [fb.NO_ACTIVE_STATUS]: {\n        desc: \"no active status\",\n        retry: !1\n      },\n      [fb.DYNAMIC_KEY_EXPIRED]: {\n        desc: \"dynamic key expired\",\n        retry: !1\n      },\n      [fb.STATIC_USE_DYNAMIC_KEY]: {\n        desc: \"static use dynamic key\",\n        retry: !1\n      },\n      [fb.DYNAMIC_USE_STATIC_KEY]: {\n        desc: \"dynamic use static key\",\n        retry: !1\n      },\n      [fb.USER_OVERLOAD]: {\n        desc: \"amount of users over load\",\n        retry: !1\n      },\n      [fb.FORBIDDEN_REGION]: {\n        desc: \"the request is forbidden in this area\",\n        retry: !1\n      },\n      [fb.CANNOT_MEET_AREA_DEMAND]: {\n        desc: \"unable to allocate services in this area\",\n        retry: !1\n      }\n    },\n    [Eb.STRING_UID_ALLOCATOR]: {\n      [mb.IIIEGAL_APPID]: {\n        desc: \"invalid appid\",\n        retry: !1\n      },\n      [mb.IIIEGAL_UID]: {\n        desc: \"invalid string uid\",\n        retry: !1\n      },\n      [mb.INTERNAL_ERROR]: {\n        desc: \"string uid allocator internal error\",\n        retry: !0\n      }\n    }\n  };\n  function vw(e) {\n    const t = Cw[Math.floor(e / 1e4)];\n    if (!t) return {\n      desc: \"unknown error\",\n      retry: !1\n    };\n    const i = t[e % 1e4];\n    if (!i) {\n      if (Math.floor(e / 1e4) === Eb.ACCESS_POINT) {\n        const t = e % 1e4;\n        if (\"1\" === t.toString()[0]) return {\n          desc: e.toString(),\n          retry: !1\n        };\n        if (\"2\" === t.toString()[0]) return {\n          desc: e.toString(),\n          retry: !0\n        };\n      }\n      return {\n        desc: \"unknown error\",\n        retry: !1\n      };\n    }\n    return i;\n  }\n  const Iw = {\n    [Sb.K_TIMESTAMP_EXPIRED]: {\n      desc: \"K_TIMESTAMP_EXPIRED\",\n      action: \"failed\"\n    },\n    [Sb.K_CHANNEL_PERMISSION_INVALID]: {\n      desc: \"K_CHANNEL_PERMISSION_INVALID\",\n      action: \"failed\"\n    },\n    [Sb.K_CERTIFICATE_INVALID]: {\n      desc: \"K_CERTIFICATE_INVALID\",\n      action: \"failed\"\n    },\n    [Sb.K_CHANNEL_NAME_EMPTY]: {\n      desc: \"K_CHANNEL_NAME_EMPTY\",\n      action: \"failed\"\n    },\n    [Sb.K_CHANNEL_NOT_FOUND]: {\n      desc: \"K_CHANNEL_NOT_FOUND\",\n      action: \"failed\"\n    },\n    [Sb.K_TICKET_INVALID]: {\n      desc: \"K_TICKET_INVALID\",\n      action: \"failed\"\n    },\n    [Sb.K_CHANNEL_CONFLICTED]: {\n      desc: \"K_CHANNEL_CONFLICTED\",\n      action: \"failed\"\n    },\n    [Sb.K_SERVICE_NOT_READY]: {\n      desc: \"K_SERVICE_NOT_READY\",\n      action: \"tryNext\"\n    },\n    [Sb.K_SERVICE_TOO_HEAVY]: {\n      desc: \"K_SERVICE_TOO_HEAVY\",\n      action: \"tryNext\"\n    },\n    [Sb.K_UID_BANNED]: {\n      desc: \"K_UID_BANNED\",\n      action: \"failed\"\n    },\n    [Sb.K_IP_BANNED]: {\n      desc: \"K_IP_BANNED\",\n      action: \"failed\"\n    },\n    [Sb.K_AUTO_REBALANCE]: {\n      desc: \"k_AUTO_REBALANCE\",\n      action: \"recover\"\n    },\n    [Sb.ERR_INVALID_VENDOR_KEY]: {\n      desc: \"ERR_INVALID_VENDOR_KEY\",\n      action: \"failed\"\n    },\n    [Sb.ERR_INVALID_CHANNEL_NAME]: {\n      desc: \"ERR_INVALID_CHANNEL_NAME\",\n      action: \"failed\"\n    },\n    [Sb.WARN_NO_AVAILABLE_CHANNEL]: {\n      desc: \"WARN_NO_AVAILABLE_CHANNEL\",\n      action: \"failed\"\n    },\n    [Sb.WARN_LOOKUP_CHANNEL_TIMEOUT]: {\n      desc: \"WARN_LOOKUP_CHANNEL_TIMEOUT\",\n      action: \"tryNext\"\n    },\n    [Sb.WARN_LOOKUP_CHANNEL_REJECTED]: {\n      desc: \"WARN_LOOKUP_CHANNEL_REJECTED\",\n      action: \"failed\"\n    },\n    [Sb.WARN_OPEN_CHANNEL_TIMEOUT]: {\n      desc: \"WARN_OPEN_CHANNEL_TIMEOUT\",\n      action: \"tryNext\"\n    },\n    [Sb.WARN_OPEN_CHANNEL_REJECTED]: {\n      desc: \"WARN_OPEN_CHANNEL_REJECTED\",\n      action: \"failed\"\n    },\n    [Sb.WARN_REQUEST_DEFERRED]: {\n      desc: \"WARN_REQUEST_DEFERRED\",\n      action: \"failed\"\n    },\n    [Sb.ERR_DYNAMIC_KEY_TIMEOUT]: {\n      desc: \"ERR_DYNAMIC_KEY_TIMEOUT\",\n      action: \"failed\"\n    },\n    [Sb.ERR_NO_AUTHORIZED]: {\n      desc: \"ERR_NO_AUTHORIZED\",\n      action: \"failed\"\n    },\n    [Sb.ERR_VOM_SERVICE_UNAVAILABLE]: {\n      desc: \"ERR_VOM_SERVICE_UNAVAILABLE\",\n      action: \"tryNext\"\n    },\n    [Sb.ERR_NO_CHANNEL_AVAILABLE_CODE]: {\n      desc: \"ERR_NO_CHANNEL_AVAILABLE_CODE\",\n      action: \"failed\"\n    },\n    [Sb.ERR_MASTER_VOCS_UNAVAILABLE]: {\n      desc: \"ERR_MASTER_VOCS_UNAVAILABLE\",\n      action: \"tryNext\"\n    },\n    [Sb.ERR_INTERNAL_ERROR]: {\n      desc: \"ERR_INTERNAL_ERROR\",\n      action: \"tryNext\"\n    },\n    [Sb.ERR_NO_ACTIVE_STATUS]: {\n      desc: \"ERR_NO_ACTIVE_STATUS\",\n      action: \"failed\"\n    },\n    [Sb.ERR_INVALID_UID]: {\n      desc: \"ERR_INVALID_UID\",\n      action: \"failed\"\n    },\n    [Sb.ERR_DYNAMIC_KEY_EXPIRED]: {\n      desc: \"ERR_DYNAMIC_KEY_EXPIRED\",\n      action: \"failed\"\n    },\n    [Sb.ERR_STATIC_USE_DYANMIC_KE]: {\n      desc: \"ERR_STATIC_USE_DYANMIC_KE\",\n      action: \"failed\"\n    },\n    [Sb.ERR_DYNAMIC_USE_STATIC_KE]: {\n      desc: \"ERR_DYNAMIC_USE_STATIC_KE\",\n      action: \"failed\"\n    },\n    [Sb.ERR_NO_VOCS_AVAILABLE]: {\n      desc: \"ERR_NO_VOCS_AVAILABLE\",\n      action: \"tryNext\"\n    },\n    [Sb.ERR_NO_VOS_AVAILABLE]: {\n      desc: \"ERR_NO_VOS_AVAILABLE\",\n      action: \"tryNext\"\n    },\n    [Sb.ERR_JOIN_CHANNEL_TIMEOUT]: {\n      desc: \"ERR_JOIN_CHANNEL_TIMEOUT\",\n      action: \"tryNext\"\n    },\n    [Sb.ERR_JOIN_BY_MULTI_IP]: {\n      desc: \"ERR_JOIN_BY_MULTI_IP\",\n      action: \"recover\"\n    },\n    [Sb.ERR_NOT_JOINED]: {\n      desc: \"ERR_NOT_JOINED\",\n      action: \"failed\"\n    },\n    [Sb.ERR_REPEAT_JOIN_REQUEST]: {\n      desc: \"ERR_REPEAT_JOIN_REQUEST\",\n      action: \"quit\"\n    },\n    [Sb.ERR_REPEAT_JOIN_CHANNEL]: {\n      desc: \"ERR_REPEAT_JOIN_CHANNEL\",\n      action: \"quit\"\n    },\n    [Sb.ERR_INVALID_STRINGUID]: {\n      desc: \"ERR_INVALID_STRINGUID\",\n      action: \"failed\"\n    },\n    [Sb.ERR_TOO_MANY_USERS]: {\n      desc: \"ERR_TOO_MANY_USERS\",\n      action: \"tryNext\"\n    },\n    [Sb.ERR_SET_CLIENT_ROLE_TIMEOUT]: {\n      desc: \"ERR_SET_CLIENT_ROLE_TIMEOUT\",\n      action: \"failed\"\n    },\n    [Sb.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: {\n      desc: \"ERR_SET_CLIENT_ROLE_TIMEOUT\",\n      action: \"failed\"\n    },\n    [Sb.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: {\n      desc: \"ERR_SET_CLIENT_ROLE_ALREADY_IN_USE\",\n      action: \"success\"\n    },\n    [Sb.ERR_PUBLISH_REQUEST_INVALID]: {\n      desc: \"ERR_PUBLISH_REQUEST_INVALID\",\n      action: \"failed\"\n    },\n    [Sb.ERR_SUBSCRIBE_REQUEST_INVALID]: {\n      desc: \"ERR_SUBSCRIBE_REQUEST_INVALID\",\n      action: \"failed\"\n    },\n    [Sb.ERR_NOT_SUPPORTED_MESSAGE]: {\n      desc: \"ERR_NOT_SUPPORTED_MESSAGE\",\n      action: \"failed\"\n    },\n    [Sb.ERR_ILLEAGAL_PLUGIN]: {\n      desc: \"ERR_ILLEAGAL_PLUGIN\",\n      action: \"failed\"\n    },\n    [Sb.ILLEGAL_CLIENT_ROLE_LEVEL]: {\n      desc: \"ILLEGAL_CLIENT_ROLE_LEVEL\",\n      action: \"failed\"\n    },\n    [Sb.ERR_REJOIN_TOKEN_INVALID]: {\n      desc: \"ERR_REJOIN_TOKEN_INVALID\",\n      action: \"failed\"\n    },\n    [Sb.ERR_REJOIN_USER_NOT_JOINED]: {\n      desc: \"ERR_REJOIN_NOT_JOINED\",\n      action: \"failed\"\n    },\n    [Sb.ERR_INVALID_OPTIONAL_INFO]: {\n      desc: \"ERR_INVALID_OPTIONAL_INFO\",\n      action: \"quit\"\n    },\n    [Sb.ERR_TEST_RECOVER]: {\n      desc: \"ERR_TEST_RECOVER\",\n      action: \"recover\"\n    },\n    [Sb.ERR_TEST_TRYNEXT]: {\n      desc: \"ERR_TEST_TRYNEXT\",\n      action: \"recover\"\n    },\n    [Sb.ERR_TEST_RETRY]: {\n      desc: \"ERR_TEST_RETRY\",\n      action: \"recover\"\n    },\n    [Sb.ILLEGAL_AES_PASSWORD]: {\n      desc: \"ERR_TEST_RETRY\",\n      action: \"failed\"\n    },\n    [Sb.ERR_TOO_MANY_BROADCASTERS]: {\n      desc: \"ERR_TOO_MANY_BROADCASTERS\",\n      action: \"failed\"\n    },\n    [Sb.ERR_TOO_MANY_SUBSCRIBERS]: {\n      desc: \"ERR_TOO_MANY_SUBSCRIBERS\",\n      action: \"failed\"\n    },\n    [Sb.ERR_LICENSE_ILLEGAL]: {\n      desc: \"ERR_LICENSE_ILLEGAL\",\n      action: \"quit\"\n    },\n    [Sb.ERR_LICENSE_MISSING]: {\n      desc: \"ERR_LICENSE_MISSING\",\n      action: \"quit\"\n    },\n    [Sb.ERR_LICENSE_EXPIRED]: {\n      desc: \"ERR_LICENSE_EXPIRED\",\n      action: \"quit\"\n    },\n    [Sb.ERR_LICENSE_MINUTES_EXCEEDED]: {\n      desc: \"ERR_LICENSE_MINUTES_EXCEEDED\",\n      action: \"quit\"\n    },\n    [Sb.ERR_LICENSE_PERIOD_INVALID]: {\n      desc: \"ERR_LICENSE_PERIOD_INVALID\",\n      action: \"quit\"\n    },\n    [Sb.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: {\n      desc: \"ERR_LICENSE_MULTIPLE_SDK_SERVICE\",\n      action: \"quit\"\n    }\n  };\n  function yw(e) {\n    const t = Iw[e];\n    return t || {\n      desc: \"UNKNOW_ERROR_\".concat(e),\n      action: \"failed\"\n    };\n  }\n  function Aw(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function bw(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? Aw(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Aw(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function ww(e) {\n    return e.every(e => e.readyState === WebSocket.CLOSED || e.readyState === WebSocket.CLOSING);\n  }\n  function Ow(e, t) {\n    if (\"string\" == typeof e) return e;\n    const i = e.proxy,\n      n = e.host,\n      r = e.port;\n    if (t) {\n      const e = Dy(\"JOIN_GATEWAY_FALLBACK_PORT\") || 443;\n      return 443 === e ? \"wss://\".concat(n, \"/ws/?p=\").concat(Number(r) + 150) : \"wss://\".concat(n, \":\").concat(e, \"/ws/?p=\").concat(Number(r) + 150);\n    }\n    return i ? \"wss://\".concat(i, \"/ws/?h=\").concat(n, \"&p=\").concat(r) : \"wss://\".concat(n, \":\").concat(r);\n  }\n  const Nw = /wss:\\/\\/(.+)\\/ws\\/\\?h=(.+)&p=([0-9]+)\\/?/,\n    Dw = /wss:\\/\\/(.+)\\/ws\\/\\?p=([0-9]+)\\/?/,\n    Pw = /wss:\\/\\/(.+):([0-9]+)\\/?/,\n    Lw = /wss:\\/\\/(.[^\\/]+)\\/?/;\n  let kw = 0;\n  class Mw {\n    constructor(e, t) {\n      ng(this, \"id\", 0), ng(this, \"store\", void 0), ng(this, \"recordIndex\", void 0), ng(this, \"websockets\", []), ng(this, \"try443PortDuration\", 2e3), ng(this, \"forceCloseWSDuration\", 5e3), ng(this, \"try443PortTimeout\", null), ng(this, \"forceCloseTimeout\", null), ng(this, \"isTry443PortFailed\", !1), ng(this, \"isNormalPortFailed\", !1), ng(this, \"useDoubleDomain\", !1), ng(this, \"useProxy\", !1), ng(this, \"startTime\", Date.now()), this.id = ++kw, this.try443PortDuration = Dy(\"JOIN_GATEWAY_TRY_443PORT_DURATION\") || 2e3, this.forceCloseWSDuration = e || 5e3, this.store = t;\n    }\n    closeAllWebsockets() {\n      this.websockets.forEach(e => {\n        e.onopen = null, e.onclose = null, e.onmessage = null, e.close();\n      }), this.websockets.length = 0;\n    }\n    clearTimeout() {\n      this.forceCloseTimeout && clearTimeout(this.forceCloseTimeout), this.try443PortTimeout && clearTimeout(this.try443PortTimeout);\n    }\n    logger() {\n      var e;\n      const t = Date.now() - this.startTime;\n      for (var i = arguments.length, n = new Array(i), r = 0; r < i; r++) n[r] = arguments[r];\n      Qy.debug(\"[choose-best-ws \".concat(null === (e = this.store) || void 0 === e ? void 0 : e.clientId, \" \").concat(this.id, \"] \").concat(t, \"ms:\"), ...n);\n    }\n    createWebSocket(e, t, i) {\n      this.logger(\"createWebSocket:\", e, {\n        isTry443Port: t,\n        hasTimeoutDetection: i\n      });\n      const n = Dy(\"GATEWAY_DOMAINS\"),\n        r = Date.now(),\n        o = [],\n        s = n.find(t => {\n          var i;\n          return Dn(i = e.host).call(i, t);\n        });\n      s || (this.useDoubleDomain = !1);\n      const a = [];\n      if (this.useDoubleDomain) n.forEach(i => {\n        a.push(Ow(bw(bw({}, e), {}, {\n          host: e.host.replace(s, i)\n        }), t));\n      });else {\n        const i = bw({}, e);\n        if (t && s) {\n          const e = n.find(e => e !== s);\n          e && (i.host = i.host.replace(s, e));\n        }\n        a.push(Ow(i, t));\n      }\n      try {\n        a.forEach(e => {\n          const t = new WebSocket(e);\n          t.binaryType = \"arraybuffer\", o.push(t), this.logger(\"ws is connecting:\", t.url);\n        });\n      } catch (n) {\n        if (this.logger(\"ws create failed\"), o.forEach(e => e.close()), o.length = 0, this.useDoubleDomain) return this.useDoubleDomain = !1, this.createWebSocket(e, t, i);\n        if (!t && 443 !== Number(e.port)) return this.createWebSocket(e, !0, i);\n        throw new bb(tI.WS_ERR, \"init websocket failed! Error: \".concat(n.toString()));\n      }\n      const c = Ev();\n      this.store && this.store.recordJoinChannelService({\n        urls: o.map(e => e.url),\n        service: \"gateway\"\n      }, this.recordIndex), o.forEach(e => {\n        e.onopen = () => {\n          this.logger(\"onopen: ws \".concat(e.url, \" open cost \").concat(Date.now() - r, \"ms\")), this.websockets.forEach(t => {\n            t !== e && (t.onopen = null, t.onclose = null, t.onmessage = null, t.close(), this.logger(\"close backup websocket: \".concat(t.url)));\n          }), this.websockets.length = 0, c.resolve(e);\n        }, e.onclose = i => {\n          this.logger(\"onclose: ws \".concat(e.url, \" closed cost \").concat(Date.now() - r, \"ms state: \").concat(e.readyState)), t ? this.isTry443PortFailed = ww(o) : this.isNormalPortFailed = ww(o), this.logger(\"443: \".concat(this.useProxy ? \"not try\" : this.isTry443PortFailed ? \"failed\" : \"trying\", \" 47xx: \").concat(this.isNormalPortFailed ? \"failed\" : \"trying\")), (t && this.isTry443PortFailed || !t && (this.isTry443PortFailed || this.useProxy) && this.isNormalPortFailed) && (this.logger(\"onclose: all websocket is closed, \".concat(i.reason)), c.reject({\n            code: i.code,\n            reason: qb.A_ROUND_WS_FAILED\n          }));\n        }, e.onmessage = t => this.logger(\"\".concat(e.url, \" onmessage: \").concat(t.data));\n      }), this.websockets.push(...o);\n      return i || (() => {\n        const i = () => {\n          this.logger(\"5s timeout close un-opens, isWebsocket created: \", c.isResolved), this.websockets.forEach(e => e.readyState !== WebSocket.OPEN && e.close());\n        };\n        if (t || this.useProxy) return this.logger(\"add 5s timeout at \".concat(t ? \"try-443\" : \"proxy\", \" condition\")), this.forceCloseTimeout = window.setTimeout(i, this.forceCloseWSDuration);\n        this.try443PortTimeout = window.setTimeout(() => {\n          if (this.logger(\"2s timeout, isWebsocket created: \", c.isResolved), c.isResolved) return i();\n          Iv().os === Sv.MAC_OS && Pv() && i(), this.createWebSocket(e, !0, !0).then(e => c.resolve(e)).catch(e => {\n            this.isNormalPortFailed && c.reject(e), this.logger(\"try 443 port to create ws failed\");\n          }), this.forceCloseTimeout = window.setTimeout(i, this.forceCloseWSDuration);\n        }, this.try443PortDuration);\n      })(), c.promise;\n    }\n    chooseBestWebsocket(e, t, i, n) {\n      return this.useDoubleDomain = !!t, \"string\" == typeof e && (e = function (e, _ref7, _ref8, _ref9, _ref10, _ref11, _ref12, _ref13, _ref14) {\n        let t, i, n;\n        return (_ref7 = e.match(Nw) || [], _ref8 = _slicedToArray(_ref7, 4), t = _ref8[1], i = _ref8[2], n = _ref8[3]), t || (_ref9 = e.match(Dw) || [], _ref10 = _slicedToArray(_ref9, 3), i = _ref10[1], n = _ref10[2], _ref9), i && n || (_ref11 = e.match(Pw) || [], _ref12 = _slicedToArray(_ref11, 3), i = _ref12[1], n = _ref12[2], _ref11), i && n || (_ref13 = e.match(Lw) || [], _ref14 = _slicedToArray(_ref13, 2), i = _ref14[1], _ref13), i || Qy.warning(\"un-destructible url: \", e), {\n          proxy: t,\n          host: i,\n          port: n || \"443\"\n        };\n      }(e)), this.recordIndex = n, this.useProxy = !!e.proxy, i && this.useProxy && (Qy.warn(\"cannot use 443 only when use proxy\"), i = !1), this.createWebSocket(e, !!i, !1).finally(() => this.clearTimeout());\n    }\n  }\n  function Uw(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  class xw extends SI {\n    get url() {\n      return this.websocket && this.websocket.url || null;\n    }\n    get reconnectMode() {\n      return this._reconnectMode;\n    }\n    set reconnectMode(e) {\n      var t;\n      Dn(t = [\"tryNext\", \"recover\"]).call(t, e) && this.resetReconnectCount(e), this._reconnectMode = e;\n    }\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      e !== this._state && (this._state = e, \"reconnecting\" === this._state ? this.emit(Ab.RECONNECTING, this.reconnectReason) : \"connected\" === this._state ? this.emit(Ab.CONNECTED) : \"closed\" === this._state ? this.emit(Ab.CLOSED) : \"failed\" === this._state && this.emit(Ab.FAILED));\n    }\n    resetReconnectCount(e) {\n      Qy.debug(\"websocket reset reconnect count, reason: \" + e), this.reconnectCount = 0;\n    }\n    constructor(e, t) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n        n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],\n        r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],\n        o = arguments.length > 5 ? arguments[5] : void 0;\n      super(), ng(this, \"connectionID\", 0), ng(this, \"currentURLIndex\", 0), ng(this, \"urls\", []), ng(this, \"_reconnectMode\", \"tryNext\"), ng(this, \"reconnectReason\", void 0), ng(this, \"_initMutex\", new uy(\"websocket\")), ng(this, \"name\", void 0), ng(this, \"_state\", \"closed\"), ng(this, \"reconnectInterrupter\", void 0), ng(this, \"websocket\", void 0), ng(this, \"retryConfig\", void 0), ng(this, \"reconnectCount\", 0), ng(this, \"forceCloseTimeout\", 5e3), ng(this, \"onlineReconnectListener\", void 0), ng(this, \"useCompress\", void 0), ng(this, \"tryDoubleDomain\", !1), ng(this, \"use443PortOnly\", !1), ng(this, \"wsInflateLength\", 0), ng(this, \"wsDeflateLength\", 0), ng(this, \"closeEstablishingWs\", () => {}), ng(this, \"store\", void 0), ng(this, \"joinGatewayRecordIndex\", void 0), this.store = o, this.name = e, this.retryConfig = function (e) {\n        for (var t = 1; t < arguments.length; t++) {\n          var i = null != arguments[t] ? arguments[t] : {};\n          t % 2 ? Uw(Object(i), !0).forEach(function (t) {\n            ng(e, t, i[t]);\n          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Uw(Object(i)).forEach(function (t) {\n            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n          });\n        }\n        return e;\n      }({}, t), this.useCompress = i, this.tryDoubleDomain = n, this.use443PortOnly = r;\n      const s = t.timeout,\n        a = t.timeoutFactor,\n        c = Math.max(300, Math.floor(3 * s / 5)),\n        d = Math.max(1.2, Math.floor(8 * a) / 10);\n      PI.ONLINE && (this.retryConfig.timeout = c, this.retryConfig.timeoutFactor = d), VI.on(LI.NETWORK_STATE_CHANGE, (e, t) => {\n        e !== t && (this.resetReconnectCount(\"network state change: \".concat(t, \" -> \").concat(e)), e === PI.ONLINE ? (this.retryConfig.timeout = c, this.retryConfig.timeoutFactor = d) : (this.retryConfig.timeout = s, this.retryConfig.timeoutFactor = a));\n      });\n    }\n    getConnection() {\n      return this.websocket || void 0;\n    }\n    async init(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;\n      const i = await this._initMutex.lock();\n      this.forceCloseTimeout = t, this.urls = e, this.state = \"connecting\";\n      try {\n        const e = Ev(),\n          t = this.urls[this.currentURLIndex];\n        this.createWebSocketConnection(t).then(e.resolve).catch(e.reject), this.once(Ab.CLOSED, () => {\n          e.reject(new iI(tI.WS_DISCONNECT));\n        }), this.once(Ab.CONNECTED, e.resolve), await e.promise;\n      } catch (e) {} finally {\n        i();\n      }\n    }\n    close(e, t) {\n      if (this.currentURLIndex = 0, this.resetReconnectCount(\"close\"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {\n        this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;\n        const e = this.websocket;\n        t ? setTimeout(() => e.close(), 500) : e.close(), this.websocket = void 0;\n      }\n      this.state = e ? \"failed\" : \"closed\", this.closeEstablishingWs && this.closeEstablishingWs();\n    }\n    reconnect(e, t) {\n      if (!this.websocket) return void Qy.warning(\"[\".concat(this.name, \"] can not reconnect, no websocket\"));\n      void 0 !== e && (this.reconnectMode = e), Qy.debug(\"[\".concat(this.name, \"] reconnect is triggered initiative\")), \"number\" == typeof this.joinGatewayRecordIndex && this.store && this.store.recordJoinChannelService({\n        status: \"error\",\n        errors: [new Error(t)]\n      }, this.joinGatewayRecordIndex);\n      const i = this.websocket.onclose;\n      this.websocket.onclose = null, this.websocket.close(), i && i.bind(this.websocket)({\n        code: 9999,\n        reason: t\n      });\n    }\n    sendMessage(e) {\n      let t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new iI(tI.WS_ABORT, \"websocket is not ready\");\n      try {\n        t || (e = JSON.stringify(e)), this.websocket.send(e);\n      } catch (e) {\n        throw new iI(tI.WS_ERR, \"send websocket message error\" + e.toString());\n      }\n    }\n    setWsInflateData(e) {\n      this.wsDeflateLength = this.wsDeflateLength + e.originLength, this.wsInflateLength = this.wsInflateLength + e.compressedLength;\n    }\n    getWsInflateData() {\n      const e = this.wsInflateLength,\n        t = this.wsDeflateLength;\n      return this.clearWsInflateData(), {\n        wsInflateLength: e,\n        wsDeflateLength: t\n      };\n    }\n    clearWsInflateData() {\n      this.wsInflateLength = 0, this.wsDeflateLength = 0;\n    }\n    async createWebSocketConnection(e) {\n      var t;\n      const i = Ev();\n      this.connectionID += 1, this.joinGatewayRecordIndex = void 0;\n      const n = e => {\n          var t;\n          null === (t = this.store) || void 0 === t || t.signalChannelOpen(), Qy.debug(\"[\".concat(this.name, \"] websocket opened:\"), e), this.reconnectMode = \"retry\", this.state = \"connected\", this.resetReconnectCount(\"opened\"), i.resolve();\n        },\n        r = async e => {\n          var t;\n          if (Qy.debug(\"[\".concat(this.name, \"] websocket close \").concat(null === (t = this.websocket) || void 0 === t ? void 0 : t.url, \", code: \").concat(e.code, \", reason: \").concat(e.reason, \", current mode: \").concat(this.reconnectMode)), this.reconnectCount >= this.retryConfig.maxRetryCount) i.reject(new iI(tI.WS_DISCONNECT, \"websocket close: \".concat(e.code))), this.close();else {\n            \"connected\" === this.state && (this.reconnectReason = e.reason, this.state = \"reconnecting\");\n            const t = UI(this, Ab.WILL_RECONNECT, this.reconnectMode, e.reason) || this.reconnectMode,\n              n = await this.reconnectWithAction(t);\n            if (\"closed\" === this.state) return void Qy.debug(\"[\".concat(this.connectionID, \"] ws is closed, no need to reconnect\"));\n            if (!n) return i.reject(new iI(tI.WS_DISCONNECT, \"websocket reconnect failed: \".concat(e.code))), this.close(!0);\n            i.resolve();\n          }\n        },\n        o = e => {\n          this.emit(Ab.ON_MESSAGE, e);\n        },\n        s = e => {\n          Qy.warn(\"[\".concat(this.connectionID, \"] ws open error \").concat(e));\n        };\n      this.websocket && (this.websocket.onclose = null, this.websocket.close()), Dy(\"GATEWAY_WSS_ADDRESS\") && this.name.startsWith(\"gateway\") && (e = Dy(\"GATEWAY_WSS_ADDRESS\")), Qy.debug(\"[\".concat(this.name, \"] start connect, url:\"), e);\n      const a = null === (t = this.store) || void 0 === t ? void 0 : t.recordJoinChannelService({\n        startTs: Date.now(),\n        status: \"pending\",\n        service: \"gateway\"\n      });\n      try {\n        var c;\n        const t = await this.chooseBestWebsocketConnection(e);\n        this.websocket = t, n && n(this.websocket.url), this.websocket.onclose = r, this.websocket.onmessage = o, this.websocket.onerror = s, null === (c = this.store) || void 0 === c || c.recordJoinChannelService({\n          endTs: Date.now(),\n          status: \"success\"\n        }, a), this.joinGatewayRecordIndex = a;\n      } catch (e) {\n        const t = \"closed\" === this.state,\n          n = e instanceof iI,\n          o = n && e.code === tI.WS_ABORT,\n          s = n && e.code === tI.WS_ERR,\n          c = n ? e.message : e && (e.reason || e.toString());\n        Qy.warning(\"[choose-best-ws] chooseBestWebsocket error: \".concat(c)), this.store && this.store.recordJoinChannelService({\n          endTs: Date.now(),\n          status: o ? \"aborted\" : \"error\",\n          errors: [e]\n        }, a), t || s ? (i.reject(t ? new iI(tI.WS_DISCONNECT, \"websocket is closed: \".concat(c)) : new iI(tI.WS_ERR, \"init websocket failed: \".concat(c))), s && Qy.error(\"[\".concat(this.name, \"] init websocket failed: \").concat(c))) : r && r(e);\n      }\n      return i.promise;\n    }\n    async reconnectWithAction(e) {\n      let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (this.reconnectCount >= this.retryConfig.maxRetryCount) return !1;\n      if (0 === this.urls.length) return !1;\n      if (\"closed\" === this.state) return !1;\n      Qy.warning(\"[choose-best-ws] action: =>\", e), this.onlineReconnectListener || VI.isOnline || !VI.onlineWaiter || (this.onlineReconnectListener = VI.onlineWaiter.then(() => {\n        this.onlineReconnectListener = void 0;\n      }));\n      let i = !0;\n      if (this.reconnectInterrupter = () => i = !1, t) {\n        const t = Ey(this.reconnectCount, this.retryConfig);\n        Qy.debug(\"[\".concat(this.name, \"] wait \").concat(t, \"ms to reconnect websocket, mode: \").concat(e)), await Gu.race([$I(t), this.onlineReconnectListener || new Gu(() => {})]);\n      }\n      if (\"closed\" === this._state || !i) return !1;\n      this.reconnectCount += 1;\n      const n = async (e, t) => {\n        this.emit(Ab.RECONNECT_CREATE_CONNECTION, t), await this.createWebSocketConnection(e);\n      };\n      try {\n        if (\"retry\" === e) this.emit(Ab.RECONNECT_WAITTING_FINISH, e), await n(this.urls[this.currentURLIndex], e);else if (\"tryNext\" === e) {\n          if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length) return this.reconnectWithAction(\"recover\", !1);\n          Qy.debug(\"[\".concat(this.name, \"] websocket url length: \").concat(this.urls.length, \" current index: \").concat(this.currentURLIndex)), this.emit(Ab.RECONNECT_WAITTING_FINISH, e), await n(this.urls[this.currentURLIndex], e);\n        } else \"recover\" === e && (Qy.debug(\"[\".concat(this.name, \"] request new urls\")), this.resetReconnectCount(\"recover mode\"), this.emit(Ab.RECONNECT_WAITTING_FINISH, e), this.urls = await kI(this, Ab.REQUEST_NEW_URLS), this.currentURLIndex = 0, await n(this.urls[this.currentURLIndex], e));\n      } catch (i) {\n        var r;\n        Qy.error(\"[\".concat(this.name, \"] reconnect failed \").concat(i && i.toString()));\n        const n = null == i || null === (r = i.data) || void 0 === r ? void 0 : r.desc;\n        return Array.isArray(n) && Dn(n).call(n, \"dynamic key expired\") ? (this.emit(Ab.ON_TOKEN_PRIVILEGE_DID_EXPIRE), !1) : this.reconnectWithAction(e, t);\n      }\n      return !0;\n    }\n  }\n  class Vw extends xw {\n    constructor(e, t) {\n      super(e, t, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);\n    }\n    async chooseBestWebsocketConnection(e, t) {\n      const i = Ev(),\n        n = function (e, t) {\n          return new Mw(e, t);\n        }(this.forceCloseTimeout, this.store);\n      this.closeEstablishingWs = () => {\n        Qy.debug(\"[choose-best-ws] close establishing websockets\"), n.closeAllWebsockets(), i.reject(new iI(tI.WS_ABORT, \"choose best websocket aborted\"));\n      };\n      const r = Dy(\"GATEWAY_DOMAINS\");\n      return Qy.debug(\"[choose-best-ws] currentDomain: \", e, \", domains: \", r, \"total: \".concat(this.urls.length), \"current: \".concat(this.currentURLIndex + 1)), n.chooseBestWebsocket(e, this.tryDoubleDomain, this.use443PortOnly, t).then(i.resolve).catch(i.reject), i.promise.finally(() => {\n        this.closeEstablishingWs = void 0;\n      });\n    }\n  }\n  class Fw extends xw {\n    constructor(e, t) {\n      super(e, t, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);\n    }\n    async chooseBestWebsocketConnection(e, t) {\n      return new Gu((i, n) => {\n        let r = !1;\n        const o = [];\n        this.closeEstablishingWs = () => {\n          Qy.debug(\"[choose-best-ws] close establishing websockets\"), o.forEach(e => {\n            e.onclose = null, e.onopen = null, e.onmessage = null, e.close();\n          }), n(new iI(tI.WS_ABORT, \"choose best websocket aborted\"));\n        };\n        const s = Dy(\"GATEWAY_DOMAINS\");\n        let a;\n        const c = e.indexOf(\"?h=\"),\n          d = s.find(t => -1 !== c ? Dn(e).call(e, t, c) : Dn(e).call(e, t));\n        Qy.debug(\"[choose-best-ws] currentDomain: \", d, \", domains: \", s);\n        let l = !this.tryDoubleDomain || !d;\n        if (!l && d) {\n          var h;\n          const u = Date.now();\n          try {\n            s.forEach(t => {\n              const i = -1 === c ? e.replace(d, t) : e.substr(0, c) + e.substr(c).replace(d, t),\n                n = new WebSocket(i);\n              n.binaryType = \"arraybuffer\", o.push(n), Qy.debug(\"[choose-best-ws] ws is connecting:\", n.url);\n            });\n          } catch (e) {\n            for (Qy.debug(\"[choose-best-ws] ws create failed, fallback to single url\"), o.forEach(e => e.close()); o.length;) o.pop();\n            l = !0;\n          }\n          null === (h = this.store) || void 0 === h || h.recordJoinChannelService({\n            urls: o.map(e => e.url),\n            service: \"gateway\"\n          }, t), o.forEach(e => {\n            e.onopen = () => {\n              if (r) return;\n              const t = Date.now() - u;\n              Qy.debug(\"[choose-best-ws] ws open cost \".concat(t, \"ms\")), o.filter(t => t !== e).forEach(e => {\n                Qy.debug(\"[choose-best-ws]close backup websocket: \".concat(e.url)), e.close();\n              }), r = !0, i(e);\n            }, e.onclose = e => {\n              if (a = e, r) return;\n              o.find(e => !(e.readyState === WebSocket.CLOSED || e.readyState === WebSocket.CLOSING)) || (Qy.debug(\"[choose-best-ws] all websocket is closed\"), r = !0, n(a));\n            }, e.onmessage = t => {\n              Qy.debug(\"[choose-best-ws]\".concat(e.url, \" onmessage: \").concat(t.data));\n            };\n          }), $I(this.forceCloseTimeout).then(() => {\n            o.forEach(e => {\n              e.readyState !== WebSocket.OPEN && e.close();\n            });\n          });\n        }\n        if (l) {\n          var u;\n          let r;\n          Qy.debug(\"[choose-best-ws] use single url: \", e), null === (u = this.store) || void 0 === u || u.recordJoinChannelService({\n            urls: [e],\n            service: \"gateway\"\n          }, t);\n          try {\n            r = new WebSocket(e), o.push(r), r.binaryType = \"arraybuffer\";\n          } catch (e) {\n            const t = new iI(tI.WS_ERR, \"init websocket failed! Error: \".concat(e.toString()));\n            return Qy.error(\"[\".concat(this.name, \"]\").concat(t)), void n(t);\n          }\n          r.onopen = () => {\n            i(r);\n          }, r.onclose = e => {\n            n(e);\n          }, r.onmessage = e => {\n            Qy.debug(\"[choose-best-ws]\".concat(r.url, \" onmessage: \").concat(e.data));\n          }, $I(this.forceCloseTimeout).then(() => {\n            r && r.readyState !== WebSocket.OPEN && r.close();\n          });\n        }\n      }).then(e => (this.closeEstablishingWs = void 0, e)).catch(e => {\n        throw this.closeEstablishingWs = void 0, e;\n      });\n    }\n  }\n  class Bw extends SI {\n    get connectionState() {\n      return this._connectionState;\n    }\n    set connectionState(e) {\n      e !== this._connectionState && (this._connectionState = e, e === gb.CONNECTED ? this.emit(Rb.WS_CONNECTED) : e === gb.RECONNECTING ? this.emit(Rb.WS_RECONNECTING, this._websocketReconnectReason) : e === gb.CLOSED && this.emit(Rb.WS_CLOSED, this._disconnectedReason));\n    }\n    get currentURLIndex() {\n      return this.websocket.currentURLIndex;\n    }\n    get url() {\n      return this.websocket && this.websocket.url || null;\n    }\n    get rtt() {\n      return this.rttRolling.mean();\n    }\n    constructor(e, t) {\n      super(), ng(this, \"_disconnectedReason\", void 0), ng(this, \"_websocketReconnectReason\", void 0), ng(this, \"_connectionState\", gb.CLOSED), ng(this, \"reconnectToken\", void 0), ng(this, \"websocket\", void 0), ng(this, \"openConnectionTime\", void 0), ng(this, \"clientId\", void 0), ng(this, \"lastMsgTime\", Date.now()), ng(this, \"uploadCache\", []), ng(this, \"uploadCacheInterval\", void 0), ng(this, \"rttRolling\", new fy(5)), ng(this, \"pingpongTimer\", void 0), ng(this, \"wsInflateDataTimer\", void 0), ng(this, \"pingpongTimeoutCount\", 0), ng(this, \"joinResponse\", void 0), ng(this, \"multiIpOption\", void 0), ng(this, \"initError\", void 0), ng(this, \"spec\", void 0), ng(this, \"store\", void 0), ng(this, \"onWebsocketMessage\", e => {\n        if (e.data instanceof ArrayBuffer) return void this.emit(Rb.ON_BINARY_DATA, e.data);\n        const t = JSON.parse(e.data);\n        if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t, \"_id\")) {\n          const e = \"res-@\".concat(t._id);\n          this.emit(e, t._result, t._message);\n        } else if (Object.prototype.hasOwnProperty.call(t, \"_type\")) {\n          if (this.emit(t._type, t._message), t._type === Ib.ON_NOTIFICATION && this.handleNotification(t._message), t._type === Ib.ON_USER_BANNED) switch (t._message.error_code) {\n            case 14:\n              this.close(AI.UID_BANNED);\n              break;\n            case 15:\n              this.close(AI.IP_BANNED);\n              break;\n            case 16:\n              this.close(AI.CHANNEL_BANNED);\n          }\n          if (t._type === Ib.ON_USER_LICENSE_BANNED) switch (t._message.error_code) {\n            case Sb.ERR_LICENSE_MISSING:\n              this.close(AI.LICENSE_MISSING);\n              break;\n            case Sb.ERR_LICENSE_EXPIRED:\n              this.close(AI.LICENSE_EXPIRED);\n              break;\n            case Sb.ERR_LICENSE_MINUTES_EXCEEDED:\n              this.close(AI.LICENSE_MINUTES_EXCEEDED);\n              break;\n            case Sb.ERR_LICENSE_PERIOD_INVALID:\n              this.close(AI.LICENSE_PERIOD_INVALID);\n              break;\n            case Sb.ERR_LICENSE_MULTIPLE_SDK_SERVICE:\n              this.close(AI.LICENSE_MULTIPLE_SDK_SERVICE);\n              break;\n            case Sb.ERR_LICENSE_ILLEGAL:\n              this.close(AI.LICENSE_ILLEGAL);\n              break;\n            default:\n              this.close();\n          }\n        }\n      }), this.clientId = e.clientId, this.spec = e, this.store = t, this.websocket = new Vw(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, Dy(\"JOIN_GATEWAY_USE_DUAL_DOMAIN\"), Dy(\"JOIN_GATEWAY_USE_443PORT_ONLY\"), t), this.handleWebsocketEvents(), window.addEventListener(\"offline\", () => {\n        this.connectionState === gb.CONNECTED && this.reconnect(\"retry\", DI.OFFLINE);\n      });\n    }\n    async request(e, t, i, n) {\n      const r = ey(6, \"\"),\n        o = {\n          _id: r,\n          _type: e,\n          _message: t\n        },\n        s = this.websocket.connectionID,\n        a = () => new Gu((t, i) => {\n          if (this.connectionState === gb.CONNECTED) return t();\n          const n = () => {\n              this.off(Rb.WS_CLOSED, r), t();\n            },\n            r = () => {\n              this.off(Rb.WS_CONNECTED, n), i(new bb(tI.WS_ABORT));\n            };\n          this.once(Rb.WS_CONNECTED, n), this.once(Rb.WS_CLOSED, r), e !== Cb.PUBLISH && e !== Cb.PUBLISH_DATASTREAM && e !== Cb.SUBSCRIBE && e !== Cb.SUBSCRIBE_DATASTREAM && e !== Cb.UNSUBSCRIBE && e !== Cb.UNSUBSCRIBE_DATASTREAM && e !== Cb.UNPUBLISH && e !== Cb.UNPUBLISH_DATASTREAM && e !== Cb.CONTROL && e !== Cb.RESTART_ICE || this.once(Rb.DISCONNECT_P2P, () => {\n            i(new bb(tI.DISCONNECT_P2P));\n          }), e !== Cb.PUBLISH && e !== Cb.RESTART_ICE || this.once(Rb.ABORT_P2P_EXECUTION, () => {\n            i(new bb(tI.DISCONNECT_P2P));\n          });\n        });\n      if (this.connectionState !== gb.CONNECTING && this.connectionState !== gb.RECONNECTING || e === Cb.JOIN || e === Cb.REJOIN || (await a()), this.websocket.sendMessage(o, !0), n) return;\n      const c = new Gu((i, n) => {\n        let o = !1;\n        const a = (n, r) => {\n          o = !0, i({\n            isSuccess: \"success\" === n,\n            message: r || {}\n          }), this.off(Rb.WS_CLOSED, c), this.off(Rb.WS_RECONNECTING, c), this.emit(Rb.REQUEST_SUCCESS, e, t);\n        };\n        this.once(\"res-@\".concat(r), a);\n        const c = () => {\n          n(new bb(tI.WS_ABORT, \"type: \".concat(e))), this.off(Rb.WS_CLOSED, c), this.off(Rb.WS_RECONNECTING, c), this.off(\"res-@\".concat(r), a);\n        };\n        this.once(Rb.WS_CLOSED, c), this.once(Rb.WS_RECONNECTING, c), $I(Dy(\"SIGNAL_REQUEST_TIMEOUT\")).then(() => {\n          this.websocket.connectionID !== s || o || (Qy.warning(\"[\".concat(this.clientId, \"] ws request timeout, type: \").concat(e)), this.emit(Rb.REQUEST_TIMEOUT, e, t));\n        });\n      });\n      let d = null;\n      try {\n        d = await c;\n      } catch (n) {\n        if (this.connectionState === gb.CLOSED || e === Cb.LEAVE) throw new bb(tI.WS_ABORT);\n        return !this.spec.forceWaitGatewayResponse || i ? n.throw() : e === Cb.JOIN || e === Cb.REJOIN ? null : (await a(), await this.request(e, t));\n      }\n      if (d.isSuccess) return d.message;\n      const l = Number(d.message.error_code || d.message.code),\n        h = yw(l),\n        u = new bb(tI.UNEXPECTED_RESPONSE, \"\".concat(h.desc, \": \").concat(d.message.error_str), {\n          code: l,\n          data: d.message\n        });\n      return \"success\" === h.action ? d.message : (Qy.warning(\"[\".concat(this.clientId, \"] [\").concat(this.websocket.connectionID, \"] unexpected response from type \").concat(e, \", error_code: \").concat(l, \", message: \").concat(h.desc, \", action: \").concat(h.action)), l === Sb.ERR_TOO_MANY_BROADCASTERS ? e === Cb.JOIN || e === Cb.REJOIN ? (this.initError = u, this.close(), u.throw()) : u.throw() : \"failed\" === h.action ? u.throw() : \"quit\" === h.action ? (this.initError = u, this.close(), u.throw()) : (l === Sb.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d.message.option, Qy.warning(\"[\".concat(this.clientId, \"] detect multi ip, recover\")), this.reconnect(\"recover\", DI.MULTI_IP)) : this.reconnect(h.action, DI.SERVER_ERROR), e === Cb.JOIN || e === Cb.REJOIN ? null : await this.request(e, t)));\n    }\n    waitMessage(e, t) {\n      return new Gu(i => {\n        const n = r => {\n          (!t || t(r)) && (this.off(e, n), i(r));\n        };\n        this.on(e, n);\n      });\n    }\n    uploadWRTCStats(e) {\n      if (!this.store.sessionId) return void Qy.warn(\"[\".concat(this.clientId, \"] no session id when upload wrtc stats\"));\n      const t = {\n        lts: Date.now(),\n        sid: this.store.sessionId,\n        uid: this.store.intUid,\n        stats: e\n      };\n      this.upload(vb.WRTC_STATS, t);\n    }\n    upload(e, t) {\n      const i = {\n        _type: e,\n        _message: t\n      };\n      try {\n        this.websocket.sendMessage(i);\n      } catch (e) {\n        const t = Dy(\"MAX_UPLOAD_CACHE\") || 50;\n        this.uploadCache.push(i), this.uploadCache.length > t && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {\n          if (this.connectionState !== gb.CONNECTED) return;\n          const e = this.uploadCache.splice(0, 1)[0];\n          0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e._type, e._message);\n        }, Dy(\"UPLOAD_CACHE_INTERVAL\") || 2e3));\n      }\n    }\n    send(e, t) {\n      const i = {\n        _type: e,\n        _message: t\n      };\n      this.websocket.sendMessage(i);\n    }\n    init(e, t) {\n      return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Gu((t, i) => {\n        this.once(Rb.WS_CONNECTED, () => t(this.joinResponse)), this.once(Rb.WS_CLOSED, () => i(this.initError || new bb(tI.WS_ABORT))), this.connectionState = gb.CONNECTING, this.websocket.init(e).catch(i), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {\n          this.handleWsInflateData();\n        }, 2e4);\n      });\n    }\n    close(e) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e || AI.LEAVE, this.connectionState = gb.CLOSED, Qy.debug(\"[\".concat(this.clientId, \"] \") + \"will close websocket in signal\"), this.websocket.close(), e === AI.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new Vw(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, Dy(\"JOIN_GATEWAY_USE_DUAL_DOMAIN\"), Dy(\"JOIN_GATEWAY_USE_443PORT_ONLY\"), this.store), this.handleWebsocketEvents());\n    }\n    async join() {\n      if (!this.joinResponse) {\n        this.emit(Rb.ABORT_P2P_EXECUTION);\n        const e = await kI(this, Rb.REQUEST_JOIN_INFO),\n          t = await this.request(Cb.JOIN, e);\n        if (!t) return this.emit(Rb.REPORT_JOIN_GATEWAY, qb.TIMEOUT, this.url || \"\"), !1;\n        this.joinResponse = t, this.emit(Rb.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;\n      }\n      return this.connectionState = gb.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), !0;\n    }\n    async rejoin() {\n      if (!this.reconnectToken) throw new bb(tI.UNEXPECTED_ERROR, \"can not rejoin, no rejoin token\");\n      const e = xI(this, Rb.REQUEST_REJOIN_INFO);\n      e.token = this.reconnectToken;\n      const t = await this.request(Cb.REJOIN, e);\n      return !!t && (this.connectionState = gb.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t.peers && t.peers.forEach(e => {\n        this.emit(Ib.ON_USER_ONLINE, {\n          uid: e.uid\n        }), e.audio && this.emit(Ib.ON_ADD_AUDIO_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id,\n          audio: !0,\n          ssrcId: e.audio_ssrc\n        }), e.video && this.emit(Ib.ON_ADD_VIDEO_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id,\n          video: !0,\n          ssrcId: e.video_ssrc\n        }), e.audio_mute ? this.emit(Ib.MUTE_AUDIO, {\n          uid: e.uid\n        }) : this.emit(Ib.UNMUTE_AUDIO, {\n          uid: e.uid\n        }), e.video_mute ? this.emit(Ib.MUTE_VIDEO, {\n          uid: e.uid\n        }) : this.emit(Ib.UNMUTE_VIDEO, {\n          uid: e.uid\n        }), e.audio_enable_local ? this.emit(Ib.ENABLE_LOCAL_AUDIO, {\n          uid: e.uid\n        }) : this.emit(Ib.DISABLE_LOCAL_AUDIO, {\n          uid: e.uid\n        }), e.video_enable_local ? this.emit(Ib.ENABLE_LOCAL_VIDEO, {\n          uid: e.uid\n        }) : this.emit(Ib.DISABLE_LOCAL_VIDEO, {\n          uid: e.uid\n        }), e.audio || e.video || this.emit(Ib.ON_REMOVE_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id\n        });\n      }), !0);\n    }\n    reconnect(e, t) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, t);\n    }\n    handleNotification(e) {\n      Qy.debug(\"[\".concat(this.clientId, \"] receive notification: \"), e);\n      const t = yw(e.code);\n      if (\"success\" !== t.action) {\n        if (\"failed\" !== t.action) return \"quit\" === t.action ? (\"ERR_REPEAT_JOIN_CHANNEL\" === t.desc && this.close(AI.UID_BANNED), void this.close()) : void this.reconnect(t.action, DI.SERVER_ERROR);\n        Qy.error(\"[\".concat(this.clientId, \"] ignore error: \"), t.desc);\n      }\n    }\n    handlePingPong() {\n      if (!this.websocket || \"connected\" !== this.websocket.state) return;\n      this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;\n      const e = Dy(\"PING_PONG_TIME_OUT\"),\n        t = Date.now();\n      this.pingpongTimeoutCount >= e && (Qy.warning(\"[\".concat(this.clientId, \"] PING-PONG Timeout. Last Socket Message: \").concat(t - this.lastMsgTime, \"ms\")), t - this.lastMsgTime > Dy(\"WEBSOCKET_TIMEOUT_MIN\")) ? this.reconnect(\"retry\", DI.TIMEOUT) : this.request(Cb.PING, void 0, !0).then(() => {\n        this.pingpongTimeoutCount = 0;\n        const e = Date.now() - t;\n        this.rttRolling.add(e), Dy(\"REPORT_STATS\") && this.send(Cb.PING_BACK, {\n          pingpongElapse: e\n        });\n      }).catch(e => {});\n    }\n    handleWsInflateData() {\n      const _this$websocket$getWs = this.websocket.getWsInflateData(),\n        e = _this$websocket$getWs.wsInflateLength,\n        t = _this$websocket$getWs.wsDeflateLength;\n      0 !== e && 0 !== t && this.upload(vb.WS_INFLATE_DATA_LENGTH, {\n        ws_deflate_length: t,\n        ws_inflate_length: e\n      });\n    }\n    handleWebsocketEvents() {\n      this.websocket.on(Ab.RECONNECT_WAITTING_FINISH, e => {\n        this.emit(Rb.WS_RECONNECT_WAITTING_FINISH, e);\n      }), this.websocket.on(Ab.RECONNECT_CREATE_CONNECTION, e => {\n        this.emit(Rb.WS_RECONNECT_CREATE_CONNECTION, e);\n      }), this.websocket.on(Ab.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Ab.CLOSED, () => {\n        this.connectionState = gb.CLOSED;\n      }), this.websocket.on(Ab.FAILED, () => {\n        this._disconnectedReason = AI.NETWORK_ERROR, this.connectionState = gb.CLOSED;\n      }), this.websocket.on(Ab.RECONNECTING, e => {\n        this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === gb.CONNECTED ? this.connectionState = gb.RECONNECTING : this.connectionState = gb.CONNECTING;\n      }), this.websocket.on(Ab.WILL_RECONNECT, (e, t, i) => {\n        const n = xI(this, Rb.IS_P2P_DISCONNECTED),\n          r = n || \"retry\" !== e;\n        n && \"retry\" === e && (Qy.debug(\"\".concat(this.clientId, \" reconnect mode is retry, but p2p lost, change to tryNext\")), e = \"tryNext\", t = qb.P2P_DISCONNECTED), r && (Qy.debug(\"\".concat(this.clientId, \" will renewSession, reconnect mode: \").concat(e)), this.emit(Rb.REPORT_JOIN_GATEWAY, t || qb.UNKNOWN_REASON, this.url || \"\"), this.reconnectToken = void 0, this.emit(Rb.NEED_RENEW_SESSION, this.websocket.currentURLIndex >= this.websocket.urls.length - 1 ? \"recover\" : e), this.emit(Rb.DISCONNECT_P2P)), i(e);\n      }), this.websocket.on(Ab.CONNECTED, () => {\n        this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch(e => {\n          Qy.warning(\"[\".concat(this.clientId, \"] rejoin failed \").concat(e)), this.reconnect(\"tryNext\", DI.SERVER_ERROR);\n        }) : this.join().catch(e => {\n          if (this.emit(Rb.REPORT_JOIN_GATEWAY, e.message || e.code || qb.UNKNOWN_REASON, this.url || \"\"), e instanceof bb) {\n            if (e.code === tI.UNEXPECTED_RESPONSE && e.data.code === Sb.ERR_NO_AUTHORIZED) return this.initError = new bb(tI.CAN_NOT_GET_GATEWAY_SERVER, \"AgoraRTCError CAN_NOT_GET_GATEWAY_SERVER: dynamic key expired\"), Qy.warning(\"[\".concat(this.clientId, \"] reconnect no authorized, recover\")), void this.reconnect(\"recover\", DI.SERVER_ERROR);\n            Qy.error(\"[\".concat(this.clientId, \"] join gateway request failed\"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect(\"tryNext\", DI.SERVER_ERROR) : (this.initError = e, this.close());\n          }\n        });\n      }), this.websocket.on(Ab.REQUEST_NEW_URLS, (e, t) => {\n        kI(this, Rb.REQUEST_RECOVER, this.multiIpOption).then(e).catch(t);\n      }), this.websocket.on(Ab.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {\n        this.emit(Ib.ON_TOKEN_PRIVILEGE_DID_EXPIRE);\n      });\n    }\n  }\n  let jw = function (e) {\n    return e[e.CHOOSE_SERVER = 11] = \"CHOOSE_SERVER\", e[e.CLOUD_PROXY = 18] = \"CLOUD_PROXY\", e[e.CLOUD_PROXY_5 = 20] = \"CLOUD_PROXY_5\", e[e.CLOUD_PROXY_FALLBACK = 26] = \"CLOUD_PROXY_FALLBACK\", e;\n  }({});\n  function Gw(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function Ww(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? Gw(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Gw(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function Hw(e) {\n    return e.match(/^[\\.\\:\\d]+$/) ? \"\".concat(e.replace(/[^\\d]/g, \"-\"), \".\").concat(Dy(\"TURN_DOMAIN\")) : (Qy.info(\"Unidentified as ip: \".concat(e, \", use as host\")), e);\n  }\n  function Kw(e, t) {\n    e.addresses || (e.addresses = []);\n    const i = function (e, t) {\n        if (Dy(\"CONNECT_GATEWAY_WITHOUT_DOMAIN\")) return e.map(e => {\n          let t = e.ip,\n            i = e.port;\n          return {\n            address: \"\".concat(t, \":\").concat(i)\n          };\n        });\n        const i = Dy(\"GATEWAY_DOMAINS\");\n        let n = i[1] && Dn(t).call(t, i[1]) ? 1 : 0;\n        return e.map(e => {\n          let t = e.domain_prefix,\n            r = e.port,\n            o = e.ip;\n          if (t) return {\n            address: \"\".concat(t, \".\").concat(i[n++ % i.length], \":\").concat(r)\n          };\n          const s = /^[\\.\\:\\d]+$/.test(o),\n            a = s ? \"\".concat(o.replace(/[^\\d]/g, \"-\"), \".\").concat(i[n++ % i.length], \":\").concat(r) : \"\".concat(o, \":\").concat(r);\n          return s || Qy.info(\"Unidentified as ip: \".concat(o, \", use as host\")), {\n            ip: o,\n            port: r,\n            address: a\n          };\n        });\n      }(e.addresses, t),\n      n = Array.isArray(e.detail) && e.detail[18];\n    if (n && \"string\" == typeof n) {\n      const e = n.split(\";\");\n      for (let t = 0; t < e.length; t++) {\n        var r;\n        const n = jp(r = e[t]).call(r);\n        i[t] && n && (i[t].ip6 = n);\n      }\n    }\n    return {\n      gatewayAddrs: i,\n      uid: e.uid,\n      cid: e.cid,\n      cert: e.cert,\n      vid: e.detail && e.detail[8],\n      uni_lbs_ip: e.detail && e.detail[1],\n      res: e,\n      csIp: e.detail && e.detail[502]\n    };\n  }\n  function Yw(e) {\n    return \"number\" == typeof e ? e : e.exact || e.ideal || e.max || e.min || 0;\n  }\n  function qw(e) {\n    const t = e._encoderConfig;\n    if (!t) return {};\n    const i = {\n      resolution: t.width && t.height ? \"\".concat(Yw(t.width), \"x\").concat(Yw(t.height)) : void 0,\n      maxVideoBW: t.bitrateMax,\n      minVideoBW: t.bitrateMin\n    };\n    return \"number\" == typeof t.frameRate ? (i.maxFrameRate = t.frameRate, i.minFrameRate = t.frameRate) : t.frameRate && (i.maxFrameRate = t.frameRate.max || t.frameRate.ideal || t.frameRate.exact || t.frameRate.min, i.minFrameRate = t.frameRate.min || t.frameRate.ideal || t.frameRate.exact || t.frameRate.max), i;\n  }\n  function zw(e) {\n    return e >= 0 && e < .17 ? 1 : e >= .17 && e < .36 ? 2 : e >= .36 && e < .59 ? 3 : e >= .59 && e <= 1 ? 4 : e > 1 ? 5 : 0;\n  }\n  function Jw(e, t) {\n    let i, n, r;\n    switch (t) {\n      case jw.CHOOSE_SERVER:\n        n = 4096, r = \"choose server\";\n        break;\n      case jw.CLOUD_PROXY:\n        n = 1048576, r = \"proxy\";\n        break;\n      case jw.CLOUD_PROXY_5:\n        n = 4194304, r = \"proxy5\";\n        break;\n      case jw.CLOUD_PROXY_FALLBACK:\n        n = 4194310, r = \"proxy fallback\";\n        break;\n      default:\n        throw new bb(tI.UNEXPECTED_ERROR, \"multi unlibs response transformer get unknown service id\", {\n          csIp: e.detail && e.detail[502],\n          retry: !1\n        });\n    }\n    if (e.response_body.forEach(t => {\n      t.buffer && t.buffer.flag === n && (i = {\n        code: t.buffer.code,\n        addresses: (t.buffer.edges_services || []).map(e => Ww(Ww({}, e), {}, {\n          ticket: t.buffer.cert\n        })),\n        server_ts: e.enter_ts,\n        uid: t.buffer.uid,\n        cid: t.buffer.cid,\n        cname: t.buffer.cname,\n        detail: Ww(Ww({}, t.buffer.detail), e.detail),\n        flag: t.buffer.flag,\n        opid: e.opid,\n        cert: t.buffer.cert\n      });\n    }), !i) throw new bb(tI.MULTI_UNILBS_RESPONSE_ERROR, \"cannot parse response \".concat(r, \" from multi unilbs response\"), {\n      csIp: e.detail && e.detail[502]\n    });\n    return i;\n  }\n  async function Xw(e, t) {\n    return await Gu.all(e.addresses.map(async e => ({\n      address: Hw(e.ip),\n      tcpport: e.port,\n      udpport: e.port,\n      username: t && Dy(\"ENCRYPT_PROXY_USERNAME_AND_PSW\") && window.isSecureContext ? t.toString() : aA.username,\n      password: t && Dy(\"ENCRYPT_PROXY_USERNAME_AND_PSW\") && window.isSecureContext ? await TI(t.toString()) : aA.password\n    })));\n  }\n  function Qw(e, t) {\n    const i = t.getMediaStreamTrack(!0).getSettings(),\n      n = t.videoHeight || i.height,\n      r = t.videoWidth || i.width;\n    return n && r ? Math.max(Math.min(n, r) / Math.min(Yw(e.height), Yw(e.width)), 1) : (Qy.warning(\"can't get ori-track's height, default scale down 4 times for low stream\"), 4);\n  }\n  function Zw(e) {\n    let t = e.candidateType,\n      i = e.relayProtocol,\n      n = e.type,\n      r = e.address,\n      o = e.port,\n      s = e.protocol;\n    return \"local-candidate\" === n ? {\n      candidateType: t,\n      relayProtocol: i,\n      protocol: s\n    } : {\n      candidateType: t,\n      relayProtocol: i,\n      address: r,\n      port: o,\n      protocol: s\n    };\n  }\n  function $w(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  class eO extends SI {\n    get url() {\n      return this._url ? this._url : null;\n    }\n    get reconnectMode() {\n      return this._reconnectMode;\n    }\n    set reconnectMode(e) {\n      var t;\n      Dn(t = [\"tryNext\", \"recover\"]).call(t, e) && this.resetReconnectCount(e), this._reconnectMode = e;\n    }\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      e !== this._state && (this._state = e, \"reconnecting\" === this._state ? this.emit(pw.RECONNECTING, this.reconnectReason) : \"connected\" === this._state ? this.emit(pw.CONNECTED) : \"closed\" === this._state ? this.emit(pw.CLOSED) : \"failed\" === this._state && this.emit(pw.FAILED));\n    }\n    constructor(e, t, i, n) {\n      super(), ng(this, \"connectionID\", 0), ng(this, \"currentURLIndex\", 0), ng(this, \"reconnectReason\", void 0), ng(this, \"_reconnectMode\", \"tryNext\"), ng(this, \"_initMutex\", void 0), ng(this, \"_name\", void 0), ng(this, \"_state\", \"closed\"), ng(this, \"_reconnectInterrupter\", void 0), ng(this, \"_url\", void 0), ng(this, \"_retryConfig\", void 0), ng(this, \"_reconnectCount\", 0), ng(this, \"_forceCloseTimeout\", 5e3), ng(this, \"_onlineReconnectListener\", void 0), ng(this, \"_closeEstablishingTransmitter\", () => {}), ng(this, \"_store\", void 0), ng(this, \"_joinChannelServiceRecordIndex\", void 0), ng(this, \"_transmitter\", void 0), ng(this, \"_useCompress\", void 0), ng(this, \"_inflateLength\", 0), ng(this, \"_deflateLength\", 0), this._store = n, this._name = e, this._retryConfig = function (e) {\n        for (var t = 1; t < arguments.length; t++) {\n          var i = null != arguments[t] ? arguments[t] : {};\n          t % 2 ? $w(Object(i), !0).forEach(function (t) {\n            ng(e, t, i[t]);\n          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : $w(Object(i)).forEach(function (t) {\n            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n          });\n        }\n        return e;\n      }({}, t), this._useCompress = i;\n    }\n    resetReconnectCount(e) {\n      Qy.debug(\"\".concat(this._name, \" reset reconnect count, reason: \").concat(e)), this._reconnectCount = 0;\n    }\n    close(e, t) {\n      if (this.currentURLIndex = 0, this.resetReconnectCount(\"close\"), this._reconnectInterrupter && this._reconnectInterrupter(), this._transmitter) {\n        this._transmitter.onclose = null, this._transmitter.onopen = null, this._transmitter.onmessage = null;\n        const e = this._transmitter;\n        t ? setTimeout(() => e.close(), 500) : e.close(), this._transmitter = void 0;\n      }\n      this.state = e ? \"failed\" : \"closed\", this._closeEstablishingTransmitter && this._closeEstablishingTransmitter();\n    }\n    reconnect(e, t) {\n      if (!this._transmitter) return void Qy.warning(\"[\".concat(this._name, \"] can not reconnect, no websocket\"));\n      var i;\n      (void 0 !== e && (this.reconnectMode = e), Qy.debug(\"[\".concat(this._name, \"] reconnect is triggered initiative\")), \"number\" == typeof this._joinChannelServiceRecordIndex) && (null === (i = this._store) || void 0 === i || i.recordJoinChannelService({\n        status: \"error\",\n        errors: [new Error(t)]\n      }, this._joinChannelServiceRecordIndex));\n      const n = this._transmitter.onclose;\n      this._transmitter.onclose = null, this._transmitter.close(), n && n.bind(this._transmitter)({\n        code: 9999,\n        reason: t\n      });\n    }\n    getInflateData() {\n      const e = this._inflateLength,\n        t = this._deflateLength;\n      return this.clearInflateData(), {\n        inflateLength: e,\n        deflateLength: t\n      };\n    }\n    setInflateData(e) {\n      this._deflateLength = this._deflateLength + e.originLength, this._inflateLength = this._inflateLength + e.compressedLength;\n    }\n    clearInflateData() {\n      this._inflateLength = 0, this._deflateLength = 0;\n    }\n  }\n  let tO = function (e) {\n    return e[e.Default = 0] = \"Default\", e[e.Ack = 1] = \"Ack\", e;\n  }({});\n  class iO {\n    constructor(e, t, i) {\n      ng(this, \"version\", 1), ng(this, \"initialRTO\", void 0), ng(this, \"maxBatchAckCount\", void 0), ng(this, \"maxRTO\", void 0), ng(this, \"initialRTT\", void 0), ng(this, \"ID\", void 0), ng(this, \"rtt\", void 0), ng(this, \"packetNumber\", 1), ng(this, \"rtoRatioMap\", new Map()), ng(this, \"timeoutMap\", new Map()), ng(this, \"unorderedPacketQueue\", []), ng(this, \"batchAckPacketQueue\", []), ng(this, \"lastOrderedPacketNumber\", 0), ng(this, \"batchAckTimer\", void 0), ng(this, \"sendImpl\", void 0), ng(this, \"receiveImpl\", void 0), this.sendImpl = e, this.receiveImpl = t, this.ID = ey(7, \"transmitter-\"), this.initialRTO = void 0 !== (null == i ? void 0 : i.initialRTO) ? i.initialRTO : Dy(\"TRANSMITTER_INITIAL_RTO\"), this.initialRTT = void 0 !== (null == i ? void 0 : i.initialRTT) ? i.initialRTT : Dy(\"TRANSMITTER_INITIAL_RTT\"), this.rtt = void 0 !== (null == i ? void 0 : i.initialRTT) ? i.initialRTT : Dy(\"TRANSMITTER_INITIAL_RTT\"), this.maxBatchAckCount = void 0 !== (null == i ? void 0 : i.maxBatchAckCount) ? i.maxBatchAckCount : Dy(\"TRANSMITTER_MAX_BATCH_ACK_COUNT\"), this.maxRTO = void 0 !== (null == i ? void 0 : i.maxRTO) ? i.maxRTO : Dy(\"TRANSMITTER_MAX_RTO\");\n    }\n    packetize(e, t) {\n      return {\n        type: tO.Default,\n        version: this.version,\n        packetNumber: t,\n        payload: e\n      };\n    }\n    serialize(e) {\n      switch (e.type) {\n        case tO.Default:\n          {\n            let t;\n            if (\"string\" == typeof e.payload) {\n              t = new TextEncoder().encode(e.payload);\n            } else t = e.payload;\n            const i = new ArrayBuffer(t.length + 15),\n              n = new DataView(i);\n            n.setUint16(0, e.version), n.setUint8(2, e.type), n.setUint32(3, e.packetNumber), uI(n, 7, BigInt(e.sendTs));\n            return new Uint8Array(n.buffer).set(t, 15), i;\n          }\n        case tO.Ack:\n          {\n            const t = new ArrayBuffer(16),\n              i = new DataView(t);\n            return i.setUint16(0, e.version), i.setUint8(2, e.type), i.setUint32(3, e.maxAckPacketNumber), i.setUint8(7, e.shift), uI(i, 8, BigInt(e.ackSendTs)), t;\n          }\n      }\n    }\n    deserialize(e) {\n      const t = new DataView(e),\n        i = t.getUint16(0),\n        n = t.getUint8(2);\n      switch (n) {\n        case tO.Default:\n          {\n            const r = t.getUint32(3),\n              o = hI(t, 7),\n              s = e.slice(15),\n              a = new TextDecoder().decode(s);\n            return {\n              version: i,\n              type: n,\n              packetNumber: r,\n              sendTs: Number(o),\n              payload: a\n            };\n          }\n        case tO.Ack:\n          {\n            const e = t.getUint32(3),\n              r = t.getUint8(7),\n              o = hI(t, 8);\n            return {\n              version: i,\n              type: n,\n              maxAckPacketNumber: e,\n              shift: r,\n              ackSendTs: Number(o)\n            };\n          }\n        default:\n          throw Qy.error(\"[\".concat(this.ID, \"] Unrecognized packet type \").concat(n)), new Error(\"Unrecognized packet type \".concat(n));\n      }\n    }\n    sendMessage(e) {\n      const t = this.packetize(e, this.packetNumber);\n      this.packetNumber = 4294967295 === this.packetNumber ? 1 : this.packetNumber + 1;\n      const i = this.calculateRTO(t),\n        n = window.setTimeout(() => {\n          this.resendMessage(t);\n        }, i);\n      this.timeoutMap.set(t.packetNumber, n), this.sendPacket(t);\n    }\n    onData(e) {\n      const t = this.deserialize(e);\n      t.type === tO.Default ? this.ack(t) : t.type === tO.Ack && (this.updateRTT(t, Math.round(performance.now())), this.clearRTO(t));\n    }\n    close() {\n      this.rtt = this.initialRTT, this.packetNumber = 1, Array.from(this.timeoutMap.entries()).forEach(e => {\n        let _e7 = _slicedToArray(e, 2),\n          t = _e7[0],\n          i = _e7[1];\n        window.clearTimeout(i);\n      }), this.timeoutMap = new Map(), this.rtoRatioMap = new Map(), this.unorderedPacketQueue = [], this.batchAckPacketQueue = [], this.lastOrderedPacketNumber = 0, void 0 !== this.batchAckTimer && window.clearTimeout(this.batchAckTimer);\n    }\n    resendMessage(e) {\n      const t = this.calculateRTO(e),\n        i = window.setTimeout(() => {\n          this.resendMessage(e);\n        }, t);\n      this.timeoutMap.set(e.packetNumber, i), this.sendPacket(e);\n    }\n    calculateRTO(e) {\n      const t = this.rtoRatioMap.get(e.packetNumber);\n      if (void 0 === t) return this.rtoRatioMap.set(e.packetNumber, 1), this.initialRTO;\n      {\n        const i = 9 * this.rtt / 8 * t;\n        return this.rtoRatioMap.set(e.packetNumber, t + 1), i > this.maxRTO ? this.maxRTO : i;\n      }\n    }\n    updateRTT(e, t) {\n      const i = e.ackSendTs;\n      this.rtt = this.rtt * (7 / 8) + (t - i - this.rtt) / 8;\n    }\n    ack(e) {\n      if (e.packetNumber === this.lastOrderedPacketNumber + 1) for (this.batchAckPacketQueue.length >= this.maxBatchAckCount && this.batchAck(), this.batchAckTimer ? this.batchAckPacketQueue.push(e) : (this.batchAckPacketQueue.push(e), this.batchAckTimer = window.setTimeout(() => {\n        this.batchAck();\n      }, this.rtt / 8)), this.lastOrderedPacketNumber += 1, this.receiveImpl(e.payload);;) {\n        const e = this.unorderedPacketQueue[0];\n        if (!e) {\n          this.unorderedPacketQueue.shift();\n          break;\n        }\n        this.batchAckTimer && this.batchAck(), this.receiveImpl(e.payload), this.unorderedPacketQueue.shift(), this.lastOrderedPacketNumber += 1;\n      } else if (e.packetNumber <= this.lastOrderedPacketNumber) {\n        const t = {\n          ackSendTs: e.sendTs,\n          maxAckPacketNumber: e.packetNumber,\n          shift: 0,\n          type: tO.Ack,\n          version: this.version\n        };\n        this.sendPacket(t);\n      } else if (e.packetNumber > this.lastOrderedPacketNumber) {\n        this.unorderedPacketQueue[e.packetNumber - this.lastOrderedPacketNumber - 2] = e;\n        const t = {\n          ackSendTs: e.sendTs,\n          maxAckPacketNumber: e.packetNumber,\n          shift: 0,\n          type: tO.Ack,\n          version: this.version\n        };\n        this.sendPacket(t);\n      }\n    }\n    batchAck() {\n      window.clearTimeout(this.batchAckTimer), this.batchAckTimer = void 0;\n      const e = {\n        ackSendTs: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].sendTs,\n        maxAckPacketNumber: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].packetNumber,\n        shift: this.batchAckPacketQueue.length - 1,\n        type: tO.Ack,\n        version: this.version\n      };\n      this.sendPacket(e), this.batchAckPacketQueue = [];\n    }\n    sendPacket(e) {\n      e.type === tO.Default && (e.sendTs = Math.round(performance.now()));\n      const t = this.serialize(e);\n      this.sendImpl(t);\n    }\n    clearRTO(e) {\n      for (let t = e.maxAckPacketNumber - e.shift; t <= e.maxAckPacketNumber; t++) {\n        const e = this.timeoutMap.get(t);\n        void 0 !== e && window.clearTimeout(e), this.timeoutMap.delete(t), this.rtoRatioMap.delete(t);\n      }\n    }\n  }\n  class nO extends eO {\n    constructor(e, t) {\n      super(e, t, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), ng(this, \"_initMutex\", void 0), ng(this, \"_reconnectInterrupter\", void 0), ng(this, \"_url\", void 0), ng(this, \"_transmitter\", void 0), ng(this, \"_addresses\", void 0), ng(this, \"_reliableTransmission\", void 0), this._initMutex = new uy(\"datachannel\");\n      const i = t.timeout,\n        n = t.timeoutFactor,\n        r = Math.max(300, Math.floor(3 * i / 5)),\n        o = Math.max(1.2, Math.floor(8 * n) / 10);\n      PI.ONLINE && (this._retryConfig.timeout = r, this._retryConfig.timeoutFactor = o), VI.on(LI.NETWORK_STATE_CHANGE, (e, t) => {\n        e !== t && (this.resetReconnectCount(\"network state change: \".concat(t, \" -> \").concat(e)), e === PI.ONLINE ? (this._retryConfig.timeout = r, this._retryConfig.timeoutFactor = o) : (this._retryConfig.timeout = i, this._retryConfig.timeoutFactor = n));\n      });\n    }\n    getConnection() {\n      if (this._reliableTransmission) return this._reliableTransmission;\n    }\n    async init(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;\n      this._forceCloseTimeout = t;\n      const i = (t, i) => {\n        this._addresses = e, this.currentURLIndex = this._addresses.findIndex(e => e.fingerprint || Dy(\"FINGERPRINT\"));\n        const n = this._addresses[this.currentURLIndex];\n        this.state = \"connecting\", this.createTransmitterConnection(n).then(t).catch(i), this.once(pw.CLOSED, () => i(new bb(tI.WS_DISCONNECT))), this.once(pw.CONNECTED, () => t());\n      };\n      return this._initMutex.lock().then(e => new Gu((e, t) => {\n        i(e, t);\n      }).then(() => {\n        e();\n      }).catch(() => {\n        e();\n      }));\n    }\n    sendMessage(e) {\n      let t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      if (!this._transmitter || !this._reliableTransmission) throw new bb(tI.WS_ABORT, \"datachannel is not ready\");\n      try {\n        t || (e = JSON.stringify(e)), this._reliableTransmission.sendMessage(e);\n      } catch (e) {\n        throw new bb(tI.WS_ERR, \"send datachannel signal message error\" + e.toString());\n      }\n    }\n    unbindDcCloseEventListener() {\n      this._transmitter && (this._transmitter.onclose = null);\n    }\n    sendMessageWithJSON(e) {\n      const t = JSON.stringify(e);\n      return {\n        compressed: t,\n        compressedLength: t.length,\n        origin: e\n      };\n    }\n    sendMessageWithUint8Array(e) {\n      return {\n        compressed: e,\n        compressedLength: e.byteLength,\n        origin: e\n      };\n    }\n    createTransmitterConnection(e) {\n      return this.connectionID += 1, this._joinChannelServiceRecordIndex = void 0, this._url = \"dc://\".concat(e.ip, \":\").concat(e.port), new Gu((t, i) => {\n        var n;\n        const r = () => {\n            Qy.debug(\"[\".concat(this._name, \"] datachannel opened:\"), this._url), this.reconnectMode = \"retry\", this.state = \"connected\", this.resetReconnectCount(\"opened\"), t();\n          },\n          o = async e => {\n            var n;\n            if (null === (n = this._closeEstablishingTransmitter) || void 0 === n || n.call(this), Qy.debug(\"[\".concat(this._name, \"] datachannel close \").concat(this._url, \", code: \").concat(e.code, \", reason: \").concat(e.reason, \", current mode: \").concat(this.reconnectMode)), this._reconnectCount < this._retryConfig.maxRetryCount) {\n              \"connected\" === this.state && (this.reconnectReason = e.reason, this.state = \"reconnecting\");\n              const n = UI(this, pw.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode,\n                r = await this.reconnectWithAction(n);\n              if (\"closed\" === this.state) return void Qy.debug(\"[\".concat(this.connectionID, \"] dc is closed, no need to reconnect\"));\n              if (!r) return i(new bb(tI.WS_DISCONNECT, \"datachannel reconnect failed: \".concat(e.code))), void this.close(!0);\n              t();\n            } else i(new bb(tI.WS_DISCONNECT, \"datachannel close: \".concat(e.code))), this.close();\n          },\n          s = e => {\n            var t;\n            null === (t = this._reliableTransmission) || void 0 === t || t.onData(e.data);\n          };\n        this._transmitter && (this._transmitter.onclose = null, this._transmitter.close()), this._reliableTransmission && (this._reliableTransmission.close(), this._reliableTransmission = void 0), Qy.debug(\"[\".concat(this._name, \"] start connect, address: \").concat(JSON.stringify(e)));\n        const a = null === (n = this._store) || void 0 === n ? void 0 : n.recordJoinChannelService({\n            startTs: Date.now(),\n            status: \"pending\",\n            service: \"gateway\"\n          }),\n          c = Date.now();\n        kI(this, pw.TO_CONNECT_DATACHANNEL, e).then(e => {\n          var t, i;\n          if (!e) throw new Error(\"transmissonInfo not exist yet\");\n          const n = e.transmitter,\n            d = e.close;\n          this._transmitter = n, null === (t = this._store) || void 0 === t || t.signalChannelOpen();\n          const l = Date.now() - c;\n          Qy.debug(\"[choose dc] dc open cost \".concat(l, \"ms\"));\n          this._reliableTransmission = new iO(e => {\n            var t;\n            this._transmitter && \"open\" === this._transmitter.readyState && (null === (t = this._transmitter) || void 0 === t || t.send(e));\n          }, e => {\n            \"string\" == typeof e && this.emit(pw.ON_MESSAGE, e);\n          }), this._closeEstablishingTransmitter = () => {\n            var e;\n            null === (e = this._reliableTransmission) || void 0 === e || e.close(), this._reliableTransmission = void 0, d();\n          }, r && r(), n.onclose = o, n.onmessage = s, null === (i = this._store) || void 0 === i || i.recordJoinChannelService({\n            endTs: Date.now(),\n            status: \"success\"\n          }, a), this._joinChannelServiceRecordIndex = a;\n        }).catch(e => {\n          var t;\n          if (null === (t = this._store) || void 0 === t || t.recordJoinChannelService({\n            endTs: Date.now(),\n            status: e instanceof bb && e.code === tI.WS_ABORT ? \"aborted\" : \"error\",\n            errors: [e]\n          }, a), \"closed\" !== this.state) {\n            if (e instanceof bb && e.code === tI.WS_ERR) {\n              const t = new bb(tI.WS_ERR, \"init datachannel failed! Error: \".concat(e.toString()));\n              return Qy.error(\"[\".concat(this._name, \"]\").concat(t)), void i(t);\n            }\n            o && o(e);\n          } else i(new bb(tI.WS_DISCONNECT, \"datachannel is closed: \".concat(e.toString())));\n        });\n      });\n    }\n    async reconnectWithAction(e) {\n      let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (this._reconnectCount >= this._retryConfig.maxRetryCount) return !1;\n      if (!this._addresses) return !1;\n      if (\"closed\" === this.state) return !1;\n      this._onlineReconnectListener || VI.networkState !== PI.OFFLINE || (this._onlineReconnectListener = VI.onlineWaiter && VI.onlineWaiter.then(() => {\n        this._onlineReconnectListener = void 0;\n      }));\n      let i = !0;\n      if (this._reconnectInterrupter = () => {\n        i = !1;\n      }, t) {\n        const t = Ey(this._reconnectCount, this._retryConfig);\n        Qy.debug(\"[\".concat(this._name, \"] wait \").concat(t, \"ms to reconnect datachannel, mode: \").concat(e)), await Gu.race([$I(t), this._onlineReconnectListener || new Gu(() => {})]);\n      }\n      if (\"closed\" === this.state || !i) return !1;\n      this._reconnectCount += 1;\n      const n = async (e, t) => {\n        this.emit(pw.RECONNECT_CREATE_CONNECTION, t), await this.createTransmitterConnection(e);\n      };\n      try {\n        if (\"retry\" === e) {\n          const t = this._addresses[this.currentURLIndex];\n          this.emit(pw.RECONNECT_WAITTING_FINISH, e), await n(t, e);\n        } else if (\"tryNext\" === e) {\n          this.currentURLIndex += 1;\n          for (let e = this.currentURLIndex; e < this._addresses.length; e++) {\n            if (this._addresses[e].fingerprint || Dy(\"FINGERPRINT\")) {\n              this.currentURLIndex = e;\n              break;\n            }\n            this.currentURLIndex += 1;\n          }\n          if (this.currentURLIndex >= this._addresses.length) return Qy.debug(\"[\".concat(this._name, \"] the available addresses are exhausted, change to recover\")), await this.reconnectWithAction(\"recover\", !1);\n          Qy.debug(\"[\".concat(this._name, \"] datachannel url length: \").concat(this._addresses.length, \" current index: \").concat(this.currentURLIndex));\n          const t = this._addresses[this.currentURLIndex];\n          this.emit(pw.RECONNECT_WAITTING_FINISH, e), await n(t, e);\n        } else \"recover\" === e && (Qy.debug(\"[\".concat(this._name, \"] start to failback to websocket\")), this.resetReconnectCount(\"recover mode\"), this.emit(pw.RECONNECT_WAITTING_FINISH, e), this.emit(pw.FAILBACK));\n        return !0;\n      } catch (i) {\n        var r, o;\n        return Qy.error(\"[\".concat(this._name, \"] reconnect failed\"), i.toString()), null != i && null !== (r = i.data) && void 0 !== r && r.desc && Array.isArray(i.data.desc) && i.data.desc.length && Dn(o = i.data.desc).call(o, \"dynamic key expired\") ? (this.emit(pw.ON_TOKEN_PRIVILEGE_DID_EXPIRE), !1) : await this.reconnectWithAction(e, t);\n      }\n    }\n  }\n  class rO extends SI {\n    get connectionState() {\n      return this._connectionState;\n    }\n    set connectionState(e) {\n      e !== this._connectionState && (this._connectionState = e, e === gb.CONNECTED ? this.emit(Rb.WS_CONNECTED) : e === gb.RECONNECTING ? this.emit(Rb.WS_RECONNECTING, this._websocketReconnectReason) : e === gb.CLOSED && this.emit(Rb.WS_CLOSED, this._disconnectedReason));\n    }\n    get currentURLIndex() {\n      return this.websocket.currentURLIndex;\n    }\n    get url() {\n      return this.websocket ? this.websocket.url : null;\n    }\n    get rtt() {\n      return this.rttRolling.mean();\n    }\n    constructor(e, t) {\n      super(), ng(this, \"_disconnectedReason\", void 0), ng(this, \"_websocketReconnectReason\", void 0), ng(this, \"_connectionState\", gb.CLOSED), ng(this, \"reconnectToken\", void 0), ng(this, \"websocket\", void 0), ng(this, \"openConnectionTime\", void 0), ng(this, \"clientId\", void 0), ng(this, \"lastMsgTime\", Date.now()), ng(this, \"uploadCache\", []), ng(this, \"uploadCacheInterval\", void 0), ng(this, \"rttRolling\", new fy(5)), ng(this, \"pingpongTimer\", void 0), ng(this, \"inflateDataTimer\", void 0), ng(this, \"pingpongTimeoutCount\", 0), ng(this, \"joinResponse\", void 0), ng(this, \"multiIpOption\", void 0), ng(this, \"initError\", void 0), ng(this, \"spec\", void 0), ng(this, \"store\", void 0), ng(this, \"onWebsocketMessage\", e => {\n        if (e instanceof ArrayBuffer) return void this.emit(Rb.ON_BINARY_DATA, e);\n        const t = JSON.parse(e);\n        if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t, \"_id\")) {\n          const e = \"res-@\".concat(t._id);\n          this.emit(e, t._result, t._message);\n        } else if (Object.prototype.hasOwnProperty.call(t, \"_type\") && (this.emit(t._type, t._message), t._type === Ib.ON_NOTIFICATION && this.handleNotification(t._message), t._type === Ib.ON_USER_BANNED)) switch (t._message.error_code) {\n          case 14:\n            this.close(AI.UID_BANNED);\n            break;\n          case 15:\n            this.close(AI.IP_BANNED);\n            break;\n          case 16:\n            this.close(AI.CHANNEL_BANNED);\n        }\n      }), this.clientId = e.clientId, this.spec = e, this.store = t, this.websocket = new nO(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, t), this.handleWebsocketEvents(), window.addEventListener(\"offline\", () => {\n        this.connectionState === gb.CONNECTED && this.reconnect(\"retry\", uw.OFFLINE);\n      });\n    }\n    async request(e, t, i, n) {\n      const r = ey(6, \"\"),\n        o = {\n          _id: r,\n          _type: e,\n          _message: t\n        },\n        s = this.websocket.connectionID,\n        a = () => new Gu((t, i) => {\n          if (this.connectionState === gb.CONNECTED) return t();\n          const n = () => {\n              this.off(Rb.WS_CLOSED, r), t();\n            },\n            r = () => {\n              this.off(Rb.WS_CONNECTED, n), i(new bb(tI.WS_ABORT));\n            };\n          this.once(Rb.WS_CONNECTED, n), this.once(Rb.WS_CLOSED, r), e !== Cb.PUBLISH && e !== Cb.SUBSCRIBE && e !== Cb.UNSUBSCRIBE && e !== Cb.UNPUBLISH && e !== Cb.CONTROL && e !== Cb.RESTART_ICE || this.once(Rb.DISCONNECT_P2P, () => {\n            i(new bb(tI.DISCONNECT_P2P));\n          }), e !== Cb.PUBLISH && e !== Cb.RESTART_ICE || this.once(Rb.ABORT_P2P_EXECUTION, () => {\n            i(new bb(tI.DISCONNECT_P2P));\n          });\n        });\n      if (this.connectionState !== gb.CONNECTING && this.connectionState !== gb.RECONNECTING || e === Cb.JOIN || e === Cb.REJOIN || (await a()), e === Cb.LEAVE && (this.websocket.unbindDcCloseEventListener(), n = !0), this.websocket.sendMessage(o, !0, !1), n) return;\n      const c = new Gu((i, n) => {\n        let o = !1;\n        const a = (n, r) => {\n          o = !0, i({\n            isSuccess: \"success\" === n,\n            message: r || {}\n          }), this.off(Rb.WS_CLOSED, c), this.off(Rb.WS_RECONNECTING, c), this.emit(Rb.REQUEST_SUCCESS, e, t);\n        };\n        this.once(\"res-@\".concat(r), a);\n        const c = () => {\n          n(new bb(tI.WS_ABORT, \"type: \".concat(e))), this.off(Rb.WS_CLOSED, c), this.off(Rb.WS_RECONNECTING, c), this.off(\"res-@\".concat(r), a);\n        };\n        this.once(Rb.WS_CLOSED, c), this.once(Rb.WS_RECONNECTING, c), $I(Dy(\"SIGNAL_REQUEST_TIMEOUT\")).then(() => {\n          this.websocket.connectionID !== s || o || (Qy.warning(\"dc request timeout, type: \".concat(e)), this.emit(Rb.REQUEST_TIMEOUT, e, t));\n        });\n      });\n      let d = null;\n      try {\n        d = await c;\n      } catch (n) {\n        if (this.connectionState === gb.CLOSED || e === Cb.LEAVE) throw new bb(tI.WS_ABORT);\n        return !this.spec.forceWaitGatewayResponse || i ? n.throw() : e === Cb.JOIN || e === Cb.REJOIN ? null : (await a(), await this.request(e, t));\n      }\n      if (d.isSuccess) return d.message;\n      const l = Number(d.message.error_code || d.message.code),\n        h = yw(l),\n        u = new bb(tI.UNEXPECTED_RESPONSE, \"\".concat(h.desc, \": \").concat(d.message.error_str), {\n          code: l,\n          data: d.message\n        });\n      return \"success\" === h.action ? d.message : (Qy.warning(\"[\".concat(this.websocket.connectionID, \"] unexpected response from type \").concat(e, \", error_code: \").concat(l, \", message: \").concat(h.desc, \", action: \").concat(h.action)), l === Sb.ERR_TOO_MANY_BROADCASTERS ? e === Cb.JOIN || e === Cb.REJOIN ? (this.initError = u, this.close(), u.throw()) : u.throw() : \"failed\" === h.action ? u.throw() : \"quit\" === h.action ? (this.initError = u, this.close(), u.throw()) : (l === Sb.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d.message.option, Qy.warning(\"[\".concat(this.clientId, \"] detect multi ip, recover\")), this.reconnect(\"recover\", uw.MULTI_IP)) : this.reconnect(h.action, uw.SERVER_ERROR), e === Cb.JOIN || e === Cb.REJOIN ? null : await this.request(e, t)));\n    }\n    waitMessage(e, t) {\n      return new Gu(i => {\n        const n = r => {\n          (!t || t(r)) && (this.off(e, n), i(r));\n        };\n        this.on(e, n);\n      });\n    }\n    uploadWRTCStats(e) {\n      if (!this.store.sessionId) return void Qy.warn(\"[\".concat(this.clientId, \"] no session id when upload wrtc stats\"));\n      const t = {\n        lts: Date.now(),\n        sid: this.store.sessionId,\n        uid: this.store.intUid,\n        stats: e\n      };\n      this.upload(vb.WRTC_STATS, t);\n    }\n    upload(e, t) {\n      const i = {\n        _type: e,\n        _message: t\n      };\n      try {\n        this.websocket.sendMessage(i);\n      } catch (e) {\n        const t = Dy(\"MAX_UPLOAD_CACHE\") || 50;\n        this.uploadCache.push(i), this.uploadCache.length > t && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {\n          if (this.connectionState !== gb.CONNECTED) return;\n          const e = this.uploadCache.splice(0, 1)[0];\n          0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e._type, e._message);\n        }, Dy(\"UPLOAD_CACHE_INTERVAL\") || 2e3));\n      }\n    }\n    send(e, t) {\n      const i = {\n        _type: e,\n        _message: t\n      };\n      this.websocket.sendMessage(i);\n    }\n    init(e, t) {\n      return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Gu((i, n) => {\n        this.once(Rb.WS_CONNECTED, () => i(this.joinResponse)), this.once(Rb.WS_CLOSED, () => n(this.initError || new bb(tI.WS_ABORT))), this.connectionState = gb.CONNECTING, this.websocket.init(e).catch(n), this.websocket.once(pw.FAILBACK, () => {\n          void 0 === this.openConnectionTime && n(new bb(tI.INIT_DATACHANNEL_TIMEOUT));\n        }), this.inflateDataTimer && window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = window.setInterval(() => {\n          this.handleInflateData();\n        }, 2e4), setTimeout(() => {\n          t && void 0 === this.openConnectionTime && (Qy.debug(\"[\".concat(this.clientId, \"] init datachannel timeout while join with failback to websocket\")), n(new bb(tI.INIT_DATACHANNEL_TIMEOUT)));\n        }, Dy(\"DC_JOIN_WITH_FAILBACK\"));\n      });\n    }\n    close(e) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.inflateDataTimer && (this.handleInflateData(), window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e || AI.LEAVE, this.connectionState = gb.CLOSED, Qy.debug(\"[\".concat(this.clientId, \"] \") + \"will close datachannel in signal\"), this.websocket.close(), e === AI.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new nO(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, this.store), this.handleWebsocketEvents());\n    }\n    async join() {\n      if (!this.joinResponse) {\n        this.emit(Rb.ABORT_P2P_EXECUTION);\n        const e = await kI(this, Rb.DATACHANNEL_CONNECTING),\n          t = await this.request(Cb.JOIN, e);\n        if (!t) return this.emit(Rb.REPORT_JOIN_GATEWAY, tI.TIMEOUT, this.url || \"\"), !1;\n        this.joinResponse = t, this.emit(Rb.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;\n      }\n      return this.connectionState = gb.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), !0;\n    }\n    async rejoin() {\n      if (!this.reconnectToken) throw new bb(tI.UNEXPECTED_ERROR, \"can not rejoin, no rejoin token\");\n      const e = xI(this, Rb.REQUEST_REJOIN_INFO);\n      e.token = this.reconnectToken;\n      const t = await this.request(Cb.REJOIN, e);\n      return !!t && (this.connectionState = gb.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t.peers && t.peers.forEach(e => {\n        this.emit(Ib.ON_USER_ONLINE, {\n          uid: e.uid\n        }), e.audio && this.emit(Ib.ON_ADD_AUDIO_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id,\n          audio: !0,\n          ssrcId: e.audio_ssrc\n        }), e.video && this.emit(Ib.ON_ADD_VIDEO_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id,\n          video: !0,\n          ssrcId: e.video_ssrc\n        }), e.audio_mute ? this.emit(Ib.MUTE_AUDIO, {\n          uid: e.uid\n        }) : this.emit(Ib.UNMUTE_AUDIO, {\n          uid: e.uid\n        }), e.video_mute ? this.emit(Ib.MUTE_VIDEO, {\n          uid: e.uid\n        }) : this.emit(Ib.UNMUTE_VIDEO, {\n          uid: e.uid\n        }), e.audio_enable_local ? this.emit(Ib.ENABLE_LOCAL_AUDIO, {\n          uid: e.uid\n        }) : this.emit(Ib.DISABLE_LOCAL_AUDIO, {\n          uid: e.uid\n        }), e.video_enable_local ? this.emit(Ib.ENABLE_LOCAL_VIDEO, {\n          uid: e.uid\n        }) : this.emit(Ib.DISABLE_LOCAL_VIDEO, {\n          uid: e.uid\n        }), e.audio || e.video || this.emit(Ib.ON_REMOVE_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id\n        });\n      }), !0);\n    }\n    reconnect(e, t) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, t);\n    }\n    handleNotification(e) {\n      Qy.debug(\"[\".concat(this.clientId, \"] receive notification: \"), e);\n      const t = yw(e.code);\n      if (\"success\" !== t.action) {\n        if (\"failed\" !== t.action) return \"quit\" === t.action ? (\"ERR_REPEAT_JOIN_CHANNEL\" === t.desc && this.close(AI.UID_BANNED), void this.close()) : void this.reconnect(t.action, uw.SERVER_ERROR);\n        Qy.error(\"[\".concat(this.clientId, \"] ignore error: \"), t.desc);\n      }\n    }\n    handlePingPong() {\n      if (!this.websocket || \"connected\" !== this.websocket.state) return;\n      this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;\n      const e = Dy(\"PING_PONG_TIME_OUT\"),\n        t = Date.now();\n      this.pingpongTimeoutCount >= e && (Qy.warning(\"PINGPONG Timeout. Last Socket Message: \".concat(t - this.lastMsgTime, \"ms\")), t - this.lastMsgTime > Dy(\"WEBSOCKET_TIMEOUT_MIN\")) ? this.reconnect(\"retry\", uw.TIMEOUT) : this.request(Cb.PING, void 0, !0).then(() => {\n        this.pingpongTimeoutCount = 0;\n        const e = Date.now() - t;\n        this.rttRolling.add(e), Dy(\"REPORT_STATS\") && this.send(Cb.PING_BACK, {\n          pingpongElapse: e\n        });\n      }).catch(e => {});\n    }\n    handleInflateData() {\n      const _this$websocket$getIn = this.websocket.getInflateData(),\n        e = _this$websocket$getIn.inflateLength,\n        t = _this$websocket$getIn.deflateLength;\n      0 !== e && 0 !== t && this.upload(vb.WS_INFLATE_DATA_LENGTH, {\n        ws_deflate_length: t,\n        ws_inflate_length: e\n      });\n    }\n    handleWebsocketEvents() {\n      this.websocket.on(pw.RECONNECT_WAITTING_FINISH, e => {\n        this.emit(Rb.WS_RECONNECT_WAITTING_FINISH, e);\n      }), this.websocket.on(pw.RECONNECT_CREATE_CONNECTION, e => {\n        this.emit(Rb.WS_RECONNECT_CREATE_CONNECTION, e);\n      }), this.websocket.on(pw.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(pw.CLOSED, () => {\n        this.connectionState = gb.CLOSED;\n      }), this.websocket.on(pw.FAILED, () => {\n        this._disconnectedReason = AI.NETWORK_ERROR, this.connectionState = gb.CLOSED;\n      }), this.websocket.on(pw.RECONNECTING, e => {\n        this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === gb.CONNECTED ? this.connectionState = gb.RECONNECTING : this.connectionState = gb.CONNECTING;\n      }), this.websocket.on(pw.WILL_RECONNECT, (e, t) => {\n        if (xI(this, Rb.IS_P2P_DISCONNECTED) && \"retry\" === e) return Qy.debug(\"\".concat(this.clientId, \" reconnect mode is retry, but p2p lost, change to tryNext\")), this.reconnectToken = void 0, this.emit(Rb.NEED_RENEW_SESSION), this.emit(Rb.DISCONNECT_P2P), t(\"tryNext\");\n        \"retry\" !== e && (Qy.debug(\"\".concat(this.clientId, \" websockt will_connect event, renewSession reconnectMode is \").concat(e)), this.reconnectToken = void 0, this.emit(Rb.NEED_RENEW_SESSION), this.emit(Rb.DISCONNECT_P2P)), t(e);\n      }), this.websocket.on(pw.CONNECTED, () => {\n        this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch(e => {\n          Qy.warning(\"[\".concat(this.clientId, \"] rejoin failed \").concat(e)), this.reconnect(\"tryNext\", uw.SERVER_ERROR);\n        }) : this.join().catch(e => {\n          if (this.emit(Rb.REPORT_JOIN_GATEWAY, e.message || e.code, this.url || \"\"), e instanceof bb && e.code === tI.UNEXPECTED_RESPONSE && e.data.code === Sb.ERR_NO_AUTHORIZED) return Qy.warning(\"[\".concat(this.clientId, \"] reconnect no authorized, recover\")), void this.reconnect(\"recover\", uw.SERVER_ERROR);\n          Qy.error(\"[\".concat(this.clientId, \"] join gateway request failed\"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect(\"tryNext\", uw.SERVER_ERROR) : (this.initError = e, this.close());\n        });\n      }), this.websocket.on(pw.REQUEST_NEW_URLS, (e, t) => {\n        kI(this, Rb.REQUEST_RECOVER, this.multiIpOption).then(e).catch(t);\n      }), this.websocket.on(pw.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {\n        this.emit(Ib.ON_TOKEN_PRIVILEGE_DID_EXPIRE);\n      }), this.websocket.on(pw.TO_CONNECT_DATACHANNEL, async (e, t, i) => kI(this, Rb.DATACHANNEL_PRECONNECT, e).then(t).catch(i)), this.websocket.on(pw.FAILBACK, () => {\n        void 0 !== this.openConnectionTime && this.emit(Rb.DATACHANNEL_FAILBACK);\n      });\n    }\n  }\n  class oO extends SI {\n    constructor(e, t) {\n      super(), ng(this, \"signal\", void 0), ng(this, \"token\", void 0), ng(this, \"tokenTimeout\", void 0), ng(this, \"tokenInterval\", void 0), ng(this, \"_sequence\", 0), ng(this, \"userMap\", new Map()), ng(this, \"encoder\", new TextEncoder()), this.signal = e, this.token = t;\n      const i = () => {\n        this.signal.connectionState === gb.CONNECTED && this.check(), 0 === this.userMap.size ? this.tokenInterval = window.setTimeout(i, 1e3) : this.tokenInterval = window.setTimeout(i, 3 * Dy(\"P2P_TOKEN_INTERVAL\"));\n      };\n      i();\n    }\n    async send(e, t, i, n, r) {\n      var o, s, a;\n      if (0 === this.userMap.size) return;\n      const c = Array.from(ub(o = this.userMap).call(o))[0].token;\n      \"string\" != typeof t && (t = JSON.stringify(t)), n = null !== (s = n) && void 0 !== s ? s : ey(6, \"\"), r = null !== (a = r) && void 0 !== a ? a : this._sequence++;\n      const d = {\n        _id: n,\n        _type: e,\n        _seq: r,\n        _message: t,\n        token: \"\".concat(this.token, \"_\").concat(c)\n      };\n      Dy(\"SHOW_P2P_LOG\") && Qy.debug(\"send message\", d, \"noNeedResponse : \".concat(i));\n      this.splitMessage(JSON.stringify(d)).forEach(e => {\n        this.signal.request(Cb.DATA_STREAM, {\n          payload: qI(this.encoder.encode(e))\n        });\n      });\n      const l = new Gu((t, r) => {\n        const o = window.setTimeout(() => {\n            this.off(\"res-@\".concat(n, \"_ack\"), s), this.off(\"res-@\".concat(n), c), this.off(Sw.ABORT, a), Qy.debug(\"[external-signal] request timeout, type: \".concat(e, \", requestId: \").concat(n)), 0 === this.userMap.size ? r(new iI(tI.INVALID_REMOTE_USER)) : r(new iI(tI.TIMEOUT));\n          }, Dy(\"EXTERNAL_SIGNAL_REQUEST_TIMEOUT\")),\n          s = () => {\n            o && window.clearTimeout(o), this.off(Sw.ABORT, a), i && t();\n          },\n          a = () => {\n            o && window.clearTimeout(o), this.off(\"res-@\".concat(n, \"_ack\"), s), this.off(\"res-@\".concat(n), c), r(new iI(tI.EXTERNAL_SIGNAL_ABORT, \"type: \".concat(e, \", requestId: \").concat(n)));\n          };\n        this.once(Sw.ABORT, a), this.once(\"res-@\".concat(n, \"_ack\"), s);\n        const c = (i, c) => {\n          l = !0, o && window.clearTimeout(o), this.off(\"res-@\".concat(n, \"_ack\"), s), this.off(Sw.ABORT, a), \"success\" === i ? t(c) : r(new iI(tI.P2P_MESSAGE_FAILED, \"request \".concat(e, \" failed, requestId: \").concat(n)));\n        };\n        let l = !1;\n        i || (this.once(\"res-@\".concat(n), c), $I(Dy(\"SIGNAL_REQUEST_TIMEOUT\")).then(() => {\n          l || Qy.warning(\"external_signal request timeout, type: \".concat(e, \", requestId: \").concat(n, \", \").concat(d));\n        }));\n      });\n      try {\n        return await l;\n      } catch (o) {\n        if (o.code === tI.TIMEOUT) return await this.send(e, t, i, n, r);\n        throw o;\n      }\n    }\n    onMessage(e) {\n      var t;\n      const _e8 = e,\n        i = _e8._uid;\n      let n,\n        r = this.userMap.get(i);\n      if (r) n = r.splitMessageMap;else {\n        if (this.userMap.size > 0 || !(\"_type\" in e) || e._type !== Tw.CHECK) return;\n        const _e9 = e,\n          t = _e9.token;\n        n = new Map(), r = {\n          uid: i,\n          isStart: !0,\n          token: t,\n          splitMessageMap: n,\n          nextExpectedSequenceNumber: 0,\n          receivedMessagesMap: new Map()\n        }, this.userMap.set(i, r), this.signal.emit(Ib.ON_USER_ONLINE, {\n          uid: i\n        }), this.handleUserOnline();\n      }\n      if (\"id\" in e && \"total\" in e) {\n        var o;\n        const _e10 = e,\n          t = _e10.id,\n          r = _e10.total,\n          s = null !== (o = n.get(t)) && void 0 !== o ? o : [];\n        if (s.push(e), n.has(t) || n.set(t, s), s.length !== r) return;\n        {\n          const r = oE(s).call(s, (e, t) => e.index - t.index).map(e => e.payload).join(\"\");\n          n.delete(t), (e = JSON.parse(r))._uid = i;\n        }\n      }\n      const _e11 = e,\n        s = _e11._type,\n        a = _e11.token;\n      if (Dn(t = [Tw.ACK, Tw.CHECK]).call(t, s)) return s === Tw.CHECK && this.handleCheckToken(r, a), void this.receiveMessage(e);\n      a === \"\".concat(r.token, \"_\").concat(this.token) ? this.handleReceivedMessage(e) : Qy.debug('Receive unexpected message\", '.concat(a, \", cur_token: \").concat(r.token, \"_\").concat(this.token), e);\n    }\n    check() {\n      const e = {\n        _id: ey(6, \"\"),\n        token: this.token,\n        _type: Tw.CHECK\n      };\n      Dy(\"SHOW_P2P_LOG\") && Qy.debug(\"send message\", e), this.signal.request(Cb.DATA_STREAM, {\n        payload: qI(this.encoder.encode(JSON.stringify(e)))\n      });\n    }\n    ack(e) {\n      const t = {\n        _id: e,\n        _type: Tw.ACK,\n        token: this.token\n      };\n      Dy(\"SHOW_P2P_LOG\") && Qy.debug(\"send message\", t), this.signal.request(Cb.DATA_STREAM, {\n        payload: qI(this.encoder.encode(JSON.stringify(t)))\n      });\n    }\n    response(e, t, i) {\n      this.send(Tw.RESPONSE, JSON.stringify({\n        success: !i,\n        message: t\n      }), !0, e);\n    }\n    handleReceivedMessage(e) {\n      const t = () => {\n        this.userMap.forEach(e => {\n          const t = e.receivedMessagesMap,\n            i = e.nextExpectedSequenceNumber;\n          for (; t.has(i);) {\n            const n = t.get(i);\n            t.delete(i), this.receiveMessage(n), e.nextExpectedSequenceNumber++;\n          }\n        });\n      };\n      if (!e) return void t();\n      const i = e._uid,\n        n = e._seq,\n        r = this.userMap.get(i),\n        o = r.receivedMessagesMap,\n        s = r.isStart,\n        a = r.nextExpectedSequenceNumber;\n      if (n < a) return this.ack(e._id), void Qy.debug(\"[external-signal] receive old message, seq: \".concat(n, \", \").concat(e._message));\n      o.set(n, e), s && n === a && (this.receiveMessage(e), o.delete(a), r.nextExpectedSequenceNumber++, t());\n    }\n    receiveMessage(e) {\n      const t = e._id,\n        i = e._type,\n        n = e._message,\n        r = e._uid;\n      if (Dy(\"SHOW_P2P_LOG\") && Qy.debug(\"receive message\", e), t) {\n        let o;\n        switch (e._type !== Tw.ACK && (n && (o = JSON.parse(n)), this.ack(e._id)), e._type) {\n          case Tw.CANDIDATE:\n          case Tw.CONTROL:\n            this.signal.emit(i, o, r);\n            break;\n          case Tw.PUBLISH:\n          case Tw.UNPUBLISH:\n          case Tw.RESTART_ICE:\n          case Tw.CALL:\n            o.uid = r, kI(this.signal, i, o).then(t => {\n              this.response(e._id, t);\n            }).catch(() => {\n              this.response(e._id, void 0, !0);\n            });\n            break;\n          case Tw.ACK:\n            this.getListeners(\"res-@\".concat(t, \"_ack\")).length > 0 && this.emit(\"res-@\".concat(t, \"_ack\"));\n            break;\n          case Tw.RESPONSE:\n            {\n              const _o2 = o,\n                e = _o2.success,\n                i = _o2.message;\n              this.emit(\"res-@\".concat(t), e ? \"success\" : \"failed\", i);\n              break;\n            }\n        }\n      }\n    }\n    splitMessage(e) {\n      if (e.length < oO.MAX_MESSAGE_SIZE) return [e];\n      const t = [],\n        _JSON$parse = JSON.parse(e),\n        i = _JSON$parse.remoteToken,\n        n = ey(6, \"\");\n      let r = 0,\n        o = 800;\n      const s = Math.ceil(e.length / o);\n      for (; e.length > 0;) {\n        r++;\n        const a = {\n          id: n,\n          index: r,\n          total: s,\n          payload: e.slice(0, o),\n          token: \"\".concat(this.token, \"_\").concat(i)\n        };\n        JSON.stringify(a).length > oO.MAX_MESSAGE_SIZE ? o -= 50 : (t.push(a), e = e.slice(o));\n      }\n      return t.map(e => JSON.stringify(e));\n    }\n    handleCheckToken(e, t) {\n      return e.token !== t ? (Qy.debug(\"token changed, from \".concat(e.token, \" to \").concat(t)), this.reset(e.uid, t), !1) : (this.tokenTimeout && (window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0), this.tokenTimeout = window.setTimeout(() => {\n        Qy.debug(\"token timeout, \".concat(t)), this.reset(e.uid);\n      }, Dy(\"MAX_P2P_TIMEOUT\")), !0);\n    }\n    async handleUserOnline() {\n      const e = await kI(this.signal, Tw.CALL, void 0),\n        t = await this.send(Tw.CALL, e);\n      this.signal.emit(Rb.P2P_CONNECTION, t, !0);\n    }\n    async reset(e, t) {\n      const i = this.userMap.get(e);\n      i && (this.emit(Sw.ABORT), this.signal.emit(Ib.ON_USER_OFFLINE, {\n        uid: i.uid,\n        reason: Rw.P2P_TOKEN_CHANGED\n      }), this._sequence = 0, this.userMap.clear(), t || (Qy.debug(\"change local token from \".concat(t, \" to \").concat(t)), this.token = ey(6, \"\")));\n    }\n    clear() {\n      this._sequence = 0, this.userMap.clear(), this.tokenInterval && window.clearTimeout(this.tokenInterval), this.tokenInterval = void 0, this.tokenTimeout && window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0, this.emit(Sw.ABORT);\n    }\n  }\n  ng(oO, \"MAX_SIZE\", 1), ng(oO, \"MAX_MESSAGE_SIZE\", 1024);\n  class sO extends SI {\n    get connectionState() {\n      return this._connectionState;\n    }\n    set connectionState(e) {\n      e !== this._connectionState && (this._connectionState = e, e === gb.CONNECTED ? this.emit(Rb.WS_CONNECTED) : e === gb.RECONNECTING ? this.emit(Rb.WS_RECONNECTING, this._websocketReconnectReason) : e === gb.CLOSED && this.emit(Rb.WS_CLOSED, this._disconnectedReason));\n    }\n    get currentURLIndex() {\n      return this.websocket.currentURLIndex;\n    }\n    get url() {\n      return this.websocket && this.websocket.url || null;\n    }\n    get rtt() {\n      return this.rttRolling.mean();\n    }\n    constructor(e, t) {\n      super(), ng(this, \"_disconnectedReason\", void 0), ng(this, \"_websocketReconnectReason\", void 0), ng(this, \"_connectionState\", gb.CLOSED), ng(this, \"reconnectToken\", void 0), ng(this, \"p2pToken\", void 0), ng(this, \"websocket\", void 0), ng(this, \"openConnectionTime\", void 0), ng(this, \"clientId\", void 0), ng(this, \"lastMsgTime\", Date.now()), ng(this, \"uploadCache\", []), ng(this, \"uploadCacheInterval\", void 0), ng(this, \"rttRolling\", new fy(5)), ng(this, \"pingpongTimer\", void 0), ng(this, \"pingpongTimeoutCount\", 0), ng(this, \"joinResponse\", void 0), ng(this, \"multiIpOption\", void 0), ng(this, \"initError\", void 0), ng(this, \"spec\", void 0), ng(this, \"store\", void 0), ng(this, \"_external_signal\", void 0), ng(this, \"onWebsocketMessage\", e => {\n        if (e.data instanceof ArrayBuffer) return void this.emit(Rb.ON_BINARY_DATA, e.data);\n        const t = JSON.parse(e.data);\n        if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t, \"_id\")) {\n          const e = \"res-@\".concat(t._id);\n          this.emit(e, t._result, t._message);\n        } else if (Object.prototype.hasOwnProperty.call(t, \"_type\")) {\n          switch (t._type) {\n            case Ib.ON_DATA_STREAM:\n              return void this.handleDataStream(t._message);\n            case Ib.MUTE_AUDIO:\n            case Ib.MUTE_VIDEO:\n            case Ib.ON_P2P_LOST:\n            case Ib.ON_USER_ONLINE:\n              return;\n            case Ib.ON_USER_OFFLINE:\n              const e = t._message.uid;\n              return Qy.debug(\"[\".concat(this.clientId, \"] user-offline uid: \").concat(e)), void this._external_signal.reset(e);\n          }\n          if (this.emit(t._type, t._message), t._type === Ib.ON_NOTIFICATION && this.handleNotification(t._message), t._type === Ib.ON_USER_BANNED) switch (t._message.error_code) {\n            case 14:\n              this.close(AI.UID_BANNED);\n              break;\n            case 15:\n              this.close(AI.IP_BANNED);\n              break;\n            case 16:\n              this.close(AI.CHANNEL_BANNED);\n          }\n          if (t._type === Ib.ON_USER_LICENSE_BANNED) switch (t._message.error_code) {\n            case Sb.ERR_LICENSE_MISSING:\n              this.close(AI.LICENSE_MISSING);\n              break;\n            case Sb.ERR_LICENSE_EXPIRED:\n              this.close(AI.LICENSE_EXPIRED);\n              break;\n            case Sb.ERR_LICENSE_MINUTES_EXCEEDED:\n              this.close(AI.LICENSE_MINUTES_EXCEEDED);\n              break;\n            case Sb.ERR_LICENSE_PERIOD_INVALID:\n              this.close(AI.LICENSE_PERIOD_INVALID);\n              break;\n            case Sb.ERR_LICENSE_MULTIPLE_SDK_SERVICE:\n              this.close(AI.LICENSE_MULTIPLE_SDK_SERVICE);\n              break;\n            case Sb.ERR_LICENSE_ILLEGAL:\n              this.close(AI.LICENSE_ILLEGAL);\n              break;\n            default:\n              this.close();\n          }\n        }\n      }), this.clientId = e.clientId, this.spec = e, this.store = t, this.websocket = new Vw(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, Dy(\"JOIN_GATEWAY_USE_DUAL_DOMAIN\"), Dy(\"JOIN_GATEWAY_USE_443PORT_ONLY\"), t), this.handleWebsocketEvents(), window.addEventListener(\"offline\", () => {\n        this.connectionState === gb.CONNECTED && this.reconnect(\"retry\", DI.OFFLINE);\n      }), this.p2pToken = ey(6, \"\"), this._external_signal = new oO(this, this.p2pToken);\n    }\n    async request(e, t, i, n) {\n      const r = ey(6, \"\"),\n        o = {\n          _id: r,\n          _type: e,\n          _message: t\n        },\n        s = this.websocket.connectionID,\n        a = () => new Gu((e, t) => {\n          if (this.connectionState === gb.CONNECTED) return e();\n          const i = () => {\n              this.off(Rb.WS_CLOSED, n), e();\n            },\n            n = () => {\n              this.off(Rb.WS_CONNECTED, i), t(new iI(tI.WS_ABORT));\n            };\n          this.once(Rb.WS_CONNECTED, i), this.once(Rb.WS_CLOSED, n);\n        });\n      if (this.connectionState !== gb.CONNECTING && this.connectionState !== gb.RECONNECTING || e === Cb.JOIN || e === Cb.REJOIN || (await a()), this.websocket.sendMessage(o, !0), n) return;\n      const c = new Gu((i, n) => {\n        let o = !1;\n        const a = (n, r) => {\n          o = !0, i({\n            isSuccess: \"success\" === n,\n            message: r || {}\n          }), this.off(Rb.WS_CLOSED, c), this.off(Rb.WS_RECONNECTING, c), this.emit(Rb.REQUEST_SUCCESS, e, t);\n        };\n        this.once(\"res-@\".concat(r), a);\n        const c = () => {\n          n(new iI(tI.WS_ABORT, \"type: \".concat(e))), this.off(Rb.WS_CLOSED, c), this.off(Rb.WS_RECONNECTING, c), this.off(\"res-@\".concat(r), a);\n        };\n        this.once(Rb.WS_CLOSED, c), this.once(Rb.WS_RECONNECTING, c), $I(Dy(\"SIGNAL_REQUEST_TIMEOUT\")).then(() => {\n          this.websocket.connectionID !== s || o || (Qy.warning(\"[\".concat(this.clientId, \"] ws request timeout, type: \").concat(e)), this.emit(Rb.REQUEST_TIMEOUT, e, t));\n        });\n      });\n      let d = null;\n      try {\n        d = await c;\n      } catch (n) {\n        if (this.connectionState === gb.CLOSED || e === Cb.LEAVE) throw new iI(tI.WS_ABORT);\n        return !this.spec.forceWaitGatewayResponse || i ? n.throw() : e === Cb.JOIN || e === Cb.REJOIN ? null : (await a(), await this.request(e, t));\n      }\n      if (d.isSuccess) return d.message;\n      const l = Number(d.message.error_code || d.message.code),\n        h = yw(l),\n        u = new iI(tI.UNEXPECTED_RESPONSE, \"\".concat(h.desc, \": \").concat(d.message.error_str), {\n          code: l,\n          data: d.message\n        });\n      return \"success\" === h.action ? d.message : (Qy.warning(\"[\".concat(this.clientId, \"] [\").concat(this.websocket.connectionID, \"] unexpected response from type \").concat(e, \", error_code: \").concat(l, \", message: \").concat(h.desc, \", action: \").concat(h.action)), l === Sb.ERR_TOO_MANY_BROADCASTERS ? e === Cb.JOIN || e === Cb.REJOIN ? (this.initError = u, this.close(), u.throw()) : u.throw() : \"failed\" === h.action ? u.throw() : \"quit\" === h.action ? (this.initError = u, this.close(), u.throw()) : (l === Sb.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d.message.option, Qy.warning(\"[\".concat(this.clientId, \"] detect multi ip, recover\")), this.reconnect(\"recover\", DI.MULTI_IP)) : this.reconnect(h.action, DI.SERVER_ERROR), e === Cb.JOIN || e === Cb.REJOIN ? null : await this.request(e, t)));\n    }\n    waitMessage(e, t) {\n      return new Gu(i => {\n        const n = r => {\n          (!t || t(r)) && (this.off(e, n), i(r));\n        };\n        this.on(e, n);\n      });\n    }\n    uploadWRTCStats(e) {\n      if (!this.store.sessionId) return void Qy.warn(\"[\".concat(this.clientId, \"] no session id when upload wrtc stats\"));\n      const t = {\n        lts: Date.now(),\n        sid: this.store.sessionId,\n        uid: this.store.intUid,\n        stats: e\n      };\n      this.upload(vb.WRTC_STATS, t);\n    }\n    upload(e, t) {\n      const i = {\n        _type: e,\n        _message: t\n      };\n      try {\n        this.websocket.sendMessage(i);\n      } catch (e) {\n        const t = Dy(\"MAX_UPLOAD_CACHE\") || 50;\n        this.uploadCache.push(i), this.uploadCache.length > t && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {\n          if (this.connectionState !== gb.CONNECTED) return;\n          const e = this.uploadCache.splice(0, 1)[0];\n          0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e._type, e._message);\n        }, Dy(\"UPLOAD_CACHE_INTERVAL\") || 2e3));\n      }\n    }\n    send(e, t) {\n      const i = {\n        _type: e,\n        _message: t\n      };\n      this.websocket.sendMessage(i);\n    }\n    async sendExtensionMessage(e, t, i) {\n      return await this._external_signal.send(e, t, i);\n    }\n    init(e) {\n      return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Gu((t, i) => {\n        this.once(Rb.WS_CONNECTED, () => t(this.joinResponse)), this.once(Rb.WS_CLOSED, () => i(this.initError || new iI(tI.WS_ABORT))), this.connectionState = gb.CONNECTING, this.websocket.init(e).catch(i);\n      });\n    }\n    close(e) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._external_signal.clear(), this._disconnectedReason = e || AI.LEAVE, this.connectionState = gb.CLOSED, Qy.debug(\"[\".concat(this.clientId, \"] \") + \"will close websocket in signal\"), this.websocket.close(), e === AI.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new Vw(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, Dy(\"JOIN_GATEWAY_USE_DUAL_DOMAIN\"), Dy(\"JOIN_GATEWAY_USE_443PORT_ONLY\"), this.store), this.handleWebsocketEvents()), this.p2pToken = ey(6, \"\"), this._external_signal.clear(), this._external_signal = new oO(this, this.p2pToken);\n    }\n    async join() {\n      if (!this.joinResponse) {\n        this.emit(Rb.ABORT_P2P_EXECUTION);\n        const e = await kI(this, Rb.REQUEST_JOIN_INFO),\n          t = await this.request(Cb.JOIN, e);\n        if (!t) return this.emit(Rb.REPORT_JOIN_GATEWAY, tI.TIMEOUT, this.url || \"\"), !1;\n        this.joinResponse = t, this.emit(Rb.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;\n      }\n      return this.connectionState = gb.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), !0;\n    }\n    reconnect(e, t) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, t);\n    }\n    handleDataStream(e) {\n      try {\n        var t;\n        const i = YI(e.payload),\n          n = new TextDecoder().decode(i),\n          r = JSON.parse(n);\n        \"total\" in r && \"id\" in r || Dn(t = Object.values(Tw)).call(t, r._type) ? (r._uid = e.uid, this._external_signal.onMessage(r)) : this.emit(Ib.ON_DATA_STREAM, e);\n      } catch (t) {\n        this.emit(Ib.ON_DATA_STREAM, e);\n      }\n    }\n    handleNotification(e) {\n      Qy.debug(\"[\".concat(this.clientId, \"] receive notification: \"), e);\n      const t = yw(e.code);\n      if (\"success\" !== t.action) {\n        if (\"failed\" !== t.action) return \"quit\" === t.action ? (\"ERR_REPEAT_JOIN_CHANNEL\" === t.desc && this.close(AI.UID_BANNED), void this.close()) : void this.reconnect(t.action, DI.SERVER_ERROR);\n        Qy.error(\"[\".concat(this.clientId, \"] ignore error: \"), t.desc);\n      }\n    }\n    handlePingPong() {\n      if (!this.websocket || \"connected\" !== this.websocket.state) return;\n      this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;\n      const e = Dy(\"PING_PONG_TIME_OUT\"),\n        t = Date.now();\n      this.pingpongTimeoutCount >= e && (Qy.warning(\"[\".concat(this.clientId, \"] PINGPONG Timeout. Last Socket Message: \").concat(t - this.lastMsgTime, \"ms\")), t - this.lastMsgTime > Dy(\"WEBSOCKET_TIMEOUT_MIN\")) ? this.reconnect(\"retry\", DI.TIMEOUT) : this.request(Cb.PING, void 0, !0).then(() => {\n        this.pingpongTimeoutCount = 0;\n        const e = Date.now() - t;\n        this.rttRolling.add(e), Dy(\"REPORT_STATS\") && this.send(Cb.PING_BACK, {\n          pingpongElapse: e\n        });\n      }).catch(e => {});\n    }\n    handleWebsocketEvents() {\n      this.websocket.on(Ab.RECONNECT_WAITTING_FINISH, e => {\n        this.emit(Rb.WS_RECONNECT_WAITTING_FINISH, e);\n      }), this.websocket.on(Ab.RECONNECT_CREATE_CONNECTION, e => {\n        this.emit(Rb.WS_RECONNECT_CREATE_CONNECTION, e);\n      }), this.websocket.on(Ab.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Ab.CLOSED, () => {\n        this.connectionState = gb.CLOSED;\n      }), this.websocket.on(Ab.FAILED, () => {\n        this._disconnectedReason = AI.NETWORK_ERROR, this.connectionState = gb.CLOSED;\n      }), this.websocket.on(Ab.RECONNECTING, e => {\n        this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === gb.CONNECTED ? this.connectionState = gb.RECONNECTING : this.connectionState = gb.CONNECTING;\n      }), this.websocket.on(Ab.WILL_RECONNECT, (e, t, i) => {\n        \"retry\" !== e ? (Qy.debug(\"\".concat(this.clientId, \" websocket will_connect event, renewSession reconnectMode is \").concat(e)), this.reconnectToken = void 0, this.emit(Rb.NEED_RENEW_SESSION)) : Qy.debug(\"\".concat(this.clientId, \" reconnect mode is retry, no need to renew session\")), i(e);\n      }), this.websocket.on(Ab.CONNECTED, () => {\n        this.openConnectionTime = Date.now(), this.join().catch(e => {\n          if (this.emit(Rb.REPORT_JOIN_GATEWAY, e.message || e.code, this.url || \"\"), e instanceof iI && e.code === tI.UNEXPECTED_RESPONSE && e.data.code === Sb.ERR_NO_AUTHORIZED) return Qy.warning(\"[\".concat(this.clientId, \"] reconnect no authorized, recover\")), void this.reconnect(\"recover\", DI.SERVER_ERROR);\n          Qy.error(\"[\".concat(this.clientId, \"] join gateway request failed\"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect(\"tryNext\", DI.SERVER_ERROR) : (this.initError = e, this.close());\n        });\n      }), this.websocket.on(Ab.REQUEST_NEW_URLS, (e, t) => {\n        kI(this, Rb.REQUEST_RECOVER, this.multiIpOption).then(e).catch(t);\n      }), this.websocket.on(Ab.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {\n        this.emit(Ib.ON_TOKEN_PRIVILEGE_DID_EXPIRE);\n      });\n    }\n  }\n  function aO(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function cO(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? aO(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : aO(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  const dO = new Map();\n  class lO extends SI {\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      if (e === this._state) return;\n      const t = this._state;\n      this._state = e, \"DISCONNECTED\" === e && this._disconnectedReason ? this.emit(Yb.CONNECTION_STATE_CHANGE, e, t, this._disconnectedReason) : this.emit(Yb.CONNECTION_STATE_CHANGE, e, t);\n    }\n    get joinGatewayStartTime() {\n      return this._joinGatewayStartTime;\n    }\n    set joinGatewayStartTime(e) {\n      Qy.debug(\"[\".concat(this.store.clientId, \"] set joinGatewayStartTime at \").concat(e)), this._joinGatewayStartTime = e;\n    }\n    constructor(e, t) {\n      super(), ng(this, \"store\", void 0), ng(this, \"joinInfo\", void 0), ng(this, \"key\", void 0), ng(this, \"ntpOffset\", 0), ng(this, \"signal\", void 0), ng(this, \"role\", void 0), ng(this, \"inChannelInfo\", {\n        joinAt: null,\n        duration: 0\n      }), ng(this, \"spec\", void 0), ng(this, \"_state\", \"DISCONNECTED\"), ng(this, \"_statsCollector\", void 0), ng(this, \"_disconnectedReason\", void 0), ng(this, \"isSignalRecover\", !1), ng(this, \"hasChangeBGPAddress\", !1), ng(this, \"trafficStatsInterval\", void 0), ng(this, \"networkQualityInterval\", void 0), ng(this, \"_joinGatewayStartTime\", 0), ng(this, \"_signalTimeout\", !1), ng(this, \"_clientRoleOptions\", void 0), ng(this, \"_isProactiveJoin\", !1), this.store = e, this.spec = t, this.signal = this.store.useP2P ? new sO(cO(cO({}, t), {}, {\n        retryConfig: t.websocketRetryConfig\n      }), e) : this.store.useDataChannel ? new rO(cO(cO({}, t), {}, {\n        retryConfig: t.websocketRetryConfig\n      }), e) : new Bw(cO(cO({}, t), {}, {\n        retryConfig: t.websocketRetryConfig\n      }), e), this._statsCollector = t.statsCollector, this.role = t.role || \"audience\", this._clientRoleOptions = t.clientRoleOptions, this.handleSignalEvents();\n    }\n    async join(e, t, i) {\n      if (this.signal instanceof rO) {\n        let t = !1;\n        \"disabled\" !== e.cloudProxyServer ? (Qy.debug(\"[\".concat(this.store.clientId, \"] Dc is not supported, because cloudProxyServer are not supported (\").concat(e.cloudProxyServer, \")\")), t = !0) : \"\".concat(e.apResponse.cid, \"_\").concat(e.apResponse.cert).length > 255 || \"\".concat(e.apResponse.cid, \"_\").concat(e.apResponse.cert).length < 22 ? (Qy.debug(\"[\".concat(this.store.clientId, \"] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255\")), t = !0) : e.apResponse.addresses.some(e => e.fingerprint) || Dy(\"FINGERPRINT\") || (Qy.debug(\"[\".concat(this.store.clientId, \"] Dc is not supported, because fingerprint does not exist\")), t = !0), t && this.resetSignal();\n      }\n      this.store.joinGatewayStart(), \"disabled\" !== e.cloudProxyServer && (this.hasChangeBGPAddress = !0);\n      const n = Date.now();\n      let r = dO.get(e.cname);\n      if (r || (r = new Map(), dO.set(e.cname, r)), this._isProactiveJoin = !0, r.has(e.uid)) {\n        const t = new bb(tI.UID_CONFLICT);\n        throw oA.joinGateway(e.sid, {\n          lts: n,\n          succ: !1,\n          ec: t.message,\n          addr: null,\n          uid: e.uid,\n          cid: e.cid,\n          firstSuccess: this._isProactiveJoin,\n          avoidJoinStartTime: this.store.avoidJoinStart,\n          isProxy: !!e.proxyServer,\n          signalChannel: this.signal instanceof rO ? \"1\" : \"0\"\n        }), this._isProactiveJoin = !1, t;\n      }\n      r.set(e.uid, !0), this.joinInfo = e, this.key = t;\n      let o = 0;\n      this.joinGatewayStartTime = n;\n      const s = e.proxyServer;\n      try {\n        let t;\n        if (Qy.debug(\"[\".concat(this.store.clientId, \"] use \").concat(this.signal instanceof rO ? \"datachannel\" : \"websocket\", \" join uid \").concat(o)), this.signal instanceof rO) t = await this.signal.init(e.apResponse.addresses, i);else {\n          const n = e.gatewayAddrs.map(t => {\n            let i = t.address;\n            const _i$split = i.split(\":\"),\n              _i$split2 = _slicedToArray(_i$split, 2),\n              n = _i$split2[0],\n              r = _i$split2[1],\n              o = {\n                host: n,\n                port: r\n              };\n            return e.proxyServer && (o.proxy = e.proxyServer), o;\n          });\n          t = await this.signal.init(n, i);\n        }\n        o = t.uid, Qy.debug(\"[\".concat(this.store.clientId, \"] \").concat(this.signal instanceof rO ? \"datachannel\" : \"websocket\", \" join uid \").concat(o, \" cost \").concat(Date.now() - this.joinGatewayStartTime));\n      } catch (t) {\n        if (t && t.code === tI.INIT_WEBSOCKET_TIMEOUT) throw Qy.warning(\"[\".concat(this.store.clientId, \"] User join failed\"), t.toString()), t;\n        if (t && t.code === tI.INIT_DATACHANNEL_TIMEOUT) throw Qy.warning(\"[\".concat(this.store.clientId, \"] User join datachannel failed\"), t.toString()), this.resetSignal(), t;\n        throw Qy.error(\"[\".concat(this.store.clientId, \"] User join failed\"), t.toString()), oA.joinGateway(e.sid, {\n          lts: n,\n          succ: !1,\n          ec: t.message,\n          addr: this.signal.url,\n          uid: e.uid,\n          cid: e.cid,\n          firstSuccess: this._isProactiveJoin,\n          avoidJoinStartTime: this.store.avoidJoinStart,\n          isProxy: !!s,\n          signalChannel: this.signal instanceof rO ? \"1\" : \"0\"\n        }), this._isProactiveJoin = !1, r.delete(e.uid), this.signal.close(), t;\n      }\n      return this.state = \"CONNECTED\", this.inChannelInfo.joinAt = Date.now(), Qy.debug(\"[\".concat(this.store.clientId, \"] Connected to gateway server\")), this.trafficStatsInterval = window.setInterval(() => {\n        this.updateTrafficStats().catch(e => {\n          Qy.warning(\"[\".concat(this.store.clientId, \"] get traffic stats error\"), e.toString());\n        });\n      }, 3e3), this.networkQualityInterval = window.setInterval(() => {\n        navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(Yb.NETWORK_QUALITY, {\n          downlinkNetworkQuality: 6,\n          uplinkNetworkQuality: 6\n        }) : this._signalTimeout ? this.emit(Yb.NETWORK_QUALITY, {\n          downlinkNetworkQuality: 5,\n          uplinkNetworkQuality: 5\n        }) : \"CONNECTED\" === this.state && this._statsCollector.trafficStats ? this.emit(Yb.NETWORK_QUALITY, {\n          uplinkNetworkQuality: zw(this._statsCollector.trafficStats.B_unq),\n          downlinkNetworkQuality: zw(this._statsCollector.trafficStats.B_dnq)\n        }) : this.emit(Yb.NETWORK_QUALITY, {\n          uplinkNetworkQuality: 0,\n          downlinkNetworkQuality: 0\n        });\n      }, 2e3), this.store.joinGatewayEnd(), o;\n    }\n    async leave() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],\n        t = arguments.length > 1 ? arguments[1] : void 0;\n      if (\"DISCONNECTED\" !== this.state) {\n        t !== AI.FALLBACK && (this.state = \"DISCONNECTING\");\n        try {\n          e || this.signal.connectionState !== gb.CONNECTED || (await function (e, t) {\n            return t === 1 / 0 ? e : Gu.race([e, ZI(t)]);\n          }(this.signal.request(Cb.LEAVE, void 0, !0), 3e3));\n        } catch (e) {\n          Qy.warning(\"[\".concat(this.store.clientId, \"] leave request failed, ignore\"), e);\n        }\n        this.signal.close(t), t !== AI.FALLBACK && (this.state = \"DISCONNECTED\"), this.reset();\n      }\n    }\n    async publish(e, t, i) {\n      if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new bb(tI.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n      const n = {\n        state: \"offer\",\n        p2p_id: this.store.p2pId,\n        ortc: t,\n        mode: this.spec.mode,\n        extend: Dy(\"PUB_EXTEND\"),\n        twcc: !!Dy(\"PUBLISH_TWCC\"),\n        rtx: !!Dy(\"USE_PUB_RTX\")\n      };\n      try {\n        return (await this.signal.request(Cb.PUBLISH, n, !0))._message;\n      } catch (n) {\n        if (i && n.data && n.data.code === Sb.ERR_PUBLISH_REQUEST_INVALID) return Qy.warning(\"[\".concat(this.store.clientId, \"] receive publish error code, retry\"), n.toString()), await this.tryUnpubBeforeRepub(e, t), this.publish(e, t, !1);\n        throw n;\n      }\n    }\n    async publishDataChannel(e, t, i) {\n      var n;\n      if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new bb(tI.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n      const r = {\n        stream_id: t.streamId,\n        ordered: t.ordered ? 1 : 0,\n        max_retrans_times: null !== (n = t.maxRetransmits) && void 0 !== n ? n : 10,\n        channel_id: t.channelId,\n        metadata: t.metadata\n      };\n      try {\n        await this.signal.request(Cb.PUBLISH_DATASTREAM, r, !0);\n      } catch (n) {\n        if (i && n.data && n.data.code === Sb.ERR_PUBLISH_REQUEST_INVALID) return Qy.warning(\"[\".concat(this.store.clientId, \"] receive publish datachannels error code, retry\"), n.toString()), await this.tryUnpubDataChannelBeforeRepub(e, t), this.publishDataChannel(e, t, !1);\n        throw n;\n      }\n    }\n    async unpublish(e, t) {\n      try {\n        if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new bb(tI.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n        await this.signal.request(Cb.UNPUBLISH, {\n          stream_id: t,\n          ortc: e\n        }, !0);\n      } catch (e) {\n        Qy.warning(\"[\".concat(this.store.clientId, \"] unpublish warning: \"), e);\n      }\n    }\n    async unpublishDataChannel(e) {\n      try {\n        if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new bb(tI.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n        await Gu.all(e.map(e => this.signal.request(Cb.UNPUBLISH_DATASTREAM, {\n          channel_id: e\n        }, !0)));\n      } catch (e) {\n        Qy.warning(\"unpublish datachannels warning: \", e);\n      }\n    }\n    async presubscribe(e, t, i) {\n      if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new bb(tI.INVALID_OPERATION, \"can not presubscribe when connection state is \".concat(this.state));\n      const n = {\n        stream_id: e,\n        stream_type: t,\n        mode: this.spec.mode,\n        codec: this.spec.codec,\n        p2p_id: this.store.p2pId,\n        twcc: !!Dy(\"SUBSCRIBE_TWCC\"),\n        rtx: !!Dy(\"USE_SUB_RTX\") || void 0,\n        extend: Dy(\"SUB_EXTEND\"),\n        svc: Array.isArray(Dy(\"SVC\")) && 0 !== Dy(\"SVC\").length ? Dy(\"SVC\") : void 0\n      };\n      try {\n        return await this.signal.request(Cb.PRE_SUBSCRIBE, n, !0);\n      } catch (n) {\n        if (i && n.data && n.data.code === Sb.ERR_SUBSCRIBE_REQUEST_INVALID) return Qy.warning(\"[\".concat(this.store.clientId, \"] pre-subscribe error, retry\"), n.toString()), this.presubscribe(e, t, !1);\n        throw n;\n      }\n    }\n    async subscribe(e, t, i) {\n      if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new bb(tI.INVALID_OPERATION, \"can not subscribe when connection state is \".concat(this.state));\n      const n = {\n        stream_id: e,\n        stream_type: t.stream_type,\n        mode: this.spec.mode,\n        codec: this.spec.codec,\n        p2p_id: this.store.p2pId,\n        twcc: !!Dy(\"SUBSCRIBE_TWCC\"),\n        rtx: !!Dy(\"USE_SUB_RTX\"),\n        extend: Dy(\"SUB_EXTEND\"),\n        ssrcId: t.ssrcId,\n        svc: Array.isArray(Dy(\"SVC\")) && 0 !== Dy(\"SVC\").length ? Dy(\"SVC\") : void 0\n      };\n      try {\n        return (await this.signal.request(Cb.SUBSCRIBE, n, !0))._message;\n      } catch (n) {\n        if (i && n.data && n.data.code === Sb.ERR_SUBSCRIBE_REQUEST_INVALID) return Qy.warning(\"[\".concat(this.store.clientId, \"] receiver subscribe error code, retry\"), n.toString()), await this.tryUnsubBeforeResub(e, t), await this.subscribe(e, t, !1);\n        throw n;\n      }\n    }\n    async subscribeDataChannel(e, t, i) {\n      if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new bb(tI.INVALID_OPERATION, \"can not subscribe datachannel when connection state is \".concat(this.state));\n      const n = {\n        uid: e,\n        stream_id: t.id,\n        channel_id: t.datachannelId\n      };\n      try {\n        return void (await this.signal.request(Cb.SUBSCRIBE_DATASTREAM, n, !0));\n      } catch (n) {\n        if (i && n.data && n.data.code === Sb.ERR_SUBSCRIBE_REQUEST_INVALID) return Qy.warning(\"[\".concat(this.store.clientId, \"] receiver subscribe datachannel error code, retry\"), n.toString()), await this.tryUnsubDataChannelBeforeResub(e, t), await this.subscribeDataChannel(e, t, !1);\n        throw n;\n      }\n    }\n    async subscribeAll(e, t) {\n      if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new bb(tI.INVALID_OPERATION, \"can not massSubscribe when connection state is \".concat(this.state));\n      const i = {\n        p2p_id: this.store.p2pId,\n        users: e,\n        dtx: !1,\n        rtx: !!Dy(\"USE_SUB_RTX\"),\n        twcc: !!Dy(\"SUBSCRIBE_TWCC\"),\n        svc: Array.isArray(Dy(\"SVC\")) && 0 !== Dy(\"SVC\").length ? Dy(\"SVC\") : void 0\n      };\n      try {\n        return await this.signal.request(Cb.SUBSCRIBE_STREAMS, i, !0);\n      } catch (i) {\n        if (t && i.data && i.data.code === Sb.ERR_SUBSCRIBE_REQUEST_INVALID) return Qy.warning(\"[\".concat(this.store.clientId, \"] receiver massSubscribe error code, retry\"), i.toString()), await this.tryMassUnsubBeforeResub(e), await this.subscribeAll(e, !1);\n        throw i;\n      }\n    }\n    async setVideoProfile(e) {\n      const t = function (e) {\n        if (!(e.bitrateMax && e.bitrateMin && e.frameRate && e.height && e.width)) return;\n        let t = e.frameRate,\n          i = e.width,\n          n = e.height,\n          r = !0;\n        return \"number\" != typeof t && (t = t.exact || t.ideal || t.max || t.min || 0, t || (r = !1)), \"number\" != typeof i && (i = i.exact || i.ideal || i.max || i.min || 0, i || (r = !1)), \"number\" != typeof n && (n = n.exact || n.ideal || n.max || n.min || 0, t || (r = !1)), r ? {\n          stream_type: 0,\n          width: i,\n          height: n,\n          fps: t,\n          start_bps: 1e3 * e.bitrateMax,\n          min_bps: 1e3 * e.bitrateMin,\n          target_bps: 1e3 * e.bitrateMax\n        } : void 0;\n      }(e);\n      if (t) return this.signal.request(Cb.SET_VIDEO_PROFILE, t);\n      Qy.debug(\"[\".concat(this.store.clientId, \"] encoder config is not complete, do not report to gateway\"));\n    }\n    async unsubscribe(e, t) {\n      try {\n        await this.signal.request(Cb.UNSUBSCRIBE, {\n          p2p_id: this.store.p2pId,\n          ortc: e,\n          stream_id: t\n        }, !0);\n      } catch (e) {\n        Qy.warning(\"[\".concat(this.store.clientId, \"] unsubscribe warning: \"), e);\n      }\n    }\n    async unsubscribeDataChannel(e, t) {\n      try {\n        if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new bb(tI.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n        await Gu.all(e.map(e => this.signal.request(Cb.UNSUBSCRIBE_DATASTREAM, {\n          stream_id: e,\n          uid: t\n        }, !0)));\n      } catch (e) {\n        Qy.warning(\"unsubscribeDataChannel warning: \", e);\n      }\n    }\n    async massUnsubscribe(e) {\n      try {\n        await this.signal.request(Cb.UNSUBSCRIBE_STREAMS, e, !0);\n      } catch (e) {\n        Qy.warning(\"[\".concat(this.store.clientId, \"] massUnsubscribeAll warning: \"), e);\n      }\n    }\n    async reconnectPC(e) {\n      const t = e.iceParameters,\n        i = e.dtlsParameters,\n        n = e.rtpCapabilities;\n      return {\n        gatewayEstablishParams: await this.signal.request(Cb.CONNECT_PC, {\n          p2p_id: this.store.p2pId,\n          stream_id: this.store.uid,\n          ortc: {\n            iceParameters: t,\n            dtlsParameters: i,\n            rtpCapabilities: n\n          }\n        }, !0),\n        gatewayAddress: this.getCurrentGatewayAddress()\n      };\n    }\n    getGatewayInfo() {\n      return this.signal.request(Cb.GATEWAY_INFO);\n    }\n    async renewToken(e) {\n      await this.signal.request(Cb.RENEW_TOKEN, e), this.key = e.token;\n    }\n    async setClientRole(e, t) {\n      if (t && (this._clientRoleOptions = Object.assign({}, t)), \"CONNECTED\" !== this.state) return void (this.role = e);\n      let i,\n        n = 0;\n      \"audience\" === e ? this._clientRoleOptions && this._clientRoleOptions.delay ? (i = this._clientRoleOptions.delay, n = 1) : n = this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : n = 0, await this.signal.request(Cb.SET_CLIENT_ROLE, {\n        role: e,\n        level: n,\n        delay: i,\n        client_ts: Date.now()\n      }), this.role = e;\n    }\n    async setRemoteVideoStreamType(e, t) {\n      await this.signal.request(Cb.SWITCH_VIDEO_STREAM, {\n        stream_id: e,\n        stream_type: t\n      });\n    }\n    async setDefaultRemoteVideoStreamType(e) {\n      await this.signal.request(Cb.DEFAULT_VIDEO_STREAM, {\n        stream_type: e\n      });\n    }\n    async setStreamFallbackOption(e, t) {\n      await this.signal.request(Cb.SET_FALLBACK_OPTION, {\n        stream_id: e,\n        fallback_type: t\n      });\n    }\n    async pickSVCLayer(e, t) {\n      await this.signal.request(Cb.PICK_SVC_LAYER, {\n        stream_id: e,\n        spatial_layer: t.spatialLayer,\n        temporal_layer: t.temporalLayer\n      });\n    }\n    async setRTM2Flag(e) {\n      await this.signal.request(Cb.SET_RTM2_FLAG, {\n        rtm2_flag: e\n      });\n    }\n    async sendExtensionMessage(e, t, i) {\n      if (this.signal instanceof sO) return this.signal.sendExtensionMessage(e, t, i);\n    }\n    getInChannelInfo() {\n      return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), cO({}, this.inChannelInfo);\n    }\n    async getGatewayVersion() {\n      return (await this.signal.request(Cb.GATEWAY_INFO)).version;\n    }\n    reset() {\n      if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {\n        const e = dO.get(this.joinInfo.cname);\n        e && e.delete(this.joinInfo.uid);\n      }\n      this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);\n    }\n    updateTurnConfigFromSignal() {\n      if (!this.joinInfo) return;\n      const e = function (e) {\n        let t;\n        return t = e.startsWith(\"dc\") ? e.match(/(dc\\:\\/\\/)?([^:]+):(\\d+)/) : e.match(/(wss\\:\\/\\/)?([^:]+):(\\d+)/), t ? {\n          username: aA.username,\n          password: aA.password,\n          turnServerURL: t[2],\n          tcpport: parseInt(t[3]) + 30,\n          udpport: parseInt(t[3]) + 30,\n          forceturn: !1\n        } : null;\n      }((\"disabled\" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || \"\");\n      this.joinInfo.turnServer.serversFromGateway = [], e && \"off\" !== this.joinInfo.turnServer.mode && \"disabled\" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(cO(cO({}, aA), {}, {\n        turnServerURL: e.turnServerURL,\n        tcpport: e.tcpport,\n        udpport: e.udpport,\n        username: this.joinInfo.uid.toString(),\n        password: this.joinInfo.token\n      }));\n    }\n    async updateTrafficStats() {\n      if (\"CONNECTED\" !== this.state) return;\n      const e = await this.signal.request(Cb.TRAFFIC_STATS, void 0, !0);\n      e.timestamp = Date.now(), null != e.ntp_offset && (this.ntpOffset = e.ntp_offset), e.peer_delay.forEach(e => {\n        const t = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find(t => t.peer_uid === e.peer_uid);\n        t && t.B_st !== e.B_st && jI(() => {\n          this.emit(Yb.STREAM_TYPE_CHANGE, e.peer_uid, e.B_st);\n        });\n      }), this._statsCollector.updateTrafficStats(e);\n    }\n    getJoinMessage(e) {\n      if (!this.joinInfo || !this.key) throw new bb(tI.UNEXPECTED_ERROR, \"can not generate join message, no join info\");\n      const t = Object.assign({}, this.joinInfo.apResponse);\n      let i = Dy(\"REPORT_APP_SCENARIO\");\n      if (\"string\" != typeof i) try {\n        i = JSON.stringify(i);\n      } catch (e) {\n        i = void 0;\n      }\n      i && i.length > 128 && (i = void 0);\n      const n = cO({\n        license: this.joinInfo.license,\n        p2p_id: this.store.p2pId,\n        session_id: this.joinInfo.sid,\n        app_id: this.joinInfo.appId,\n        channel_key: this.key,\n        channel_name: this.joinInfo.cname,\n        sdk_version: Iy,\n        browser: navigator.userAgent,\n        process_id: Dy(\"PROCESS_ID\"),\n        mode: this.store.useP2P ? \"p2p\" : this.spec.mode,\n        codec: this.spec.codec,\n        role: this.role,\n        has_changed_gateway: this.hasChangeBGPAddress,\n        ap_response: t,\n        extend: Dy(\"JOIN_EXTEND\"),\n        details: {\n          6: this.joinInfo.stringUid,\n          cservice_map: \"proxy3\" === this.joinInfo.cloudProxyServer ? \"1\" : \"proxy5\" === this.joinInfo.cloudProxyServer ? \"2\" : void 0\n        },\n        features: {\n          rejoin: !0\n        },\n        optionalInfo: this.joinInfo.optionalInfo,\n        appScenario: i,\n        attributes: {\n          userAttributes: {\n            enablePublishedUserList: Dy(\"ENABLE_PUBLISHED_USER_LIST\"),\n            maxSubscription: Dy(\"MAX_SUBSCRIPTION\"),\n            subscribeAudioFilterTopN: \"number\" == typeof Dy(\"SUBSCRIBE_AUDIO_FILTER_TOPN\") ? Dy(\"SUBSCRIBE_AUDIO_FILTER_TOPN\") : void 0,\n            enablePublishAudioFilter: \"boolean\" == typeof Dy(\"ENABLE_PUBLISH_AUDIO_FILTER\") ? Dy(\"ENABLE_PUBLISH_AUDIO_FILTER\") : void 0,\n            enableUserLicenseCheck: \"boolean\" == typeof Dy(\"ENABLE_USER_LICENSE_CHECK\") ? Dy(\"ENABLE_USER_LICENSE_CHECK\") : void 0,\n            enableRTX: !0 === Dy(\"USE_PUB_RTX\") || !0 === Dy(\"USE_SUB_RTX\") || void 0,\n            disableFEC: Dy(\"DISABLE_FEC\"),\n            enableNTPReport: !!Dy(\"ENABLE_NTP_REPORT\") || void 0,\n            enableInstantVideo: !!Dy(\"ENABLE_INSTANT_VIDEO\") || void 0,\n            enableDataStream2: \"boolean\" == typeof Dy(\"ENABLE_DATASTREAM_2\") ? Dy(\"ENABLE_DATASTREAM_2\") : void 0,\n            rtm2Flag: \"number\" == typeof this.joinInfo.rtmFlag ? this.joinInfo.rtmFlag : void 0,\n            enableUserAutoRebalanceCheck: !!Dy(\"ENABLE_USER_AUTO_REBALANCE_CHECK\"),\n            enableXR: \"boolean\" == typeof Dy(\"USE_XR\") ? Dy(\"USE_XR\") : void 0,\n            enableLossbasedBwe: \"boolean\" == typeof Dy(\"ENABLE_LOSSBASED_BWE\") ? Dy(\"ENABLE_LOSSBASED_BWE\") : void 0,\n            enableAutCC: \"boolean\" == typeof Dy(\"ENABLE_AUT_CC\") ? Dy(\"ENABLE_AUT_CC\") : void 0,\n            enableCCFallback: \"boolean\" == typeof Dy(\"ENABLE_CC_FALLBACK\") ? Dy(\"ENABLE_CC_FALLBACK\") : void 0\n          }\n        },\n        join_ts: this.joinGatewayStartTime\n      }, e);\n      return this.joinInfo.stringUid && (n.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (n.aes_mode = this.joinInfo.aesmode, Dy(\"ENCRYPT_AES\") ? (n.aes_secret = this.joinInfo.aespassword, n.aes_encrypt = !0) : n.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (n.aes_salt = this.joinInfo.aessalt)), t.addresses[this.signal.websocket.currentURLIndex] && (n.ap_response.ticket = t.addresses[this.signal.websocket.currentURLIndex].ticket, delete t.addresses), void 0 !== this.joinInfo.defaultVideoStream && (n.default_video_stream = this.joinInfo.defaultVideoStream), n;\n    }\n    getRejoinMessage() {\n      if (!this.joinInfo) throw new bb(tI.UNEXPECTED_ERROR, \"can not generate rejoin message, no join info\");\n      return {\n        session_id: this.joinInfo.sid,\n        channel_name: this.joinInfo.cname,\n        cid: this.joinInfo.cid,\n        uid: this.joinInfo.uid,\n        vid: Number(this.joinInfo.vid)\n      };\n    }\n    handleSignalEvents() {\n      this.signal.on(Rb.WS_RECONNECT_WAITTING_FINISH, e => {\n        var t;\n        Dn(t = [\"tryNext\", \"recover\"]).call(t, e) && this.joinInfo && oA.adjustSessionStartTime(this.joinInfo.sid);\n      }), this.signal.on(Rb.WS_RECONNECT_CREATE_CONNECTION, e => {\n        this.joinGatewayStartTime = Date.now();\n      }), this.signal.on(Rb.WS_RECONNECTING, e => {\n        this.joinInfo && oA.WebSocketQuit(this.joinInfo.sid, {\n          lts: Date.now(),\n          succ: -1,\n          cname: this.joinInfo.cname,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid,\n          errorCode: e || DI.NETWORK_ERROR\n        }), this.joinInfo && (this.state = \"RECONNECTING\", oA.sessionInit(this.joinInfo.sid, {\n          lts: new Date().getTime(),\n          extend: this.isSignalRecover ? {\n            recover: !0\n          } : {\n            rejoin: !0\n          },\n          cname: this.joinInfo.cname,\n          appid: this.joinInfo.appId,\n          mode: this.spec.mode,\n          stringUid: this.joinInfo.stringUid,\n          channelProfile: \"live\" === this.spec.mode ? 1 : 0,\n          channelMode: 0,\n          lsid: this.joinInfo.sid,\n          clientRole: \"audience\" === this.role ? 2 : 1,\n          buildFormat: 1\n        }), this.isSignalRecover = !1, this.joinGatewayStartTime = Date.now());\n      }), this.signal.on(Rb.WS_CLOSED, e => {\n        let t;\n        switch (e) {\n          case AI.LEAVE:\n            t = DI.LEAVE;\n            break;\n          case AI.UID_BANNED:\n          case AI.IP_BANNED:\n          case AI.CHANNEL_BANNED:\n          case AI.SERVER_ERROR:\n            t = DI.SERVER_ERROR;\n            break;\n          case AI.FALLBACK:\n            t = DI.FALLBACK;\n            break;\n          case AI.LICENSE_MISSING:\n          case AI.LICENSE_EXPIRED:\n          case AI.LICENSE_MINUTES_EXCEEDED:\n          case AI.LICENSE_PERIOD_INVALID:\n          case AI.LICENSE_MULTIPLE_SDK_SERVICE:\n          case AI.LICENSE_ILLEGAL:\n          case AI.TOKEN_EXPIRE:\n            t = e;\n            break;\n          default:\n            t = DI.NETWORK_ERROR;\n        }\n        Qy.debug(\"[\".concat(this.store.clientId, \"] [signal] websocket closed, reason: \").concat(t || \"undefined -> \" + DI.NETWORK_ERROR)), this.joinInfo && oA.WebSocketQuit(this.joinInfo.sid, {\n          lts: Date.now(),\n          succ: e === AI.LEAVE ? 1 : -1,\n          cname: this.joinInfo.cname,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid,\n          errorCode: t\n        }), this._disconnectedReason = e, e !== AI.FALLBACK && (this.state = \"DISCONNECTED\"), this.reset();\n      }), this.signal.on(Rb.WS_CONNECTED, () => {\n        if (this.updateTurnConfigFromSignal(), this.state = \"CONNECTED\", this.joinInfo && (\"audience\" === this.role && this._clientRoleOptions && (this._clientRoleOptions.level || this._clientRoleOptions.delay) && (Qy.debug(\"[\".concat(this.store.clientId, \"] patch to send set client role, role: \").concat(this.role, \", mode: \").concat(this.spec.mode, \", level: \").concat(this._clientRoleOptions.level, \", delay: \").concat(this._clientRoleOptions.delay)), this.setClientRole(this.role, this._clientRoleOptions)), oA.joinGateway(this.joinInfo.sid, {\n          lts: this.joinGatewayStartTime,\n          succ: !0,\n          ec: null,\n          vid: this.joinInfo.vid,\n          addr: this.signal.url,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid,\n          firstSuccess: this._isProactiveJoin,\n          avoidJoinStartTime: this.store.avoidJoinStart,\n          isProxy: !!this.joinInfo.proxyServer,\n          signalChannel: this.signal instanceof rO ? \"1\" : \"0\"\n        }), this._isProactiveJoin = !1, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion)) {\n          const e = this.signal.url && this.signal.url.match(/wss\\:\\/\\/([^:]+):(\\d+)/);\n          if (!e) return void Qy.error(\"[\".concat(this.store.clientId, \"] set local access point after joined failed: \").concat(e));\n          Ny(\"EVENT_REPORT_DOMAIN\", e[1]), Ny(\"EVENT_REPORT_BACKUP_DOMAIN\", e[1]), Ny(\"LOG_UPLOAD_SERVER\", \"\".concat(e[1], \":6444\"));\n        }\n      }), this.signal.on(Ib.ON_UPLINK_STATS, e => {\n        this._statsCollector.updateUplinkStats(e);\n      }), this.signal.on(Rb.REQUEST_RECOVER, (e, t, i) => {\n        if (!this.joinInfo) return i(new bb(tI.UNEXPECTED_ERROR, \"gateway: can not recover, no join info\"));\n        e && (this.joinInfo.multiIP = e, this.hasChangeBGPAddress = !0), this.isSignalRecover = !0, kI(this, Yb.REQUEST_NEW_GATEWAY_LIST).then(t).catch(i);\n      }), this.signal.on(Rb.REQUEST_JOIN_INFO, async e => {\n        var t;\n        if (this.updateTurnConfigFromSignal(), this.store.useP2P) return void e(this.getJoinMessage({\n          ortc: {}\n        }));\n        const _await$kI = await kI(this, Yb.REQUEST_P2P_CONNECTION_PARAMS, {\n            turnServer: null === (t = this.joinInfo) || void 0 === t ? void 0 : t.turnServer\n          }),\n          i = _await$kI.iceParameters,\n          n = _await$kI.dtlsParameters,\n          r = _await$kI.rtpCapabilities;\n        e(this.getJoinMessage({\n          ortc: {\n            iceParameters: i,\n            dtlsParameters: n,\n            rtpCapabilities: r,\n            version: \"2\"\n          }\n        }));\n      }), this.signal.on(Rb.REQUEST_REJOIN_INFO, e => {\n        e(this.getRejoinMessage());\n      }), this.signal.on(Rb.REPORT_JOIN_GATEWAY, (e, t) => {\n        this.joinInfo && (oA.joinGateway(this.joinInfo.sid, {\n          lts: this.joinGatewayStartTime,\n          succ: !1,\n          ec: e,\n          addr: t,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid,\n          firstSuccess: this._isProactiveJoin,\n          avoidJoinStartTime: this.store.avoidJoinStart,\n          isProxy: !!this.joinInfo.proxyServer,\n          signalChannel: this.signal instanceof rO ? \"1\" : \"0\"\n        }), this._isProactiveJoin = !1);\n      }), this.signal.on(Rb.IS_P2P_DISCONNECTED, e => {\n        e(xI(this, Yb.IS_P2P_DISCONNECTED));\n      }), this.signal.on(Rb.DISCONNECT_P2P, () => {\n        this.emit(Yb.DISCONNECT_P2P);\n      }), this.signal.on(Rb.NEED_RENEW_SESSION, e => {\n        this.emit(Yb.NEED_RENEW_SESSION, e);\n      }), this.signal.on(Rb.REQUEST_SUCCESS, () => {\n        this._signalTimeout = !1;\n      }), this.signal.on(Rb.REQUEST_TIMEOUT, () => {\n        this._signalTimeout = !0;\n      }), this.signal.on(Rb.JOIN_RESPONSE, e => {\n        const t = this.getCurrentGatewayAddress();\n        this.emit(Yb.JOIN_RESPONSE, e, t);\n      }), this.signal.on(Rb.DATACHANNEL_PRECONNECT, async (e, t, i) => {\n        this.updateTurnConfigFromSignal();\n        const n = this.getCurrentGatewayAddress();\n        return kI(this, Yb.DATACHANNEL_PRECONNECT, e, n).then(t).catch(i);\n      }), this.signal.on(Rb.DATACHANNEL_CONNECTING, async e => {\n        const _await$kI2 = await kI(this, Yb.REQUEST_DC_CONNECTION_PARAMS),\n          t = _await$kI2.iceParameters,\n          i = _await$kI2.dtlsParameters,\n          n = _await$kI2.rtpCapabilities;\n        e(this.getJoinMessage({\n          ortc: {\n            iceParameters: t,\n            dtlsParameters: i,\n            rtpCapabilities: n,\n            version: \"2\"\n          }\n        }));\n      }), this.signal.on(Rb.DATACHANNEL_FAILBACK, () => {\n        Qy.warning(\"[\".concat(this.store.clientId, \"] User join datachannel failed\")), this.reset(), this.resetSignal(), this.emit(Yb.DATACHANNEL_FAILBACK);\n      });\n    }\n    async tryUnsubBeforeResub(e, t) {\n      try {\n        await this.signal.request(Cb.UNSUBSCRIBE, {\n          p2p_id: this.store.p2pId,\n          stream_id: e,\n          ortc: [t]\n        }, !0);\n      } catch (e) {\n        throw Qy.warning(\"[\".concat(this.store.clientId, \"] tryUnsubBeforeResub warning\"), e), e;\n      }\n    }\n    async tryUnsubDataChannelBeforeResub(e, t) {\n      try {\n        await this.signal.request(Cb.UNSUBSCRIBE, {\n          stream_id: t.id\n        }, !0);\n      } catch (e) {\n        throw Qy.warning(\"unsubscribe datachannel warning\", e), e;\n      }\n    }\n    async tryUnpubBeforeRepub(e, t) {\n      try {\n        await this.signal.request(Cb.UNPUBLISH, {\n          stream_id: e,\n          ortc: t\n        }, !0);\n      } catch (e) {\n        throw Qy.warning(\"[\".concat(this.store.clientId, \"] tryUnpubBeforeRepub warning: \"), e), e;\n      }\n    }\n    async tryUnpubDataChannelBeforeRepub(e, t) {\n      try {\n        await this.signal.request(Cb.UNPUBLISH_DATASTREAM, {\n          channnel_id: t.channelId\n        }, !0);\n      } catch (e) {\n        throw Qy.warning(\"unpublish datastream warning: \", e), e;\n      }\n    }\n    async tryMassUnsubBeforeResub(e) {\n      const t = {\n        users: e.map(e => ({\n          stream_id: e.stream_id,\n          stream_type: e.stream_type\n        }))\n      };\n      try {\n        await this.signal.request(Cb.UNSUBSCRIBE_STREAMS, t, !0);\n      } catch (e) {\n        throw Qy.warning(\"[\".concat(this.store.clientId, \"] tryMassUnsubBeforeResub warning\"), e), e;\n      }\n    }\n    async muteLocal(e, t) {\n      const i = {\n        action: e.find(e => e.stream_type === Kb.Audio) ? \"mute_local_audio\" : \"mute_local_video\",\n        p2p_id: this.store.p2pId,\n        ortc: e,\n        stream_id: t\n      };\n      try {\n        await this.signal.request(Cb.CONTROL, i, !0, !0);\n      } catch (e) {\n        throw Qy.warning(\"[\".concat(this.store.clientId, \"] gateway muteLocal warning: \"), e), e;\n      }\n    }\n    async unmuteLocal(e, t) {\n      const i = {\n        action: e.find(e => e.stream_type === Kb.Audio) ? \"unmute_local_audio\" : \"unmute_local_video\",\n        p2p_id: this.store.p2pId,\n        ortc: e,\n        stream_id: t\n      };\n      try {\n        await this.signal.request(Cb.CONTROL, i, !0, !0);\n      } catch (e) {\n        throw Qy.warning(\"[\".concat(this.store.clientId, \"] gateway unmuteLocal warning: \"), e), e;\n      }\n    }\n    async muteRemote(e, t) {\n      const i = {\n        action: e === nw.AUDIO ? \"mute_remote_audio\" : \"mute_remote_video\",\n        p2p_id: this.store.p2pId,\n        stream_id: t\n      };\n      try {\n        await this.signal.request(Cb.CONTROL, i, !0, !0);\n      } catch (e) {\n        throw Qy.warning(\"[\".concat(this.store.clientId, \"] gateway muteRemote warning: \"), e), e;\n      }\n    }\n    async unmuteRemote(e, t) {\n      const i = {\n        action: e === nw.AUDIO ? \"unmute_remote_audio\" : \"unmute_remote_video\",\n        p2p_id: this.store.p2pId,\n        stream_id: t\n      };\n      try {\n        await this.signal.request(Cb.CONTROL, i, !0, !0);\n      } catch (e) {\n        throw Qy.warning(\"[\".concat(this.store.clientId, \"] gateway unmuteRemote warning: \"), e), e;\n      }\n    }\n    uploadWRTCStats(e) {\n      this.signal.uploadWRTCStats(e);\n    }\n    upload(e, t) {\n      this.signal.upload(e, t);\n    }\n    getSignalRTT() {\n      return this.signal.rtt;\n    }\n    async restartICE(e) {\n      const t = {\n        p2p_id: this.store.p2pId,\n        stream_id: this.store.uid,\n        ortc: e\n      };\n      try {\n        return await this.signal.request(Cb.RESTART_ICE, t, !0);\n      } catch (e) {\n        throw Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel.restartICE warning: \"), e), e;\n      }\n    }\n    reconnect() {\n      \"CONNECTED\" === this.state && this.signal.reconnect(void 0, DI.P2P_FAILED);\n    }\n    getCurrentGatewayAddress() {\n      var e;\n      if (!Dy(\"GATEWAY_WSS_ADDRESS\")) return null !== (e = this.joinInfo) && void 0 !== e && e.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;\n    }\n    async setPublishAudioFilterEnabled(e) {\n      await this.signal.request(Cb.SET_PARAMETER, {\n        enablePublishAudioFilter: e\n      });\n    }\n    resetSignal() {\n      this.signal && (this.signal.removeAllListeners(), this.signal.close(AI.FALLBACK)), this.store.useDataChannel = !1, this.signal = new Bw(cO(cO({}, this.spec), {}, {\n        retryConfig: this.spec.websocketRetryConfig\n      }), this.store), this.handleSignalEvents(), this.emit(Yb.RESET_SIGNAL, Jb.websocket);\n    }\n  }\n  let hO = 0,\n    uO = 0;\n  function pO(e, t, i, n) {\n    return new Gu((r, o) => {\n      t.timeout = t.timeout || Dy(\"HTTP_CONNECT_TIMEOUT\"), t.responseType = t.responseType || \"json\", t.data && !i ? (t.data = JSON.stringify(t.data), hO += XI(t.data)) : i && (t.data.size ? hO += t.data.size : t.data instanceof FormData ? hO += QI(t.data) : hO += XI(JSON.stringify(t.data))), t.headers = t.headers || {}, t.headers[\"Content-Type\"] = t.headers[\"Content-Type\"] || \"application/json\", t.method = \"POST\", t.url = e, pv.request(t).then(e => {\n        \"string\" == typeof e.data ? uO += XI(e.data) : e.data instanceof ArrayBuffer || e.data instanceof Uint8Array ? uO += e.data.byteLength : uO += XI(JSON.stringify(e.data)), n && r({\n          data: e.data,\n          headers: e.headers\n        }), r(e.data);\n      }).catch(e => {\n        pv.isCancel(e) ? o(new bb(tI.OPERATION_ABORTED, \"cancel token canceled\")) : \"ECONNABORTED\" === e.code ? o(new bb(tI.NETWORK_TIMEOUT, e.message)) : e.response ? o(new bb(tI.NETWORK_RESPONSE_ERROR, e.response.status)) : o(new bb(tI.NETWORK_ERROR, e.message));\n      });\n    });\n  }\n  /*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */\n  !function () {\n    var e;\n    function i(e) {\n      var t = 0;\n      return function () {\n        return t < e.length ? {\n          done: !1,\n          value: e[t++]\n        } : {\n          done: !0\n        };\n      };\n    }\n    var n = \"function\" == typeof Object.defineProperties ? Object.defineProperty : function (e, t, i) {\n      return e == Array.prototype || e == Object.prototype || (e[t] = i.value), e;\n    };\n    var r,\n      o = function (e) {\n        e = [\"object\" == typeof globalThis && globalThis, e, \"object\" == typeof window && window, \"object\" == typeof self && self, \"object\" == typeof t && t];\n        for (var i = 0; i < e.length; ++i) {\n          var n = e[i];\n          if (n && n.Math == Math) return n;\n        }\n        throw Error(\"Cannot find global object\");\n      }(this);\n    function s(e, t) {\n      if (t) e: {\n        var i = o;\n        e = e.split(\".\");\n        for (var r = 0; r < e.length - 1; r++) {\n          var s = e[r];\n          if (!(s in i)) break e;\n          i = i[s];\n        }\n        (t = t(r = i[e = e[e.length - 1]])) != r && null != t && n(i, e, {\n          configurable: !0,\n          writable: !0,\n          value: t\n        });\n      }\n    }\n    function a(e) {\n      return (e = {\n        next: e\n      })[Symbol.iterator] = function () {\n        return this;\n      }, e;\n    }\n    function c(e) {\n      var t = \"undefined\" != typeof Symbol && Symbol.iterator && e[Symbol.iterator];\n      return t ? t.call(e) : {\n        next: i(e)\n      };\n    }\n    if (s(\"Symbol\", function (e) {\n      function t(e, t) {\n        this.A = e, n(this, \"description\", {\n          configurable: !0,\n          writable: !0,\n          value: t\n        });\n      }\n      if (e) return e;\n      t.prototype.toString = function () {\n        return this.A;\n      };\n      var i = \"jscomp_symbol_\" + (1e9 * Math.random() >>> 0) + \"_\",\n        r = 0;\n      return function e(n) {\n        if (this instanceof e) throw new TypeError(\"Symbol is not a constructor\");\n        return new t(i + (n || \"\") + \"_\" + r++, n);\n      };\n    }), s(\"Symbol.iterator\", function (e) {\n      if (e) return e;\n      e = Symbol(\"Symbol.iterator\");\n      for (var t = \"Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".split(\" \"), r = 0; r < t.length; r++) {\n        var s = o[t[r]];\n        \"function\" == typeof s && \"function\" != typeof s.prototype[e] && n(s.prototype, e, {\n          configurable: !0,\n          writable: !0,\n          value: function () {\n            return a(i(this));\n          }\n        });\n      }\n      return e;\n    }), \"function\" == typeof Object.setPrototypeOf) r = Object.setPrototypeOf;else {\n      var d;\n      e: {\n        var l = {};\n        try {\n          l.__proto__ = {\n            a: !0\n          }, d = l.a;\n          break e;\n        } catch (e) {}\n        d = !1;\n      }\n      r = d ? function (e, t) {\n        if (e.__proto__ = t, e.__proto__ !== t) throw new TypeError(e + \" is not extensible\");\n        return e;\n      } : null;\n    }\n    var h = r;\n    function u() {\n      this.m = !1, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;\n    }\n    function p(e) {\n      if (e.m) throw new TypeError(\"Generator is already running\");\n      e.m = !0;\n    }\n    function _(e, t) {\n      return e.h = 3, {\n        value: t\n      };\n    }\n    function E(e) {\n      this.g = new u(), this.G = e;\n    }\n    function m(e, t, i, n) {\n      try {\n        var r = t.call(e.g.j, i);\n        if (!(r instanceof Object)) throw new TypeError(\"Iterator result \" + r + \" is not an object\");\n        if (!r.done) return e.g.m = !1, r;\n        var o = r.value;\n      } catch (t) {\n        return e.g.j = null, e.g.s(t), f(e);\n      }\n      return e.g.j = null, n.call(e.g, o), f(e);\n    }\n    function f(e) {\n      for (; e.g.h;) try {\n        var t = e.G(e.g);\n        if (t) return e.g.m = !1, {\n          value: t.value,\n          done: !1\n        };\n      } catch (t) {\n        e.g.v = void 0, e.g.s(t);\n      }\n      if (e.g.m = !1, e.g.l) {\n        if (t = e.g.l, e.g.l = null, t.F) throw t.D;\n        return {\n          value: t.return,\n          done: !0\n        };\n      }\n      return {\n        value: void 0,\n        done: !0\n      };\n    }\n    function T(e) {\n      this.next = function (t) {\n        return e.o(t);\n      }, this.throw = function (t) {\n        return e.s(t);\n      }, this.return = function (t) {\n        return function (e, t) {\n          p(e.g);\n          var i = e.g.j;\n          return i ? m(e, \"return\" in i ? i.return : function (e) {\n            return {\n              value: e,\n              done: !0\n            };\n          }, t, e.g.return) : (e.g.return(t), f(e));\n        }(e, t);\n      }, this[Symbol.iterator] = function () {\n        return this;\n      };\n    }\n    function S(e, t) {\n      return t = new T(new E(t)), h && e.prototype && h(t, e.prototype), t;\n    }\n    if (u.prototype.o = function (e) {\n      this.v = e;\n    }, u.prototype.s = function (e) {\n      this.l = {\n        D: e,\n        F: !0\n      }, this.h = this.C || this.u;\n    }, u.prototype.return = function (e) {\n      this.l = {\n        return: e\n      }, this.h = this.u;\n    }, E.prototype.o = function (e) {\n      return p(this.g), this.g.j ? m(this, this.g.j.next, e, this.g.o) : (this.g.o(e), f(this));\n    }, E.prototype.s = function (e) {\n      return p(this.g), this.g.j ? m(this, this.g.j.throw, e, this.g.o) : (this.g.s(e), f(this));\n    }, s(\"Array.prototype.entries\", function (e) {\n      return e || function () {\n        return function (e, t) {\n          e instanceof String && (e += \"\");\n          var i = 0,\n            n = !1,\n            r = {\n              next: function () {\n                if (!n && i < e.length) {\n                  var r = i++;\n                  return {\n                    value: t(r, e[r]),\n                    done: !1\n                  };\n                }\n                return n = !0, {\n                  done: !0,\n                  value: void 0\n                };\n              }\n            };\n          return r[Symbol.iterator] = function () {\n            return r;\n          }, r;\n        }(this, function (e, t) {\n          return [e, t];\n        });\n      };\n    }), \"undefined\" != typeof Blob && (\"undefined\" == typeof FormData || !FormData.prototype.keys)) {\n      var g = function (e, t) {\n          for (var i = 0; i < e.length; i++) t(e[i]);\n        },\n        R = function (e) {\n          return e.replace(/\\r?\\n|\\r/g, \"\\r\\n\");\n        },\n        C = function (e, t, i) {\n          return t instanceof Blob ? (i = void 0 !== i ? String(i + \"\") : \"string\" == typeof t.name ? t.name : \"blob\", t.name === i && \"[object Blob]\" !== Object.prototype.toString.call(t) || (t = new File([t], i)), [String(e), t]) : [String(e), String(t)];\n        },\n        v = function (e, t) {\n          if (e.length < t) throw new TypeError(t + \" argument required, but only \" + e.length + \" present.\");\n        },\n        I = \"object\" == typeof globalThis ? globalThis : \"object\" == typeof window ? window : \"object\" == typeof self ? self : this,\n        y = I.FormData,\n        A = I.XMLHttpRequest && I.XMLHttpRequest.prototype.send,\n        b = I.Request && I.fetch,\n        w = I.navigator && I.navigator.sendBeacon,\n        O = I.Element && I.Element.prototype,\n        N = I.Symbol && Symbol.toStringTag;\n      N && (Blob.prototype[N] || (Blob.prototype[N] = \"Blob\"), \"File\" in I && !File.prototype[N] && (File.prototype[N] = \"File\"));\n      try {\n        new File([], \"\");\n      } catch (e) {\n        I.File = function (e, t, i) {\n          return e = new Blob(e, i || {}), Object.defineProperties(e, {\n            name: {\n              value: t\n            },\n            lastModified: {\n              value: +(i && void 0 !== i.lastModified ? new Date(i.lastModified) : new Date())\n            },\n            toString: {\n              value: function () {\n                return \"[object File]\";\n              }\n            }\n          }), N && Object.defineProperty(e, N, {\n            value: \"File\"\n          }), e;\n        };\n      }\n      var D = function (e) {\n          return e.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\");\n        },\n        P = function (e) {\n          this.i = [];\n          var t = this;\n          e && g(e.elements, function (e) {\n            if (e.name && !e.disabled && \"submit\" !== e.type && \"button\" !== e.type && !e.matches(\"form fieldset[disabled] *\")) if (\"file\" === e.type) {\n              var i = e.files && e.files.length ? e.files : [new File([], \"\", {\n                type: \"application/octet-stream\"\n              })];\n              g(i, function (i) {\n                t.append(e.name, i);\n              });\n            } else \"select-multiple\" === e.type || \"select-one\" === e.type ? g(e.options, function (i) {\n              !i.disabled && i.selected && t.append(e.name, i.value);\n            }) : \"checkbox\" === e.type || \"radio\" === e.type ? e.checked && t.append(e.name, e.value) : (i = \"textarea\" === e.type ? R(e.value) : e.value, t.append(e.name, i));\n          });\n        };\n      if ((e = P.prototype).append = function (e, t, i) {\n        v(arguments, 2), this.i.push(C(e, t, i));\n      }, e.delete = function (e) {\n        v(arguments, 1);\n        var t = [];\n        e = String(e), g(this.i, function (i) {\n          i[0] !== e && t.push(i);\n        }), this.i = t;\n      }, e.entries = function e() {\n        var t,\n          i = this;\n        return S(e, function (e) {\n          if (1 == e.h && (t = 0), 3 != e.h) return t < i.i.length ? e = _(e, i.i[t]) : (e.h = 0, e = void 0), e;\n          t++, e.h = 2;\n        });\n      }, e.forEach = function (e, t) {\n        v(arguments, 1);\n        for (var i = c(this), n = i.next(); !n.done; n = i.next()) {\n          var r = c(n.value);\n          n = r.next().value, r = r.next().value, e.call(t, r, n, this);\n        }\n      }, e.get = function (e) {\n        v(arguments, 1);\n        var t = this.i;\n        e = String(e);\n        for (var i = 0; i < t.length; i++) if (t[i][0] === e) return t[i][1];\n        return null;\n      }, e.getAll = function (e) {\n        v(arguments, 1);\n        var t = [];\n        return e = String(e), g(this.i, function (i) {\n          i[0] === e && t.push(i[1]);\n        }), t;\n      }, e.has = function (e) {\n        v(arguments, 1), e = String(e);\n        for (var t = 0; t < this.i.length; t++) if (this.i[t][0] === e) return !0;\n        return !1;\n      }, e.keys = function e() {\n        var t,\n          i,\n          n,\n          r,\n          o = this;\n        return S(e, function (e) {\n          if (1 == e.h && (t = c(o), i = t.next()), 3 != e.h) return i.done ? void (e.h = 0) : (n = i.value, r = c(n), _(e, r.next().value));\n          i = t.next(), e.h = 2;\n        });\n      }, e.set = function (e, t, i) {\n        v(arguments, 2), e = String(e);\n        var n = [],\n          r = C(e, t, i),\n          o = !0;\n        g(this.i, function (t) {\n          t[0] === e ? o && (o = !n.push(r)) : n.push(t);\n        }), o && n.push(r), this.i = n;\n      }, e.values = function e() {\n        var t,\n          i,\n          n,\n          r,\n          o = this;\n        return S(e, function (e) {\n          if (1 == e.h && (t = c(o), i = t.next()), 3 != e.h) return i.done ? void (e.h = 0) : (n = i.value, (r = c(n)).next(), _(e, r.next().value));\n          i = t.next(), e.h = 2;\n        });\n      }, P.prototype._asNative = function () {\n        for (var e = new y(), t = c(this), i = t.next(); !i.done; i = t.next()) {\n          var n = c(i.value);\n          i = n.next().value, n = n.next().value, e.append(i, n);\n        }\n        return e;\n      }, P.prototype._blob = function () {\n        var e = \"----formdata-polyfill-\" + Math.random(),\n          t = [],\n          i = \"--\" + e + '\\r\\nContent-Disposition: form-data; name=\"';\n        return this.forEach(function (e, n) {\n          return \"string\" == typeof e ? t.push(i + D(R(n)) + '\"\\r\\n\\r\\n' + R(e) + \"\\r\\n\") : t.push(i + D(R(n)) + '\"; filename=\"' + D(e.name) + '\"\\r\\nContent-Type: ' + (e.type || \"application/octet-stream\") + \"\\r\\n\\r\\n\", e, \"\\r\\n\");\n        }), t.push(\"--\" + e + \"--\"), new Blob(t, {\n          type: \"multipart/form-data; boundary=\" + e\n        });\n      }, P.prototype[Symbol.iterator] = function () {\n        return this.entries();\n      }, P.prototype.toString = function () {\n        return \"[object FormData]\";\n      }, O && !O.matches && (O.matches = O.matchesSelector || O.mozMatchesSelector || O.msMatchesSelector || O.oMatchesSelector || O.webkitMatchesSelector || function (e) {\n        for (var t = (e = (this.document || this.ownerDocument).querySelectorAll(e)).length; 0 <= --t && e.item(t) !== this;);\n        return -1 < t;\n      }), N && (P.prototype[N] = \"FormData\"), A) {\n        var L = I.XMLHttpRequest.prototype.setRequestHeader;\n        I.XMLHttpRequest.prototype.setRequestHeader = function (e, t) {\n          L.call(this, e, t), \"content-type\" === e.toLowerCase() && (this.B = !0);\n        }, I.XMLHttpRequest.prototype.send = function (e) {\n          e instanceof P ? (e = e._blob(), this.B || this.setRequestHeader(\"Content-Type\", e.type), A.call(this, e)) : A.call(this, e);\n        };\n      }\n      b && (I.fetch = function (e, t) {\n        return t && t.body && t.body instanceof P && (t.body = t.body._blob()), b.call(this, e, t);\n      }), w && (I.navigator.sendBeacon = function (e, t) {\n        return t instanceof P && (t = t._asNative()), w.call(this, e, t);\n      }), I.FormData = P;\n    }\n  }();\n  const _O = () => {\n      const e = Dy(\"AREAS\");\n      0 === e.length && e.push(Xb.GLOBAL);\n      return Jn(e).call(e, (e, t, i) => {\n        const n = EO(t);\n        return n ? 0 === i ? n : \"\".concat(e, \",\").concat(n) : e;\n      }, \"\");\n    },\n    EO = e => e === Xb.OVERSEA ? \"\".concat(Zb.ASIA, \",\").concat(Zb.EUROPE, \",\").concat(Zb.AFRICA, \",\").concat(Zb.NORTH_AMERICA, \",\").concat(Zb.SOUTH_AMERICA, \",\").concat(Zb.OCEANIA) : Zb[e],\n    mO = e => {\n      const t = {\n        CODE: \"\",\n        WEBCS_DOMAIN: [],\n        WEBCS_DOMAIN_BACKUP_LIST: [],\n        PROXY_CS: [],\n        CDS_AP: [],\n        ACCOUNT_REGISTER: [],\n        UAP_AP: [],\n        EVENT_REPORT_DOMAIN: [],\n        EVENT_REPORT_BACKUP_DOMAIN: [],\n        LOG_UPLOAD_SERVER: [],\n        PROXY_SERVER_TYPE3: []\n      };\n      return e.map(e => {\n        const i = $b[e],\n          n = Object.keys(i);\n        n && n.map(e => {\n          \"CODE\" !== e && (t[e] = t[e].concat(i[e]));\n        });\n      }), t;\n    },\n    fO = {\n      GLOBAL: {\n        ASIA: [Xb.CHINA, Xb.JAPAN, Xb.INDIA, Xb.KOREA, Xb.HKMC],\n        EUROPE: [],\n        NORTH_AMERICA: [Xb.US],\n        SOUTH_AMERICA: [],\n        OCEANIA: [],\n        AFRICA: []\n      }\n    },\n    TO = Object.keys(fO[Xb.GLOBAL]),\n    SO = [Xb.CHINA, Xb.NORTH_AMERICA, Xb.EUROPE, Xb.ASIA, Xb.JAPAN, Xb.INDIA, Xb.OCEANIA, Xb.SOUTH_AMERICA, Xb.AFRICA, Xb.KOREA, Xb.HKMC, Xb.US],\n    gO = function (e, t) {\n      let i = [];\n      if (Dn(e).call(e, Xb.GLOBAL)) {\n        const o = [Xb.GLOBAL, Xb.OVERSEA],\n          s = Object.keys($b);\n        if (t === Xb.GLOBAL) throw new bb(tI.INVALID_PARAMS, \"GLOBAL is an invalid excludedArea value\");\n        if (t === Xb.CHINA) i = [Xb.OVERSEA];else if (r = t, Dn(TO).call(TO, r)) {\n          const e = (n = t, fO[Xb.GLOBAL][n] || []),\n            r = [...o, t, ...e];\n          i = s.filter(e => !Dn(r).call(r, e));\n        } else if (function (e) {\n          let t = !1;\n          return TO.forEach(i => {\n            var n;\n            Dn(n = fO[Xb.GLOBAL][i]).call(n, e) && (t = !0);\n          }), t;\n        }(t)) {\n          const e = function (e) {\n              let t;\n              return TO.forEach(i => {\n                var n;\n                Dn(n = fO[Xb.GLOBAL][i]).call(n, e) && (t = i);\n              }), t;\n            }(t),\n            n = [...o, e, t];\n          i = s.filter(e => !Dn(n).call(n, e));\n        } else i = e;\n        i = function (e) {\n          const t = [];\n          return SO.forEach(i => {\n            Dn(e).call(e, i) && t.push(i);\n          }), t.concat(e.filter(e => !Dn(SO).call(SO, e)));\n        }(i);\n      } else i = e;\n      var n, r;\n      return i;\n    };\n  function RO(e) {\n    var t, i;\n    if (!e && Dn(t = Dy(\"AREAS\")).call(t, Xb.EXTENSIONS)) return Qy.debug(\"update area from ap : reset\"), void CO(sA, !0);\n    if (!Dn(i = Dy(\"AREAS\")).call(i, Xb.GLOBAL) || !e) return;\n    let n = $b.EXTENSIONS;\n    n && (n = {\n      CODE: EO(Xb.EXTENSIONS),\n      WEBCS_DOMAIN: [\"ap-web-1-\".concat(e, \".agora.io\")],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-\".concat(e, \".ap.sd-rtn.com\")],\n      PROXY_CS: [\"proxy-ap-web-\".concat(e, \".agora.io\")],\n      CDS_AP: [\"cds-ap-web-1-\".concat(e, \".agora.io\"), \"cds-ap-web-2-\".concat(e, \".ap.sd-rtn.com\")],\n      ACCOUNT_REGISTER: [\"sua-ap-web-1-\".concat(e, \".agora.io\"), \"sua-ap-web-2-\".concat(e, \".ap.sd-rtn.com\")],\n      UAP_AP: [\"uap-ap-web-1-\".concat(e, \".agora.io\"), \"uap-ap-web-2-\".concat(e, \".ap.sd-rtn.com\")],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-\".concat(e, \".agora.io\")],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-\".concat(e, \".agora.io\")],\n      LOG_UPLOAD_SERVER: [\"logservice-\".concat(e, \".agora.io\")],\n      PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy-\".concat(e, \".agora.io\")]\n    }, Qy.debug(\"update area from ap success: \".concat(e, \",config is \"), n), Ny(\"AREAS\", [Xb.EXTENSIONS], !0), Object.keys(n).map(e => {\n      if (\"LOG_UPLOAD_SERVER\" === e || \"EVENT_REPORT_DOMAIN\" === e || \"EVENT_REPORT_BACKUP_DOMAIN\" === e || \"PROXY_SERVER_TYPE3\" === e) {\n        Ny(e, n[e][0]);\n      } else Ny(e, n[e]);\n    }));\n  }\n  function CO(e) {\n    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n    const i = oA.reportApiInvoke(null, {\n      name: CI.SET_AREA,\n      options: e,\n      tag: vI.TRACER\n    });\n    try {\n      let n = [];\n      if (\"string\" == typeof e && (n = [e]), Array.isArray(e) && (e.forEach(e => {\n        if (!Dn(Qb).call(Qb, e)) throw new bb(tI.INVALID_PARAMS, \"invalid area code\");\n      }), n = e), \"[object Object]\" === Object.prototype.toString.call(e)) {\n        const t = e.areaCode,\n          i = e.excludedArea;\n        if (!t) throw new bb(tI.INVALID_PARAMS, \"area code is needed\");\n        let r = t;\n        \"string\" == typeof t && (r = [t]), n = i ? gO(r, i) : r;\n      }\n      if (!t) {\n        if (Py.AREAS) {\n          const e = new bb(tI.PROHIBITED_OPERATION, \"setArea is prohibited because of config-distribute\");\n          return i.onError(e), void Qy.warning(\"setArea is prohibited because of config-distribute\");\n        }\n        if (Dn(n).call(n, Xb.GLOBAL) && Dy(\"AREAS\") === Xb.EXTENSIONS) {\n          const e = new bb(tI.PROHIBITED_OPERATION, \"setArea is prohibited because of ap extensions\");\n          return i.onError(e), void Qy.warning(\"setArea is prohibited because of ap extensions\");\n        }\n      }\n      Ny(\"AREAS\", n, t);\n      const r = mO(n);\n      Object.keys(r).map(e => {\n        if (\"LOG_UPLOAD_SERVER\" === e || \"EVENT_REPORT_DOMAIN\" === e || \"EVENT_REPORT_BACKUP_DOMAIN\" === e || \"PROXY_SERVER_TYPE3\" === e) {\n          Ny(e, r[e][0]);\n        } else Ny(e, r[e]);\n      }), Qy.debug(\"set area success:\", n.join(\",\"));\n    } catch (e) {\n      throw i.onError(e), e;\n    }\n    i.onSuccess();\n  }\n  function vO(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function IO(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? vO(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : vO(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let yO = 1;\n  function AO(e, t, i, n, r) {\n    yO += 1;\n    const o = {\n        sid: i.sid,\n        command: \"convergeAllocateEdge\",\n        uid: \"666\",\n        appId: i.appId,\n        ts: Math.floor(Date.now() / 1e3),\n        seq: yO,\n        requestId: yO,\n        version: Iy,\n        cname: i.cname\n      },\n      s = {\n        service_name: t,\n        json_body: JSON.stringify(o)\n      };\n    let a,\n      c,\n      d = e[0];\n    return my(async () => {\n      a = Date.now();\n      const e = await pO(d, {\n        data: s,\n        cancelToken: n,\n        headers: {\n          \"X-Packet-Service-Type\": \"0\",\n          \"X-Packet-URI\": \"61\"\n        }\n      });\n      if (c = Date.now() - a, 0 !== e.code) {\n        const t = new bb(tI.UNEXPECTED_RESPONSE, \"live streaming ap error, code\" + e.code, {\n          retry: !0,\n          responseTime: c\n        });\n        throw Qy.error(t.toString()), t;\n      }\n      const i = JSON.parse(e.json_body);\n      if (200 !== i.code) {\n        const e = new bb(tI.UNEXPECTED_RESPONSE, \"live streaming app center error, code: \".concat(i.code, \", reason: \").concat(i.reason), {\n          code: i.code,\n          responseTime: c\n        });\n        throw Qy.error(e.toString()), e;\n      }\n      if (!i.servers || 0 === i.servers.length) {\n        const e = new bb(tI.UNEXPECTED_RESPONSE, \"live streaming app center empty server\", {\n          code: i.code,\n          responseTime: c\n        });\n        throw Qy.error(e.toString()), e;\n      }\n      const r = function (e, t) {\n        return {\n          addressList: e.servers.map(e => \"wss://\".concat(e.address.replace(/\\./g, \"-\"), \".\").concat(Dy(\"WORKER_DOMAIN\"), \":\").concat(e.wss, \"?serviceName=\").concat(encodeURIComponent(t))),\n          workerToken: e.workerToken,\n          vid: e.vid\n        };\n      }(i, t);\n      return Dy(\"LIVE_STREAMING_ADDRESS\") && (r.addressList = Dy(\"LIVE_STREAMING_ADDRESS\") instanceof Array ? Dy(\"LIVE_STREAMING_ADDRESS\") : [Dy(\"LIVE_STREAMING_ADDRESS\")]), IO(IO({}, r), {}, {\n        responseTime: c\n      });\n    }, (n, r) => (oA.apworkerEvent(i.sid, {\n      success: !0,\n      sc: 200,\n      serviceName: t,\n      responseDetail: JSON.stringify(n.addressList),\n      firstSuccess: 0 === r,\n      responseTime: c,\n      serverIp: e[r % e.length]\n    }), !1), (n, r) => (oA.apworkerEvent(i.sid, {\n      success: !1,\n      sc: n.data && n.data.code || 200,\n      serviceName: t,\n      responseTime: c,\n      serverIp: e[r % e.length]\n    }), !!(n.code !== tI.OPERATION_ABORTED && n.code !== tI.UNEXPECTED_RESPONSE || n.data && n.data.retry) && (d = e[(r + 1) % e.length], !0)), r);\n  }\n  let bO = 1;\n  function wO(e, t, i, n) {\n    let r = e.url,\n      o = e.areaCode;\n    const s = t.clientId,\n      a = t.sid,\n      c = Date.now();\n    let d;\n    const _LO = LO(t, o, [jw.CHOOSE_SERVER]),\n      _LO2 = _slicedToArray(_LO, 2),\n      l = _LO2[0],\n      h = _LO2[1];\n    let u = VI.networkState;\n    return my(async () => {\n      u && VI.networkState === PI.OFFLINE && VI.onlineWaiter && (await Gu.race([VI.onlineWaiter, $I(n && n.maxRetryTimeout || _y.maxRetryTimeout)])), u = VI.networkState;\n      const _await$pO = await pO(r, {\n          data: l,\n          cancelToken: i,\n          headers: {\n            \"Content-Type\": \"multipart/form-data;\"\n          }\n        }, !0, !0),\n        e = _await$pO.data,\n        o = _await$pO.headers;\n      d = \"1\" === o.http3 ? 1 : -1, oA.reportResourceTiming(r, a), NO(e, r, t, c, [jw.CHOOSE_SERVER], d);\n      const s = Jw(e, jw.CHOOSE_SERVER);\n      return DO(s), Kw(s, r);\n    }, e => (e && oA.joinChooseServer(a, {\n      lts: c,\n      succ: !0,\n      csAddr: r,\n      opid: h,\n      serverList: e.gatewayAddrs.map(e => e.address),\n      ec: null,\n      cid: e.cid.toString(),\n      uid: e.uid.toString(),\n      csIp: e.csIp,\n      unilbsServerIds: [jw.CHOOSE_SERVER].toString(),\n      isHttp3: d\n    }), !1), e => e.code !== tI.OPERATION_ABORTED && (e.code === tI.CAN_NOT_GET_GATEWAY_SERVER ? e.data.retry : (oA.joinChooseServer(a, {\n      lts: c,\n      succ: !1,\n      csAddr: r,\n      serverList: null,\n      opid: h,\n      ec: e.code,\n      csIp: e.data && e.data.csIp,\n      unilbsServerIds: [jw.CHOOSE_SERVER].toString(),\n      extend: JSON.stringify({\n        networkState: u\n      }),\n      isHttp3: d\n    }), Qy.warning(\"[\".concat(s || \"sid-\".concat(a.slice(0, 6)), \"] Choose server network error, retry\"), e), !0)), n);\n  }\n  function OO(e, t, i, n) {\n    let r,\n      o = e.url,\n      s = e.areaCode,\n      a = e.serviceIds;\n    const c = Date.now(),\n      _LO3 = LO(t, s, a),\n      _LO4 = _slicedToArray(_LO3, 2),\n      d = _LO4[0],\n      l = _LO4[1];\n    let h;\n    return my(async () => {\n      h && VI.networkState === PI.OFFLINE && VI.onlineWaiter && (await Gu.race([VI.onlineWaiter, $I(n && n.maxRetryTimeout || _y.maxRetryTimeout)])), h = VI.networkState;\n      const _await$pO2 = await pO(o, {\n          data: d,\n          cancelToken: i,\n          headers: {\n            \"Content-Type\": \"multipart/form-data;\"\n          }\n        }, !0, !0),\n        e = _await$pO2.data,\n        s = _await$pO2.headers;\n      r = \"1\" === s.http3 ? 1 : -1, oA.reportResourceTiming(o, t.sid), NO(e, o, t, c, a, r);\n      const l = Jw(e, jw.CHOOSE_SERVER),\n        u = Jw(e, \"proxy5\" === t.cloudProxyServer ? jw.CLOUD_PROXY_5 : \"proxy3\" === t.cloudProxyServer || \"proxy4\" === t.cloudProxyServer ? jw.CLOUD_PROXY : jw.CLOUD_PROXY_FALLBACK);\n      return DO(l), {\n        gatewayInfo: Kw(l, o),\n        proxyInfo: u,\n        url: o\n      };\n    }, e => (e.gatewayInfo && oA.joinChooseServer(t.sid, {\n      lts: c,\n      succ: !0,\n      csAddr: o,\n      serverList: e.gatewayInfo.gatewayAddrs.map(e => e.address),\n      ec: null,\n      opid: l,\n      cid: e.gatewayInfo.cid.toString(),\n      uid: e.gatewayInfo.uid.toString(),\n      csIp: e.gatewayInfo.csIp,\n      unilbsServerIds: a.toString(),\n      isHttp3: r\n    }), e.proxyInfo && oA.joinWebProxyAP(t.sid, {\n      lts: c,\n      sucess: 1,\n      apServerAddr: o,\n      turnServerAddrList: e.proxyInfo.addresses.map(e => e.ip).join(\",\"),\n      errorCode: null,\n      eventType: t.cloudProxyServer,\n      unilbsServerIds: a.toString()\n    }), !1), e => e.code !== tI.OPERATION_ABORTED && (e.code === tI.CAN_NOT_GET_GATEWAY_SERVER ? e.data.retry : (oA.joinWebProxyAP(t.sid, {\n      lts: c,\n      sucess: 0,\n      apServerAddr: o,\n      turnServerAddrList: null,\n      errorCode: e.code,\n      eventType: t.cloudProxyServer,\n      unilbsServerIds: a.toString(),\n      extend: JSON.stringify({\n        networkState: h\n      })\n    }), Qy.warning(\"[\".concat(t.clientId, \"] multi unilbs network error, retry\"), e), !0)), n);\n  }\n  const NO = (e, t, i, n, r, o) => {\n      const s = i.sid,\n        a = i.clientId,\n        c = i.cloudProxyServer,\n        d = [],\n        l = i => {\n          4096 === i.flag ? oA.joinChooseServer(s, {\n            lts: n,\n            succ: !1,\n            csAddr: t,\n            opid: e.opid,\n            serverList: null,\n            ec: i.error.message,\n            csIp: i.error.data && i.error.data.csIp,\n            unilbsServerIds: r.toString(),\n            isHttp3: o\n          }) : 1048576 !== i.flag && 4194304 !== i.flag && 4194310 !== i.flag || oA.joinWebProxyAP(s, {\n            lts: n,\n            sucess: 0,\n            apServerAddr: t,\n            turnServerAddrList: null,\n            errorCode: i.error.code,\n            eventType: c,\n            unilbsServerIds: r.toString()\n          });\n        };\n      if (e.response_body.forEach(t => {\n        const i = t.buffer.code;\n        if (23 === t.uri && 0 === i && !t.buffer.edges_services) if (4194310 === t.buffer.flag) Qy.warning(\"no edge services in ap response of proxy fallback, will not set proxy in iceServers\"), t.buffer.edges_services = [];else {\n          const i = {\n            error: new bb(tI.CAN_NOT_GET_GATEWAY_SERVER, \"no edge services in ap response\", {\n              retry: !0,\n              csIp: e.detail[502]\n            }),\n            flag: t.buffer.flag\n          };\n          d.push(i), l(i);\n        }\n        if (0 !== i) {\n          const n = vw(i),\n            r = {\n              error: new bb(tI.CAN_NOT_GET_GATEWAY_SERVER, n.desc, {\n                desc: n.desc,\n                retry: n.retry,\n                csIp: e.detail[502]\n              }),\n              flag: t.buffer.flag\n            };\n          4194310 === t.buffer.flag ? Qy.warning(r.error.toString()) : d.push(r), l(r);\n        }\n      }), d.length) throw Qy.warning(\"[\".concat(a || \"sid-\".concat(s.slice(0, 6)), \"] multi unilbs \").concat(t, \" failed, \").concat(d.map(e => \"flag: \".concat(e.flag, \", message: \").concat(e.error.message, \", retry: \").concat(e.error.data.retry)).join(\" | \"))), new bb(tI.CAN_NOT_GET_GATEWAY_SERVER, d.map(e => \"flag: \".concat(e.flag, \", message: \").concat(e.error.message)).join(\" | \"), {\n        retry: !!d.find(e => e.error.data.retry),\n        csIp: e.detail[502],\n        desc: [...new Set(d.map(e => {\n          var t;\n          return null == e || null === (t = e.error) || void 0 === t || null === (t = t.data) || void 0 === t ? void 0 : t.desc;\n        }).filter(e => !!e))]\n      });\n    },\n    DO = e => {\n      var t, i, n, r;\n      if (e.addresses && 0 === e.addresses.length && 0 === e.code) throw new bb(tI.CAN_NOT_GET_GATEWAY_SERVER, \"void gateway address\", {\n        retry: !0,\n        csIp: e.detail && e.detail[502]\n      });\n      Dy(\"AP_AREA\") && (null !== (n = e.detail) && void 0 !== n && n[23] && \"string\" == typeof (null === (r = e.detail) || void 0 === r ? void 0 : r[23]) ? RO(e.detail[23].toLowerCase()) : RO());\n      if (null !== (t = e.detail) && void 0 !== t && t[19] && \"string\" == typeof (null === (i = e.detail) || void 0 === i ? void 0 : i[19])) {\n        const t = e.detail[19],\n          i = null == t ? void 0 : t.split(\";\");\n        for (let t = 0; t < i.length; t++) {\n          var o;\n          const n = jp(o = i[t]).call(o);\n          e.addresses[t] && i && (e.addresses[t].fingerprint = n);\n        }\n      }\n      if (Dy(\"GATEWAY_ADDRESS\") && Dy(\"GATEWAY_ADDRESS\").length > 0) {\n        Qy.debug(\"assign gateway address to\", Dy(\"GATEWAY_ADDRESS\"));\n        const t = Dy(\"GATEWAY_ADDRESS\").map(t => {\n          var i, n;\n          const r = null !== (i = null === (n = e.addresses.find(e => e.ip === t.ip && e.port === t.port)) || void 0 === n ? void 0 : n.fingerprint) && void 0 !== i ? i : \"\";\n          return {\n            ip: t.ip,\n            port: t.port,\n            ticket: e.addresses[0] && e.addresses[0].ticket,\n            fingerprint: r\n          };\n        });\n        e.addresses = t;\n      }\n    },\n    PO = (e, t) => {\n      if (e.response_body && e.response_body.length) {\n        const t = e.response_body[0];\n        if (0 !== t.buffer.code) {\n          const e = vw(t.buffer.code);\n          throw new bb(tI.UPDATE_TICKET_FAILED, \"[\".concat(t.buffer.code, \"]: \").concat(e.desc), {\n            retry: e.retry\n          });\n        }\n        return t.buffer.ticket;\n      }\n      throw Qy.debug(\"update ticket request received ap response without response body:\", t), new bb(tI.UPDATE_TICKET_FAILED, \"cannot find response body from ap response\", {\n        retry: !1\n      });\n    },\n    LO = (e, t, i) => {\n      const n = Math.floor(Math.random() * 10 ** 12),\n        r = {\n          appid: e.appId,\n          client_ts: Date.now(),\n          opid: n,\n          sid: e.sid,\n          request_bodies: [{\n            uri: 22,\n            buffer: {\n              cname: e.cname,\n              detail: IO({\n                6: e.stringUid,\n                11: t,\n                12: Dy(\"USE_NEW_TOKEN\") ? \"1\" : void 0,\n                22: t\n              }, e.apRTM ? {\n                26: \"RTM2\"\n              } : {}),\n              key: e.token,\n              service_ids: i,\n              uid: e.uid || 0\n            }\n          }]\n        };\n      r.request_bodies.forEach(t => {\n        e.multiIP && e.multiIP.gateway_ip && (t.buffer.detail[5] = JSON.stringify({\n          vocs_ip: [e.multiIP.uni_lbs_ip],\n          vos_ip: [e.multiIP.gateway_ip]\n        }));\n      });\n      const o = new FormData();\n      return o.append(\"request\", JSON.stringify(r)), [o, n];\n    },\n    kO = (e, t) => {\n      const i = Math.floor(Math.random() * 10 ** 12),\n        n = {\n          appid: e.appId,\n          client_ts: Date.now(),\n          opid: i,\n          sid: e.sid,\n          request_bodies: [{\n            uri: 28,\n            buffer: {\n              cname: e.cname,\n              detail: {\n                1: \"\",\n                6: e.stringUid,\n                12: \"1\"\n              },\n              token: e.token,\n              service_ids: t,\n              uid: e.uid || 0,\n              edges_services: e.apResponse.addresses.map(e => ({\n                ip: e.ip,\n                port: e.port\n              }))\n            }\n          }]\n        },\n        r = new FormData();\n      return r.append(\"request\", JSON.stringify(n)), [r, i];\n    };\n  let MO = 0;\n  function UO(e) {\n    return Gu.all(e.map(e => e.then(e => {\n      throw e;\n    }, e => e))).then(e => {\n      throw e;\n    }, e => e);\n  }\n  const xO = async e => {\n      let t = e.fragementLength,\n        i = e.referenceList,\n        n = e.asyncMapHandler,\n        r = e.allFailedhandler,\n        o = e.promisesCollector,\n        s = 0;\n      const a = t;\n      let c,\n        d = 0;\n      const l = async () => {\n        const e = (() => {\n          const e = s * a,\n            t = e + a;\n          return i.slice(e, t).map(n);\n        })();\n        o && o.push(...e);\n        try {\n          c = await UO(e);\n        } catch (e) {\n          if (d += a, s++, !(d >= i.length)) return void (await l());\n          r(e);\n        }\n        e.forEach(e => e.cancel());\n      };\n      return await l(), c;\n    },\n    VO = async e => {\n      let t = e.referenceList,\n        i = e.asyncMapHandler,\n        n = e.closeFn;\n      const r = t.length;\n      let o = 0;\n      const s = async () => {\n        const e = i(t.shift());\n        try {\n          return await e;\n        } catch (e) {\n          if (o++, o >= r || null != n && n(e)) throw e;\n          return s();\n        }\n      };\n      return s();\n    };\n  async function FO(e, t, i, n) {\n    const r = async function (e, t, i, n) {\n      let r = null;\n      const o = [],\n        s = async () => {\n          const r = Dy(\"WEBCS_DOMAIN\").slice(0, Dy(\"AJAX_REQUEST_CONCURRENT\")).map(t => ({\n              url: e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v2/transpond/webrtc?v=2\") : \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\"),\n              areaCode: _O()\n            })),\n            s = n.recordJoinChannelService({\n              startTs: Date.now(),\n              status: \"pending\",\n              service: \"chooseServer\",\n              urls: r.map(e => e.url)\n            }),\n            a = await xO({\n              fragementLength: Dy(\"FRAGEMENT_LENGTH\"),\n              referenceList: r,\n              asyncMapHandler: n => (Qy.debug(\"[\".concat(e.clientId, \"] Connect to choose_server:\"), n.url), wO(n, e, t, i)),\n              allFailedhandler: e => {\n                throw n.recordJoinChannelService({\n                  endTs: Date.now(),\n                  status: \"error\",\n                  errors: e\n                }, s), e[0];\n              },\n              promisesCollector: o\n            });\n          return n.recordJoinChannelService({\n            endTs: Date.now(),\n            status: \"success\"\n          }, s), a;\n        },\n        a = async () => {\n          if (await $I(1e3), null !== r) return r;\n          const s = Dy(\"WEBCS_DOMAIN_BACKUP_LIST\").map(t => ({\n              url: e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v2/transpond/webrtc?v=2\") : \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\"),\n              areaCode: _O()\n            })),\n            a = n.recordJoinChannelService({\n              endTs: void 0,\n              startTs: Date.now(),\n              status: \"pending\",\n              service: \"chooseServer\",\n              urls: s.map(e => e.url)\n            }),\n            c = await xO({\n              fragementLength: Dy(\"FRAGEMENT_LENGTH\"),\n              referenceList: s,\n              asyncMapHandler: n => (Qy.debug(\"[\".concat(e.clientId, \"] Connect to backup choose_server:\"), n.url), wO(n, e, t, i)),\n              allFailedhandler: e => {\n                throw n.recordJoinChannelService({\n                  endTs: Date.now(),\n                  status: \"error\",\n                  errors: e\n                }, a), e[0];\n              },\n              promisesCollector: o\n            });\n          return n.recordJoinChannelService({\n            endTs: Date.now(),\n            status: \"success\"\n          }, a), c;\n        };\n      try {\n        return r = await UO([s(), a()]), o.length && o.forEach(e => e.cancel && \"function\" == typeof e.cancel && e.cancel()), r;\n      } catch (e) {\n        throw e[0];\n      }\n    }(e, t, i, n);\n    return {\n      gatewayInfo: await r\n    };\n  }\n  async function BO(e, t, i, n, r) {\n    const o = e.cloudProxyServer;\n    if (\"disabled\" === o) {\n      if (!n) return;\n      if (e.useLocalAccessPoint) return await FO(e, t, i, r);\n      if (Dy(\"JOIN_WITH_FALLBACK_MEDIA_PROXY\")) {\n        const _await$KO = await KO(e, t, i, r),\n          n = _await$KO.gatewayInfo,\n          o = _await$KO.proxyInfo;\n        if (e.turnServer && \"auto\" !== e.turnServer.mode) return {\n          gatewayInfo: n\n        };\n        const a = o.map(e => ({\n          turnServerURL: e.address,\n          tcpport: e.tcpport || aA.tcpport,\n          udpport: e.udpport || aA.udpport,\n          username: e.username || aA.username,\n          password: e.password || aA.password,\n          forceturn: !1,\n          security: !0\n        }));\n        if (r.useP2P) {\n          var s;\n          const t = null !== (s = e.uid) && void 0 !== s ? s : n.uid,\n            i = \"glb:\".concat(t.toString()),\n            r = await TI(i),\n            c = o.map(e => ({\n              turnServerURL: e.address,\n              tcpport: e.tcpport || aA.tcpport,\n              udpport: e.udpport || aA.udpport,\n              username: i,\n              password: r,\n              forceturn: !1,\n              security: !0\n            }));\n          a.push(...c);\n        }\n        return e.turnServer = {\n          mode: \"manual\",\n          servers: a\n        }, {\n          gatewayInfo: n\n        };\n      }\n      return await FO(e, t, i, r);\n    }\n    const _await$KO2 = await KO(e, t, i, r),\n      a = _await$KO2.proxyInfo,\n      c = _await$KO2.gatewayInfo,\n      d = {\n        gatewayInfo: c\n      },\n      l = a.map(e => ({\n        turnServerURL: e.address,\n        tcpport: \"proxy3\" === o ? void 0 : e.tcpport ? e.tcpport : aA.tcpport,\n        udpport: \"proxy4\" === o ? void 0 : e.udpport ? e.udpport : aA.udpport,\n        username: e.username || aA.username,\n        password: e.password || aA.password,\n        forceturn: \"proxy4\" !== o,\n        security: \"proxy5\" === o\n      }));\n    if (r.useP2P) {\n      var h;\n      const t = null !== (h = e.uid) && void 0 !== h ? h : c.uid,\n        i = \"glb:\".concat(t.toString()),\n        n = await TI(i),\n        r = a.map(e => ({\n          turnServerURL: e.address,\n          tcpport: \"proxy3\" === o ? void 0 : e.tcpport || aA.tcpport,\n          udpport: \"proxy4\" === o ? void 0 : e.udpport || aA.udpport,\n          username: i,\n          password: n,\n          forceturn: \"proxy4\" !== o,\n          security: \"proxy5\" === o\n        }));\n      l.push(...r);\n    }\n    return e.turnServer = {\n      mode: \"manual\",\n      servers: l\n    }, Qy.debug(\"[\".concat(e.clientId, \"] set proxy server: \").concat(e.proxyServer, \", mode: \").concat(o)), d;\n  }\n  async function jO(e, t, i, n, r) {\n    const o = Dy(\"ACCOUNT_REGISTER\").slice(0, Dy(\"AJAX_REQUEST_CONCURRENT\"));\n    let s = [];\n    s = t.proxyServer ? o.map(e => \"https://\".concat(t.proxyServer, \"/ap/?url=\").concat(e + \"/api/v1\")) : o.map(e => \"https://\".concat(e, \"/api/v1\"));\n    const a = null == r ? void 0 : r.recordJoinChannelService({\n      startTs: Date.now(),\n      status: \"pending\",\n      service: \"stringUID\",\n      urls: s\n    });\n    try {\n      const o = await async function (e, t, i, n, r) {\n        const o = Date.now(),\n          s = {\n            sid: i.sid,\n            opid: 10,\n            appid: i.appId,\n            string_uid: t\n          };\n        let a = e[0];\n        const c = await my(() => pO(a + \"\".concat(-1 === a.indexOf(\"?\") ? \"?\" : \"&\", \"action=stringuid\"), {\n          data: s,\n          cancelToken: n,\n          headers: {\n            \"X-Packet-Service-Type\": 0,\n            \"X-Packet-URI\": 72\n          }\n        }), (i, n) => {\n          if (0 === i.code) {\n            if (i.uid <= 0 || i.uid >= Math.pow(2, 32)) throw Qy.error(\"Invalid Uint Uid \".concat(t, \" => \").concat(i.uid), i), oA.reqUserAccount(s.sid, {\n              lts: o,\n              success: !1,\n              serverAddr: a,\n              stringUid: s.string_uid,\n              uid: i.uid,\n              errorCode: tI.INVALID_UINT_UID_FROM_STRING_UID,\n              extend: s\n            }), new bb(tI.INVALID_UINT_UID_FROM_STRING_UID);\n            return oA.reqUserAccount(s.sid, {\n              lts: o,\n              success: !0,\n              serverAddr: a,\n              stringUid: s.string_uid,\n              uid: i.uid,\n              errorCode: null,\n              extend: s\n            }), !1;\n          }\n          const r = vw(i.code);\n          return r.retry && (a = e[(n + 1) % e.length]), oA.reqUserAccount(s.sid, {\n            lts: o,\n            success: !1,\n            serverAddr: a,\n            stringUid: s.string_uid,\n            uid: i.uid,\n            errorCode: r.desc,\n            extend: s\n          }), r.retry;\n        }, (t, i) => t.code !== tI.OPERATION_ABORTED && (oA.reqUserAccount(s.sid, {\n          lts: o,\n          success: !1,\n          serverAddr: a,\n          stringUid: s.string_uid,\n          uid: null,\n          errorCode: t.code,\n          extend: s\n        }), a = e[(i + 1) % e.length], !0), r);\n        if (0 !== c.code) {\n          const e = vw(c.code);\n          throw new bb(tI.UNEXPECTED_RESPONSE, e.desc);\n        }\n        return c;\n      }(s, e, t, i, n);\n      return null == r || r.recordJoinChannelService({\n        status: \"success\",\n        endTs: Date.now()\n      }, a), o.uid;\n    } catch (e) {\n      throw null == r || r.recordJoinChannelService({\n        status: \"error\",\n        endTs: Date.now(),\n        errors: [e]\n      }, a), e;\n    }\n  }\n  async function GO(e, t, i) {\n    const n = Dy(\"ACCOUNT_REGISTER\");\n    let r = [];\n    r = t.proxyServer ? n.map(e => \"https://\".concat(t.proxyServer, \"/ap/?url=\").concat(e + \"/api/v1\")) : n.map(e => \"https://\".concat(e, \"/api/v1\"));\n    try {\n      const n = await VO({\n        referenceList: r,\n        asyncMapHandler: n => async function (e, t, i, n) {\n          const r = Date.now(),\n            o = {\n              sid: i.sid,\n              opid: 10,\n              appid: i.appId,\n              string_uid: t\n            };\n          try {\n            const t = await pO(e + \"\".concat(-1 === e.indexOf(\"?\") ? \"?\" : \"&\", \"action=stringuid\"), {\n              data: o,\n              cancelToken: n,\n              headers: {\n                \"X-Packet-Service-Type\": 0,\n                \"X-Packet-URI\": 72\n              }\n            });\n            if (0 !== t.code) {\n              const e = vw(t.code);\n              throw new bb(tI.UNEXPECTED_RESPONSE, \"preload sua error:\".concat(e.desc), e);\n            }\n            if (t.uid <= 0 || t.uid >= Math.pow(2, 32)) throw new bb(tI.INVALID_UINT_UID_FROM_STRING_UID);\n            return {\n              requestTime: r,\n              url: e,\n              req: o,\n              uid: t.uid,\n              elapse: Date.now() - r\n            };\n          } catch (e) {\n            throw e;\n          }\n        }(n, e, t, i),\n        closeFn: e => e.code === tI.OPERATION_ABORTED || e.code === tI.UNEXPECTED_RESPONSE && !e.data.retry\n      });\n      return n;\n    } catch (e) {\n      throw e;\n    }\n  }\n  async function WO(e, t, i) {\n    const n = Dy(\"CDS_AP\").slice(0, Dy(\"AJAX_REQUEST_CONCURRENT\")).map(t => e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v1\") : \"https://\".concat(t, \"/api/v1?action=config\")),\n      r = n.map(n => function (e, t, i, n) {\n        const r = Iv(),\n          o = {\n            flag: 64,\n            cipher_method: 0,\n            features: {\n              device: r.name,\n              system: r.os,\n              system_general: navigator.userAgent,\n              vendor: t.appId,\n              version: Iy,\n              cname: t.cname,\n              sid: t.sid,\n              session_id: t.sid,\n              detail: \"\",\n              proxyServer: t.proxyServer\n            }\n          };\n        return my(() => pO(e, {\n          data: o,\n          timeout: 1e3,\n          cancelToken: i,\n          headers: {\n            \"X-Packet-Service-Type\": 0,\n            \"X-Packet-URI\": 54\n          }\n        }), void 0, e => e.code !== tI.OPERATION_ABORTED, n);\n      }(n, e, t, i));\n    let o = null,\n      s = null,\n      a = {};\n    try {\n      o = await UO(r);\n    } catch (e) {\n      if (e.code === tI.OPERATION_ABORTED) throw e;\n      s = e;\n    }\n    r.forEach(e => e.cancel());\n    if (oA.reportApiInvoke(e.sid, {\n      name: CI.REQUEST_CONFIG_DISTRIBUTE,\n      options: {\n        error: s,\n        res: o\n      }\n    }).onSuccess(), o && o.test_tags) try {\n      a = function (e) {\n        if (!e.test_tags) return {};\n        const t = e.test_tags,\n          i = Object.keys(t),\n          n = {};\n        return i.forEach(e => {\n          var i;\n          const r = jp(i = e.slice(4)).call(i),\n            o = JSON.parse(t[e])[1];\n          n[r] = o;\n        }), n;\n      }(o);\n    } catch (e) {}\n    return a;\n  }\n  async function HO(e, t) {\n    const i = Dy(\"WEBCS_DOMAIN\").concat(Dy(\"WEBCS_DOMAIN_BACKUP_LIST\")).map(e => ({\n      url: \"https://\".concat(e, \"/api/v2/transpond/webrtc?v=2\"),\n      areaCode: _O(),\n      serviceIds: [jw.CHOOSE_SERVER, jw.CLOUD_PROXY_FALLBACK]\n    }));\n    try {\n      const n = await VO({\n        referenceList: i,\n        asyncMapHandler: i => async function (e, t, i) {\n          let n,\n            r = e.url,\n            o = e.areaCode,\n            s = e.serviceIds;\n          const a = Date.now(),\n            _LO5 = LO(t, o, s),\n            _LO6 = _slicedToArray(_LO5, 2),\n            c = _LO6[0],\n            d = _LO6[1];\n          let l = VI.networkState;\n          try {\n            l && VI.networkState === PI.OFFLINE && VI.onlineWaiter && (await Gu.race([VI.onlineWaiter, $I(_y.maxRetryTimeout)])), l = VI.networkState;\n            const _await$pO3 = await pO(r, {\n                data: c,\n                cancelToken: i,\n                headers: {\n                  \"Content-Type\": \"multipart/form-data;\"\n                }\n              }, !0, !0),\n              e = _await$pO3.data,\n              t = _await$pO3.headers;\n            n = \"1\" === t.http3 ? 1 : -1;\n            const o = e => {\n              const t = [];\n              if (e.response_body.forEach(i => {\n                const n = i.buffer.code;\n                if (23 === i.uri && 0 === n && !i.buffer.edges_services) if (4194310 === i.buffer.flag) i.buffer.edges_services = [];else {\n                  const n = {\n                    error: new bb(tI.CAN_NOT_GET_GATEWAY_SERVER, \"no edge services in ap response\", {\n                      retry: !0,\n                      csIp: e.detail[502]\n                    }),\n                    flag: i.buffer.flag\n                  };\n                  t.push(n);\n                }\n                if (0 !== n) {\n                  const r = vw(n),\n                    o = {\n                      error: new bb(tI.CAN_NOT_GET_GATEWAY_SERVER, r.desc, {\n                        desc: r.desc,\n                        retry: r.retry,\n                        csIp: e.detail[502]\n                      }),\n                      flag: i.buffer.flag\n                    };\n                  4194310 === i.buffer.flag ? Qy.warning(o.error.toString()) : t.push(o);\n                }\n              }), t.length) throw new bb(tI.CAN_NOT_GET_GATEWAY_SERVER, t.map(e => \"flag: \".concat(e.flag, \", message: \").concat(e.error.message)).join(\" | \"), {\n                retry: !!t.find(e => e.error.data.retry),\n                csIp: e.detail[502],\n                desc: [...new Set(t.map(e => {\n                  var t;\n                  return null == e || null === (t = e.error) || void 0 === t || null === (t = t.data) || void 0 === t ? void 0 : t.desc;\n                }).filter(e => !!e))]\n              });\n            };\n            o(e);\n            const s = Jw(e, jw.CHOOSE_SERVER),\n              h = Jw(e, jw.CLOUD_PROXY_FALLBACK);\n            return DO(s), {\n              gatewayInfo: Kw(s, r),\n              proxyInfo: h,\n              opid: d,\n              requestTime: a,\n              url: r,\n              isHttp3: n,\n              elapse: Date.now() - a\n            };\n          } catch (e) {\n            throw e;\n          }\n        }(i, e, t),\n        closeFn: e => e.code === tI.OPERATION_ABORTED || e.code === tI.CAN_NOT_GET_GATEWAY_SERVER && !e.data.retry\n      });\n      return n;\n    } catch (e) {\n      throw e;\n    }\n  }\n  async function KO(e, t, i, n) {\n    const r = Dy(\"PROXY_SERVER_TYPE3\"),\n      o = (e, t, i) => {\n        let n = i || r;\n        return Array.isArray(n) && (n = t % 2 == 0 ? r[1] : r[0]), \"https://\".concat(n, \"/ap/?url=\").concat(e);\n      };\n    let s = null;\n    const a = [],\n      c = async () => {\n        const r = Dy(\"WEBCS_DOMAIN\").slice(0, Dy(\"AJAX_REQUEST_CONCURRENT\")).map((t, i) => {\n            let n;\n            return n = \"disabled\" === e.cloudProxyServer && e.proxyServer ? o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i, e.proxyServer) : \"disabled\" === e.cloudProxyServer || \"fallback\" === e.cloudProxyServer ? \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\") : o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i), {\n              url: n,\n              areaCode: _O(),\n              serviceIds: [jw.CHOOSE_SERVER, \"proxy5\" === e.cloudProxyServer ? jw.CLOUD_PROXY_5 : \"proxy3\" === e.cloudProxyServer || \"proxy4\" === e.cloudProxyServer ? jw.CLOUD_PROXY : jw.CLOUD_PROXY_FALLBACK]\n            };\n          }),\n          s = n.recordJoinChannelService({\n            startTs: Date.now(),\n            status: \"pending\",\n            service: \"chooseServer\",\n            urls: r.map(e => e.url)\n          }),\n          c = await xO({\n            fragementLength: Dy(\"FRAGEMENT_LENGTH\"),\n            referenceList: r,\n            asyncMapHandler: n => (Qy.debug(\"[\".concat(e.clientId, \"] Connect to choose_server:\"), n.url), OO(n, e, t, i)),\n            allFailedhandler: e => {\n              throw n.recordJoinChannelService({\n                endTs: Date.now(),\n                status: \"error\",\n                errors: e\n              }, s), e[0];\n            },\n            promisesCollector: a\n          });\n        return n.recordJoinChannelService({\n          endTs: Date.now(),\n          status: \"success\"\n        }, s), c;\n      },\n      d = async () => {\n        if (await $I(1e3), null !== s) return s;\n        const r = Dy(\"WEBCS_DOMAIN_BACKUP_LIST\").map((t, i) => {\n            let n;\n            return n = \"disabled\" === e.cloudProxyServer && e.proxyServer ? o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i, e.proxyServer) : \"disabled\" === e.cloudProxyServer || \"fallback\" === e.cloudProxyServer ? \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\") : o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i), {\n              url: n,\n              areaCode: _O(),\n              serviceIds: [jw.CHOOSE_SERVER, \"proxy5\" === e.cloudProxyServer ? jw.CLOUD_PROXY_5 : \"proxy3\" === e.cloudProxyServer || \"proxy4\" === e.cloudProxyServer ? jw.CLOUD_PROXY : jw.CLOUD_PROXY_FALLBACK]\n            };\n          }),\n          c = n.recordJoinChannelService({\n            startTs: Date.now(),\n            status: \"pending\",\n            service: \"chooseServer\",\n            urls: r.map(e => e.url)\n          }),\n          d = await xO({\n            fragementLength: Dy(\"FRAGEMENT_LENGTH\"),\n            referenceList: r,\n            asyncMapHandler: n => (Qy.debug(\"[\".concat(e.clientId, \"] Connect to backup choose_server:\"), n.url), OO(n, e, t, i)),\n            allFailedhandler: e => {\n              throw n.recordJoinChannelService({\n                endTs: Date.now(),\n                status: \"error\",\n                errors: e\n              }, c), e[0];\n            },\n            promisesCollector: a\n          });\n        return n.recordJoinChannelService({\n          endTs: Date.now(),\n          status: \"success\"\n        }, c), d;\n      };\n    let l, h, u;\n    try {\n      var _await$UO = await UO([c(), d()]);\n      l = _await$UO.gatewayInfo;\n      h = _await$UO.proxyInfo;\n      u = _await$UO.url;\n    } catch (e) {\n      throw e[0];\n    }\n    if (a.length && a.forEach(e => e.cancel && \"function\" == typeof e.cancel && e.cancel()), !l || !h) throw new bb(tI.UNEXPECTED_ERROR, \"missing gateway or proxy response\").print();\n    if (e.apUrl = u, \"disabled\" !== e.cloudProxyServer && Array.isArray(r) && u) {\n      const t = /^https?:\\/\\/(.+?)(\\/.*)?$/.exec(u)[1];\n      Dn(r).call(r, t) && (e.proxyServer = t, Qy.setProxyServer(t), oA.setProxyServer(t));\n    }\n    return s = {\n      gatewayInfo: l,\n      proxyInfo: await Xw(h, l.uid)\n    }, s;\n  }\n  async function YO(e, t, i, n) {\n    const r = Dy(\"UAP_AP\").slice(0, Dy(\"AJAX_REQUEST_CONCURRENT\")).map(e => t.proxyServer ? \"https://\".concat(t.proxyServer, \"/ap/?url=\").concat(e + \"/api/v1?action=uap\") : \"https://\".concat(e, \"/api/v1?action=uap\"));\n    return await AO(r, e, t, i, n);\n  }\n  async function qO(e, t, i) {\n    const n = Dy(\"UAP_AP\").slice(0, Dy(\"AJAX_REQUEST_CONCURRENT\")).map(t => e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v1?action=uap\") : \"https://\".concat(t, \"/api/v1?action=uap\")),\n      r = n.map(n => function (e, t, i, n) {\n        const r = {\n          command: \"convergeAllocateEdge\",\n          sid: t.sid,\n          appId: t.appId,\n          token: t.token,\n          ts: Date.now(),\n          version: Iy,\n          cname: t.cname,\n          uid: t.uid.toString(),\n          requestId: bO,\n          seq: bO\n        };\n        bO += 1;\n        const o = {\n          service_name: \"tele_channel\",\n          json_body: JSON.stringify(r)\n        };\n        return my(async () => {\n          const t = await pO(e, {\n            data: o,\n            cancelToken: i,\n            headers: {\n              \"X-Packet-Service-Type\": 0,\n              \"X-Packet-URI\": 61\n            }\n          });\n          if (0 !== t.code) {\n            const e = new bb(tI.UNEXPECTED_RESPONSE, \"cross channel ap error, code\" + t.code, {\n              retry: !0\n            });\n            throw Qy.error(e.toString()), e;\n          }\n          const n = JSON.parse(t.json_body);\n          if (200 !== n.code) {\n            const e = new bb(tI.UNEXPECTED_RESPONSE, \"cross channel app center error, code: \".concat(n.code, \", reason: \").concat(n.reason));\n            throw Qy.error(e.toString()), e;\n          }\n          if (!n.servers || 0 === n.servers.length) {\n            const e = new bb(tI.UNEXPECTED_RESPONSE, \"cross channel app center empty server\");\n            throw Qy.error(e.toString()), e;\n          }\n          return {\n            vid: n.vid,\n            workerToken: n.workerToken,\n            addressList: (Dy(\"CHANNEL_MEDIA_RELAY_SERVERS\") || n.servers).map(e => \"wss://\".concat(e.address.replace(/\\./g, \"-\"), \".\").concat(Dy(\"WORKER_DOMAIN\"), \":\").concat(e.wss))\n          };\n        }, void 0, e => !!(e.code !== tI.OPERATION_ABORTED && e.code !== tI.UNEXPECTED_RESPONSE || e.data && e.data.retry), n);\n      }(n, e, t, i));\n    try {\n      const e = await UO(r);\n      return r.forEach(e => e.cancel()), e;\n    } catch (e) {\n      throw e[0];\n    }\n  }\n  async function zO(e, t, i) {\n    let n = null;\n    const r = [],\n      o = async o => {\n        const s = Dy(o ? \"WEBCS_DOMAIN_BACKUP_LIST\" : \"WEBCS_DOMAIN\").map(t => e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v2/transpond/webrtc?v=2\") : \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\"));\n        return o && (await $I(1e3), null !== n) ? n : await xO({\n          fragementLength: Dy(\"FRAGEMENT_LENGTH\"),\n          referenceList: s,\n          asyncMapHandler: n => (Qy.debug(\"[\".concat(e.clientId, \"] update ticket, Connect to \").concat(o ? \"backup\" : \"\", \" choose_server:\"), n), function (e, t, i, n) {\n            const _kO = kO(t, [jw.CHOOSE_SERVER]),\n              _kO2 = _slicedToArray(_kO, 1),\n              r = _kO2[0];\n            let o = VI.networkState;\n            return my(async () => {\n              o && VI.networkState === PI.OFFLINE && VI.onlineWaiter && (await Gu.race([VI.onlineWaiter, $I(n && n.maxRetryTimeout || _y.maxRetryTimeout)])), o = VI.networkState;\n              const t = await pO(e, {\n                data: r,\n                cancelToken: i,\n                headers: {\n                  \"Content-Type\": \"multipart/form-data;\"\n                }\n              }, !0);\n              return PO(t, e);\n            }, () => !1, e => e.code !== tI.OPERATION_ABORTED && (e.code === tI.UPDATE_TICKET_FAILED ? e.data.retry : (Qy.warning(\"[\".concat(t.clientId, \"] update ticket network error, retry\"), e), !0)), n);\n          }(n, e, t, i)),\n          allFailedhandler: e => {\n            throw e[0];\n          },\n          promisesCollector: r\n        });\n      };\n    try {\n      return n = await UO([o(!1), o(!0)]), r.length && r.forEach(e => e.cancel && \"function\" == typeof e.cancel && e.cancel()), n;\n    } catch (e) {\n      throw e[0];\n    }\n  }\n  function JO(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function XO(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? JO(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : JO(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class QO extends SI {\n    get isSuccess() {\n      return !!this.configs;\n    }\n    constructor() {\n      super(), ng(this, \"configs\", void 0), ng(this, \"joinInfo\", void 0), ng(this, \"cancelToken\", void 0), ng(this, \"retryConfig\", {\n        timeout: 3e3,\n        timeoutFactor: 1.5,\n        maxRetryCount: 1,\n        maxRetryTimeout: 1e4\n      }), ng(this, \"interval\", void 0), ng(this, \"mutex\", new uy(\"config-distribute\")), ng(this, \"mutableParamsRead\", !1);\n    }\n    startGetConfigDistribute(e, t) {\n      this.joinInfo = e, this.cancelToken = t, this.interval && this.stopGetConfigDistribute(), Dy(\"ENABLE_CONFIG_DISTRIBUTE\") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {\n        this.updateConfigDistribute();\n      }, Dy(\"CONFIG_DISTRIBUTE_INTERVAL\")));\n    }\n    stopGetConfigDistribute() {\n      this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;\n    }\n    async awaitConfigDistributeComplete() {\n      if (!this.mutex.isLocked) return;\n      (await this.mutex.lock())();\n    }\n    async updateConfigDistribute() {\n      if (!this.mutableParamsRead) {\n        this.mutableParamsRead = !0;\n        oA.reportApiInvoke(null, {\n          options: void 0,\n          name: CI.LOAD_CONFIG_FROM_LOCALSTORAGE,\n          tag: vI.TRACER\n        }).onSuccess(JSON.stringify(Py));\n      }\n      if (!this.joinInfo || !this.cancelToken || !this.retryConfig) return void Qy.debug(\"[config-distribute] get config distribute interrupted have no joininfo\");\n      let e;\n      const t = await this.mutex.lock();\n      try {\n        e = await WO(this.joinInfo, this.cancelToken, this.retryConfig), Qy.debug(\"[config-distribute] get config distribute\", JSON.stringify(e)), e.limit_bitrate && this.handleBitrateLimit(e.limit_bitrate), this.cacheGlobalParameterConfig(e), this.configs = e;\n      } catch (e) {\n        const t = new bb(tI.NETWORK_RESPONSE_ERROR, e);\n        Qy.warning(\"[config-distribute] \".concat(t.toString()));\n      } finally {\n        t();\n      }\n    }\n    getBitrateLimit() {\n      return this.configs ? this.configs.limit_bitrate : void 0;\n    }\n    handleBitrateLimit(e) {\n      var t;\n      (t = e) && t.uplink && t.id && void 0 !== t.uplink.max_bitrate && void 0 !== t.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e.id && this.emit(ew.UPDATE_BITRATE_LIMIT, e) : this.emit(ew.UPDATE_BITRATE_LIMIT, e));\n    }\n    getLowStreamConfigDistribute() {\n      return this.configs && this.configs.limit_bitrate && XO({}, this.configs.limit_bitrate.low_stream_uplink);\n    }\n    cacheGlobalParameterConfig(e) {\n      var t;\n      const i = oE(t = Object.keys(e).filter(e => /^webrtc_ng_global_parameter/.test(e))).call(t);\n      for (let t = 0; t < i.length; t++) for (let n = i.length - 1; n > t; n--) {\n        const t = i[n];\n        if (\"number\" == typeof e[t].__priority) {\n          const r = e[t].__priority,\n            o = i[n - 1];\n          if (\"number\" == typeof e[o].__priority) {\n            if (!(r > e[o].__priority)) continue;\n            {\n              const e = t;\n              i[n] = i[n - 1], i[n - 1] = e;\n            }\n          } else {\n            const e = t;\n            i[n] = i[n - 1], i[n - 1] = e;\n          }\n        }\n      }\n      const n = {};\n      i.forEach(t => {\n        const i = e[t],\n          r = i.__expires;\n        Object.keys(i).forEach(e => {\n          \"__priority\" === e || \"__expires\" === e || Object.prototype.hasOwnProperty.call(n, e) || (n[e] = XO({\n            value: i[e]\n          }, r && {\n            expires: r\n          }));\n        });\n      });\n      try {\n        !function (e) {\n          try {\n            const t = Date.now();\n            Object.keys(e).forEach(i => {\n              switch (i) {\n                case \"ENABLE_EVENT_REPORT\":\n                case \"UPLOAD_LOG\":\n                case \"ENABLE_AG_ADAPTATION\":\n                case \"FORCE_AG_HIGH_FRAMERATE\":\n                case \"FORCE_SUPPORT_AG_ADAPTATION\":\n                case \"ENCODER_CONFIG_LIMIT\":\n                case \"CAMERA_CAPTURE_CONFIG\":\n                case \"ENABLE_PRELOAD\":\n                  if (Object.prototype.hasOwnProperty.call(Oy, i)) {\n                    const _e$i = e[i],\n                      n = _e$i.value,\n                      r = _e$i.expires;\n                    if (r && r <= t) return;\n                    Py[i] = n, Oy[i] = n, Qy.debug(\"Update global parameters from config distribute\", i, n);\n                  }\n              }\n            });\n          } catch (t) {\n            Qy.error(\"Error update config immediately: \".concat(e), t.message);\n          }\n        }(n);\n        const e = JSON.stringify(n),\n          t = window.btoa(e);\n        window.localStorage.setItem(\"websdk_ng_global_parameter\", t), Qy.debug(\"Caching global parameters \".concat(e));\n      } catch (e) {\n        Qy.error(\"Error caching global parameters:\", e.message);\n      }\n    }\n  }\n  var ZO,\n    $O = i(MA),\n    eN = N,\n    tN = d,\n    iN = L,\n    nN = n,\n    rN = eo,\n    oN = Br,\n    sN = k,\n    aN = Je,\n    cN = K,\n    dN = Object.assign,\n    lN = Object.defineProperty,\n    hN = tN([].concat),\n    uN = !dN || nN(function () {\n      if (eN && 1 !== dN({\n        b: 1\n      }, dN(lN({}, \"a\", {\n        enumerable: !0,\n        get: function () {\n          lN(this, \"b\", {\n            value: 3,\n            enumerable: !1\n          });\n        }\n      }), {\n        b: 2\n      })).b) return !0;\n      var e = {},\n        t = {},\n        i = Symbol(),\n        n = \"abcdefghijklmnopqrst\";\n      return e[i] = 7, n.split(\"\").forEach(function (e) {\n        t[e] = e;\n      }), 7 != dN({}, e)[i] || rN(dN({}, t)).join(\"\") != n;\n    }) ? function (e, t) {\n      for (var i = aN(e), n = arguments.length, r = 1, o = oN.f, s = sN.f; n > r;) for (var a, c = cN(arguments[r++]), d = o ? hN(rN(c), o(c)) : rN(c), l = d.length, h = 0; l > h;) a = d[h++], eN && !iN(s, c, a) || (i[a] = c[a]);\n      return i;\n    } : dN,\n    pN = ii,\n    _N = rs,\n    EN = Xt,\n    mN = L,\n    fN = Je,\n    TN = function (e, t, i, n) {\n      try {\n        return n ? t(pN(i)[0], i[1]) : t(i);\n      } catch (t) {\n        _N(e, \"throw\", t);\n      }\n    },\n    SN = jo,\n    gN = jc,\n    RN = Gi,\n    CN = E_,\n    vN = es,\n    IN = qo,\n    yN = Array,\n    AN = d,\n    bN = 2147483647,\n    wN = /[^\\0-\\u007E]/,\n    ON = /[.\\u3002\\uFF0E\\uFF61]/g,\n    NN = \"Overflow: input needs wider integers to process\",\n    DN = RangeError,\n    PN = AN(ON.exec),\n    LN = Math.floor,\n    kN = String.fromCharCode,\n    MN = AN(\"\".charCodeAt),\n    UN = AN([].join),\n    xN = AN([].push),\n    VN = AN(\"\".replace),\n    FN = AN(\"\".split),\n    BN = AN(\"\".toLowerCase),\n    jN = function (e) {\n      return e + 22 + 75 * (e < 26);\n    },\n    GN = function (e, t, i) {\n      var n = 0;\n      for (e = i ? LN(e / 700) : e >> 1, e += LN(e / t); e > 455;) e = LN(e / 35), n += 36;\n      return LN(n + 36 * e / (e + 38));\n    },\n    WN = function (e) {\n      var t = [];\n      e = function (e) {\n        for (var t = [], i = 0, n = e.length; i < n;) {\n          var r = MN(e, i++);\n          if (r >= 55296 && r <= 56319 && i < n) {\n            var o = MN(e, i++);\n            56320 == (64512 & o) ? xN(t, ((1023 & r) << 10) + (1023 & o) + 65536) : (xN(t, r), i--);\n          } else xN(t, r);\n        }\n        return t;\n      }(e);\n      var i,\n        n,\n        r = e.length,\n        o = 128,\n        s = 0,\n        a = 72;\n      for (i = 0; i < e.length; i++) (n = e[i]) < 128 && xN(t, kN(n));\n      var c = t.length,\n        d = c;\n      for (c && xN(t, \"-\"); d < r;) {\n        var l = bN;\n        for (i = 0; i < e.length; i++) (n = e[i]) >= o && n < l && (l = n);\n        var h = d + 1;\n        if (l - o > LN((bN - s) / h)) throw DN(NN);\n        for (s += (l - o) * h, o = l, i = 0; i < e.length; i++) {\n          if ((n = e[i]) < o && ++s > bN) throw DN(NN);\n          if (n == o) {\n            for (var u = s, p = 36;;) {\n              var _ = p <= a ? 1 : p >= a + 26 ? 26 : p - a;\n              if (u < _) break;\n              var E = u - _,\n                m = 36 - _;\n              xN(t, kN(jN(_ + E % m))), u = LN(E / m), p += 36;\n            }\n            xN(t, kN(jN(u))), a = GN(s, h, d == c), s = 0, d++;\n          }\n        }\n        s++, o++;\n      }\n      return UN(t, \"\");\n    },\n    HN = wi,\n    KN = N,\n    YN = sg,\n    qN = u,\n    zN = Xt,\n    JN = d,\n    XN = ua,\n    QN = uc,\n    ZN = Sc,\n    $N = Ze,\n    eD = uN,\n    tD = function (e) {\n      var t = fN(e),\n        i = gN(this),\n        n = arguments.length,\n        r = n > 1 ? arguments[1] : void 0,\n        o = void 0 !== r;\n      o && (r = EN(r, n > 2 ? arguments[2] : void 0));\n      var s,\n        a,\n        c,\n        d,\n        l,\n        h,\n        u = IN(t),\n        p = 0;\n      if (!u || this === yN && SN(u)) for (s = RN(t), a = i ? new this(s) : yN(s); s > p; p++) h = o ? r(t[p], p) : t[p], CN(a, p, h);else for (l = (d = vN(t, u)).next, a = i ? new this() : []; !(c = mN(l, d)).done; p++) h = o ? TN(d, r, [c.value, p], !0) : c.value, CN(a, p, h);\n      return a.length = p, a;\n    },\n    iD = R_,\n    nD = Cu.codeAt,\n    rD = function (e) {\n      var t,\n        i,\n        n = [],\n        r = FN(VN(BN(e), ON, \".\"), \".\");\n      for (t = 0; t < r.length; t++) i = r[t], xN(n, PN(wN, i) ? \"xn--\" + WN(i) : i);\n      return UN(n, \".\");\n    },\n    oD = mn,\n    sD = Da,\n    aD = Zc,\n    cD = CR,\n    dD = ra,\n    lD = dD.set,\n    hD = dD.getterFor(\"URL\"),\n    uD = cD.URLSearchParams,\n    pD = cD.getState,\n    _D = qN.URL,\n    ED = qN.TypeError,\n    mD = qN.parseInt,\n    fD = Math.floor,\n    TD = Math.pow,\n    SD = JN(\"\".charAt),\n    gD = JN(/./.exec),\n    RD = JN([].join),\n    CD = JN(1..toString),\n    vD = JN([].pop),\n    ID = JN([].push),\n    yD = JN(\"\".replace),\n    AD = JN([].shift),\n    bD = JN(\"\".split),\n    wD = JN(\"\".slice),\n    OD = JN(\"\".toLowerCase),\n    ND = JN([].unshift),\n    DD = \"Invalid scheme\",\n    PD = \"Invalid host\",\n    LD = \"Invalid port\",\n    kD = /[a-z]/i,\n    MD = /[\\d+-.a-z]/i,\n    UD = /\\d/,\n    xD = /^0x/i,\n    VD = /^[0-7]+$/,\n    FD = /^\\d+$/,\n    BD = /^[\\da-f]+$/i,\n    jD = /[\\0\\t\\n\\r #%/:<>?@[\\\\\\]^|]/,\n    GD = /[\\0\\t\\n\\r #/:<>?@[\\\\\\]^|]/,\n    WD = /^[\\u0000-\\u0020]+/,\n    HD = /(^|[^\\u0000-\\u0020])[\\u0000-\\u0020]+$/,\n    KD = /[\\t\\n\\r]/g,\n    YD = function (e) {\n      var t, i, n, r;\n      if (\"number\" == typeof e) {\n        for (t = [], i = 0; i < 4; i++) ND(t, e % 256), e = fD(e / 256);\n        return RD(t, \".\");\n      }\n      if (\"object\" == typeof e) {\n        for (t = \"\", n = function (e) {\n          for (var t = null, i = 1, n = null, r = 0, o = 0; o < 8; o++) 0 !== e[o] ? (r > i && (t = n, i = r), n = null, r = 0) : (null === n && (n = o), ++r);\n          return r > i && (t = n, i = r), t;\n        }(e), i = 0; i < 8; i++) r && 0 === e[i] || (r && (r = !1), n === i ? (t += i ? \":\" : \"::\", r = !0) : (t += CD(e[i], 16), i < 7 && (t += \":\")));\n        return \"[\" + t + \"]\";\n      }\n      return e;\n    },\n    qD = {},\n    zD = eD({}, qD, {\n      \" \": 1,\n      '\"': 1,\n      \"<\": 1,\n      \">\": 1,\n      \"`\": 1\n    }),\n    JD = eD({}, zD, {\n      \"#\": 1,\n      \"?\": 1,\n      \"{\": 1,\n      \"}\": 1\n    }),\n    XD = eD({}, JD, {\n      \"/\": 1,\n      \":\": 1,\n      \";\": 1,\n      \"=\": 1,\n      \"@\": 1,\n      \"[\": 1,\n      \"\\\\\": 1,\n      \"]\": 1,\n      \"^\": 1,\n      \"|\": 1\n    }),\n    QD = function (e, t) {\n      var i = nD(e, 0);\n      return i > 32 && i < 127 && !$N(t, e) ? e : encodeURIComponent(e);\n    },\n    ZD = {\n      ftp: 21,\n      file: null,\n      http: 80,\n      https: 443,\n      ws: 80,\n      wss: 443\n    },\n    $D = function (e, t) {\n      var i;\n      return 2 == e.length && gD(kD, SD(e, 0)) && (\":\" == (i = SD(e, 1)) || !t && \"|\" == i);\n    },\n    eP = function (e) {\n      var t;\n      return e.length > 1 && $D(wD(e, 0, 2)) && (2 == e.length || \"/\" === (t = SD(e, 2)) || \"\\\\\" === t || \"?\" === t || \"#\" === t);\n    },\n    tP = function (e) {\n      return \".\" === e || \"%2e\" === OD(e);\n    },\n    iP = {},\n    nP = {},\n    rP = {},\n    oP = {},\n    sP = {},\n    aP = {},\n    cP = {},\n    dP = {},\n    lP = {},\n    hP = {},\n    uP = {},\n    pP = {},\n    _P = {},\n    EP = {},\n    mP = {},\n    fP = {},\n    TP = {},\n    SP = {},\n    gP = {},\n    RP = {},\n    CP = {},\n    vP = function (e, t, i) {\n      var n,\n        r,\n        o,\n        s = oD(e);\n      if (t) {\n        if (r = this.parse(s)) throw ED(r);\n        this.searchParams = null;\n      } else {\n        if (void 0 !== i && (n = new vP(i, !0)), r = this.parse(s, null, n)) throw ED(r);\n        (o = pD(new uD())).bindURL(this), this.searchParams = o;\n      }\n    };\n  vP.prototype = {\n    type: \"URL\",\n    parse: function (e, t, i) {\n      var n,\n        r,\n        o,\n        s,\n        a,\n        c = this,\n        d = t || iP,\n        l = 0,\n        h = \"\",\n        u = !1,\n        p = !1,\n        _ = !1;\n      for (e = oD(e), t || (c.scheme = \"\", c.username = \"\", c.password = \"\", c.host = null, c.port = null, c.path = [], c.query = null, c.fragment = null, c.cannotBeABaseURL = !1, e = yD(e, WD, \"\"), e = yD(e, HD, \"$1\")), e = yD(e, KD, \"\"), n = tD(e); l <= n.length;) {\n        switch (r = n[l], d) {\n          case iP:\n            if (!r || !gD(kD, r)) {\n              if (t) return DD;\n              d = rP;\n              continue;\n            }\n            h += OD(r), d = nP;\n            break;\n          case nP:\n            if (r && (gD(MD, r) || \"+\" == r || \"-\" == r || \".\" == r)) h += OD(r);else {\n              if (\":\" != r) {\n                if (t) return DD;\n                h = \"\", d = rP, l = 0;\n                continue;\n              }\n              if (t && (c.isSpecial() != $N(ZD, h) || \"file\" == h && (c.includesCredentials() || null !== c.port) || \"file\" == c.scheme && !c.host)) return;\n              if (c.scheme = h, t) return void (c.isSpecial() && ZD[c.scheme] == c.port && (c.port = null));\n              h = \"\", \"file\" == c.scheme ? d = EP : c.isSpecial() && i && i.scheme == c.scheme ? d = oP : c.isSpecial() ? d = dP : \"/\" == n[l + 1] ? (d = sP, l++) : (c.cannotBeABaseURL = !0, ID(c.path, \"\"), d = gP);\n            }\n            break;\n          case rP:\n            if (!i || i.cannotBeABaseURL && \"#\" != r) return DD;\n            if (i.cannotBeABaseURL && \"#\" == r) {\n              c.scheme = i.scheme, c.path = iD(i.path), c.query = i.query, c.fragment = \"\", c.cannotBeABaseURL = !0, d = CP;\n              break;\n            }\n            d = \"file\" == i.scheme ? EP : aP;\n            continue;\n          case oP:\n            if (\"/\" != r || \"/\" != n[l + 1]) {\n              d = aP;\n              continue;\n            }\n            d = lP, l++;\n            break;\n          case sP:\n            if (\"/\" == r) {\n              d = hP;\n              break;\n            }\n            d = SP;\n            continue;\n          case aP:\n            if (c.scheme = i.scheme, r == ZO) c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = iD(i.path), c.query = i.query;else if (\"/\" == r || \"\\\\\" == r && c.isSpecial()) d = cP;else if (\"?\" == r) c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = iD(i.path), c.query = \"\", d = RP;else {\n              if (\"#\" != r) {\n                c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = iD(i.path), c.path.length--, d = SP;\n                continue;\n              }\n              c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = iD(i.path), c.query = i.query, c.fragment = \"\", d = CP;\n            }\n            break;\n          case cP:\n            if (!c.isSpecial() || \"/\" != r && \"\\\\\" != r) {\n              if (\"/\" != r) {\n                c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, d = SP;\n                continue;\n              }\n              d = hP;\n            } else d = lP;\n            break;\n          case dP:\n            if (d = lP, \"/\" != r || \"/\" != SD(h, l + 1)) continue;\n            l++;\n            break;\n          case lP:\n            if (\"/\" != r && \"\\\\\" != r) {\n              d = hP;\n              continue;\n            }\n            break;\n          case hP:\n            if (\"@\" == r) {\n              u && (h = \"%40\" + h), u = !0, o = tD(h);\n              for (var E = 0; E < o.length; E++) {\n                var m = o[E];\n                if (\":\" != m || _) {\n                  var f = QD(m, XD);\n                  _ ? c.password += f : c.username += f;\n                } else _ = !0;\n              }\n              h = \"\";\n            } else if (r == ZO || \"/\" == r || \"?\" == r || \"#\" == r || \"\\\\\" == r && c.isSpecial()) {\n              if (u && \"\" == h) return \"Invalid authority\";\n              l -= tD(h).length + 1, h = \"\", d = uP;\n            } else h += r;\n            break;\n          case uP:\n          case pP:\n            if (t && \"file\" == c.scheme) {\n              d = fP;\n              continue;\n            }\n            if (\":\" != r || p) {\n              if (r == ZO || \"/\" == r || \"?\" == r || \"#\" == r || \"\\\\\" == r && c.isSpecial()) {\n                if (c.isSpecial() && \"\" == h) return PD;\n                if (t && \"\" == h && (c.includesCredentials() || null !== c.port)) return;\n                if (s = c.parseHost(h)) return s;\n                if (h = \"\", d = TP, t) return;\n                continue;\n              }\n              \"[\" == r ? p = !0 : \"]\" == r && (p = !1), h += r;\n            } else {\n              if (\"\" == h) return PD;\n              if (s = c.parseHost(h)) return s;\n              if (h = \"\", d = _P, t == pP) return;\n            }\n            break;\n          case _P:\n            if (!gD(UD, r)) {\n              if (r == ZO || \"/\" == r || \"?\" == r || \"#\" == r || \"\\\\\" == r && c.isSpecial() || t) {\n                if (\"\" != h) {\n                  var T = mD(h, 10);\n                  if (T > 65535) return LD;\n                  c.port = c.isSpecial() && T === ZD[c.scheme] ? null : T, h = \"\";\n                }\n                if (t) return;\n                d = TP;\n                continue;\n              }\n              return LD;\n            }\n            h += r;\n            break;\n          case EP:\n            if (c.scheme = \"file\", \"/\" == r || \"\\\\\" == r) d = mP;else {\n              if (!i || \"file\" != i.scheme) {\n                d = SP;\n                continue;\n              }\n              if (r == ZO) c.host = i.host, c.path = iD(i.path), c.query = i.query;else if (\"?\" == r) c.host = i.host, c.path = iD(i.path), c.query = \"\", d = RP;else {\n                if (\"#\" != r) {\n                  eP(RD(iD(n, l), \"\")) || (c.host = i.host, c.path = iD(i.path), c.shortenPath()), d = SP;\n                  continue;\n                }\n                c.host = i.host, c.path = iD(i.path), c.query = i.query, c.fragment = \"\", d = CP;\n              }\n            }\n            break;\n          case mP:\n            if (\"/\" == r || \"\\\\\" == r) {\n              d = fP;\n              break;\n            }\n            i && \"file\" == i.scheme && !eP(RD(iD(n, l), \"\")) && ($D(i.path[0], !0) ? ID(c.path, i.path[0]) : c.host = i.host), d = SP;\n            continue;\n          case fP:\n            if (r == ZO || \"/\" == r || \"\\\\\" == r || \"?\" == r || \"#\" == r) {\n              if (!t && $D(h)) d = SP;else if (\"\" == h) {\n                if (c.host = \"\", t) return;\n                d = TP;\n              } else {\n                if (s = c.parseHost(h)) return s;\n                if (\"localhost\" == c.host && (c.host = \"\"), t) return;\n                h = \"\", d = TP;\n              }\n              continue;\n            }\n            h += r;\n            break;\n          case TP:\n            if (c.isSpecial()) {\n              if (d = SP, \"/\" != r && \"\\\\\" != r) continue;\n            } else if (t || \"?\" != r) {\n              if (t || \"#\" != r) {\n                if (r != ZO && (d = SP, \"/\" != r)) continue;\n              } else c.fragment = \"\", d = CP;\n            } else c.query = \"\", d = RP;\n            break;\n          case SP:\n            if (r == ZO || \"/\" == r || \"\\\\\" == r && c.isSpecial() || !t && (\"?\" == r || \"#\" == r)) {\n              if (\"..\" === (a = OD(a = h)) || \"%2e.\" === a || \".%2e\" === a || \"%2e%2e\" === a ? (c.shortenPath(), \"/\" == r || \"\\\\\" == r && c.isSpecial() || ID(c.path, \"\")) : tP(h) ? \"/\" == r || \"\\\\\" == r && c.isSpecial() || ID(c.path, \"\") : (\"file\" == c.scheme && !c.path.length && $D(h) && (c.host && (c.host = \"\"), h = SD(h, 0) + \":\"), ID(c.path, h)), h = \"\", \"file\" == c.scheme && (r == ZO || \"?\" == r || \"#\" == r)) for (; c.path.length > 1 && \"\" === c.path[0];) AD(c.path);\n              \"?\" == r ? (c.query = \"\", d = RP) : \"#\" == r && (c.fragment = \"\", d = CP);\n            } else h += QD(r, JD);\n            break;\n          case gP:\n            \"?\" == r ? (c.query = \"\", d = RP) : \"#\" == r ? (c.fragment = \"\", d = CP) : r != ZO && (c.path[0] += QD(r, qD));\n            break;\n          case RP:\n            t || \"#\" != r ? r != ZO && (\"'\" == r && c.isSpecial() ? c.query += \"%27\" : c.query += \"#\" == r ? \"%23\" : QD(r, qD)) : (c.fragment = \"\", d = CP);\n            break;\n          case CP:\n            r != ZO && (c.fragment += QD(r, zD));\n        }\n        l++;\n      }\n    },\n    parseHost: function (e) {\n      var t, i, n;\n      if (\"[\" == SD(e, 0)) {\n        if (\"]\" != SD(e, e.length - 1)) return PD;\n        if (t = function (e) {\n          var t,\n            i,\n            n,\n            r,\n            o,\n            s,\n            a,\n            c = [0, 0, 0, 0, 0, 0, 0, 0],\n            d = 0,\n            l = null,\n            h = 0,\n            u = function () {\n              return SD(e, h);\n            };\n          if (\":\" == u()) {\n            if (\":\" != SD(e, 1)) return;\n            h += 2, l = ++d;\n          }\n          for (; u();) {\n            if (8 == d) return;\n            if (\":\" != u()) {\n              for (t = i = 0; i < 4 && gD(BD, u());) t = 16 * t + mD(u(), 16), h++, i++;\n              if (\".\" == u()) {\n                if (0 == i) return;\n                if (h -= i, d > 6) return;\n                for (n = 0; u();) {\n                  if (r = null, n > 0) {\n                    if (!(\".\" == u() && n < 4)) return;\n                    h++;\n                  }\n                  if (!gD(UD, u())) return;\n                  for (; gD(UD, u());) {\n                    if (o = mD(u(), 10), null === r) r = o;else {\n                      if (0 == r) return;\n                      r = 10 * r + o;\n                    }\n                    if (r > 255) return;\n                    h++;\n                  }\n                  c[d] = 256 * c[d] + r, 2 != ++n && 4 != n || d++;\n                }\n                if (4 != n) return;\n                break;\n              }\n              if (\":\" == u()) {\n                if (h++, !u()) return;\n              } else if (u()) return;\n              c[d++] = t;\n            } else {\n              if (null !== l) return;\n              h++, l = ++d;\n            }\n          }\n          if (null !== l) for (s = d - l, d = 7; 0 != d && s > 0;) a = c[d], c[d--] = c[l + s - 1], c[l + --s] = a;else if (8 != d) return;\n          return c;\n        }(wD(e, 1, -1)), !t) return PD;\n        this.host = t;\n      } else if (this.isSpecial()) {\n        if (e = rD(e), gD(jD, e)) return PD;\n        if (t = function (e) {\n          var t,\n            i,\n            n,\n            r,\n            o,\n            s,\n            a,\n            c = bD(e, \".\");\n          if (c.length && \"\" == c[c.length - 1] && c.length--, (t = c.length) > 4) return e;\n          for (i = [], n = 0; n < t; n++) {\n            if (\"\" == (r = c[n])) return e;\n            if (o = 10, r.length > 1 && \"0\" == SD(r, 0) && (o = gD(xD, r) ? 16 : 8, r = wD(r, 8 == o ? 1 : 2)), \"\" === r) s = 0;else {\n              if (!gD(10 == o ? FD : 8 == o ? VD : BD, r)) return e;\n              s = mD(r, o);\n            }\n            ID(i, s);\n          }\n          for (n = 0; n < t; n++) if (s = i[n], n == t - 1) {\n            if (s >= TD(256, 5 - t)) return null;\n          } else if (s > 255) return null;\n          for (a = vD(i), n = 0; n < i.length; n++) a += i[n] * TD(256, 3 - n);\n          return a;\n        }(e), null === t) return PD;\n        this.host = t;\n      } else {\n        if (gD(GD, e)) return PD;\n        for (t = \"\", i = tD(e), n = 0; n < i.length; n++) t += QD(i[n], qD);\n        this.host = t;\n      }\n    },\n    cannotHaveUsernamePasswordPort: function () {\n      return !this.host || this.cannotBeABaseURL || \"file\" == this.scheme;\n    },\n    includesCredentials: function () {\n      return \"\" != this.username || \"\" != this.password;\n    },\n    isSpecial: function () {\n      return $N(ZD, this.scheme);\n    },\n    shortenPath: function () {\n      var e = this.path,\n        t = e.length;\n      !t || \"file\" == this.scheme && 1 == t && $D(e[0], !0) || e.length--;\n    },\n    serialize: function () {\n      var e = this,\n        t = e.scheme,\n        i = e.username,\n        n = e.password,\n        r = e.host,\n        o = e.port,\n        s = e.path,\n        a = e.query,\n        c = e.fragment,\n        d = t + \":\";\n      return null !== r ? (d += \"//\", e.includesCredentials() && (d += i + (n ? \":\" + n : \"\") + \"@\"), d += YD(r), null !== o && (d += \":\" + o)) : \"file\" == t && (d += \"//\"), d += e.cannotBeABaseURL ? s[0] : s.length ? \"/\" + RD(s, \"/\") : \"\", null !== a && (d += \"?\" + a), null !== c && (d += \"#\" + c), d;\n    },\n    setHref: function (e) {\n      var t = this.parse(e);\n      if (t) throw ED(t);\n      this.searchParams.update();\n    },\n    getOrigin: function () {\n      var e = this.scheme,\n        t = this.port;\n      if (\"blob\" == e) try {\n        return new IP(e.path[0]).origin;\n      } catch (e) {\n        return \"null\";\n      }\n      return \"file\" != e && this.isSpecial() ? e + \"://\" + YD(this.host) + (null !== t ? \":\" + t : \"\") : \"null\";\n    },\n    getProtocol: function () {\n      return this.scheme + \":\";\n    },\n    setProtocol: function (e) {\n      this.parse(oD(e) + \":\", iP);\n    },\n    getUsername: function () {\n      return this.username;\n    },\n    setUsername: function (e) {\n      var t = tD(oD(e));\n      if (!this.cannotHaveUsernamePasswordPort()) {\n        this.username = \"\";\n        for (var i = 0; i < t.length; i++) this.username += QD(t[i], XD);\n      }\n    },\n    getPassword: function () {\n      return this.password;\n    },\n    setPassword: function (e) {\n      var t = tD(oD(e));\n      if (!this.cannotHaveUsernamePasswordPort()) {\n        this.password = \"\";\n        for (var i = 0; i < t.length; i++) this.password += QD(t[i], XD);\n      }\n    },\n    getHost: function () {\n      var e = this.host,\n        t = this.port;\n      return null === e ? \"\" : null === t ? YD(e) : YD(e) + \":\" + t;\n    },\n    setHost: function (e) {\n      this.cannotBeABaseURL || this.parse(e, uP);\n    },\n    getHostname: function () {\n      var e = this.host;\n      return null === e ? \"\" : YD(e);\n    },\n    setHostname: function (e) {\n      this.cannotBeABaseURL || this.parse(e, pP);\n    },\n    getPort: function () {\n      var e = this.port;\n      return null === e ? \"\" : oD(e);\n    },\n    setPort: function (e) {\n      this.cannotHaveUsernamePasswordPort() || (\"\" == (e = oD(e)) ? this.port = null : this.parse(e, _P));\n    },\n    getPathname: function () {\n      var e = this.path;\n      return this.cannotBeABaseURL ? e[0] : e.length ? \"/\" + RD(e, \"/\") : \"\";\n    },\n    setPathname: function (e) {\n      this.cannotBeABaseURL || (this.path = [], this.parse(e, TP));\n    },\n    getSearch: function () {\n      var e = this.query;\n      return e ? \"?\" + e : \"\";\n    },\n    setSearch: function (e) {\n      \"\" == (e = oD(e)) ? this.query = null : (\"?\" == SD(e, 0) && (e = wD(e, 1)), this.query = \"\", this.parse(e, RP)), this.searchParams.update();\n    },\n    getSearchParams: function () {\n      return this.searchParams.facade;\n    },\n    getHash: function () {\n      var e = this.fragment;\n      return e ? \"#\" + e : \"\";\n    },\n    setHash: function (e) {\n      \"\" != (e = oD(e)) ? (\"#\" == SD(e, 0) && (e = wD(e, 1)), this.fragment = \"\", this.parse(e, CP)) : this.fragment = null;\n    },\n    update: function () {\n      this.query = this.searchParams.serialize() || null;\n    }\n  };\n  var IP = function (e) {\n      var t = ZN(this, yP),\n        i = aD(arguments.length, 1) > 1 ? arguments[1] : void 0,\n        n = lD(t, new vP(e, !1, i));\n      KN || (t.href = n.serialize(), t.origin = n.getOrigin(), t.protocol = n.getProtocol(), t.username = n.getUsername(), t.password = n.getPassword(), t.host = n.getHost(), t.hostname = n.getHostname(), t.port = n.getPort(), t.pathname = n.getPathname(), t.search = n.getSearch(), t.searchParams = n.getSearchParams(), t.hash = n.getHash());\n    },\n    yP = IP.prototype,\n    AP = function (e, t) {\n      return {\n        get: function () {\n          return hD(this)[e]();\n        },\n        set: t && function (e) {\n          return hD(this)[t](e);\n        },\n        configurable: !0,\n        enumerable: !0\n      };\n    };\n  if (KN && (QN(yP, \"href\", AP(\"serialize\", \"setHref\")), QN(yP, \"origin\", AP(\"getOrigin\")), QN(yP, \"protocol\", AP(\"getProtocol\", \"setProtocol\")), QN(yP, \"username\", AP(\"getUsername\", \"setUsername\")), QN(yP, \"password\", AP(\"getPassword\", \"setPassword\")), QN(yP, \"host\", AP(\"getHost\", \"setHost\")), QN(yP, \"hostname\", AP(\"getHostname\", \"setHostname\")), QN(yP, \"port\", AP(\"getPort\", \"setPort\")), QN(yP, \"pathname\", AP(\"getPathname\", \"setPathname\")), QN(yP, \"search\", AP(\"getSearch\", \"setSearch\")), QN(yP, \"searchParams\", AP(\"getSearchParams\")), QN(yP, \"hash\", AP(\"getHash\", \"setHash\"))), XN(yP, \"toJSON\", function () {\n    return hD(this).serialize();\n  }, {\n    enumerable: !0\n  }), XN(yP, \"toString\", function () {\n    return hD(this).serialize();\n  }, {\n    enumerable: !0\n  }), _D) {\n    var bP = _D.createObjectURL,\n      wP = _D.revokeObjectURL;\n    bP && XN(IP, \"createObjectURL\", zN(bP, _D)), wP && XN(IP, \"revokeObjectURL\", zN(wP, _D));\n  }\n  sD(IP, \"URL\"), HN({\n    global: !0,\n    constructor: !0,\n    forced: !YN,\n    sham: !KN\n  }, {\n    URL: IP\n  });\n  var OP = wi,\n    NP = n,\n    DP = Zc,\n    PP = mn,\n    LP = sg,\n    kP = ae(\"URL\");\n  OP({\n    target: \"URL\",\n    stat: !0,\n    forced: !(LP && NP(function () {\n      kP.canParse();\n    }))\n  }, {\n    canParse: function (e) {\n      var t = DP(arguments.length, 1),\n        i = PP(e),\n        n = t < 2 || void 0 === arguments[1] ? void 0 : PP(arguments[1]);\n      try {\n        return !!new kP(i, n);\n      } catch (e) {\n        return !1;\n      }\n    }\n  });\n  var MP = i(ie.URL),\n    UP = l,\n    xP = VR,\n    VP = RegExp.prototype,\n    FP = function (e) {\n      return e === VP || UP(VP, e) ? xP(e) : e.flags;\n    },\n    BP = i(FP);\n  function jP(e) {\n    let t = e.length;\n    for (; --t >= 0;) e[t] = 0;\n  }\n  const GP = 256,\n    WP = 286,\n    HP = 30,\n    KP = 15,\n    YP = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),\n    qP = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),\n    zP = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),\n    JP = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),\n    XP = new Array(576);\n  jP(XP);\n  const QP = new Array(60);\n  jP(QP);\n  const ZP = new Array(512);\n  jP(ZP);\n  const $P = new Array(256);\n  jP($P);\n  const eL = new Array(29);\n  jP(eL);\n  const tL = new Array(HP);\n  function iL(e, t, i, n, r) {\n    this.static_tree = e, this.extra_bits = t, this.extra_base = i, this.elems = n, this.max_length = r, this.has_stree = e && e.length;\n  }\n  let nL, rL, oL;\n  function sL(e, t) {\n    this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;\n  }\n  jP(tL);\n  const aL = e => e < 256 ? ZP[e] : ZP[256 + (e >>> 7)],\n    cL = (e, t) => {\n      e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255;\n    },\n    dL = (e, t, i) => {\n      e.bi_valid > 16 - i ? (e.bi_buf |= t << e.bi_valid & 65535, cL(e, e.bi_buf), e.bi_buf = t >> 16 - e.bi_valid, e.bi_valid += i - 16) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += i);\n    },\n    lL = (e, t, i) => {\n      dL(e, i[2 * t], i[2 * t + 1]);\n    },\n    hL = (e, t) => {\n      let i = 0;\n      do {\n        i |= 1 & e, e >>>= 1, i <<= 1;\n      } while (--t > 0);\n      return i >>> 1;\n    },\n    uL = (e, t, i) => {\n      const n = new Array(16);\n      let r,\n        o,\n        s = 0;\n      for (r = 1; r <= KP; r++) s = s + i[r - 1] << 1, n[r] = s;\n      for (o = 0; o <= t; o++) {\n        let t = e[2 * o + 1];\n        0 !== t && (e[2 * o] = hL(n[t]++, t));\n      }\n    },\n    pL = e => {\n      let t;\n      for (t = 0; t < WP; t++) e.dyn_ltree[2 * t] = 0;\n      for (t = 0; t < HP; t++) e.dyn_dtree[2 * t] = 0;\n      for (t = 0; t < 19; t++) e.bl_tree[2 * t] = 0;\n      e.dyn_ltree[512] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;\n    },\n    _L = e => {\n      e.bi_valid > 8 ? cL(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;\n    },\n    EL = (e, t, i, n) => {\n      const r = 2 * t,\n        o = 2 * i;\n      return e[r] < e[o] || e[r] === e[o] && n[t] <= n[i];\n    },\n    mL = (e, t, i) => {\n      const n = e.heap[i];\n      let r = i << 1;\n      for (; r <= e.heap_len && (r < e.heap_len && EL(t, e.heap[r + 1], e.heap[r], e.depth) && r++, !EL(t, n, e.heap[r], e.depth));) e.heap[i] = e.heap[r], i = r, r <<= 1;\n      e.heap[i] = n;\n    },\n    fL = (e, t, i) => {\n      let n,\n        r,\n        o,\n        s,\n        a = 0;\n      if (0 !== e.sym_next) do {\n        n = 255 & e.pending_buf[e.sym_buf + a++], n += (255 & e.pending_buf[e.sym_buf + a++]) << 8, r = e.pending_buf[e.sym_buf + a++], 0 === n ? lL(e, r, t) : (o = $P[r], lL(e, o + GP + 1, t), s = YP[o], 0 !== s && (r -= eL[o], dL(e, r, s)), n--, o = aL(n), lL(e, o, i), s = qP[o], 0 !== s && (n -= tL[o], dL(e, n, s)));\n      } while (a < e.sym_next);\n      lL(e, 256, t);\n    },\n    TL = (e, t) => {\n      const i = t.dyn_tree,\n        n = t.stat_desc.static_tree,\n        r = t.stat_desc.has_stree,\n        o = t.stat_desc.elems;\n      let s,\n        a,\n        c,\n        d = -1;\n      for (e.heap_len = 0, e.heap_max = 573, s = 0; s < o; s++) 0 !== i[2 * s] ? (e.heap[++e.heap_len] = d = s, e.depth[s] = 0) : i[2 * s + 1] = 0;\n      for (; e.heap_len < 2;) c = e.heap[++e.heap_len] = d < 2 ? ++d : 0, i[2 * c] = 1, e.depth[c] = 0, e.opt_len--, r && (e.static_len -= n[2 * c + 1]);\n      for (t.max_code = d, s = e.heap_len >> 1; s >= 1; s--) mL(e, i, s);\n      c = o;\n      do {\n        s = e.heap[1], e.heap[1] = e.heap[e.heap_len--], mL(e, i, 1), a = e.heap[1], e.heap[--e.heap_max] = s, e.heap[--e.heap_max] = a, i[2 * c] = i[2 * s] + i[2 * a], e.depth[c] = (e.depth[s] >= e.depth[a] ? e.depth[s] : e.depth[a]) + 1, i[2 * s + 1] = i[2 * a + 1] = c, e.heap[1] = c++, mL(e, i, 1);\n      } while (e.heap_len >= 2);\n      e.heap[--e.heap_max] = e.heap[1], ((e, t) => {\n        const i = t.dyn_tree,\n          n = t.max_code,\n          r = t.stat_desc.static_tree,\n          o = t.stat_desc.has_stree,\n          s = t.stat_desc.extra_bits,\n          a = t.stat_desc.extra_base,\n          c = t.stat_desc.max_length;\n        let d,\n          l,\n          h,\n          u,\n          p,\n          _,\n          E = 0;\n        for (u = 0; u <= KP; u++) e.bl_count[u] = 0;\n        for (i[2 * e.heap[e.heap_max] + 1] = 0, d = e.heap_max + 1; d < 573; d++) l = e.heap[d], u = i[2 * i[2 * l + 1] + 1] + 1, u > c && (u = c, E++), i[2 * l + 1] = u, l > n || (e.bl_count[u]++, p = 0, l >= a && (p = s[l - a]), _ = i[2 * l], e.opt_len += _ * (u + p), o && (e.static_len += _ * (r[2 * l + 1] + p)));\n        if (0 !== E) {\n          do {\n            for (u = c - 1; 0 === e.bl_count[u];) u--;\n            e.bl_count[u]--, e.bl_count[u + 1] += 2, e.bl_count[c]--, E -= 2;\n          } while (E > 0);\n          for (u = c; 0 !== u; u--) for (l = e.bl_count[u]; 0 !== l;) h = e.heap[--d], h > n || (i[2 * h + 1] !== u && (e.opt_len += (u - i[2 * h + 1]) * i[2 * h], i[2 * h + 1] = u), l--);\n        }\n      })(e, t), uL(i, d, e.bl_count);\n    },\n    SL = (e, t, i) => {\n      let n,\n        r,\n        o = -1,\n        s = t[1],\n        a = 0,\n        c = 7,\n        d = 4;\n      for (0 === s && (c = 138, d = 3), t[2 * (i + 1) + 1] = 65535, n = 0; n <= i; n++) r = s, s = t[2 * (n + 1) + 1], ++a < c && r === s || (a < d ? e.bl_tree[2 * r] += a : 0 !== r ? (r !== o && e.bl_tree[2 * r]++, e.bl_tree[32]++) : a <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++, a = 0, o = r, 0 === s ? (c = 138, d = 3) : r === s ? (c = 6, d = 3) : (c = 7, d = 4));\n    },\n    gL = (e, t, i) => {\n      let n,\n        r,\n        o = -1,\n        s = t[1],\n        a = 0,\n        c = 7,\n        d = 4;\n      for (0 === s && (c = 138, d = 3), n = 0; n <= i; n++) if (r = s, s = t[2 * (n + 1) + 1], !(++a < c && r === s)) {\n        if (a < d) do {\n          lL(e, r, e.bl_tree);\n        } while (0 != --a);else 0 !== r ? (r !== o && (lL(e, r, e.bl_tree), a--), lL(e, 16, e.bl_tree), dL(e, a - 3, 2)) : a <= 10 ? (lL(e, 17, e.bl_tree), dL(e, a - 3, 3)) : (lL(e, 18, e.bl_tree), dL(e, a - 11, 7));\n        a = 0, o = r, 0 === s ? (c = 138, d = 3) : r === s ? (c = 6, d = 3) : (c = 7, d = 4);\n      }\n    };\n  let RL = !1;\n  const CL = (e, t, i, n) => {\n    dL(e, 0 + (n ? 1 : 0), 3), _L(e), cL(e, i), cL(e, ~i), i && e.pending_buf.set(e.window.subarray(t, t + i), e.pending), e.pending += i;\n  };\n  var vL = e => {\n      RL || ((() => {\n        let e, t, i, n, r;\n        const o = new Array(16);\n        for (i = 0, n = 0; n < 28; n++) for (eL[n] = i, e = 0; e < 1 << YP[n]; e++) $P[i++] = n;\n        for ($P[i - 1] = n, r = 0, n = 0; n < 16; n++) for (tL[n] = r, e = 0; e < 1 << qP[n]; e++) ZP[r++] = n;\n        for (r >>= 7; n < HP; n++) for (tL[n] = r << 7, e = 0; e < 1 << qP[n] - 7; e++) ZP[256 + r++] = n;\n        for (t = 0; t <= KP; t++) o[t] = 0;\n        for (e = 0; e <= 143;) XP[2 * e + 1] = 8, e++, o[8]++;\n        for (; e <= 255;) XP[2 * e + 1] = 9, e++, o[9]++;\n        for (; e <= 279;) XP[2 * e + 1] = 7, e++, o[7]++;\n        for (; e <= 287;) XP[2 * e + 1] = 8, e++, o[8]++;\n        for (uL(XP, 287, o), e = 0; e < HP; e++) QP[2 * e + 1] = 5, QP[2 * e] = hL(e, 5);\n        nL = new iL(XP, YP, 257, WP, KP), rL = new iL(QP, qP, 0, HP, KP), oL = new iL(new Array(0), zP, 0, 19, 7);\n      })(), RL = !0), e.l_desc = new sL(e.dyn_ltree, nL), e.d_desc = new sL(e.dyn_dtree, rL), e.bl_desc = new sL(e.bl_tree, oL), e.bi_buf = 0, e.bi_valid = 0, pL(e);\n    },\n    IL = (e, t, i, n) => {\n      let r,\n        o,\n        s = 0;\n      e.level > 0 ? (2 === e.strm.data_type && (e.strm.data_type = (e => {\n        let t,\n          i = 4093624447;\n        for (t = 0; t <= 31; t++, i >>>= 1) if (1 & i && 0 !== e.dyn_ltree[2 * t]) return 0;\n        if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return 1;\n        for (t = 32; t < GP; t++) if (0 !== e.dyn_ltree[2 * t]) return 1;\n        return 0;\n      })(e)), TL(e, e.l_desc), TL(e, e.d_desc), s = (e => {\n        let t;\n        for (SL(e, e.dyn_ltree, e.l_desc.max_code), SL(e, e.dyn_dtree, e.d_desc.max_code), TL(e, e.bl_desc), t = 18; t >= 3 && 0 === e.bl_tree[2 * JP[t] + 1]; t--);\n        return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;\n      })(e), r = e.opt_len + 3 + 7 >>> 3, o = e.static_len + 3 + 7 >>> 3, o <= r && (r = o)) : r = o = i + 5, i + 4 <= r && -1 !== t ? CL(e, t, i, n) : 4 === e.strategy || o === r ? (dL(e, 2 + (n ? 1 : 0), 3), fL(e, XP, QP)) : (dL(e, 4 + (n ? 1 : 0), 3), ((e, t, i, n) => {\n        let r;\n        for (dL(e, t - 257, 5), dL(e, i - 1, 5), dL(e, n - 4, 4), r = 0; r < n; r++) dL(e, e.bl_tree[2 * JP[r] + 1], 3);\n        gL(e, e.dyn_ltree, t - 1), gL(e, e.dyn_dtree, i - 1);\n      })(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1), fL(e, e.dyn_ltree, e.dyn_dtree)), pL(e), n && _L(e);\n    },\n    yL = (e, t, i) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = i, 0 === t ? e.dyn_ltree[2 * i]++ : (e.matches++, t--, e.dyn_ltree[2 * ($P[i] + GP + 1)]++, e.dyn_dtree[2 * aL(t)]++), e.sym_next === e.sym_end),\n    AL = e => {\n      dL(e, 2, 3), lL(e, 256, XP), (e => {\n        16 === e.bi_valid ? (cL(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8);\n      })(e);\n    },\n    bL = {\n      _tr_init: vL,\n      _tr_stored_block: CL,\n      _tr_flush_block: IL,\n      _tr_tally: yL,\n      _tr_align: AL\n    };\n  var wL = (e, t, i, n) => {\n    let r = 65535 & e | 0,\n      o = e >>> 16 & 65535 | 0,\n      s = 0;\n    for (; 0 !== i;) {\n      s = i > 2e3 ? 2e3 : i, i -= s;\n      do {\n        r = r + t[n++] | 0, o = o + r | 0;\n      } while (--s);\n      r %= 65521, o %= 65521;\n    }\n    return r | o << 16 | 0;\n  };\n  const OL = new Uint32Array((() => {\n    let e,\n      t = [];\n    for (var i = 0; i < 256; i++) {\n      e = i;\n      for (var n = 0; n < 8; n++) e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;\n      t[i] = e;\n    }\n    return t;\n  })());\n  var NL = (e, t, i, n) => {\n      const r = OL,\n        o = n + i;\n      e ^= -1;\n      for (let i = n; i < o; i++) e = e >>> 8 ^ r[255 & (e ^ t[i])];\n      return -1 ^ e;\n    },\n    DL = {\n      2: \"need dictionary\",\n      1: \"stream end\",\n      0: \"\",\n      \"-1\": \"file error\",\n      \"-2\": \"stream error\",\n      \"-3\": \"data error\",\n      \"-4\": \"insufficient memory\",\n      \"-5\": \"buffer error\",\n      \"-6\": \"incompatible version\"\n    },\n    PL = {\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_MEM_ERROR: -4,\n      Z_BUF_ERROR: -5,\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      Z_UNKNOWN: 2,\n      Z_DEFLATED: 8\n    };\n  const LL = bL._tr_init,\n    kL = bL._tr_stored_block,\n    ML = bL._tr_flush_block,\n    UL = bL._tr_tally,\n    xL = bL._tr_align,\n    VL = PL.Z_NO_FLUSH,\n    FL = PL.Z_PARTIAL_FLUSH,\n    BL = PL.Z_FULL_FLUSH,\n    jL = PL.Z_FINISH,\n    GL = PL.Z_BLOCK,\n    WL = PL.Z_OK,\n    HL = PL.Z_STREAM_END,\n    KL = PL.Z_STREAM_ERROR,\n    YL = PL.Z_DATA_ERROR,\n    qL = PL.Z_BUF_ERROR,\n    zL = PL.Z_DEFAULT_COMPRESSION,\n    JL = PL.Z_FILTERED,\n    XL = PL.Z_HUFFMAN_ONLY,\n    QL = PL.Z_RLE,\n    ZL = PL.Z_FIXED,\n    $L = PL.Z_DEFAULT_STRATEGY,\n    ek = PL.Z_UNKNOWN,\n    tk = PL.Z_DEFLATED,\n    ik = 286,\n    nk = 30,\n    rk = 19,\n    ok = 2 * ik + 1,\n    sk = 15,\n    ak = 258,\n    ck = 262,\n    dk = 42,\n    lk = 113,\n    hk = 666,\n    uk = (e, t) => (e.msg = DL[t], t),\n    pk = e => 2 * e - (e > 4 ? 9 : 0),\n    _k = e => {\n      let t = e.length;\n      for (; --t >= 0;) e[t] = 0;\n    },\n    Ek = e => {\n      let t,\n        i,\n        n,\n        r = e.w_size;\n      t = e.hash_size, n = t;\n      do {\n        i = e.head[--n], e.head[n] = i >= r ? i - r : 0;\n      } while (--t);\n      t = r, n = t;\n      do {\n        i = e.prev[--n], e.prev[n] = i >= r ? i - r : 0;\n      } while (--t);\n    };\n  let mk = (e, t, i) => (t << e.hash_shift ^ i) & e.hash_mask;\n  const fk = e => {\n      const t = e.state;\n      let i = t.pending;\n      i > e.avail_out && (i = e.avail_out), 0 !== i && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + i), e.next_out), e.next_out += i, t.pending_out += i, e.total_out += i, e.avail_out -= i, t.pending -= i, 0 === t.pending && (t.pending_out = 0));\n    },\n    Tk = (e, t) => {\n      ML(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, fk(e.strm);\n    },\n    Sk = (e, t) => {\n      e.pending_buf[e.pending++] = t;\n    },\n    gk = (e, t) => {\n      e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t;\n    },\n    Rk = (e, t, i, n) => {\n      let r = e.avail_in;\n      return r > n && (r = n), 0 === r ? 0 : (e.avail_in -= r, t.set(e.input.subarray(e.next_in, e.next_in + r), i), 1 === e.state.wrap ? e.adler = wL(e.adler, t, r, i) : 2 === e.state.wrap && (e.adler = NL(e.adler, t, r, i)), e.next_in += r, e.total_in += r, r);\n    },\n    Ck = (e, t) => {\n      let i,\n        n,\n        r = e.max_chain_length,\n        o = e.strstart,\n        s = e.prev_length,\n        a = e.nice_match;\n      const c = e.strstart > e.w_size - ck ? e.strstart - (e.w_size - ck) : 0,\n        d = e.window,\n        l = e.w_mask,\n        h = e.prev,\n        u = e.strstart + ak;\n      let p = d[o + s - 1],\n        _ = d[o + s];\n      e.prev_length >= e.good_match && (r >>= 2), a > e.lookahead && (a = e.lookahead);\n      do {\n        if (i = t, d[i + s] === _ && d[i + s - 1] === p && d[i] === d[o] && d[++i] === d[o + 1]) {\n          o += 2, i++;\n          do {} while (d[++o] === d[++i] && d[++o] === d[++i] && d[++o] === d[++i] && d[++o] === d[++i] && d[++o] === d[++i] && d[++o] === d[++i] && d[++o] === d[++i] && d[++o] === d[++i] && o < u);\n          if (n = ak - (u - o), o = u - ak, n > s) {\n            if (e.match_start = t, s = n, n >= a) break;\n            p = d[o + s - 1], _ = d[o + s];\n          }\n        }\n      } while ((t = h[t & l]) > c && 0 != --r);\n      return s <= e.lookahead ? s : e.lookahead;\n    },\n    vk = e => {\n      const t = e.w_size;\n      let i, n, r;\n      do {\n        if (n = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - ck) && (e.window.set(e.window.subarray(t, t + t - n), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), Ek(e), n += t), 0 === e.strm.avail_in) break;\n        if (i = Rk(e.strm, e.window, e.strstart + e.lookahead, n), e.lookahead += i, e.lookahead + e.insert >= 3) for (r = e.strstart - e.insert, e.ins_h = e.window[r], e.ins_h = mk(e, e.ins_h, e.window[r + 1]); e.insert && (e.ins_h = mk(e, e.ins_h, e.window[r + 3 - 1]), e.prev[r & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = r, r++, e.insert--, !(e.lookahead + e.insert < 3)););\n      } while (e.lookahead < ck && 0 !== e.strm.avail_in);\n    },\n    Ik = (e, t) => {\n      let i,\n        n,\n        r,\n        o = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5,\n        s = 0,\n        a = e.strm.avail_in;\n      do {\n        if (i = 65535, r = e.bi_valid + 42 >> 3, e.strm.avail_out < r) break;\n        if (r = e.strm.avail_out - r, n = e.strstart - e.block_start, i > n + e.strm.avail_in && (i = n + e.strm.avail_in), i > r && (i = r), i < o && (0 === i && t !== jL || t === VL || i !== n + e.strm.avail_in)) break;\n        s = t === jL && i === n + e.strm.avail_in ? 1 : 0, kL(e, 0, 0, s), e.pending_buf[e.pending - 4] = i, e.pending_buf[e.pending - 3] = i >> 8, e.pending_buf[e.pending - 2] = ~i, e.pending_buf[e.pending - 1] = ~i >> 8, fk(e.strm), n && (n > i && (n = i), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + n), e.strm.next_out), e.strm.next_out += n, e.strm.avail_out -= n, e.strm.total_out += n, e.block_start += n, i -= n), i && (Rk(e.strm, e.strm.output, e.strm.next_out, i), e.strm.next_out += i, e.strm.avail_out -= i, e.strm.total_out += i);\n      } while (0 === s);\n      return a -= e.strm.avail_in, a && (a >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= a && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - a, e.strm.next_in), e.strstart), e.strstart += a, e.insert += a > e.w_size - e.insert ? e.w_size - e.insert : a), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), s ? 4 : t !== VL && t !== jL && 0 === e.strm.avail_in && e.strstart === e.block_start ? 2 : (r = e.window_size - e.strstart, e.strm.avail_in > r && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, r += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), r > e.strm.avail_in && (r = e.strm.avail_in), r && (Rk(e.strm, e.window, e.strstart, r), e.strstart += r, e.insert += r > e.w_size - e.insert ? e.w_size - e.insert : r), e.high_water < e.strstart && (e.high_water = e.strstart), r = e.bi_valid + 42 >> 3, r = e.pending_buf_size - r > 65535 ? 65535 : e.pending_buf_size - r, o = r > e.w_size ? e.w_size : r, n = e.strstart - e.block_start, (n >= o || (n || t === jL) && t !== VL && 0 === e.strm.avail_in && n <= r) && (i = n > r ? r : n, s = t === jL && 0 === e.strm.avail_in && i === n ? 1 : 0, kL(e, e.block_start, i, s), e.block_start += i, fk(e.strm)), s ? 3 : 1);\n    },\n    yk = (e, t) => {\n      let i, n;\n      for (;;) {\n        if (e.lookahead < ck) {\n          if (vk(e), e.lookahead < ck && t === VL) return 1;\n          if (0 === e.lookahead) break;\n        }\n        if (i = 0, e.lookahead >= 3 && (e.ins_h = mk(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== i && e.strstart - i <= e.w_size - ck && (e.match_length = Ck(e, i)), e.match_length >= 3) {\n          if (n = UL(e, e.strstart - e.match_start, e.match_length - 3), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= 3) {\n            e.match_length--;\n            do {\n              e.strstart++, e.ins_h = mk(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;\n            } while (0 != --e.match_length);\n            e.strstart++;\n          } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = mk(e, e.ins_h, e.window[e.strstart + 1]);\n        } else n = UL(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;\n        if (n && (Tk(e, !1), 0 === e.strm.avail_out)) return 1;\n      }\n      return e.insert = e.strstart < 2 ? e.strstart : 2, t === jL ? (Tk(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Tk(e, !1), 0 === e.strm.avail_out) ? 1 : 2;\n    },\n    Ak = (e, t) => {\n      let i, n, r;\n      for (;;) {\n        if (e.lookahead < ck) {\n          if (vk(e), e.lookahead < ck && t === VL) return 1;\n          if (0 === e.lookahead) break;\n        }\n        if (i = 0, e.lookahead >= 3 && (e.ins_h = mk(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = 2, 0 !== i && e.prev_length < e.max_lazy_match && e.strstart - i <= e.w_size - ck && (e.match_length = Ck(e, i), e.match_length <= 5 && (e.strategy === JL || 3 === e.match_length && e.strstart - e.match_start > 4096) && (e.match_length = 2)), e.prev_length >= 3 && e.match_length <= e.prev_length) {\n          r = e.strstart + e.lookahead - 3, n = UL(e, e.strstart - 1 - e.prev_match, e.prev_length - 3), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;\n          do {\n            ++e.strstart <= r && (e.ins_h = mk(e, e.ins_h, e.window[e.strstart + 3 - 1]), i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);\n          } while (0 != --e.prev_length);\n          if (e.match_available = 0, e.match_length = 2, e.strstart++, n && (Tk(e, !1), 0 === e.strm.avail_out)) return 1;\n        } else if (e.match_available) {\n          if (n = UL(e, 0, e.window[e.strstart - 1]), n && Tk(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return 1;\n        } else e.match_available = 1, e.strstart++, e.lookahead--;\n      }\n      return e.match_available && (n = UL(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < 2 ? e.strstart : 2, t === jL ? (Tk(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Tk(e, !1), 0 === e.strm.avail_out) ? 1 : 2;\n    };\n  function bk(e, t, i, n, r) {\n    this.good_length = e, this.max_lazy = t, this.nice_length = i, this.max_chain = n, this.func = r;\n  }\n  const wk = [new bk(0, 0, 0, 0, Ik), new bk(4, 4, 8, 4, yk), new bk(4, 5, 16, 8, yk), new bk(4, 6, 32, 32, yk), new bk(4, 4, 16, 16, Ak), new bk(8, 16, 32, 32, Ak), new bk(8, 16, 128, 128, Ak), new bk(8, 32, 128, 256, Ak), new bk(32, 128, 258, 1024, Ak), new bk(32, 258, 258, 4096, Ak)];\n  function Ok() {\n    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = tk, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * ok), this.dyn_dtree = new Uint16Array(2 * (2 * nk + 1)), this.bl_tree = new Uint16Array(2 * (2 * rk + 1)), _k(this.dyn_ltree), _k(this.dyn_dtree), _k(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(sk + 1), this.heap = new Uint16Array(2 * ik + 1), _k(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * ik + 1), _k(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;\n  }\n  const Nk = e => {\n      if (!e) return 1;\n      const t = e.state;\n      return !t || t.strm !== e || t.status !== dk && 57 !== t.status && 69 !== t.status && 73 !== t.status && 91 !== t.status && 103 !== t.status && t.status !== lk && t.status !== hk ? 1 : 0;\n    },\n    Dk = e => {\n      if (Nk(e)) return uk(e, KL);\n      e.total_in = e.total_out = 0, e.data_type = ek;\n      const t = e.state;\n      return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = 2 === t.wrap ? 57 : t.wrap ? dk : lk, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = -2, LL(t), WL;\n    },\n    Pk = e => {\n      const t = Dk(e);\n      return t === WL && (e => {\n        e.window_size = 2 * e.w_size, _k(e.head), e.max_lazy_match = wk[e.level].max_lazy, e.good_match = wk[e.level].good_length, e.nice_match = wk[e.level].nice_length, e.max_chain_length = wk[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = 2, e.match_available = 0, e.ins_h = 0;\n      })(e.state), t;\n    },\n    Lk = (e, t, i, n, r, o) => {\n      if (!e) return KL;\n      let s = 1;\n      if (t === zL && (t = 6), n < 0 ? (s = 0, n = -n) : n > 15 && (s = 2, n -= 16), r < 1 || r > 9 || i !== tk || n < 8 || n > 15 || t < 0 || t > 9 || o < 0 || o > ZL || 8 === n && 1 !== s) return uk(e, KL);\n      8 === n && (n = 9);\n      const a = new Ok();\n      return e.state = a, a.strm = e, a.status = dk, a.wrap = s, a.gzhead = null, a.w_bits = n, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = r + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + 3 - 1) / 3), a.window = new Uint8Array(2 * a.w_size), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << r + 6, a.pending_buf_size = 4 * a.lit_bufsize, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = 3 * (a.lit_bufsize - 1), a.level = t, a.strategy = o, a.method = i, Pk(e);\n    };\n  var kk = (e, t) => {\n      if (Nk(e) || t > GL || t < 0) return e ? uk(e, KL) : KL;\n      const i = e.state;\n      if (!e.output || 0 !== e.avail_in && !e.input || i.status === hk && t !== jL) return uk(e, 0 === e.avail_out ? qL : KL);\n      const n = i.last_flush;\n      if (i.last_flush = t, 0 !== i.pending) {\n        if (fk(e), 0 === e.avail_out) return i.last_flush = -1, WL;\n      } else if (0 === e.avail_in && pk(t) <= pk(n) && t !== jL) return uk(e, qL);\n      if (i.status === hk && 0 !== e.avail_in) return uk(e, qL);\n      if (i.status === dk && 0 === i.wrap && (i.status = lk), i.status === dk) {\n        let t = tk + (i.w_bits - 8 << 4) << 8,\n          n = -1;\n        if (n = i.strategy >= XL || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3, t |= n << 6, 0 !== i.strstart && (t |= 32), t += 31 - t % 31, gk(i, t), 0 !== i.strstart && (gk(i, e.adler >>> 16), gk(i, 65535 & e.adler)), e.adler = 1, i.status = lk, fk(e), 0 !== i.pending) return i.last_flush = -1, WL;\n      }\n      if (57 === i.status) if (e.adler = 0, Sk(i, 31), Sk(i, 139), Sk(i, 8), i.gzhead) Sk(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), Sk(i, 255 & i.gzhead.time), Sk(i, i.gzhead.time >> 8 & 255), Sk(i, i.gzhead.time >> 16 & 255), Sk(i, i.gzhead.time >> 24 & 255), Sk(i, 9 === i.level ? 2 : i.strategy >= XL || i.level < 2 ? 4 : 0), Sk(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (Sk(i, 255 & i.gzhead.extra.length), Sk(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (e.adler = NL(e.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69;else if (Sk(i, 0), Sk(i, 0), Sk(i, 0), Sk(i, 0), Sk(i, 0), Sk(i, 9 === i.level ? 2 : i.strategy >= XL || i.level < 2 ? 4 : 0), Sk(i, 3), i.status = lk, fk(e), 0 !== i.pending) return i.last_flush = -1, WL;\n      if (69 === i.status) {\n        if (i.gzhead.extra) {\n          let t = i.pending,\n            n = (65535 & i.gzhead.extra.length) - i.gzindex;\n          for (; i.pending + n > i.pending_buf_size;) {\n            let r = i.pending_buf_size - i.pending;\n            if (i.pending_buf.set(i.gzhead.extra.subarray(i.gzindex, i.gzindex + r), i.pending), i.pending = i.pending_buf_size, i.gzhead.hcrc && i.pending > t && (e.adler = NL(e.adler, i.pending_buf, i.pending - t, t)), i.gzindex += r, fk(e), 0 !== i.pending) return i.last_flush = -1, WL;\n            t = 0, n -= r;\n          }\n          let r = new Uint8Array(i.gzhead.extra);\n          i.pending_buf.set(r.subarray(i.gzindex, i.gzindex + n), i.pending), i.pending += n, i.gzhead.hcrc && i.pending > t && (e.adler = NL(e.adler, i.pending_buf, i.pending - t, t)), i.gzindex = 0;\n        }\n        i.status = 73;\n      }\n      if (73 === i.status) {\n        if (i.gzhead.name) {\n          let t,\n            n = i.pending;\n          do {\n            if (i.pending === i.pending_buf_size) {\n              if (i.gzhead.hcrc && i.pending > n && (e.adler = NL(e.adler, i.pending_buf, i.pending - n, n)), fk(e), 0 !== i.pending) return i.last_flush = -1, WL;\n              n = 0;\n            }\n            t = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, Sk(i, t);\n          } while (0 !== t);\n          i.gzhead.hcrc && i.pending > n && (e.adler = NL(e.adler, i.pending_buf, i.pending - n, n)), i.gzindex = 0;\n        }\n        i.status = 91;\n      }\n      if (91 === i.status) {\n        if (i.gzhead.comment) {\n          let t,\n            n = i.pending;\n          do {\n            if (i.pending === i.pending_buf_size) {\n              if (i.gzhead.hcrc && i.pending > n && (e.adler = NL(e.adler, i.pending_buf, i.pending - n, n)), fk(e), 0 !== i.pending) return i.last_flush = -1, WL;\n              n = 0;\n            }\n            t = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, Sk(i, t);\n          } while (0 !== t);\n          i.gzhead.hcrc && i.pending > n && (e.adler = NL(e.adler, i.pending_buf, i.pending - n, n));\n        }\n        i.status = 103;\n      }\n      if (103 === i.status) {\n        if (i.gzhead.hcrc) {\n          if (i.pending + 2 > i.pending_buf_size && (fk(e), 0 !== i.pending)) return i.last_flush = -1, WL;\n          Sk(i, 255 & e.adler), Sk(i, e.adler >> 8 & 255), e.adler = 0;\n        }\n        if (i.status = lk, fk(e), 0 !== i.pending) return i.last_flush = -1, WL;\n      }\n      if (0 !== e.avail_in || 0 !== i.lookahead || t !== VL && i.status !== hk) {\n        let n = 0 === i.level ? Ik(i, t) : i.strategy === XL ? ((e, t) => {\n          let i;\n          for (;;) {\n            if (0 === e.lookahead && (vk(e), 0 === e.lookahead)) {\n              if (t === VL) return 1;\n              break;\n            }\n            if (e.match_length = 0, i = UL(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, i && (Tk(e, !1), 0 === e.strm.avail_out)) return 1;\n          }\n          return e.insert = 0, t === jL ? (Tk(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Tk(e, !1), 0 === e.strm.avail_out) ? 1 : 2;\n        })(i, t) : i.strategy === QL ? ((e, t) => {\n          let i, n, r, o;\n          const s = e.window;\n          for (;;) {\n            if (e.lookahead <= ak) {\n              if (vk(e), e.lookahead <= ak && t === VL) return 1;\n              if (0 === e.lookahead) break;\n            }\n            if (e.match_length = 0, e.lookahead >= 3 && e.strstart > 0 && (r = e.strstart - 1, n = s[r], n === s[++r] && n === s[++r] && n === s[++r])) {\n              o = e.strstart + ak;\n              do {} while (n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && r < o);\n              e.match_length = ak - (o - r), e.match_length > e.lookahead && (e.match_length = e.lookahead);\n            }\n            if (e.match_length >= 3 ? (i = UL(e, 1, e.match_length - 3), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (i = UL(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), i && (Tk(e, !1), 0 === e.strm.avail_out)) return 1;\n          }\n          return e.insert = 0, t === jL ? (Tk(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Tk(e, !1), 0 === e.strm.avail_out) ? 1 : 2;\n        })(i, t) : wk[i.level].func(i, t);\n        if (3 !== n && 4 !== n || (i.status = hk), 1 === n || 3 === n) return 0 === e.avail_out && (i.last_flush = -1), WL;\n        if (2 === n && (t === FL ? xL(i) : t !== GL && (kL(i, 0, 0, !1), t === BL && (_k(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), fk(e), 0 === e.avail_out)) return i.last_flush = -1, WL;\n      }\n      return t !== jL ? WL : i.wrap <= 0 ? HL : (2 === i.wrap ? (Sk(i, 255 & e.adler), Sk(i, e.adler >> 8 & 255), Sk(i, e.adler >> 16 & 255), Sk(i, e.adler >> 24 & 255), Sk(i, 255 & e.total_in), Sk(i, e.total_in >> 8 & 255), Sk(i, e.total_in >> 16 & 255), Sk(i, e.total_in >> 24 & 255)) : (gk(i, e.adler >>> 16), gk(i, 65535 & e.adler)), fk(e), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? WL : HL);\n    },\n    Mk = (e, t) => {\n      let i = t.length;\n      if (Nk(e)) return KL;\n      const n = e.state,\n        r = n.wrap;\n      if (2 === r || 1 === r && n.status !== dk || n.lookahead) return KL;\n      if (1 === r && (e.adler = wL(e.adler, t, i, 0)), n.wrap = 0, i >= n.w_size) {\n        0 === r && (_k(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);\n        let e = new Uint8Array(n.w_size);\n        e.set(t.subarray(i - n.w_size, i), 0), t = e, i = n.w_size;\n      }\n      const o = e.avail_in,\n        s = e.next_in,\n        a = e.input;\n      for (e.avail_in = i, e.next_in = 0, e.input = t, vk(n); n.lookahead >= 3;) {\n        let e = n.strstart,\n          t = n.lookahead - 2;\n        do {\n          n.ins_h = mk(n, n.ins_h, n.window[e + 3 - 1]), n.prev[e & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = e, e++;\n        } while (--t);\n        n.strstart = e, n.lookahead = 2, vk(n);\n      }\n      return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = 2, n.match_available = 0, e.next_in = s, e.input = a, e.avail_in = o, n.wrap = r, WL;\n    },\n    Uk = {\n      deflateInit: (e, t) => Lk(e, t, tk, 15, 8, $L),\n      deflateInit2: Lk,\n      deflateReset: Pk,\n      deflateResetKeep: Dk,\n      deflateSetHeader: (e, t) => Nk(e) || 2 !== e.state.wrap ? KL : (e.state.gzhead = t, WL),\n      deflate: kk,\n      deflateEnd: e => {\n        if (Nk(e)) return KL;\n        const t = e.state.status;\n        return e.state = null, t === lk ? uk(e, YL) : WL;\n      },\n      deflateSetDictionary: Mk,\n      deflateInfo: \"pako deflate (from Nodeca project)\"\n    };\n  const xk = (e, t) => Object.prototype.hasOwnProperty.call(e, t);\n  var Vk = {\n    assign: function (e) {\n      const t = Array.prototype.slice.call(arguments, 1);\n      for (; t.length;) {\n        const i = t.shift();\n        if (i) {\n          if (\"object\" != typeof i) throw new TypeError(i + \"must be non-object\");\n          for (const t in i) xk(i, t) && (e[t] = i[t]);\n        }\n      }\n      return e;\n    },\n    flattenChunks: e => {\n      let t = 0;\n      for (let i = 0, n = e.length; i < n; i++) t += e[i].length;\n      const i = new Uint8Array(t);\n      for (let t = 0, n = 0, r = e.length; t < r; t++) {\n        let r = e[t];\n        i.set(r, n), n += r.length;\n      }\n      return i;\n    }\n  };\n  let Fk = !0;\n  try {\n    String.fromCharCode.apply(null, new Uint8Array(1));\n  } catch (e) {\n    Fk = !1;\n  }\n  const Bk = new Uint8Array(256);\n  for (let e = 0; e < 256; e++) Bk[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;\n  Bk[254] = Bk[254] = 1;\n  var jk = {\n    string2buf: e => {\n      if (\"function\" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(e);\n      let t,\n        i,\n        n,\n        r,\n        o,\n        s = e.length,\n        a = 0;\n      for (r = 0; r < s; r++) i = e.charCodeAt(r), 55296 == (64512 & i) && r + 1 < s && (n = e.charCodeAt(r + 1), 56320 == (64512 & n) && (i = 65536 + (i - 55296 << 10) + (n - 56320), r++)), a += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;\n      for (t = new Uint8Array(a), o = 0, r = 0; o < a; r++) i = e.charCodeAt(r), 55296 == (64512 & i) && r + 1 < s && (n = e.charCodeAt(r + 1), 56320 == (64512 & n) && (i = 65536 + (i - 55296 << 10) + (n - 56320), r++)), i < 128 ? t[o++] = i : i < 2048 ? (t[o++] = 192 | i >>> 6, t[o++] = 128 | 63 & i) : i < 65536 ? (t[o++] = 224 | i >>> 12, t[o++] = 128 | i >>> 6 & 63, t[o++] = 128 | 63 & i) : (t[o++] = 240 | i >>> 18, t[o++] = 128 | i >>> 12 & 63, t[o++] = 128 | i >>> 6 & 63, t[o++] = 128 | 63 & i);\n      return t;\n    },\n    buf2string: (e, t) => {\n      const i = t || e.length;\n      if (\"function\" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(e.subarray(0, t));\n      let n, r;\n      const o = new Array(2 * i);\n      for (r = 0, n = 0; n < i;) {\n        let t = e[n++];\n        if (t < 128) {\n          o[r++] = t;\n          continue;\n        }\n        let s = Bk[t];\n        if (s > 4) o[r++] = 65533, n += s - 1;else {\n          for (t &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && n < i;) t = t << 6 | 63 & e[n++], s--;\n          s > 1 ? o[r++] = 65533 : t < 65536 ? o[r++] = t : (t -= 65536, o[r++] = 55296 | t >> 10 & 1023, o[r++] = 56320 | 1023 & t);\n        }\n      }\n      return ((e, t) => {\n        if (t < 65534 && e.subarray && Fk) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));\n        let i = \"\";\n        for (let n = 0; n < t; n++) i += String.fromCharCode(e[n]);\n        return i;\n      })(o, r);\n    },\n    utf8border: (e, t) => {\n      (t = t || e.length) > e.length && (t = e.length);\n      let i = t - 1;\n      for (; i >= 0 && 128 == (192 & e[i]);) i--;\n      return i < 0 || 0 === i ? t : i + Bk[e[i]] > t ? i : t;\n    }\n  };\n  var Gk = function () {\n    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = \"\", this.state = null, this.data_type = 2, this.adler = 0;\n  };\n  const Wk = Object.prototype.toString,\n    Hk = PL.Z_NO_FLUSH,\n    Kk = PL.Z_SYNC_FLUSH,\n    Yk = PL.Z_FULL_FLUSH,\n    qk = PL.Z_FINISH,\n    zk = PL.Z_OK,\n    Jk = PL.Z_STREAM_END,\n    Xk = PL.Z_DEFAULT_COMPRESSION,\n    Qk = PL.Z_DEFAULT_STRATEGY,\n    Zk = PL.Z_DEFLATED;\n  function $k(e) {\n    this.options = Vk.assign({\n      level: Xk,\n      method: Zk,\n      chunkSize: 16384,\n      windowBits: 15,\n      memLevel: 8,\n      strategy: Qk\n    }, e || {});\n    let t = this.options;\n    t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = \"\", this.ended = !1, this.chunks = [], this.strm = new Gk(), this.strm.avail_out = 0;\n    let i = Uk.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);\n    if (i !== zk) throw new Error(DL[i]);\n    if (t.header && Uk.deflateSetHeader(this.strm, t.header), t.dictionary) {\n      let e;\n      if (e = \"string\" == typeof t.dictionary ? jk.string2buf(t.dictionary) : \"[object ArrayBuffer]\" === Wk.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, i = Uk.deflateSetDictionary(this.strm, e), i !== zk) throw new Error(DL[i]);\n      this._dict_set = !0;\n    }\n  }\n  function eM(e, t) {\n    const i = new $k(t);\n    if (i.push(e, !0), i.err) throw i.msg || DL[i.err];\n    return i.result;\n  }\n  $k.prototype.push = function (e, t) {\n    const i = this.strm,\n      n = this.options.chunkSize;\n    let r, o;\n    if (this.ended) return !1;\n    for (o = t === ~~t ? t : !0 === t ? qk : Hk, \"string\" == typeof e ? i.input = jk.string2buf(e) : \"[object ArrayBuffer]\" === Wk.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length;;) if (0 === i.avail_out && (i.output = new Uint8Array(n), i.next_out = 0, i.avail_out = n), (o === Kk || o === Yk) && i.avail_out <= 6) this.onData(i.output.subarray(0, i.next_out)), i.avail_out = 0;else {\n      if (r = Uk.deflate(i, o), r === Jk) return i.next_out > 0 && this.onData(i.output.subarray(0, i.next_out)), r = Uk.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === zk;\n      if (0 !== i.avail_out) {\n        if (o > 0 && i.next_out > 0) this.onData(i.output.subarray(0, i.next_out)), i.avail_out = 0;else if (0 === i.avail_in) break;\n      } else this.onData(i.output);\n    }\n    return !0;\n  }, $k.prototype.onData = function (e) {\n    this.chunks.push(e);\n  }, $k.prototype.onEnd = function (e) {\n    e === zk && (this.result = Vk.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;\n  };\n  var tM = {\n    Deflate: $k,\n    deflate: eM,\n    deflateRaw: function (e, t) {\n      return (t = t || {}).raw = !0, eM(e, t);\n    },\n    gzip: function (e, t) {\n      return (t = t || {}).gzip = !0, eM(e, t);\n    },\n    constants: PL\n  };\n  const iM = 16209;\n  var nM = function (e, t) {\n    let i, n, r, o, s, a, c, d, l, h, u, p, _, E, m, f, T, S, g, R, C, v, I, y;\n    const A = e.state;\n    i = e.next_in, I = e.input, n = i + (e.avail_in - 5), r = e.next_out, y = e.output, o = r - (t - e.avail_out), s = r + (e.avail_out - 257), a = A.dmax, c = A.wsize, d = A.whave, l = A.wnext, h = A.window, u = A.hold, p = A.bits, _ = A.lencode, E = A.distcode, m = (1 << A.lenbits) - 1, f = (1 << A.distbits) - 1;\n    e: do {\n      p < 15 && (u += I[i++] << p, p += 8, u += I[i++] << p, p += 8), T = _[u & m];\n      t: for (;;) {\n        if (S = T >>> 24, u >>>= S, p -= S, S = T >>> 16 & 255, 0 === S) y[r++] = 65535 & T;else {\n          if (!(16 & S)) {\n            if (0 == (64 & S)) {\n              T = _[(65535 & T) + (u & (1 << S) - 1)];\n              continue t;\n            }\n            if (32 & S) {\n              A.mode = 16191;\n              break e;\n            }\n            e.msg = \"invalid literal/length code\", A.mode = iM;\n            break e;\n          }\n          g = 65535 & T, S &= 15, S && (p < S && (u += I[i++] << p, p += 8), g += u & (1 << S) - 1, u >>>= S, p -= S), p < 15 && (u += I[i++] << p, p += 8, u += I[i++] << p, p += 8), T = E[u & f];\n          i: for (;;) {\n            if (S = T >>> 24, u >>>= S, p -= S, S = T >>> 16 & 255, !(16 & S)) {\n              if (0 == (64 & S)) {\n                T = E[(65535 & T) + (u & (1 << S) - 1)];\n                continue i;\n              }\n              e.msg = \"invalid distance code\", A.mode = iM;\n              break e;\n            }\n            if (R = 65535 & T, S &= 15, p < S && (u += I[i++] << p, p += 8, p < S && (u += I[i++] << p, p += 8)), R += u & (1 << S) - 1, R > a) {\n              e.msg = \"invalid distance too far back\", A.mode = iM;\n              break e;\n            }\n            if (u >>>= S, p -= S, S = r - o, R > S) {\n              if (S = R - S, S > d && A.sane) {\n                e.msg = \"invalid distance too far back\", A.mode = iM;\n                break e;\n              }\n              if (C = 0, v = h, 0 === l) {\n                if (C += c - S, S < g) {\n                  g -= S;\n                  do {\n                    y[r++] = h[C++];\n                  } while (--S);\n                  C = r - R, v = y;\n                }\n              } else if (l < S) {\n                if (C += c + l - S, S -= l, S < g) {\n                  g -= S;\n                  do {\n                    y[r++] = h[C++];\n                  } while (--S);\n                  if (C = 0, l < g) {\n                    S = l, g -= S;\n                    do {\n                      y[r++] = h[C++];\n                    } while (--S);\n                    C = r - R, v = y;\n                  }\n                }\n              } else if (C += l - S, S < g) {\n                g -= S;\n                do {\n                  y[r++] = h[C++];\n                } while (--S);\n                C = r - R, v = y;\n              }\n              for (; g > 2;) y[r++] = v[C++], y[r++] = v[C++], y[r++] = v[C++], g -= 3;\n              g && (y[r++] = v[C++], g > 1 && (y[r++] = v[C++]));\n            } else {\n              C = r - R;\n              do {\n                y[r++] = y[C++], y[r++] = y[C++], y[r++] = y[C++], g -= 3;\n              } while (g > 2);\n              g && (y[r++] = y[C++], g > 1 && (y[r++] = y[C++]));\n            }\n            break;\n          }\n        }\n        break;\n      }\n    } while (i < n && r < s);\n    g = p >> 3, i -= g, p -= g << 3, u &= (1 << p) - 1, e.next_in = i, e.next_out = r, e.avail_in = i < n ? n - i + 5 : 5 - (i - n), e.avail_out = r < s ? s - r + 257 : 257 - (r - s), A.hold = u, A.bits = p;\n  };\n  const rM = 15,\n    oM = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),\n    sM = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),\n    aM = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),\n    cM = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);\n  var dM = (e, t, i, n, r, o, s, a) => {\n    const c = a.bits;\n    let d,\n      l,\n      h,\n      u,\n      p,\n      _,\n      E = 0,\n      m = 0,\n      f = 0,\n      T = 0,\n      S = 0,\n      g = 0,\n      R = 0,\n      C = 0,\n      v = 0,\n      I = 0,\n      y = null;\n    const A = new Uint16Array(16),\n      b = new Uint16Array(16);\n    let w,\n      O,\n      N,\n      D = null;\n    for (E = 0; E <= rM; E++) A[E] = 0;\n    for (m = 0; m < n; m++) A[t[i + m]]++;\n    for (S = c, T = rM; T >= 1 && 0 === A[T]; T--);\n    if (S > T && (S = T), 0 === T) return r[o++] = 20971520, r[o++] = 20971520, a.bits = 1, 0;\n    for (f = 1; f < T && 0 === A[f]; f++);\n    for (S < f && (S = f), C = 1, E = 1; E <= rM; E++) if (C <<= 1, C -= A[E], C < 0) return -1;\n    if (C > 0 && (0 === e || 1 !== T)) return -1;\n    for (b[1] = 0, E = 1; E < rM; E++) b[E + 1] = b[E] + A[E];\n    for (m = 0; m < n; m++) 0 !== t[i + m] && (s[b[t[i + m]]++] = m);\n    if (0 === e ? (y = D = s, _ = 20) : 1 === e ? (y = oM, D = sM, _ = 257) : (y = aM, D = cM, _ = 0), I = 0, m = 0, E = f, p = o, g = S, R = 0, h = -1, v = 1 << S, u = v - 1, 1 === e && v > 852 || 2 === e && v > 592) return 1;\n    for (;;) {\n      w = E - R, s[m] + 1 < _ ? (O = 0, N = s[m]) : s[m] >= _ ? (O = D[s[m] - _], N = y[s[m] - _]) : (O = 96, N = 0), d = 1 << E - R, l = 1 << g, f = l;\n      do {\n        l -= d, r[p + (I >> R) + l] = w << 24 | O << 16 | N | 0;\n      } while (0 !== l);\n      for (d = 1 << E - 1; I & d;) d >>= 1;\n      if (0 !== d ? (I &= d - 1, I += d) : I = 0, m++, 0 == --A[E]) {\n        if (E === T) break;\n        E = t[i + s[m]];\n      }\n      if (E > S && (I & u) !== h) {\n        for (0 === R && (R = S), p += f, g = E - R, C = 1 << g; g + R < T && (C -= A[g + R], !(C <= 0));) g++, C <<= 1;\n        if (v += 1 << g, 1 === e && v > 852 || 2 === e && v > 592) return 1;\n        h = I & u, r[h] = S << 24 | g << 16 | p - o | 0;\n      }\n    }\n    return 0 !== I && (r[p + I] = E - R << 24 | 64 << 16 | 0), a.bits = S, 0;\n  };\n  const lM = PL.Z_FINISH,\n    hM = PL.Z_BLOCK,\n    uM = PL.Z_TREES,\n    pM = PL.Z_OK,\n    _M = PL.Z_STREAM_END,\n    EM = PL.Z_NEED_DICT,\n    mM = PL.Z_STREAM_ERROR,\n    fM = PL.Z_DATA_ERROR,\n    TM = PL.Z_MEM_ERROR,\n    SM = PL.Z_BUF_ERROR,\n    gM = PL.Z_DEFLATED,\n    RM = 16180,\n    CM = 16190,\n    vM = 16191,\n    IM = 16192,\n    yM = 16194,\n    AM = 16199,\n    bM = 16200,\n    wM = 16206,\n    OM = 16209,\n    NM = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);\n  function DM() {\n    this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;\n  }\n  const PM = e => {\n      if (!e) return 1;\n      const t = e.state;\n      return !t || t.strm !== e || t.mode < RM || t.mode > 16211 ? 1 : 0;\n    },\n    LM = e => {\n      if (PM(e)) return mM;\n      const t = e.state;\n      return e.total_in = e.total_out = t.total = 0, e.msg = \"\", t.wrap && (e.adler = 1 & t.wrap), t.mode = RM, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, pM;\n    },\n    kM = e => {\n      if (PM(e)) return mM;\n      const t = e.state;\n      return t.wsize = 0, t.whave = 0, t.wnext = 0, LM(e);\n    },\n    MM = (e, t) => {\n      let i;\n      if (PM(e)) return mM;\n      const n = e.state;\n      return t < 0 ? (i = 0, t = -t) : (i = 5 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? mM : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = i, n.wbits = t, kM(e));\n    },\n    UM = (e, t) => {\n      if (!e) return mM;\n      const i = new DM();\n      e.state = i, i.strm = e, i.window = null, i.mode = RM;\n      const n = MM(e, t);\n      return n !== pM && (e.state = null), n;\n    };\n  let xM,\n    VM,\n    FM = !0;\n  const BM = e => {\n      if (FM) {\n        xM = new Int32Array(512), VM = new Int32Array(32);\n        let t = 0;\n        for (; t < 144;) e.lens[t++] = 8;\n        for (; t < 256;) e.lens[t++] = 9;\n        for (; t < 280;) e.lens[t++] = 7;\n        for (; t < 288;) e.lens[t++] = 8;\n        for (dM(1, e.lens, 0, 288, xM, 0, e.work, {\n          bits: 9\n        }), t = 0; t < 32;) e.lens[t++] = 5;\n        dM(2, e.lens, 0, 32, VM, 0, e.work, {\n          bits: 5\n        }), FM = !1;\n      }\n      e.lencode = xM, e.lenbits = 9, e.distcode = VM, e.distbits = 5;\n    },\n    jM = (e, t, i, n) => {\n      let r;\n      const o = e.state;\n      return null === o.window && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new Uint8Array(o.wsize)), n >= o.wsize ? (o.window.set(t.subarray(i - o.wsize, i), 0), o.wnext = 0, o.whave = o.wsize) : (r = o.wsize - o.wnext, r > n && (r = n), o.window.set(t.subarray(i - n, i - n + r), o.wnext), (n -= r) ? (o.window.set(t.subarray(i - n, i), 0), o.wnext = n, o.whave = o.wsize) : (o.wnext += r, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += r))), 0;\n    };\n  var GM = (e, t) => {\n      let i,\n        n,\n        r,\n        o,\n        s,\n        a,\n        c,\n        d,\n        l,\n        h,\n        u,\n        p,\n        _,\n        E,\n        m,\n        f,\n        T,\n        S,\n        g,\n        R,\n        C,\n        v,\n        I = 0;\n      const y = new Uint8Array(4);\n      let A, b;\n      const w = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n      if (PM(e) || !e.output || !e.input && 0 !== e.avail_in) return mM;\n      i = e.state, i.mode === vM && (i.mode = IM), s = e.next_out, r = e.output, c = e.avail_out, o = e.next_in, n = e.input, a = e.avail_in, d = i.hold, l = i.bits, h = a, u = c, v = pM;\n      e: for (;;) switch (i.mode) {\n        case RM:\n          if (0 === i.wrap) {\n            i.mode = IM;\n            break;\n          }\n          for (; l < 16;) {\n            if (0 === a) break e;\n            a--, d += n[o++] << l, l += 8;\n          }\n          if (2 & i.wrap && 35615 === d) {\n            0 === i.wbits && (i.wbits = 15), i.check = 0, y[0] = 255 & d, y[1] = d >>> 8 & 255, i.check = NL(i.check, y, 2, 0), d = 0, l = 0, i.mode = 16181;\n            break;\n          }\n          if (i.head && (i.head.done = !1), !(1 & i.wrap) || (((255 & d) << 8) + (d >> 8)) % 31) {\n            e.msg = \"incorrect header check\", i.mode = OM;\n            break;\n          }\n          if ((15 & d) !== gM) {\n            e.msg = \"unknown compression method\", i.mode = OM;\n            break;\n          }\n          if (d >>>= 4, l -= 4, C = 8 + (15 & d), 0 === i.wbits && (i.wbits = C), C > 15 || C > i.wbits) {\n            e.msg = \"invalid window size\", i.mode = OM;\n            break;\n          }\n          i.dmax = 1 << i.wbits, i.flags = 0, e.adler = i.check = 1, i.mode = 512 & d ? 16189 : vM, d = 0, l = 0;\n          break;\n        case 16181:\n          for (; l < 16;) {\n            if (0 === a) break e;\n            a--, d += n[o++] << l, l += 8;\n          }\n          if (i.flags = d, (255 & BP(i)) !== gM) {\n            e.msg = \"unknown compression method\", i.mode = OM;\n            break;\n          }\n          if (57344 & BP(i)) {\n            e.msg = \"unknown header flags set\", i.mode = OM;\n            break;\n          }\n          i.head && (i.head.text = d >> 8 & 1), 512 & BP(i) && 4 & i.wrap && (y[0] = 255 & d, y[1] = d >>> 8 & 255, i.check = NL(i.check, y, 2, 0)), d = 0, l = 0, i.mode = 16182;\n        case 16182:\n          for (; l < 32;) {\n            if (0 === a) break e;\n            a--, d += n[o++] << l, l += 8;\n          }\n          i.head && (i.head.time = d), 512 & BP(i) && 4 & i.wrap && (y[0] = 255 & d, y[1] = d >>> 8 & 255, y[2] = d >>> 16 & 255, y[3] = d >>> 24 & 255, i.check = NL(i.check, y, 4, 0)), d = 0, l = 0, i.mode = 16183;\n        case 16183:\n          for (; l < 16;) {\n            if (0 === a) break e;\n            a--, d += n[o++] << l, l += 8;\n          }\n          i.head && (i.head.xflags = 255 & d, i.head.os = d >> 8), 512 & BP(i) && 4 & i.wrap && (y[0] = 255 & d, y[1] = d >>> 8 & 255, i.check = NL(i.check, y, 2, 0)), d = 0, l = 0, i.mode = 16184;\n        case 16184:\n          if (1024 & BP(i)) {\n            for (; l < 16;) {\n              if (0 === a) break e;\n              a--, d += n[o++] << l, l += 8;\n            }\n            i.length = d, i.head && (i.head.extra_len = d), 512 & BP(i) && 4 & i.wrap && (y[0] = 255 & d, y[1] = d >>> 8 & 255, i.check = NL(i.check, y, 2, 0)), d = 0, l = 0;\n          } else i.head && (i.head.extra = null);\n          i.mode = 16185;\n        case 16185:\n          if (1024 & BP(i) && (p = i.length, p > a && (p = a), p && (i.head && (C = i.head.extra_len - i.length, i.head.extra || (i.head.extra = new Uint8Array(i.head.extra_len)), i.head.extra.set(n.subarray(o, o + p), C)), 512 & BP(i) && 4 & i.wrap && (i.check = NL(i.check, n, p, o)), a -= p, o += p, i.length -= p), i.length)) break e;\n          i.length = 0, i.mode = 16186;\n        case 16186:\n          if (2048 & BP(i)) {\n            if (0 === a) break e;\n            p = 0;\n            do {\n              C = n[o + p++], i.head && C && i.length < 65536 && (i.head.name += String.fromCharCode(C));\n            } while (C && p < a);\n            if (512 & BP(i) && 4 & i.wrap && (i.check = NL(i.check, n, p, o)), a -= p, o += p, C) break e;\n          } else i.head && (i.head.name = null);\n          i.length = 0, i.mode = 16187;\n        case 16187:\n          if (4096 & BP(i)) {\n            if (0 === a) break e;\n            p = 0;\n            do {\n              C = n[o + p++], i.head && C && i.length < 65536 && (i.head.comment += String.fromCharCode(C));\n            } while (C && p < a);\n            if (512 & BP(i) && 4 & i.wrap && (i.check = NL(i.check, n, p, o)), a -= p, o += p, C) break e;\n          } else i.head && (i.head.comment = null);\n          i.mode = 16188;\n        case 16188:\n          if (512 & BP(i)) {\n            for (; l < 16;) {\n              if (0 === a) break e;\n              a--, d += n[o++] << l, l += 8;\n            }\n            if (4 & i.wrap && d !== (65535 & i.check)) {\n              e.msg = \"header crc mismatch\", i.mode = OM;\n              break;\n            }\n            d = 0, l = 0;\n          }\n          i.head && (i.head.hcrc = BP(i) >> 9 & 1, i.head.done = !0), e.adler = i.check = 0, i.mode = vM;\n          break;\n        case 16189:\n          for (; l < 32;) {\n            if (0 === a) break e;\n            a--, d += n[o++] << l, l += 8;\n          }\n          e.adler = i.check = NM(d), d = 0, l = 0, i.mode = CM;\n        case CM:\n          if (0 === i.havedict) return e.next_out = s, e.avail_out = c, e.next_in = o, e.avail_in = a, i.hold = d, i.bits = l, EM;\n          e.adler = i.check = 1, i.mode = vM;\n        case vM:\n          if (t === hM || t === uM) break e;\n        case IM:\n          if (i.last) {\n            d >>>= 7 & l, l -= 7 & l, i.mode = wM;\n            break;\n          }\n          for (; l < 3;) {\n            if (0 === a) break e;\n            a--, d += n[o++] << l, l += 8;\n          }\n          switch (i.last = 1 & d, d >>>= 1, l -= 1, 3 & d) {\n            case 0:\n              i.mode = 16193;\n              break;\n            case 1:\n              if (BM(i), i.mode = AM, t === uM) {\n                d >>>= 2, l -= 2;\n                break e;\n              }\n              break;\n            case 2:\n              i.mode = 16196;\n              break;\n            case 3:\n              e.msg = \"invalid block type\", i.mode = OM;\n          }\n          d >>>= 2, l -= 2;\n          break;\n        case 16193:\n          for (d >>>= 7 & l, l -= 7 & l; l < 32;) {\n            if (0 === a) break e;\n            a--, d += n[o++] << l, l += 8;\n          }\n          if ((65535 & d) != (d >>> 16 ^ 65535)) {\n            e.msg = \"invalid stored block lengths\", i.mode = OM;\n            break;\n          }\n          if (i.length = 65535 & d, d = 0, l = 0, i.mode = yM, t === uM) break e;\n        case yM:\n          i.mode = 16195;\n        case 16195:\n          if (p = i.length, p) {\n            if (p > a && (p = a), p > c && (p = c), 0 === p) break e;\n            r.set(n.subarray(o, o + p), s), a -= p, o += p, c -= p, s += p, i.length -= p;\n            break;\n          }\n          i.mode = vM;\n          break;\n        case 16196:\n          for (; l < 14;) {\n            if (0 === a) break e;\n            a--, d += n[o++] << l, l += 8;\n          }\n          if (i.nlen = 257 + (31 & d), d >>>= 5, l -= 5, i.ndist = 1 + (31 & d), d >>>= 5, l -= 5, i.ncode = 4 + (15 & d), d >>>= 4, l -= 4, i.nlen > 286 || i.ndist > 30) {\n            e.msg = \"too many length or distance symbols\", i.mode = OM;\n            break;\n          }\n          i.have = 0, i.mode = 16197;\n        case 16197:\n          for (; i.have < i.ncode;) {\n            for (; l < 3;) {\n              if (0 === a) break e;\n              a--, d += n[o++] << l, l += 8;\n            }\n            i.lens[w[i.have++]] = 7 & d, d >>>= 3, l -= 3;\n          }\n          for (; i.have < 19;) i.lens[w[i.have++]] = 0;\n          if (i.lencode = i.lendyn, i.lenbits = 7, A = {\n            bits: i.lenbits\n          }, v = dM(0, i.lens, 0, 19, i.lencode, 0, i.work, A), i.lenbits = A.bits, v) {\n            e.msg = \"invalid code lengths set\", i.mode = OM;\n            break;\n          }\n          i.have = 0, i.mode = 16198;\n        case 16198:\n          for (; i.have < i.nlen + i.ndist;) {\n            for (; I = i.lencode[d & (1 << i.lenbits) - 1], m = I >>> 24, f = I >>> 16 & 255, T = 65535 & I, !(m <= l);) {\n              if (0 === a) break e;\n              a--, d += n[o++] << l, l += 8;\n            }\n            if (T < 16) d >>>= m, l -= m, i.lens[i.have++] = T;else {\n              if (16 === T) {\n                for (b = m + 2; l < b;) {\n                  if (0 === a) break e;\n                  a--, d += n[o++] << l, l += 8;\n                }\n                if (d >>>= m, l -= m, 0 === i.have) {\n                  e.msg = \"invalid bit length repeat\", i.mode = OM;\n                  break;\n                }\n                C = i.lens[i.have - 1], p = 3 + (3 & d), d >>>= 2, l -= 2;\n              } else if (17 === T) {\n                for (b = m + 3; l < b;) {\n                  if (0 === a) break e;\n                  a--, d += n[o++] << l, l += 8;\n                }\n                d >>>= m, l -= m, C = 0, p = 3 + (7 & d), d >>>= 3, l -= 3;\n              } else {\n                for (b = m + 7; l < b;) {\n                  if (0 === a) break e;\n                  a--, d += n[o++] << l, l += 8;\n                }\n                d >>>= m, l -= m, C = 0, p = 11 + (127 & d), d >>>= 7, l -= 7;\n              }\n              if (i.have + p > i.nlen + i.ndist) {\n                e.msg = \"invalid bit length repeat\", i.mode = OM;\n                break;\n              }\n              for (; p--;) i.lens[i.have++] = C;\n            }\n          }\n          if (i.mode === OM) break;\n          if (0 === i.lens[256]) {\n            e.msg = \"invalid code -- missing end-of-block\", i.mode = OM;\n            break;\n          }\n          if (i.lenbits = 9, A = {\n            bits: i.lenbits\n          }, v = dM(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, A), i.lenbits = A.bits, v) {\n            e.msg = \"invalid literal/lengths set\", i.mode = OM;\n            break;\n          }\n          if (i.distbits = 6, i.distcode = i.distdyn, A = {\n            bits: i.distbits\n          }, v = dM(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, A), i.distbits = A.bits, v) {\n            e.msg = \"invalid distances set\", i.mode = OM;\n            break;\n          }\n          if (i.mode = AM, t === uM) break e;\n        case AM:\n          i.mode = bM;\n        case bM:\n          if (a >= 6 && c >= 258) {\n            e.next_out = s, e.avail_out = c, e.next_in = o, e.avail_in = a, i.hold = d, i.bits = l, nM(e, u), s = e.next_out, r = e.output, c = e.avail_out, o = e.next_in, n = e.input, a = e.avail_in, d = i.hold, l = i.bits, i.mode === vM && (i.back = -1);\n            break;\n          }\n          for (i.back = 0; I = i.lencode[d & (1 << i.lenbits) - 1], m = I >>> 24, f = I >>> 16 & 255, T = 65535 & I, !(m <= l);) {\n            if (0 === a) break e;\n            a--, d += n[o++] << l, l += 8;\n          }\n          if (f && 0 == (240 & f)) {\n            for (S = m, g = f, R = T; I = i.lencode[R + ((d & (1 << S + g) - 1) >> S)], m = I >>> 24, f = I >>> 16 & 255, T = 65535 & I, !(S + m <= l);) {\n              if (0 === a) break e;\n              a--, d += n[o++] << l, l += 8;\n            }\n            d >>>= S, l -= S, i.back += S;\n          }\n          if (d >>>= m, l -= m, i.back += m, i.length = T, 0 === f) {\n            i.mode = 16205;\n            break;\n          }\n          if (32 & f) {\n            i.back = -1, i.mode = vM;\n            break;\n          }\n          if (64 & f) {\n            e.msg = \"invalid literal/length code\", i.mode = OM;\n            break;\n          }\n          i.extra = 15 & f, i.mode = 16201;\n        case 16201:\n          if (i.extra) {\n            for (b = i.extra; l < b;) {\n              if (0 === a) break e;\n              a--, d += n[o++] << l, l += 8;\n            }\n            i.length += d & (1 << i.extra) - 1, d >>>= i.extra, l -= i.extra, i.back += i.extra;\n          }\n          i.was = i.length, i.mode = 16202;\n        case 16202:\n          for (; I = i.distcode[d & (1 << i.distbits) - 1], m = I >>> 24, f = I >>> 16 & 255, T = 65535 & I, !(m <= l);) {\n            if (0 === a) break e;\n            a--, d += n[o++] << l, l += 8;\n          }\n          if (0 == (240 & f)) {\n            for (S = m, g = f, R = T; I = i.distcode[R + ((d & (1 << S + g) - 1) >> S)], m = I >>> 24, f = I >>> 16 & 255, T = 65535 & I, !(S + m <= l);) {\n              if (0 === a) break e;\n              a--, d += n[o++] << l, l += 8;\n            }\n            d >>>= S, l -= S, i.back += S;\n          }\n          if (d >>>= m, l -= m, i.back += m, 64 & f) {\n            e.msg = \"invalid distance code\", i.mode = OM;\n            break;\n          }\n          i.offset = T, i.extra = 15 & f, i.mode = 16203;\n        case 16203:\n          if (i.extra) {\n            for (b = i.extra; l < b;) {\n              if (0 === a) break e;\n              a--, d += n[o++] << l, l += 8;\n            }\n            i.offset += d & (1 << i.extra) - 1, d >>>= i.extra, l -= i.extra, i.back += i.extra;\n          }\n          if (i.offset > i.dmax) {\n            e.msg = \"invalid distance too far back\", i.mode = OM;\n            break;\n          }\n          i.mode = 16204;\n        case 16204:\n          if (0 === c) break e;\n          if (p = u - c, i.offset > p) {\n            if (p = i.offset - p, p > i.whave && i.sane) {\n              e.msg = \"invalid distance too far back\", i.mode = OM;\n              break;\n            }\n            p > i.wnext ? (p -= i.wnext, _ = i.wsize - p) : _ = i.wnext - p, p > i.length && (p = i.length), E = i.window;\n          } else E = r, _ = s - i.offset, p = i.length;\n          p > c && (p = c), c -= p, i.length -= p;\n          do {\n            r[s++] = E[_++];\n          } while (--p);\n          0 === i.length && (i.mode = bM);\n          break;\n        case 16205:\n          if (0 === c) break e;\n          r[s++] = i.length, c--, i.mode = bM;\n          break;\n        case wM:\n          if (i.wrap) {\n            for (; l < 32;) {\n              if (0 === a) break e;\n              a--, d |= n[o++] << l, l += 8;\n            }\n            if (u -= c, e.total_out += u, i.total += u, 4 & i.wrap && u && (e.adler = i.check = BP(i) ? NL(i.check, r, u, s - u) : wL(i.check, r, u, s - u)), u = c, 4 & i.wrap && (BP(i) ? d : NM(d)) !== i.check) {\n              e.msg = \"incorrect data check\", i.mode = OM;\n              break;\n            }\n            d = 0, l = 0;\n          }\n          i.mode = 16207;\n        case 16207:\n          if (i.wrap && BP(i)) {\n            for (; l < 32;) {\n              if (0 === a) break e;\n              a--, d += n[o++] << l, l += 8;\n            }\n            if (4 & i.wrap && d !== (4294967295 & i.total)) {\n              e.msg = \"incorrect length check\", i.mode = OM;\n              break;\n            }\n            d = 0, l = 0;\n          }\n          i.mode = 16208;\n        case 16208:\n          v = _M;\n          break e;\n        case OM:\n          v = fM;\n          break e;\n        case 16210:\n          return TM;\n        default:\n          return mM;\n      }\n      return e.next_out = s, e.avail_out = c, e.next_in = o, e.avail_in = a, i.hold = d, i.bits = l, (i.wsize || u !== e.avail_out && i.mode < OM && (i.mode < wM || t !== lM)) && jM(e, e.output, e.next_out, u - e.avail_out), h -= e.avail_in, u -= e.avail_out, e.total_in += h, e.total_out += u, i.total += u, 4 & i.wrap && u && (e.adler = i.check = BP(i) ? NL(i.check, r, u, e.next_out - u) : wL(i.check, r, u, e.next_out - u)), e.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === vM ? 128 : 0) + (i.mode === AM || i.mode === yM ? 256 : 0), (0 === h && 0 === u || t === lM) && v === pM && (v = SM), v;\n    },\n    WM = {\n      inflateReset: kM,\n      inflateReset2: MM,\n      inflateResetKeep: LM,\n      inflateInit: e => UM(e, 15),\n      inflateInit2: UM,\n      inflate: GM,\n      inflateEnd: e => {\n        if (PM(e)) return mM;\n        let t = e.state;\n        return t.window && (t.window = null), e.state = null, pM;\n      },\n      inflateGetHeader: (e, t) => {\n        if (PM(e)) return mM;\n        const i = e.state;\n        return 0 == (2 & i.wrap) ? mM : (i.head = t, t.done = !1, pM);\n      },\n      inflateSetDictionary: (e, t) => {\n        const i = t.length;\n        let n, r, o;\n        return PM(e) ? mM : (n = e.state, 0 !== n.wrap && n.mode !== CM ? mM : n.mode === CM && (r = 1, r = wL(r, t, i, 0), r !== n.check) ? fM : (o = jM(e, t, i, i), o ? (n.mode = 16210, TM) : (n.havedict = 1, pM)));\n      },\n      inflateInfo: \"pako inflate (from Nodeca project)\"\n    };\n  var HM = function () {\n    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = \"\", this.comment = \"\", this.hcrc = 0, this.done = !1;\n  };\n  const KM = Object.prototype.toString,\n    YM = PL.Z_NO_FLUSH,\n    qM = PL.Z_FINISH,\n    zM = PL.Z_OK,\n    JM = PL.Z_STREAM_END,\n    XM = PL.Z_NEED_DICT,\n    QM = PL.Z_STREAM_ERROR,\n    ZM = PL.Z_DATA_ERROR,\n    $M = PL.Z_MEM_ERROR;\n  function eU(e) {\n    this.options = Vk.assign({\n      chunkSize: 65536,\n      windowBits: 15,\n      to: \"\"\n    }, e || {});\n    const t = this.options;\n    t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = \"\", this.ended = !1, this.chunks = [], this.strm = new Gk(), this.strm.avail_out = 0;\n    let i = WM.inflateInit2(this.strm, t.windowBits);\n    if (i !== zM) throw new Error(DL[i]);\n    if (this.header = new HM(), WM.inflateGetHeader(this.strm, this.header), t.dictionary && (\"string\" == typeof t.dictionary ? t.dictionary = jk.string2buf(t.dictionary) : \"[object ArrayBuffer]\" === KM.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (i = WM.inflateSetDictionary(this.strm, t.dictionary), i !== zM))) throw new Error(DL[i]);\n  }\n  function tU(e, t) {\n    const i = new eU(t);\n    if (i.push(e), i.err) throw i.msg || DL[i.err];\n    return i.result;\n  }\n  eU.prototype.push = function (e, t) {\n    const i = this.strm,\n      n = this.options.chunkSize,\n      r = this.options.dictionary;\n    let o, s, a;\n    if (this.ended) return !1;\n    for (s = t === ~~t ? t : !0 === t ? qM : YM, \"[object ArrayBuffer]\" === KM.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length;;) {\n      for (0 === i.avail_out && (i.output = new Uint8Array(n), i.next_out = 0, i.avail_out = n), o = WM.inflate(i, s), o === XM && r && (o = WM.inflateSetDictionary(i, r), o === zM ? o = WM.inflate(i, s) : o === ZM && (o = XM)); i.avail_in > 0 && o === JM && i.state.wrap > 0 && 0 !== e[i.next_in];) WM.inflateReset(i), o = WM.inflate(i, s);\n      switch (o) {\n        case QM:\n        case ZM:\n        case XM:\n        case $M:\n          return this.onEnd(o), this.ended = !0, !1;\n      }\n      if (a = i.avail_out, i.next_out && (0 === i.avail_out || o === JM)) if (\"string\" === this.options.to) {\n        let e = jk.utf8border(i.output, i.next_out),\n          t = i.next_out - e,\n          r = jk.buf2string(i.output, e);\n        i.next_out = t, i.avail_out = n - t, t && i.output.set(i.output.subarray(e, e + t), 0), this.onData(r);\n      } else this.onData(i.output.length === i.next_out ? i.output : i.output.subarray(0, i.next_out));\n      if (o !== zM || 0 !== a) {\n        if (o === JM) return o = WM.inflateEnd(this.strm), this.onEnd(o), this.ended = !0, !0;\n        if (0 === i.avail_in) break;\n      }\n    }\n    return !0;\n  }, eU.prototype.onData = function (e) {\n    this.chunks.push(e);\n  }, eU.prototype.onEnd = function (e) {\n    e === zM && (\"string\" === this.options.to ? this.result = this.chunks.join(\"\") : this.result = Vk.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;\n  };\n  var iU = {\n    Inflate: eU,\n    inflate: tU,\n    inflateRaw: function (e, t) {\n      return (t = t || {}).raw = !0, tU(e, t);\n    },\n    ungzip: tU,\n    constants: PL\n  };\n  const nU = tM.Deflate,\n    rU = tM.deflate,\n    oU = tM.deflateRaw,\n    sU = tM.gzip,\n    aU = iU.Inflate,\n    cU = iU.inflate,\n    dU = iU.inflateRaw,\n    lU = iU.ungzip;\n  var hU = rU,\n    uU = cU;\n  const pU = {\n    getDisplayMedia: !1,\n    getStreamFromExtension: !1,\n    supportUnifiedPlan: !1,\n    supportMinBitrate: !1,\n    supportSetRtpSenderParameters: !1,\n    supportDualStream: !0,\n    webAudioMediaStreamDest: !1,\n    supportReplaceTrack: !1,\n    supportWebGL: !1,\n    webAudioWithAEC: !1,\n    supportRequestFrame: !1,\n    supportShareAudio: !1,\n    supportDualStreamEncoding: !1,\n    supportDataChannel: !1,\n    supportPCSetConfiguration: !1,\n    supportWebRTCEncodedTransform: !1,\n    supportWebRTCInsertableStream: !1,\n    supportRequestVideoFrameCallback: !1,\n    supportWebCrypto: !1\n  };\n  function _U() {\n    return pU;\n  }\n  function EU() {\n    return \"setSinkId\" in HTMLAudioElement.prototype && (!Dy(\"RESTRICTION_SET_PLAYBACK_DEVICE\") || (Ov() || Dv()) && !zv());\n  }\n  let mU = function (e) {\n    return e.IOS_15_16_INTERRUPTION_START = \"ios15_16-interruption-start\", e.IOS_15_16_INTERRUPTION_END = \"ios15_16-interruption-end\", e.IOS_INTERRUPTION_START = \"ios-interruption-start\", e.IOS_INTERRUPTION_END = \"ios-interruption-end\", e.STATE_CHANGE = \"state-change\", e;\n  }({});\n  function fU(e, t, i) {\n    return {\n      sampleRate: e,\n      stereo: t,\n      bitrate: i\n    };\n  }\n  function TU(e, t, i, n, r) {\n    return {\n      width: e,\n      height: t,\n      frameRate: i,\n      bitrateMin: n,\n      bitrateMax: r\n    };\n  }\n  function SU(e, t, i, n, r) {\n    return {\n      width: {\n        max: e\n      },\n      height: {\n        max: t\n      },\n      frameRate: i,\n      bitrateMin: n,\n      bitrateMax: r\n    };\n  }\n  function gU(e, t) {\n    return {\n      numSpatialLayers: e,\n      numTemporalLayers: t\n    };\n  }\n  const RU = {\n      \"90p\": TU(160, 90),\n      \"90p_1\": TU(160, 90),\n      \"120p\": TU(160, 120, 15, 30, 65),\n      \"120p_1\": TU(160, 120, 15, 30, 65),\n      \"120p_3\": TU(120, 120, 15, 30, 50),\n      \"120p_4\": TU(212, 120),\n      \"180p\": TU(320, 180, 15, 30, 140),\n      \"180p_1\": TU(320, 180, 15, 30, 140),\n      \"180p_3\": TU(180, 180, 15, 30, 100),\n      \"180p_4\": TU(240, 180, 15, 30, 120),\n      \"240p\": TU(320, 240, 15, 40, 200),\n      \"240p_1\": TU(320, 240, 15, 40, 200),\n      \"240p_3\": TU(240, 240, 15, 40, 140),\n      \"240p_4\": TU(424, 240, 15, 40, 220),\n      \"360p\": TU(640, 360, 15, 80, 400),\n      \"360p_1\": TU(640, 360, 15, 80, 400),\n      \"360p_3\": TU(360, 360, 15, 80, 260),\n      \"360p_4\": TU(640, 360, 30, 80, 600),\n      \"360p_6\": TU(360, 360, 30, 80, 400),\n      \"360p_7\": TU(480, 360, 15, 80, 320),\n      \"360p_8\": TU(480, 360, 30, 80, 490),\n      \"360p_9\": TU(640, 360, 15, 80, 800),\n      \"360p_10\": TU(640, 360, 24, 80, 800),\n      \"360p_11\": TU(640, 360, 24, 80, 1e3),\n      \"480p\": TU(640, 480, 15, 100, 500),\n      \"480p_1\": TU(640, 480, 15, 100, 500),\n      \"480p_2\": TU(640, 480, 30, 100, 1e3),\n      \"480p_3\": TU(480, 480, 15, 100, 400),\n      \"480p_4\": TU(640, 480, 30, 100, 750),\n      \"480p_6\": TU(480, 480, 30, 100, 600),\n      \"480p_8\": TU(848, 480, 15, 100, 610),\n      \"480p_9\": TU(848, 480, 30, 100, 930),\n      \"480p_10\": TU(640, 480, 10, 100, 400),\n      \"720p\": TU(1280, 720, 15, 120, 1130),\n      \"720p_auto\": TU(1280, 720, 30, 900, 3e3),\n      \"720p_1\": TU(1280, 720, 15, 120, 1130),\n      \"720p_2\": TU(1280, 720, 30, 120, 2e3),\n      \"720p_3\": TU(1280, 720, 30, 120, 1710),\n      \"720p_5\": TU(960, 720, 15, 120, 910),\n      \"720p_6\": TU(960, 720, 30, 120, 1380),\n      \"1080p\": TU(1920, 1080, 15, 120, 2080),\n      \"1080p_1\": TU(1920, 1080, 15, 120, 2080),\n      \"1080p_2\": TU(1920, 1080, 30, 120, 3e3),\n      \"1080p_3\": TU(1920, 1080, 30, 120, 3150),\n      \"1080p_5\": TU(1920, 1080, 60, 120, 4780),\n      \"1440p\": TU(2560, 1440, 30, 120, 4850),\n      \"1440p_1\": TU(2560, 1440, 30, 120, 4850),\n      \"1440p_2\": TU(2560, 1440, 60, 120, 7350),\n      \"4k\": TU(3840, 2160, 30, 120, 8910),\n      \"4k_1\": TU(3840, 2160, 30, 120, 8910),\n      \"4k_3\": TU(3840, 2160, 60, 120, 13500)\n    },\n    CU = [{\n      scaleResolutionDownBy: 2,\n      width: 1280,\n      height: 720,\n      frameRate: 30,\n      bitrateMin: 300,\n      bitrateMax: 900\n    }, {\n      scaleResolutionDownBy: 1.333333,\n      width: 1280,\n      height: 720,\n      frameRate: 30,\n      bitrateMin: 600,\n      bitrateMax: 2e3\n    }, {\n      scaleResolutionDownBy: 1,\n      width: 1280,\n      height: 720,\n      frameRate: 30,\n      bitrateMin: 900,\n      bitrateMax: 3e3\n    }],\n    vU = {\n      \"480p\": SU(640, 480, 5),\n      \"480p_1\": SU(640, 480, 5),\n      \"480p_2\": SU(640, 480, 30),\n      \"480p_3\": SU(640, 480, 15),\n      \"720p\": SU(1280, 720, 5),\n      \"720p_auto\": TU(1280, 720, 30, 900, 3e3),\n      \"720p_1\": SU(1280, 720, 5),\n      \"720p_2\": SU(1280, 720, 30),\n      \"720p_3\": SU(1280, 720, 15),\n      \"1080p\": SU(1920, 1080, 5),\n      \"1080p_1\": SU(1920, 1080, 5),\n      \"1080p_2\": SU(1920, 1080, 30),\n      \"1080p_3\": SU(1920, 1080, 15)\n    },\n    IU = {\n      \"1SL1TL\": gU(1, 1),\n      \"3SL3TL\": gU(3, 3),\n      \"2SL3TL\": gU(2, 3)\n    };\n  function yU(e) {\n    return e || (e = \"480p_1\"), \"string\" == typeof e ? Object.assign({}, RU[e]) : e;\n  }\n  function AU(e) {\n    return \"string\" == typeof e ? Object.assign({}, vU[e]) : e;\n  }\n  function bU(e) {\n    return \"string\" == typeof e ? Object.assign({}, IU[e]) : e;\n  }\n  const wU = {\n    speech_low_quality: fU(16e3, !1),\n    speech_standard: fU(32e3, !1, 18),\n    music_standard: fU(48e3, !1),\n    standard_stereo: fU(48e3, !0, 56),\n    high_quality: fU(48e3, !1, 128),\n    high_quality_stereo: fU(48e3, !0, 192)\n  };\n  function OU(e) {\n    return \"string\" == typeof e ? Object.assign({}, wU[e]) : e;\n  }\n  const NU = [];\n  function DU(e) {\n    return rI(e, \"mediaSource\", [\"screen\", \"window\", \"application\"]), !0;\n  }\n  let PU = function (e) {\n      return e.NEED_RENEGOTIATE = \"@need_renegotiate\", e.NEED_REPLACE_TRACK = \"@need_replace_track\", e.NEED_REPLACE_MIXING_TRACK = \"@need_replace_mixing_track\", e.NEED_CLOSE = \"@need_close\", e.NEED_ENABLE_TRACK = \"@need_enable_track\", e.NEED_DISABLE_TRACK = \"@need_disable_track\", e.NEED_SESSION_ID = \"@need_sid\", e.SET_OPTIMIZATION_MODE = \"@set_optimization_mode\", e.GET_STATS = \"@get_stats\", e.GET_RTC_STATS = \"@get_rtc_stats\", e.GET_LOW_VIDEO_TRACK = \"@get_low_video_track\", e.NEED_RESET_REMOTE_SDP = \"@need_reset_remote_sdp\", e.NEED_UPDATE_VIDEO_ENCODER = \"@need_update_video_encoder\", e.NEED_UPDATE_VIDEO_SEND_PARAMETERS = \"@need_update_video_send_parameters\", e.NEED_MUTE_TRACK = \"@need_mute_track\", e.NEED_UNMUTE_TRACK = \"@need_unmute_track\", e;\n    }({}),\n    LU = function (e) {\n      return e.SCREEN_TRACK = \"screen_track\", e.CUSTOM_TRACK = \"custome_track\", e.LOW_STREAM = \"low_stream\", e;\n    }({});\n  let kU = function (e) {\n      return e[e.HIGH_STREAM = 0] = \"HIGH_STREAM\", e[e.LOW_STREAM = 1] = \"LOW_STREAM\", e;\n    }({}),\n    MU = function (e) {\n      return e[e.HIGH_STREAM = 0] = \"HIGH_STREAM\", e[e.LOW_STREAM = 1] = \"LOW_STREAM\", e;\n    }({}),\n    UU = function (e) {\n      return e[e.DISABLE = 0] = \"DISABLE\", e[e.LOW_STREAM = 1] = \"LOW_STREAM\", e[e.AUDIO_ONLY = 2] = \"AUDIO_ONLY\", e;\n    }({}),\n    xU = function (e) {\n      return e.TRANSCEIVER_UPDATED = \"transceiver-updated\", e.SEI_TO_SEND = \"sei-to-send\", e.SEI_RECEIVED = \"sei-received\", e.TRACK_UPDATED = \"track-updated\", e;\n    }({}),\n    VU = function (e) {\n      return e.SOURCE_STATE_CHANGE = \"source-state-change\", e.TRACK_ENDED = \"track-ended\", e.BEAUTY_EFFECT_OVERLOAD = \"beauty-effect-overload\", e.VIDEO_ELEMENT_VISIBLE_STATUS = \"video-element-visible-status\", e.CLOSED = \"closed\", e;\n    }({}),\n    FU = function (e) {\n      return e.FIRST_FRAME_DECODED = \"first-frame-decoded\", e.VIDEO_ELEMENT_VISIBLE_STATUS = \"video-element-visible-status\", e.VIDEO_STATE_CHANGED = \"video-state-changed\", e;\n    }({}),\n    BU = function (e) {\n      return e.AUDIO_SOURCE_STATE_CHANGE = \"audio_source_state_change\", e.RECEIVE_TRACK_BUFFER = \"receive_track_buffer\", e.ON_AUDIO_BUFFER = \"on_audio_buffer\", e.UPDATE_SOURCE = \"update_source\", e;\n    }({});\n  !function (e) {\n    e.UPDATE_TRACK_SOURCE = \"update-track-source\";\n  }({});\n  const jU = {\n      sendVolumeLevel: 0,\n      sendBitrate: 0,\n      sendBytes: 0,\n      sendPackets: 0,\n      sendPacketsLost: 0,\n      sendJitterMs: 0,\n      sendRttMs: 0,\n      currentPacketLossRate: 0\n    },\n    GU = {\n      sendBytes: 0,\n      sendBitrate: 0,\n      sendPackets: 0,\n      sendPacketsLost: 0,\n      sendJitterMs: 0,\n      sendRttMs: 0,\n      sendResolutionHeight: 0,\n      sendResolutionWidth: 0,\n      captureResolutionHeight: 0,\n      captureResolutionWidth: 0,\n      targetSendBitrate: 0,\n      totalDuration: 0,\n      totalFreezeTime: 0,\n      currentPacketLossRate: 0\n    },\n    WU = {\n      transportDelay: 0,\n      end2EndDelay: 0,\n      receiveBitrate: 0,\n      receiveLevel: 0,\n      receiveBytes: 0,\n      receiveDelay: 0,\n      receivePackets: 0,\n      receivePacketsLost: 0,\n      totalDuration: 0,\n      totalFreezeTime: 0,\n      freezeRate: 0,\n      packetLossRate: 0,\n      currentPacketLossRate: 0,\n      publishDuration: -1\n    },\n    HU = {\n      uplinkNetworkQuality: 0,\n      downlinkNetworkQuality: 0\n    },\n    KU = {\n      transportDelay: 0,\n      end2EndDelay: 0,\n      receiveBitrate: 0,\n      receiveBytes: 0,\n      receiveDelay: 0,\n      receivePackets: 0,\n      receivePacketsLost: 0,\n      receiveResolutionHeight: 0,\n      receiveResolutionWidth: 0,\n      totalDuration: 0,\n      totalFreezeTime: 0,\n      freezeRate: 0,\n      packetLossRate: 0,\n      currentPacketLossRate: 0,\n      publishDuration: -1\n    };\n  let YU = function (e) {\n      return e.ON_TRACK = \"on_track\", e.ON_NODE = \"on_node\", e;\n    }({}),\n    qU = function (e) {\n      return e.REQUEST_UPDATE_CONSTRAINTS = \"request_update_constraints\", e.REQUEST_CONSTRAINTS = \"request_constraints\", e;\n    }({}),\n    zU = function (e) {\n      return e.IDLE = \"IDLE\", e.INITING = \"INITING\", e.INITEND = \"INITEND\", e;\n    }({}),\n    JU = function (e) {\n      return e.STATE_CHANGE = \"state_change\", e.RECORDING_DEVICE_CHANGED = \"recordingDeviceChanged\", e.PLAYOUT_DEVICE_CHANGED = \"playoutDeviceChanged\", e.CAMERA_DEVICE_CHANGED = \"cameraDeviceChanged\", e;\n    }({}),\n    XU = function (e) {\n      return e.NONE = \"none\", e.INIT = \"init\", e.CANPLAY = \"canplay\", e.PLAYING = \"playing\", e.PAUSED = \"paused\", e.SUSPEND = \"suspend\", e.STALLED = \"stalled\", e.WAITING = \"waiting\", e.ERROR = \"error\", e.DESTROYED = \"destroyed\", e.ABORT = \"abort\", e.ENDED = \"ended\", e.EMPTIED = \"emptied\", e.LOADEDDATA = \"loadeddata\", e;\n    }({}),\n    QU = function (e) {\n      return e[e.VideoStateStopped = 0] = \"VideoStateStopped\", e[e.VideoStateStarting = 1] = \"VideoStateStarting\", e[e.VideoStateDecoding = 2] = \"VideoStateDecoding\", e[e.VideoStateFrozen = 3] = \"VideoStateFrozen\", e;\n    }({});\n  const ZU = {\n    uninit: 100,\n    none: 110,\n    init: 120,\n    loadeddata: 130,\n    canplay: 200,\n    playing: 210,\n    paused: 220,\n    suspend: 300,\n    stalled: 310,\n    waiting: 320,\n    error: 330,\n    destroyed: 340,\n    abort: 350,\n    ended: 360,\n    emptied: 370\n  };\n  let $U = function (e) {\n    return e.OPEN = \"open\", e.MESSAGE = \"message\", e.CLOSE = \"close\", e.CLOSING = \"closing\", e.ERROR = \"error\", e;\n  }({});\n  function ex(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function tx(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? ex(Object(i), !0).forEach(function (t) {\n        ix(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : ex(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function ix(e, t, i) {\n    return (t = function (e) {\n      var t = function (e, t) {\n        if (\"object\" != typeof e || null === e) return e;\n        var i = e[Symbol.toPrimitive];\n        if (void 0 !== i) {\n          var n = i.call(e, \"string\");\n          if (\"object\" != typeof n) return n;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return String(e);\n      }(e);\n      return \"symbol\" == typeof t ? t : String(t);\n    }(t)) in e ? Object.defineProperty(e, t, {\n      value: i,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = i, e;\n  }\n  function nx(e, t, i, n, r) {\n    var o,\n      s,\n      a = {};\n    return Object.keys(n).forEach(function (e) {\n      a[e] = n[e];\n    }), a.enumerable = !!a.enumerable, a.configurable = !!a.configurable, (\"value\" in a || a.initializer) && (a.writable = !0), a = Jn(o = $O(s = i.slice()).call(s)).call(o, function (i, n) {\n      return n(e, t, i) || i;\n    }, a), r && void 0 !== a.initializer && (a.value = a.initializer ? a.initializer.call(r) : void 0, a.initializer = void 0), void 0 === a.initializer && (Object.defineProperty(e, t, a), a = null), a;\n  }\n  class rx extends SI {\n    set _mediaStreamTrack(e) {\n      e !== this.mediaStreamTrack && (this.safeEmit(xU.TRACK_UPDATED, e), this.mediaStreamTrack = e);\n    }\n    get _mediaStreamTrack() {\n      return this.mediaStreamTrack;\n    }\n    constructor(e, t) {\n      super(), ix(this, \"trackMediaType\", void 0), ix(this, \"_ID\", void 0), ix(this, \"_rtpTransceiver\", void 0), ix(this, \"_lowRtpTransceiver\", void 0), ix(this, \"_hints\", []), ix(this, \"_isClosed\", !1), ix(this, \"_originMediaStreamTrack\", void 0), ix(this, \"mediaStreamTrack\", void 0), ix(this, \"_external\", {}), this._ID = t || ey(8, \"track-\"), this._originMediaStreamTrack = e, this.mediaStreamTrack = e, function (e) {\n        Dn(NU).call(NU, e) || NU.push(e);\n      }(this);\n    }\n    toString() {\n      return this._ID;\n    }\n    getTrackId() {\n      return this._ID;\n    }\n    getMediaStreamTrack(e) {\n      return e || KI(() => {\n        var e;\n        oA.reportApiInvoke(null, {\n          name: CI.GET_MEDIA_STREAM_TRACK,\n          options: [],\n          tag: vI.TRACER\n        }).onSuccess((null === (e = this._mediaStreamTrack) || void 0 === e ? void 0 : e.label) || \"\");\n      }, this.mediaStreamTrack.id || this.getTrackId()), this._mediaStreamTrack;\n    }\n    getRTCRtpTransceiver(e) {\n      return e === kU.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;\n    }\n    getMediaStreamTrackSettings() {\n      return this.getMediaStreamTrack(!0).getSettings();\n    }\n    close() {\n      this._isClosed = !0, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function (e) {\n        const t = NU.indexOf(e);\n        -1 !== t && NU.splice(t, 1);\n      }(this), this.emit(VU.CLOSED), this.removeAllListeners(xU.SEI_RECEIVED);\n    }\n    _updateRtpTransceiver(e, t) {\n      if (t === kU.LOW_STREAM) {\n        if (this._lowRtpTransceiver === e) return;\n        this._lowRtpTransceiver = e;\n      } else {\n        if (this._rtpTransceiver === e) return;\n        this._rtpTransceiver = e;\n      }\n      this.emit(xU.TRANSCEIVER_UPDATED, e, t);\n    }\n  }\n  class ox extends rx {\n    get isExternalTrack() {\n      return this._isExternalTrack;\n    }\n    get muted() {\n      return this._muted;\n    }\n    get enabled() {\n      return this._enabled;\n    }\n    get processorContext() {\n      return this._processorContext;\n    }\n    constructor(e, t) {\n      super(e, t), ix(this, \"_enabled\", !0), ix(this, \"_muted\", !1), ix(this, \"_isExternalTrack\", !1), ix(this, \"_isClosed\", !1), ix(this, \"_enabledMutex\", void 0), ix(this, \"processor\", void 0), ix(this, \"_processorContext\", void 0), ix(this, \"_handleTrackEnded\", () => {\n        this.onTrackEnded();\n      }), this._enabledMutex = new uy(\"\".concat(this.getTrackId())), e.addEventListener(\"ended\", this._handleTrackEnded);\n    }\n    getTrackLabel() {\n      var e, t;\n      return null !== (e = null === (t = this._originMediaStreamTrack) || void 0 === t ? void 0 : t.label) && void 0 !== e ? e : \"\";\n    }\n    close() {\n      this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, Qy.debug(\"[\".concat(this.getTrackId(), \"] close\")), this.emit(PU.NEED_CLOSE), super.close());\n    }\n    async _updateOriginMediaStreamTrack(e, t) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      this._isExternalTrack = i, e !== this._originMediaStreamTrack && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener(\"ended\", this._handleTrackEnded), t && this._originMediaStreamTrack.stop()), e.addEventListener(\"ended\", this._handleTrackEnded), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = !1), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await MI(this, PU.NEED_REPLACE_TRACK, this), this.processor && this._processorContext && this.processor.updateInput({\n        track: this._originMediaStreamTrack,\n        context: this._processorContext\n      }));\n    }\n    _getDefaultPlayerConfig() {\n      return {};\n    }\n    onTrackEnded() {\n      Qy.debug(\"[\".concat(this.getTrackId(), \"] track ended\")), this.safeEmit(VU.TRACK_ENDED);\n    }\n    stateCheck(e, t) {\n      if (Qy.debug(\"check track state, [muted: \".concat(this._muted, \", enabled: \").concat(this._enabled, \"] to [\").concat(e, \": \").concat(t, \"]\")), nI(t, e), this._enabled && this._muted && \"enabled\" === e && !1 === t) throw new iI(tI.TRACK_STATE_UNREACHABLE, \"cannot set enabled while the track is muted\").print(\"error\", Qy);\n      if (!this._enabled && !this._muted && \"muted\" === e && !0 === t) throw new iI(tI.TRACK_STATE_UNREACHABLE, \"cannot set muted while the track is disabled\").print(\"error\", Qy);\n    }\n    getProcessorStats() {\n      return this._processorContext && this._processorContext.gatherStats() || [];\n    }\n    getProcessorUsage() {\n      return this._processorContext ? this._processorContext.gatherUsage() : Gu.resolve([]);\n    }\n  }\n  const sx = window.AudioContext || window.webkitAudioContext;\n  let ax = null;\n  const cx = new class extends SI {\n    constructor() {\n      super(...arguments), ix(this, \"prevState\", void 0), ix(this, \"curState\", void 0), ix(this, \"currentTime\", void 0), ix(this, \"currentTimeStuckAt\", void 0), ix(this, \"interruptDetectorTrack\", void 0), ix(this, \"onLocalAudioTrackMute\", () => {\n        Qy.info(\"ios15-interruption-start\"), this.emit(mU.IOS_15_16_INTERRUPTION_START);\n      }), ix(this, \"onLocalAudioTrackUnmute\", async () => {\n        Qy.info(\"ios15-interruption-end\"), \"running\" !== this.curState || this.duringInterruption ? Qy.info(\"ios15-interruption-end-canceled\") : (ax && (await ax.suspend()), this.emit(mU.IOS_15_16_INTERRUPTION_END));\n      });\n    }\n    get duringInterruption() {\n      return \"running\" === this.prevState && \"interrupted\" === this.curState;\n    }\n    bindInterruptDetectorTrack(e) {\n      Qy.debug(\"webaudio bindInterruptDetectorTrack \".concat(e.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);\n    }\n    unbindInterruptDetectorTrack(e) {\n      Qy.debug(\"webaudio unbindInterruptDetectorTrack \".concat(e.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);\n    }\n  }();\n  function dx() {\n    if (!ax) {\n      if (function () {\n        if (!sx) return void Qy.error(\"your browser is not support web audio\");\n        Qy.info(\"create audio context\");\n        const e = tx({}, Dy(\"WEBAUDIO_INIT_OPTIONS\"));\n        Qy.debug(\"audio context init option:\", JSON.stringify(e)), ax = new sx(e), cx.curState = ax.state, ax.onstatechange = () => {\n          cx.prevState = cx.curState, cx.curState = ax ? ax.state : void 0;\n          const e = cx.prevState,\n            t = cx.curState,\n            i = \"running\" === t,\n            n = \"interrupted\" === t,\n            r = \"running\" === e,\n            o = \"suspended\" === e,\n            s = \"interrupted\" === e,\n            a = Iv().osVersion;\n          (Lv() || Kv()) && r && n && (Qy.info(\"ios\".concat(a, \"-interruption-start\")), cx.emit(mU.IOS_INTERRUPTION_START)), (Lv() || Kv()) && (o || s) && i && (Qy.info(\"ios\".concat(a, \"-interruption-end\")), cx.emit(mU.IOS_INTERRUPTION_END)), e !== t && cx.emit(mU.STATE_CHANGE, t, e);\n        }, setInterval(() => {\n          var e;\n          const t = null === (e = ax) || void 0 === e ? void 0 : e.currentTime;\n          cx.currentTime !== t ? (cx.currentTimeStuckAt && (Qy.debug(\"AudioContext current time resume at \".concat(t)), cx.currentTimeStuckAt = void 0), cx.currentTime = t) : (t !== cx.currentTimeStuckAt && (oA.reportApiInvoke(null, {\n            name: \"WEB_AUDIO_CURRENT_TIME_STUCK\",\n            options: {\n              currentTime: t\n            },\n            tag: vI.TRACER\n          }).onSuccess(), Qy.warning(\"AudioContext current time stuck at \".concat(t))), cx.currentTimeStuckAt = t);\n        }, 5e3), async function (e) {\n          const t = [\"click\", \"contextmenu\", \"auxclick\", \"dblclick\", \"mousedown\", \"mouseup\", \"touchend\", \"keydown\", \"keyup\"];\n          let i,\n            n = !1,\n            r = !1,\n            o = !1;\n          function s(t) {\n            \"running\" === e.state ? a(!1) : Lv() || Kv() ? \"suspended\" === e.state && (a(!0), t && e.resume().then(c, c)) : \"closed\" !== e.state && (a(!0), t && e.resume().then(c, c));\n          }\n          function a(e) {\n            if (n !== e) {\n              n = e;\n              for (let i = 0, n = t; i < n.length; i += 1) {\n                const t = n[i];\n                e ? window.addEventListener(t, d, {\n                  capture: !0,\n                  passive: !0\n                }) : window.removeEventListener(t, d, {\n                  capture: !0,\n                  passive: !0\n                });\n              }\n            }\n          }\n          function c() {\n            s(!1);\n          }\n          function d() {\n            s(!0);\n          }\n          function l(e) {\n            if (!o) if (i.paused) {\n              if (e) {\n                let t;\n                h(!1), o = !0;\n                try {\n                  t = i.play(), t ? t.then(u, u) : (i.addEventListener(\"playing\", u), i.addEventListener(\"abort\", u), i.addEventListener(\"error\", u));\n                } catch (e) {\n                  u();\n                }\n              } else h(!0);\n            } else h(!1);\n          }\n          function h(e) {\n            if (r !== e) {\n              r = e;\n              for (let i = 0, n = t; i < n.length; i++) {\n                const t = n[i];\n                e ? window.addEventListener(t, p, {\n                  capture: !0,\n                  passive: !0\n                }) : window.removeEventListener(t, p, {\n                  capture: !0,\n                  passive: !0\n                });\n              }\n            }\n          }\n          function u() {\n            i.removeEventListener(\"playing\", u), i.removeEventListener(\"abort\", u), i.removeEventListener(\"error\", u), o = !1, l(!1);\n          }\n          function p() {\n            l(!0);\n          }\n          if (Lv()) {\n            const t = e.createMediaStreamDestination(),\n              n = document.createElement(\"div\");\n            n.innerHTML = \"<audio x-webkit-airplay='deny'></audio>\", i = n.children.item(0), i.controls = !1, i.disableRemotePlayback = !0, i.preload = \"auto\", i.srcObject = t.stream, l(!0);\n          }\n          cx.on(mU.STATE_CHANGE, function () {\n            s(!0);\n          }), s(!1);\n        }(ax);\n      }(), !ax) throw new iI(tI.NOT_SUPPORTED, \"can not create audio context\");\n      return ax;\n    }\n    return ax;\n  }\n  function lx(e) {\n    if (function () {\n      if (null !== hx) return hx;\n      const e = dx(),\n        t = e.createBufferSource(),\n        i = e.createGain(),\n        n = e.createGain();\n      t.connect(i), t.connect(n), t.disconnect(i);\n      let r = !1;\n      try {\n        t.disconnect(i);\n      } catch (e) {\n        r = !0;\n      }\n      return t.disconnect(), hx = r, r;\n    }()) return;\n    const t = e.connect,\n      i = e.disconnect;\n    e.connect = (i, n, r) => {\n      var o;\n      return e._inputNodes || (e._inputNodes = []), Dn(o = e._inputNodes).call(o, i) || (i instanceof AudioNode ? (e._inputNodes.push(i), t.call(e, i, n, r)) : t.call(e, i, n)), e;\n    }, e.disconnect = (n, r, o) => {\n      i.call(e), n ? FI(e._inputNodes, n) : e._inputNodes = [];\n      for (const i of e._inputNodes) t.call(e, i);\n    };\n  }\n  let hx = null;\n  function ux(e, t) {\n    let i = !1;\n    const n = 1 / t;\n    if (Dy(\"DISABLE_WEBAUDIO\")) {\n      const t = window.setInterval(() => {\n        i ? window.clearInterval(t) : e(performance.now() / 1e3);\n      }, 1e3 * n);\n    } else {\n      const t = dx();\n      let r = t.createGain();\n      r.gain.value = 0, r.connect(t.destination);\n      const o = () => {\n        if (i) return void (r = null);\n        const s = t.createOscillator();\n        s.onended = o, s.connect(r), s.start(0), s.stop(t.currentTime + n), e(t.currentTime);\n      };\n      o();\n    }\n    return () => {\n      i = !0;\n    };\n  }\n  class px {\n    constructor() {\n      ix(this, \"context\", void 0), ix(this, \"analyserNode\", void 0), ix(this, \"sourceNode\", void 0), this.context = dx(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = .4;\n    }\n    updateSource(e) {\n      if (e !== this.sourceNode) {\n        if (this.sourceNode) try {\n          this.sourceNode.disconnect(this.analyserNode);\n        } catch (e) {}\n        this.sourceNode = e, null == e || e.connect(this.analyserNode);\n      }\n    }\n    getVolumeLevel() {\n      if (!this.sourceNode) return 0;\n      if (!this.context || Lv() || Kv() || \"running\" !== this.context.state && this.context.resume(), !this.analyserNode) return 0;\n      const e = new Float32Array(this.analyserNode.fftSize);\n      if (this.analyserNode.getFloatTimeDomainData) this.analyserNode.getFloatTimeDomainData(e);else {\n        const t = new Uint8Array(this.analyserNode.fftSize);\n        this.analyserNode.getByteTimeDomainData(t);\n        for (let i = 0; i < e.length; ++i) e[i] = t[i] / 128 - 1;\n      }\n      const t = Jn(e).call(e, (e, t) => e + t * t, 0) / e.length;\n      return Math.max(10 * Math.log10(t) + 100, 0) / 100;\n    }\n    getAnalyserNode() {\n      return this.analyserNode;\n    }\n    rebuildAnalyser() {\n      try {\n        var e, t;\n        null === (e = this.sourceNode) || void 0 === e || e.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = .4, null === (t = this.sourceNode) || void 0 === t || t.connect(this.analyserNode);\n      } catch (e) {\n        Qy.warning(\"rebuild analyser node failed.\");\n      }\n    }\n    destroy() {\n      this.updateSource(void 0);\n    }\n  }\n  class _x extends SI {\n    get processSourceNode() {\n      return this.sourceNode;\n    }\n    set processedNode(e) {\n      var t;\n      if (!this.isDestroyed && this._processedNode !== e) {\n        try {\n          var i;\n          null === (i = this.sourceNode) || void 0 === i || i.disconnect(this.outputNode);\n        } catch (e) {}\n        null === (t = this._processedNode) || void 0 === t || t.disconnect(), this._processedNode = e, this.connect();\n      }\n    }\n    get processedNode() {\n      return this._processedNode;\n    }\n    constructor() {\n      super(), ix(this, \"outputNode\", void 0), ix(this, \"outputTrack\", void 0), ix(this, \"isPlayed\", !1), ix(this, \"sourceNode\", void 0), ix(this, \"context\", void 0), ix(this, \"audioBufferNode\", void 0), ix(this, \"destNode\", void 0), ix(this, \"audioOutputLevel\", 0), ix(this, \"volumeLevelAnalyser\", void 0), ix(this, \"_processedNode\", void 0), ix(this, \"playNode\", void 0), ix(this, \"isDestroyed\", !1), ix(this, \"onNoAudioInput\", void 0), ix(this, \"isNoAudioInput\", !1), ix(this, \"_noAudioInputCount\", 0), this.context = dx(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), lx(this.outputNode), this.volumeLevelAnalyser = new px();\n    }\n    startGetAudioBuffer(e) {\n      this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = e => {\n        this.emit(BU.ON_AUDIO_BUFFER, function (e) {\n          for (let t = 0; t < e.outputBuffer.numberOfChannels; t += 1) {\n            const i = e.outputBuffer.getChannelData(t);\n            for (let e = 0; e < i.length; e += 1) i[e] = 0;\n          }\n          return e.inputBuffer;\n        }(e));\n      });\n    }\n    stopGetAudioBuffer() {\n      this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);\n    }\n    createOutputTrack() {\n      if (!_U().webAudioMediaStreamDest) throw new iI(tI.NOT_SUPPORTED, \"your browser is not support audio processor\");\n      return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;\n    }\n    play(e) {\n      \"running\" !== this.context.state && jI(() => {\n        cx.emit(\"autoplay-failed\");\n      }), this.isPlayed = !0, this.playNode = e || this.context.destination, this.outputNode.connect(this.playNode);\n    }\n    stop() {\n      if (this.isPlayed) try {\n        this.outputNode.disconnect(this.playNode);\n      } catch (e) {}\n      this.isPlayed = !1;\n    }\n    getAccurateVolumeLevel() {\n      return this.volumeLevelAnalyser.getVolumeLevel();\n    }\n    async checkHasAudioInput() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;\n      if (e > 5) return this.isNoAudioInput = !0, this.onNoAudioInput && this.onNoAudioInput(), !1;\n      Lv() || Kv() ? \"suspended\" === this.context.state && this.context.resume() : \"running\" !== this.context.state && this.context.resume();\n      const t = this.volumeLevelAnalyser.getAnalyserNode();\n      let i;\n      t.getFloatTimeDomainData ? (i = new Float32Array(t.fftSize), t.getFloatTimeDomainData(i)) : (i = new Uint8Array(t.fftSize), t.getByteTimeDomainData(i));\n      let n = !1;\n      for (let e = 0; e < i.length; e++) 0 !== i[e] && (n = !0);\n      return n ? (this.isNoAudioInput = !1, !0) : (await $I(200), (await this.checkHasAudioInput(e ? e + 1 : 1)) && n);\n    }\n    getAudioVolume() {\n      return this.outputNode.gain.value;\n    }\n    setVolume(e) {\n      this.outputNode.gain.setValueAtTime(e, this.context.currentTime);\n    }\n    destroy() {\n      this.disconnect(), this.stop(), this.isDestroyed = !0, this.onNoAudioInput = void 0;\n    }\n    disconnect() {\n      var e, t;\n      null === (e = this.processedNode) || void 0 === e || e.disconnect(), null === (t = this.sourceNode) || void 0 === t || t.disconnect(), this.outputNode && this.outputNode.disconnect();\n    }\n    connect() {\n      var e;\n      this.processedNode ? null === (e = this.processedNode) || void 0 === e || e.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode), this.volumeLevelAnalyser.updateSource(this.outputNode);\n    }\n  }\n  class Ex extends _x {\n    get isFreeze() {\n      return !1;\n    }\n    constructor(e, t, i) {\n      var n;\n      if (super(), ix(this, \"sourceNode\", void 0), ix(this, \"track\", void 0), ix(this, \"clonedTrack\", void 0), ix(this, \"audioElement\", void 0), ix(this, \"isCurrentTrackCloned\", !1), ix(this, \"isRemoteTrack\", !1), ix(this, \"originVolumeLevelAnalyser\", void 0), ix(this, \"rebuildWebAudio\", async () => {\n        if (Qy.debug(\"ready to rebuild web audio, state:\", this.context.state), this.isNoAudioInput && (await this.checkHasAudioInput()), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener(\"click\", this.rebuildWebAudio, !0), void Qy.debug(\"rebuild web audio success, current volume status\", this.getAccurateVolumeLevel());\n        this.context.resume().then(() => Qy.info(\"resume success\")), Qy.debug(\"rebuild web audio because of ios 12 bugs\"), this.disconnect();\n        const e = this.track;\n        this.track = this.track.clone(), this.isCurrentTrackCloned ? e.stop() : this.isCurrentTrackCloned = !0;\n        const t = new MediaStream([this.track]);\n        this.sourceNode = this.context.createMediaStreamSource(t), lx(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();\n        const i = this.outputNode.gain.value;\n        this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i, this.context.currentTime), lx(this.outputNode), this.emit(BU.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();\n      }), \"audio\" !== e.kind) throw new iI(tI.UNEXPECTED_ERROR);\n      this.track = e;\n      const r = new MediaStream([this.track]);\n      if (this.isRemoteTrack = !!t, this.sourceNode = this.context.createMediaStreamSource(r), lx(this.sourceNode), i) {\n        const e = i.clone();\n        e.enabled = !0, this.clonedTrack = e, Qy.debug(\"create an unmuted track \".concat(e.id, \" from the original track \").concat(i.id, \" to get the volume\"));\n        const t = this.context.createMediaStreamSource(new MediaStream([e]));\n        lx(t), this.originVolumeLevelAnalyser = new px(), this.originVolumeLevelAnalyser.updateSource(t);\n      }\n      this.connect(), this.audioElement = document.createElement(\"audio\"), this.audioElement.srcObject = r;\n      const o = Iv();\n      t && o.os === Sv.IOS && Number(null === (n = o.osVersion) || void 0 === n ? void 0 : n.split(\".\")[0]) < 15 && (cx.on(mU.STATE_CHANGE, () => {\n        \"suspended\" === this.context.state ? document.body.addEventListener(\"click\", this.rebuildWebAudio, !0) : \"running\" === this.context.state && this.rebuildWebAudio();\n      }), this.checkHasAudioInput().then(e => {\n        e || document.body.addEventListener(\"click\", this.rebuildWebAudio, !0);\n      }));\n    }\n    updateTrack(e) {\n      this.sourceNode.disconnect(), this.track = e, this.isCurrentTrackCloned = !1;\n      const t = new MediaStream([e]);\n      this.sourceNode = this.context.createMediaStreamSource(t), lx(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(BU.UPDATE_SOURCE), this.audioElement.srcObject = t;\n    }\n    destroy() {\n      var e;\n      this.audioElement.srcObject = null, this.audioElement.remove(), cx.off(\"state-change\", this.rebuildWebAudio), null === (e = this.originVolumeLevelAnalyser) || void 0 === e || e.destroy(), this.clonedTrack = void 0, super.destroy();\n    }\n    createMediaStreamSourceNode(e) {\n      return this.context.createMediaStreamSource(new MediaStream([e]));\n    }\n    updateOriginTrack(e) {\n      const t = e.clone();\n      t.enabled = !0, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t), Qy.debug(\"create an unmuted track \".concat(t.id, \" from the original track \").concat(e.id, \" to get the volume\"));\n      const i = this.context.createMediaStreamSource(new MediaStream([t]));\n      lx(i), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i);\n    }\n    getOriginVolumeLevel() {\n      return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();\n    }\n  }\n  async function mx(e, t, i) {\n    const n = (e, t) => e ? \"number\" != typeof e ? e.max || e.exact || e.ideal || e.min || t : e : t,\n      r = {\n        audio: !!i && {\n          mandatory: {\n            chromeMediaSource: \"desktop\"\n          }\n        },\n        video: {\n          mandatory: {\n            chromeMediaSource: \"desktop\",\n            chromeMediaSourceId: e,\n            maxHeight: n(t.height, 1080),\n            maxWidth: n(t.width, 1920)\n          }\n        }\n      };\n    return t.frameRate && \"number\" != typeof t.frameRate ? (r.video.mandatory.maxFrameRate = t.frameRate.max, r.video.mandatory.minFrameRate = t.frameRate.min) : \"number\" == typeof t.frameRate && (r.video.mandatory.maxFrameRate = t.frameRate), await navigator.mediaDevices.getUserMedia(r);\n  }\n  async function fx(e, t) {\n    const i = await Tx(e.mediaSource),\n      _await = await function (e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n        return new Gu((i, n) => {\n          const r = document.createElement(\"div\");\n          r.innerText = \"share screen\", r.setAttribute(\"style\", \"text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;\");\n          const o = document.createElement(\"div\");\n          o.setAttribute(\"style\", \"width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;\");\n          const s = document.createElement(\"div\");\n          s.innerText = \"Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.\", s.setAttribute(\"style\", \"height: 12%;\");\n          const a = document.createElement(\"div\");\n          a.setAttribute(\"style\", \"width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;\");\n          const c = document.createElement(\"div\");\n          c.setAttribute(\"style\", \"display: flex; justify-content: space-between; padding: 16px 0;\");\n          const d = document.createElement(\"button\");\n          d.innerHTML = \"cancel\", d.setAttribute(\"style\", \"width: 85px;\"), d.onclick = () => {\n            document.body.removeChild(u);\n            const e = new Error(\"NotAllowedError\");\n            e.name = \"NotAllowedError\", n(e);\n          };\n          let l = t;\n          const h = document.createElement(\"div\");\n          if (t) {\n            const e = document.createElement(\"input\");\n            e.setAttribute(\"type\", \"checkbox\");\n            const t = document.createElement(\"span\");\n            e.setAttribute(\"style\", \"margin-right: 6px;\"), t.innerText = \"Share audio\", e.checked = l, e.onchange = () => {\n              l = e.checked;\n            }, h.appendChild(e), h.appendChild(t);\n          }\n          c.appendChild(h), c.appendChild(d), o.appendChild(s), o.appendChild(a), o.appendChild(c);\n          const u = document.createElement(\"div\");\n          u.setAttribute(\"style\", \"position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);\"), u.appendChild(r), u.appendChild(o), document.body.appendChild(u), e.map(e => {\n            if (e.id) {\n              const t = document.createElement(\"div\");\n              t.setAttribute(\"style\", \"width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;\");\n              let n = e.thumbnail;\n              try {\n                const _n$getSize = n.getSize(),\n                  e = _n$getSize.width;\n                e > 1920 && (n = n.resize({\n                  width: 1920\n                }));\n              } catch (e) {\n                throw e && e.message.startsWith(\"Illegal invocation\") && console.error(\"Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)\"), e;\n              }\n              t.innerHTML = '<div style=\"height: 120px; display: table-cell; vertical-align: middle;\"><img style=\"width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);\" src=' + n.toDataURL() + ' /></div><span style=\"\\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;\">' + e.name.replace(/[\\u00A0-\\u9999<>\\&]/g, function (e) {\n                return \"&#\" + e.charCodeAt(0) + \";\";\n              }) + \"</span>\", t.onclick = () => {\n                document.body.removeChild(u), i({\n                  sourceId: e.id,\n                  audio: l\n                });\n              }, a.appendChild(t);\n            }\n          });\n        });\n      }(i, t),\n      n = _await.sourceId,\n      r = _await.audio;\n    return await mx(n, e, r);\n  }\n  async function Tx(e) {\n    let t = [\"window\", \"screen\"];\n    \"application\" !== e && \"window\" !== e || (t = [\"window\"]), \"screen\" === e && (t = [\"screen\"]);\n    const i = RI();\n    if (!i) throw console.error(\"failed to fetch electron, please mount it to window\"), new iI(tI.ELECTRON_IS_NULL);\n    let n = null;\n    try {\n      var r;\n      n = (null === (r = i.desktopCapturer) || void 0 === r ? void 0 : r.getSources({\n        types: t\n      })) || i.ipcRenderer.invoke(\"DESKTOP_CAPTURER_GET_SOURCES\", {\n        types: t\n      });\n    } catch (e) {\n      n = null;\n    }\n    n && n.then || (n = new Gu((e, n) => {\n      i.desktopCapturer.getSources({\n        types: t\n      }, (t, i) => {\n        t ? n(t) : e(i);\n      });\n    }));\n    try {\n      return await n;\n    } catch (e) {\n      throw new iI(tI.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e.toString());\n    }\n  }\n  const Sx = new uy(\"safari\");\n  let gx = !1,\n    Rx = !1;\n  async function Cx(e, t) {\n    let i = 0,\n      n = null;\n    for (; i < 2;) try {\n      n = await vx(e, t, i > 0);\n      break;\n    } catch (e) {\n      if (e instanceof iI) throw Qy.error(\"[\".concat(t, \"] \").concat(e.toString())), e;\n      const n = Ix(e.name || e.code || e, e.message);\n      if (n.code === tI.MEDIA_OPTION_INVALID) {\n        Qy.debug(\"[\".concat(t, \"] detect media option invalid, retry\")), i += 1, await $I(500);\n        continue;\n      }\n      throw Qy.error(\"[\".concat(t, \"] \").concat(n.toString())), n;\n    }\n    if (!n) throw new iI(tI.UNEXPECTED_ERROR, \"can not find stream after getUserMedia\");\n    return n;\n  }\n  async function vx(e, t, i) {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new iI(tI.NOT_SUPPORTED, \"can not find getUserMedia\");\n    i && (e.video && (delete e.video.width, delete e.video.height), e.screen && (delete e.screen.width, delete e.screen.height));\n    const n = _U(),\n      r = new MediaStream();\n    if (e.audioSource && r.addTrack(e.audioSource), e.videoSource && r.addTrack(e.videoSource), !e.audio && !e.video && !e.screen) return Qy.debug(\"Using Video Source/ Audio Source\"), r;\n    if (e.screen) if (RI()) e.screen.sourceId ? yx(r, await mx(e.screen.sourceId, e.screen, e.screenAudio)) : yx(r, await fx(e.screen, e.screenAudio));else if (Ov() && e.screen.extensionId && e.screen.mandatory) {\n      if (!n.getStreamFromExtension) throw new iI(tI.NOT_SUPPORTED, \"This browser does not support screen sharing\");\n      Qy.debug(\"[\".concat(t, '] Screen access on chrome stable, looking for extension\"'));\n      const i = await (s = e.screen.extensionId, a = t, new Gu((e, t) => {\n        try {\n          chrome.runtime.sendMessage(s, {\n            getStream: !0\n          }, i => {\n            if (!i || !i.streamId) return Qy.error(\"[\".concat(a, \"] No response from Chrome Plugin. Plugin not installed properly\"), i), void t(new iI(tI.CHROME_PLUGIN_NO_RESPONSE, \"No response from Chrome Plugin. Plugin not installed properly\"));\n            e(i.streamId);\n          });\n        } catch (e) {\n          Qy.error(\"[\".concat(a, \"] AgoraRTC screensharing plugin is not accessible(\").concat(s, \")\"), e.toString()), t(new iI(tI.CHROME_PLUGIN_NOT_INSTALL));\n        }\n      }));\n      e.screen.mandatory.chromeMediaSourceId = i, yx(r, await navigator.mediaDevices.getUserMedia({\n        video: {\n          mandatory: e.screen.mandatory\n        }\n      }));\n    } else if (n.getDisplayMedia) {\n      var o;\n      e.screen.mediaSource && DU(e.screen.mediaSource);\n      const i = {\n          width: e.screen.width,\n          height: e.screen.height,\n          frameRate: e.screen.frameRate,\n          displaySurface: null !== (o = e.screen.displaySurface) && void 0 !== o ? o : \"screen\" === e.screen.mediaSource ? \"monitor\" : e.screen.mediaSource\n        },\n        _e$screen = e.screen,\n        n = _e$screen.selfBrowserSurface,\n        s = _e$screen.surfaceSwitching,\n        a = _e$screen.systemAudio,\n        c = {\n          selfBrowserSurface: n,\n          surfaceSwitching: s,\n          systemAudio: a\n        };\n      !n && delete c.selfBrowserSurface, !s && delete c.surfaceSwitching, !a && delete c.systemAudio, Qy.debug(\"[\".concat(t, \"] getDisplayMedia:\"), JSON.stringify({\n        video: i,\n        audio: !!e.screenAudio,\n        controls: c\n      })), yx(r, await navigator.mediaDevices.getDisplayMedia(tx({\n        video: i,\n        audio: !!e.screenAudio\n      }, c)));\n    } else {\n      if (!Pv()) throw Qy.error(\"[\".concat(t, \"] This browser does not support screenSharing\")), new iI(tI.NOT_SUPPORTED, \"This browser does not support screen sharing\");\n      {\n        e.screen.mediaSource && DU(e.screen.mediaSource);\n        const i = {\n          video: {\n            mediaSource: e.screen.mediaSource,\n            width: e.screen.width,\n            height: e.screen.height,\n            frameRate: e.screen.frameRate\n          }\n        };\n        Qy.debug(\"[\".concat(t, \"] getUserMedia: \").concat(JSON.stringify(i))), yx(r, await navigator.mediaDevices.getUserMedia(i));\n      }\n    }\n    var s, a;\n    if (!e.video && !e.audio) return r;\n    let c = {\n        video: e.video,\n        audio: e.audio\n      },\n      d = Dy(\"MEDIA_DEVICE_CONSTRAINTS\");\n    if (d) try {\n      \"string\" == typeof d && (d = JSON.parse(d)), c = sy(c, d);\n    } catch (e) {}\n    Qy.debug(\"[\".concat(t, \"] GetUserMedia\"), JSON.stringify(c)), Iv();\n    let l,\n      h = null;\n    (Nv() || Lv() || wv()) && (h = await Sx.lock());\n    try {\n      l = await navigator.mediaDevices.getUserMedia(c);\n    } catch (e) {\n      throw h && h(), e;\n    }\n    return c.audio && (gx = !0), c.video && (Rx = !0), yx(r, l), h && h(), r;\n  }\n  function Ix(e, t) {\n    switch (e) {\n      case \"Starting video failed\":\n      case \"OverconstrainedError\":\n      case \"TrackStartError\":\n        return new iI(tI.MEDIA_OPTION_INVALID, \"\".concat(e, \": \").concat(t));\n      case \"NotFoundError\":\n      case \"DevicesNotFoundError\":\n        return new iI(tI.DEVICE_NOT_FOUND, \"\".concat(e, \": \").concat(t));\n      case \"NotSupportedError\":\n        return new iI(tI.NOT_SUPPORTED, \"\".concat(e, \": \").concat(t));\n      case \"NotReadableError\":\n        return new iI(tI.NOT_READABLE, \"\".concat(e, \": \").concat(t));\n      case \"InvalidStateError\":\n      case \"NotAllowedError\":\n      case \"PERMISSION_DENIED\":\n      case \"PermissionDeniedError\":\n        return new iI(tI.PERMISSION_DENIED, \"\".concat(e, \": \").concat(t));\n      case \"ConstraintNotSatisfiedError\":\n        return new iI(tI.CONSTRAINT_NOT_SATISFIED, \"\".concat(e, \": \").concat(t));\n      default:\n        return Qy.error(\"getUserMedia unexpected error\", e), new iI(tI.UNEXPECTED_ERROR, \"\".concat(e, \": \").concat(t));\n    }\n  }\n  function yx(e, t) {\n    const i = e.getVideoTracks()[0],\n      n = e.getAudioTracks()[0],\n      r = t.getVideoTracks()[0],\n      o = t.getAudioTracks()[0];\n    o && (n && e.removeTrack(n), e.addTrack(o)), r && (i && e.removeTrack(i), e.addTrack(r));\n  }\n  const Ax = new class extends SI {\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      e !== this._state && (this.emit(JU.STATE_CHANGE, e), this._state = e);\n    }\n    constructor() {\n      super(), ix(this, \"_state\", zU.IDLE), ix(this, \"isAccessMicrophonePermission\", !1), ix(this, \"isAccessCameraPermission\", !1), ix(this, \"lastAccessMicrophonePermission\", !1), ix(this, \"lastAccessCameraPermission\", !1), ix(this, \"checkdeviceMatched\", !1), ix(this, \"deviceInfoMap\", new Map()), this.init().then(() => {\n        navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener(\"devicechange\", this.updateDevicesInfo.bind(this)), window.setInterval(() => {\n          (Dy(\"ENUMERATE_DEVICES_INTERVAL\") || (Xv() || Av() === Sv.HARMONY_OS) && Jv()) && this.updateDevicesInfo();\n        }, Dy(\"ENUMERATE_DEVICES_INTERVAL_TIME\"));\n      }).catch(e => Qy.error(e.toString()));\n    }\n    async enumerateDevices(e, t) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return new iI(tI.NOT_SUPPORTED, \"enumerateDevices() not supported.\").throw();\n      const n = await navigator.mediaDevices.enumerateDevices(),\n        r = this.checkMediaDeviceInfoIsOk(n);\n      let o = !this.isAccessMicrophonePermission && e,\n        s = !this.isAccessCameraPermission && t;\n      r.audio && (o = !1), r.video && (s = !1);\n      let a = null,\n        c = null,\n        d = null;\n      if (!i && (o || s)) {\n        if (Sx.isLocked && (Qy.debug(\"[device manager] wait GUM lock\"), (await Sx.lock())(), Qy.debug(\"[device manager] GUM unlock\")), gx && (o = !1, this.isAccessMicrophonePermission = !0), Rx && (s = !1, this.isAccessCameraPermission = !0), Qy.debug(\"[device manager] check media device permissions\", e, t, o, s), o && s) {\n          try {\n            d = await navigator.mediaDevices.getUserMedia({\n              audio: !0,\n              video: !0\n            });\n          } catch (e) {\n            const t = Ix(e.name || e.code || e, e.message);\n            if (t.code === tI.PERMISSION_DENIED) throw t;\n            Qy.warning(\"getUserMedia failed in getDevices\", t);\n          }\n          this.isAccessCameraPermission = !0, this.isAccessMicrophonePermission = !0;\n        } else if (o) {\n          try {\n            a = await navigator.mediaDevices.getUserMedia({\n              audio: e\n            });\n          } catch (e) {\n            const t = Ix(e.name || e.code || e, e.message);\n            if (t.code === tI.PERMISSION_DENIED) throw t;\n            Qy.warning(\"getUserMedia failed in getDevices\", t);\n          }\n          this.isAccessMicrophonePermission = !0;\n        } else if (s) {\n          try {\n            c = await navigator.mediaDevices.getUserMedia({\n              video: t\n            });\n          } catch (e) {\n            const t = Ix(e.name || e.code || e, e.message);\n            if (t.code === tI.PERMISSION_DENIED) throw t;\n            Qy.warning(\"getUserMedia failed in getDevices\", t);\n          }\n          this.isAccessCameraPermission = !0;\n        }\n        Qy.debug(\"[device manager] mic permission\", e, \"cam permission\", t);\n      }\n      try {\n        const e = await navigator.mediaDevices.enumerateDevices();\n        return a && a.getTracks().forEach(e => e.stop()), c && c.getTracks().forEach(e => e.stop()), d && d.getTracks().forEach(e => e.stop()), a = null, c = null, d = null, e;\n      } catch (e) {\n        return a && a.getTracks().forEach(e => e.stop()), c && c.getTracks().forEach(e => e.stop()), d && d.getTracks().forEach(e => e.stop()), a = null, c = null, d = null, new iI(tI.ENUMERATE_DEVICES_FAILED, e.toString()).throw();\n      }\n    }\n    async getRecordingDevices() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      return (await this.enumerateDevices(!0, !1, e)).filter(e => \"audioinput\" === e.kind);\n    }\n    async getCamerasDevices() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      return (await this.enumerateDevices(!1, !0, e)).filter(e => \"videoinput\" === e.kind);\n    }\n    async getSpeakers() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      return (await this.enumerateDevices(!0, !1, e)).filter(e => \"audiooutput\" === e.kind);\n    }\n    searchDeviceIdByName(e) {\n      let t = null;\n      return this.deviceInfoMap.forEach(i => {\n        i.device.label === e && (t = i.device.deviceId);\n      }), t;\n    }\n    async getDeviceById(e) {\n      const t = (await this.enumerateDevices(!0, !0, !0)).find(t => t.deviceId === e);\n      if (!t) throw new iI(tI.DEVICE_NOT_FOUND, \"deviceId: \".concat(e));\n      return t;\n    }\n    async init() {\n      this.state = zU.INITING;\n      try {\n        await this.updateDevicesInfo(), this.state = zU.INITEND;\n      } catch (e) {\n        throw Qy.warning(\"Device Detection functionality cannot start properly.\", e.toString()), this.state = zU.IDLE, (\"boolean\" == typeof isSecureContext ? isSecureContext : \"https:\" === location.protocol || \"file:\" === location.protocol || \"localhost\" === location.hostname || \"127.0.0.1\" === location.hostname || \"::1\" === location.hostname) || new iI(tI.WEB_SECURITY_RESTRICT, \"Your context is limited by web security, please try using https protocol or localhost.\").throw(), e;\n      }\n    }\n    async updateDevicesInfo() {\n      const e = await this.enumerateDevices(!0, !0, !0),\n        t = Date.now(),\n        i = [];\n      if (e[0] && e[0].label && !1 === this.checkdeviceMatched) {\n        this.checkdeviceMatched = !0;\n        const t = e.find(e => \"audioinput\" === e.kind && \"default\" === e.deviceId),\n          i = e.find(e => \"audiooutput\" === e.kind && \"default\" === e.deviceId);\n        t && i ? i.groupId === t.groupId ? Qy.debug(\"[device-check] default input \".concat(t.label, \" and output \").concat(i.label, \" is the same group\")) : Qy.warning(\"[device-check] default input \".concat(t.label, \" and output \").concat(i.label, \" is not the same group\")) : Qy.debug(\"[device-check] default input or output not found\");\n      }\n      const n = this.checkMediaDeviceInfoIsOk(e);\n      if (e.forEach(e => {\n        if (!e.deviceId) return;\n        const n = this.deviceInfoMap.get(\"\".concat(e.kind, \"_\").concat(e.deviceId));\n        if (\"ACTIVE\" !== (n ? n.state : \"INACTIVE\")) {\n          const n = {\n            initAt: t,\n            updateAt: t,\n            device: e,\n            state: \"ACTIVE\"\n          };\n          this.deviceInfoMap.set(\"\".concat(e.kind, \"_\").concat(e.deviceId), n), i.push(n);\n        }\n        n && (n.updateAt = t);\n      }), this.deviceInfoMap.forEach((e, n) => {\n        \"ACTIVE\" === e.state && e.updateAt !== t && (e.state = \"INACTIVE\", i.push(e));\n      }), this.state !== zU.INITEND) return n.audio && (this.lastAccessMicrophonePermission = !0, this.isAccessMicrophonePermission = !0), void (n.video && (this.lastAccessCameraPermission = !0, this.isAccessCameraPermission = !0));\n      i.forEach(e => {\n        switch (e.device.kind) {\n          case \"audioinput\":\n            this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(JU.RECORDING_DEVICE_CHANGED, e);\n            break;\n          case \"videoinput\":\n            this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(JU.CAMERA_DEVICE_CHANGED, e);\n            break;\n          case \"audiooutput\":\n            this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(JU.PLAYOUT_DEVICE_CHANGED, e);\n        }\n      }), n.audio && (this.lastAccessMicrophonePermission = !0, this.isAccessMicrophonePermission = !0), n.video && (this.lastAccessCameraPermission = !0, this.isAccessCameraPermission = !0);\n    }\n    checkMediaDeviceInfoIsOk(e) {\n      const t = e.filter(e => \"audioinput\" === e.kind),\n        i = e.filter(e => \"videoinput\" === e.kind),\n        n = {\n          audio: !1,\n          video: !1\n        };\n      for (const e of t) if (e.label && e.deviceId) {\n        n.audio = !0;\n        break;\n      }\n      for (const e of i) if (e.label && e.deviceId) {\n        n.video = !0;\n        break;\n      }\n      return n;\n    }\n  }();\n  let bx = !1;\n  const wx = new class extends SI {\n    constructor() {\n      super(...arguments), ix(this, \"onAutoplayFailed\", void 0), ix(this, \"onAudioAutoplayFailed\", void 0);\n    }\n  }();\n  function Ox() {\n    if (Iv(), !bx) {\n      const e = t => {\n        t.preventDefault(), bx = !1, Qv() ? document.body.removeEventListener(\"click\", e, !0) : (document.body.removeEventListener(\"touchstart\", e, !0), document.body.removeEventListener(\"mousedown\", e, !0));\n      };\n      bx = !0, Qv() ? document.body.addEventListener(\"click\", e, !0) : (document.body.addEventListener(\"touchstart\", e, !0), document.body.addEventListener(\"mousedown\", e, !0)), Qy.info(\"detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web\"), wx.onAutoplayFailed ? wx.onAutoplayFailed() : wx.onAudioAutoplayFailed ? Qy.warning(\"AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\\n\\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .\") : Qy.warning(\"We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\\n\\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\\n\\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .\"), wx.emit(\"autoplay-failed\");\n    }\n  }\n  function Nx(e, t, i, n) {\n    if (!e) return;\n    const r = oA.getBaseInfoBySessionId(e);\n    if (!r) return;\n    const o = r.info,\n      s = Date.now(),\n      a = tx(tx({}, o), {}, {\n        vid: void 0 === o.vid ? 0 : Number(o.vid),\n        lts: s,\n        elapse: s - r.startTime,\n        cbRegistered: wx.onAutoplayFailed || wx.onAudioAutoplayFailed ? 1 : -1,\n        errorMsg: i,\n        mediaType: t,\n        trackId: n,\n        extend: void 0\n      });\n    oA.send({\n      type: iA.AUTOPLAY_FAILED,\n      data: a\n    }, !0);\n  }\n  const Dx = [\"play\", \"playing\", \"loadeddata\", \"canplay\", \"pause\", \"stalled\", \"suspend\", \"waiting\", \"abort\", \"emptied\", \"ended\", \"error\"],\n    Px = new class {\n      constructor() {\n        ix(this, \"onAutoplayFailed\", void 0), ix(this, \"elementMap\", new Map()), ix(this, \"elementStateMap\", new Map()), ix(this, \"elementsNeedToResume\", []), ix(this, \"sinkIdMap\", new Map()), ix(this, \"autoResumeAfterInterruption\", e => {\n          Array.from(this.elementMap.entries()).forEach(t => {\n            let _t3 = _slicedToArray(t, 2),\n              i = _t3[0],\n              n = _t3[1];\n            const r = this.elementStateMap.get(i),\n              o = n.srcObject.getAudioTracks()[0],\n              s = o && o.readyState;\n            if (Qy.debug(\"resume after interrupted, ele: \".concat(r, \" audio: \").concat(s, \" \").concat(e)), \"live\" === s) {\n              if (e) return n.pause(), void n.play();\n              if (\"running\" === cx.curState) return Gv() ? (n.pause(), void n.play()) : void (r && \"paused\" === r && n.play());\n            }\n          });\n        }), ix(this, \"autoResumeAfterInterruptionOnIOS15_16\", () => {\n          Array.from(this.elementMap.entries()).forEach(e => {\n            let _e12 = _slicedToArray(e, 2),\n              t = _e12[0],\n              i = _e12[1];\n            const n = i.srcObject.getAudioTracks()[0];\n            n && \"live\" === n.readyState && (Qy.debug(\"auto resume after interruption inside autoResumeAfterInterruptionOnIOS15\"), i.pause(), i.play());\n          });\n        }), this.autoResumeAudioElement(), cx.on(mU.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), cx.on(mU.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), cx.on(mU.STATE_CHANGE, () => {\n          Lv() && \"suspended\" === cx.prevState && \"running\" === cx.curState && this.autoResumeAfterInterruption();\n        });\n      }\n      async setSinkID(e, t) {\n        const i = this.elementMap.get(e);\n        if (this.sinkIdMap.set(e, t), i) try {\n          await i.setSinkId(t);\n        } catch (e) {\n          throw new iI(tI.PERMISSION_DENIED, \"can not set sink id: \" + e.toString());\n        }\n      }\n      play(e, t, i, n) {\n        if (this.elementMap.has(t)) return;\n        const r = document.createElement(\"audio\");\n        r.autoplay = !0, r.srcObject = new MediaStream([e]), this.bindAudioElementEvents(t, r), this.elementMap.set(t, r), this.elementStateMap.set(t, XU.INIT), this.setVolume(t, i);\n        const o = this.sinkIdMap.get(t);\n        if (o) try {\n          r.setSinkId(o).catch(e => {\n            Qy.warning(\"[\".concat(t, \"] set sink id failed\"), e.toString());\n          });\n        } catch (e) {\n          Qy.warning(\"[\".concat(t, \"] set sink id failed\"), e.toString());\n        }\n        const s = r.play();\n        s && s.then && s.catch(e => {\n          n && Nx(n, \"audio\", e.message, t), Qy.warning(\"audio element play warning\", e.toString()), this.elementMap.has(t) && \"NotAllowedError\" === e.name && (Qy.warning(\"detected audio element autoplay failed\"), this.elementsNeedToResume.push(r), jI(() => {\n            this.onAutoplayFailed && this.onAutoplayFailed(), Ox();\n          }));\n        });\n      }\n      updateTrack(e, t) {\n        const i = this.elementMap.get(e);\n        i && (i.srcObject = new MediaStream([t]));\n      }\n      isPlaying(e) {\n        return this.elementMap.has(e) && \"playing\" === this.elementStateMap.get(e);\n      }\n      setVolume(e, t) {\n        const i = this.elementMap.get(e);\n        i && (t = Math.max(0, Math.min(100, t)), i.volume = t / 100);\n      }\n      stop(e) {\n        const t = this.elementMap.get(e);\n        if (this.sinkIdMap.delete(e), !t) return;\n        const i = this.elementsNeedToResume.indexOf(t);\n        this.elementsNeedToResume.splice(i, 1), t.srcObject = null, t.remove(), this.elementMap.delete(e), this.elementStateMap.delete(e);\n      }\n      bindAudioElementEvents(e, t) {\n        Dx.forEach(i => {\n          t.addEventListener(i, i => {\n            const n = this.elementStateMap.get(e),\n              r = \"pause\" === i.type ? \"paused\" : i.type;\n            if (Qy.debug(\"[\".concat(e, \"] audio-element-status change \").concat(n, \" => \").concat(r)), \"error\" === i.type) {\n              const i = null == t ? void 0 : t.error;\n              i && Qy.error(\"[\".concat(e, \"] media error, code: \").concat(i.code, \", message: \").concat(i.message));\n            }\n            this.elementStateMap.set(e, r);\n          });\n        });\n      }\n      getPlayerState(e) {\n        return this.elementStateMap.get(e) || \"uninit\";\n      }\n      autoResumeAudioElement() {\n        const e = () => {\n          this.elementsNeedToResume.forEach(e => {\n            e.play().then(e => {\n              Qy.debug(\"Auto resume audio element success\");\n            }).catch(e => {\n              Qy.warning(\"Auto resume audio element failed!\", e);\n            });\n          }), this.elementsNeedToResume = [];\n        };\n        new Gu(e => {\n          document.body ? e() : window.addEventListener(\"load\", () => e());\n        }).then(() => {\n          Qv() ? document.body.addEventListener(\"click\", e, !0) : (document.body.addEventListener(\"touchstart\", e, !0), document.body.addEventListener(\"mousedown\", e, !0));\n        });\n      }\n    }();\n  function Lx() {\n    return function (e, t, i) {\n      const n = i.value;\n      return \"function\" == typeof n && (i.value = function () {\n        this._isClosed && new iI(tI.INVALID_OPERATION, \"[\".concat(this.getTrackId(), \"] cannot operate a closed track\")).print(\"warning\", Qy);\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const r = n.apply(this, t);\n        return r instanceof Gu ? new Gu((e, t) => {\n          r.then(e).catch(t);\n        }) : r;\n      }), i;\n    };\n  }\n  class kx extends SI {\n    constructor(e) {\n      super(), ix(this, \"name\", \"VideoProcessorDestination\"), ix(this, \"ID\", \"0\"), ix(this, \"_source\", void 0), ix(this, \"videoContext\", void 0), ix(this, \"inputTrack\", void 0), this.videoContext = e;\n    }\n    get kind() {\n      return \"video\";\n    }\n    get enabled() {\n      return !0;\n    }\n    pipe() {\n      throw new iI(tI.NOT_SUPPORTED, \"VideoProcessor cannot pipe to any other Processor\");\n    }\n    unpipe() {\n      throw new iI(tI.NOT_SUPPORTED, \"VideoProcessor cannot unpipe to any other Processor\");\n    }\n    enable() {}\n    disable() {}\n    updateInput(e) {\n      if (e.context !== this.videoContext) throw new Error(\"ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\\nProbably you are making pipeline like this:\\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).\");\n      e.track && e.track !== this.inputTrack && (this.videoContext.chained = !0, this.inputTrack = e.track, this.emit(YU.ON_TRACK, e.track));\n    }\n    reset() {\n      this.inputTrack = void 0, this.videoContext.chained = !1, this.emit(YU.ON_TRACK, void 0);\n    }\n  }\n  class Mx extends SI {\n    set chained(e) {\n      this._chained = e;\n    }\n    get chained() {\n      return this._chained;\n    }\n    constructor(e, t) {\n      super(), ix(this, \"constraintsMap\", new Map()), ix(this, \"statsRegistry\", []), ix(this, \"usageRegistry\", []), ix(this, \"trackId\", void 0), ix(this, \"direction\", void 0), ix(this, \"_chained\", !1), this.trackId = e, this.direction = t;\n    }\n    async getConstraints() {\n      return await kI(this, qU.REQUEST_CONSTRAINTS);\n    }\n    async requestApplyConstraints(e, t) {\n      var i;\n      return Qy.info(\"processor \".concat(t.name, \" requestApplyConstraints for \").concat(this.trackId)), e && this.constraintsMap.set(t, e), MI(this, qU.REQUEST_UPDATE_CONSTRAINTS, Array.from(ub(i = this.constraintsMap).call(i)));\n    }\n    async requestRevertConstraints(e) {\n      var t;\n      if (this.constraintsMap.has(e)) return Qy.info(\"processor \".concat(e.name, \" requestRevertConstraints for \").concat(this.trackId)), this.constraintsMap.delete(e), MI(this, qU.REQUEST_UPDATE_CONSTRAINTS, Array.from(ub(t = this.constraintsMap).call(t)));\n    }\n    registerStats(e, t, i) {\n      this.statsRegistry.find(i => i.processorID === e.ID && i.processorName === e.name && i.type === t) || this.statsRegistry.push({\n        processorName: e.name,\n        processorID: e.ID,\n        type: t,\n        cb: i\n      });\n    }\n    unregisterStats(e, t) {\n      const i = this.statsRegistry.findIndex(i => i.processorID === e.ID && i.processorName === e.name && i.type === t);\n      -1 !== i && this.statsRegistry.splice(i, 1);\n    }\n    gatherStats() {\n      const e = [];\n      for (const _ref15 of this.statsRegistry) {\n        const t = _ref15.processorID;\n        const i = _ref15.processorName;\n        const n = _ref15.type;\n        const r = _ref15.cb;\n        try {\n          const o = r();\n          e.push({\n            processorID: t,\n            processorName: i,\n            type: n,\n            stats: o\n          });\n        } catch (e) {\n          Qy.error(new iI(tI.UNEXPECTED_ERROR, e.message));\n        }\n      }\n      return e;\n    }\n    registerUsage(e, t) {\n      this.usageRegistry.find(t => t.processorID === e.ID && t.processorName === e.name) || this.usageRegistry.push({\n        processorID: e.ID,\n        processorName: e.name,\n        cb: t\n      });\n    }\n    unregisterUsage(e) {\n      const t = this.usageRegistry.findIndex(t => t.processorID === e.ID && t.processorName === e.name);\n      -1 !== t && this.usageRegistry.splice(t, 1);\n    }\n    async gatherUsage() {\n      const e = [];\n      if (!this.chained) return [];\n      for (const _ref16 of this.usageRegistry) {\n        const t = _ref16.cb;\n        try {\n          let i = t();\n          i instanceof Gu && (i = await i), e.push(tx(tx({}, i), {}, {\n            direction: this.direction\n          }));\n        } catch (e) {\n          Qy.error(\"gather extension usage error\", e);\n        }\n      }\n      return e;\n    }\n    getDirection() {\n      return this.direction;\n    }\n  }\n  class Ux extends SI {\n    constructor(e) {\n      super(), ix(this, \"name\", \"AudioProcessorDestination\"), ix(this, \"ID\", \"0\"), ix(this, \"inputTrack\", void 0), ix(this, \"inputNode\", void 0), ix(this, \"audioProcessorContext\", void 0), ix(this, \"_source\", void 0), this.audioProcessorContext = e;\n    }\n    get kind() {\n      return \"audio\";\n    }\n    get enabled() {\n      return !0;\n    }\n    pipe() {\n      throw new iI(tI.NOT_SUPPORTED, \"AudioProcessorDestination cannot pipe to any other Processor\");\n    }\n    unpipe() {\n      throw new iI(tI.NOT_SUPPORTED, \"AudioProcessor cannot unpipe to any other Processor\");\n    }\n    enable() {}\n    disable() {}\n    reset() {\n      this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = !1, this.emit(YU.ON_TRACK, void 0), this.emit(YU.ON_NODE, void 0);\n    }\n    updateInput(e) {\n      if (e.context !== this.audioProcessorContext) throw new Error(\"ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).\");\n      e.track && this.inputTrack !== e.track && (this.audioProcessorContext.chained = !0, this.inputTrack = e.track, this.emit(YU.ON_TRACK, this.inputTrack)), e.node && this.inputNode !== e.node && (this.audioProcessorContext.chained = !0, this.inputNode = e.node, this.emit(YU.ON_NODE, this.inputNode));\n    }\n  }\n  class xx extends SI {\n    set chained(e) {\n      this._chained = e;\n    }\n    get chained() {\n      return this._chained;\n    }\n    constructor(e, t, i) {\n      super(), ix(this, \"constraintsMap\", new Map()), ix(this, \"statsRegistry\", []), ix(this, \"audioContext\", void 0), ix(this, \"trackId\", void 0), ix(this, \"direction\", void 0), ix(this, \"usageRegistry\", []), ix(this, \"_chained\", !1), this.audioContext = e, this.trackId = t, this.direction = i;\n    }\n    async getConstraints() {\n      return kI(this, qU.REQUEST_CONSTRAINTS);\n    }\n    getAudioContext() {\n      return this.audioContext;\n    }\n    async requestApplyConstraints(e, t) {\n      var i;\n      return Qy.info(\"processor \".concat(t.name, \" requestApplyConstraints for \").concat(this.trackId)), e && this.constraintsMap.set(t, e), MI(this, qU.REQUEST_UPDATE_CONSTRAINTS, Array.from(ub(i = this.constraintsMap).call(i)));\n    }\n    async requestRevertConstraints(e) {\n      var t;\n      if (this.constraintsMap.has(e)) return this.constraintsMap.delete(e), MI(this, qU.REQUEST_UPDATE_CONSTRAINTS, Array.from(ub(t = this.constraintsMap).call(t)));\n    }\n    registerStats(e, t, i) {\n      this.statsRegistry.find(i => i.processorID === e.ID && i.processorName === e.name && i.type === t) || this.statsRegistry.push({\n        processorName: e.name,\n        processorID: e.ID,\n        type: t,\n        cb: i\n      });\n    }\n    unregisterStats(e, t) {\n      const i = this.statsRegistry.findIndex(i => i.processorID === e.ID && i.processorName === e.name && i.type === t);\n      -1 !== i && this.statsRegistry.splice(i, 1);\n    }\n    gatherStats() {\n      const e = [];\n      for (const _ref17 of this.statsRegistry) {\n        const t = _ref17.processorID;\n        const i = _ref17.processorName;\n        const n = _ref17.type;\n        const r = _ref17.cb;\n        try {\n          const o = r();\n          e.push({\n            processorID: t,\n            processorName: i,\n            type: n,\n            stats: o\n          });\n        } catch (e) {\n          Qy.error(new iI(tI.UNEXPECTED_ERROR, e.message));\n        }\n      }\n      return e;\n    }\n    registerUsage(e, t) {\n      this.usageRegistry.find(t => t.processorID === e.ID && t.processorName === e.name) || this.usageRegistry.push({\n        processorID: e.ID,\n        processorName: e.name,\n        cb: t\n      });\n    }\n    unregisterUsage(e) {\n      const t = this.usageRegistry.findIndex(t => t.processorID === e.ID && t.processorName === e.name);\n      -1 !== t && this.usageRegistry.splice(t, 1);\n    }\n    async gatherUsage() {\n      const e = [];\n      if (!this.chained) return [];\n      for (const _ref18 of this.usageRegistry) {\n        const t = _ref18.cb;\n        try {\n          let i = t();\n          i instanceof Gu && (i = await i), e.push(tx(tx({}, i), {}, {\n            direction: this.direction\n          }));\n        } catch (e) {\n          Qy.error(\"gather extension usage error\", e);\n        }\n      }\n      return e;\n    }\n    getDirection() {\n      return this.direction;\n    }\n  }\n  class Vx extends SI {\n    get isPlayed() {\n      return !0;\n    }\n    get isFreeze() {\n      return !1;\n    }\n    constructor() {\n      super(), ix(this, \"context\", void 0), ix(this, \"processSourceNode\", void 0), ix(this, \"outputTrack\", void 0), ix(this, \"processedNode\", void 0), ix(this, \"clonedTrack\", void 0), ix(this, \"outputNode\", void 0), this.outputNode = new Fx();\n    }\n    setVolume() {}\n    createOutputTrack() {\n      throw new iI(tI.NOT_SUPPORTED, \"can not create output MediaStreamTrack when WebAudio disabled\");\n    }\n    getOriginVolumeLevel() {\n      return 0;\n    }\n    getAccurateVolumeLevel() {\n      return 0;\n    }\n    stopGetAudioBuffer() {}\n    startGetAudioBuffer() {}\n    play() {}\n    stop() {}\n    destroy() {}\n    updateTrack() {}\n    updateOriginTrack() {}\n    createMediaStreamSourceNode() {}\n  }\n  class Fx {\n    disconnect() {}\n    connect() {}\n  }\n  function Bx(e) {\n    return new Gu((t, i) => {\n      let n = !1;\n      const r = document.createElement(\"video\");\n      r.setAttribute(\"autoplay\", \"\"), r.setAttribute(\"muted\", \"\"), r.muted = !0, r.autoplay = !0, r.setAttribute(\"playsinline\", \"\"), r.setAttribute(\"style\", \"position: fixed; top: 0; left: 0; width: 1px; height: 1px\"), document.body.appendChild(r);\n      const o = Lv() ? \"canplay\" : \"playing\";\n      r.addEventListener(o, () => {\n        const e = r.videoWidth,\n          i = r.videoHeight;\n        !e && Pv() || (n = !0, r.srcObject = null, r.remove(), t([e, i]));\n      }), r.srcObject = new MediaStream([e]), r.play().catch(iy), setTimeout(() => {\n        n || (r.srcObject = null, r.remove(), t([r.videoWidth, r.videoHeight]));\n      }, 4e3);\n    });\n  }\n  function jx(e) {\n    const t = {};\n    e.facingMode && (t.facingMode = e.facingMode), e.cameraId && (t.deviceId = {\n      exact: e.cameraId\n    });\n    const i = yU(e.encoderConfig);\n    return null != i.width && (t.width = i.width), null != i.height && (t.height = i.height), !qv() && i.frameRate && (t.frameRate = i.frameRate), Dv() && \"object\" == typeof t.frameRate && (t.frameRate.max = 60), Pv() && (t.frameRate = {\n      ideal: 30,\n      max: 30\n    }), t;\n  }\n  function Gx(e) {\n    const t = {};\n    if (qv() || (void 0 !== e.AGC && (t.autoGainControl = e.AGC), void 0 !== e.AEC && (t.echoCancellation = e.AEC), void 0 !== e.ANS && (t.noiseSuppression = e.ANS, Ov() && e.ANS && (t.googHighpassFilter = e.ANS))), e.encoderConfig) {\n      const i = OU(e.encoderConfig);\n      t.channelCount = i.stereo ? 2 : 1, t.sampleRate = i.sampleRate, t.sampleSize = i.sampleSize;\n    }\n    return e.microphoneId && (t.deviceId = {\n      exact: e.microphoneId\n    }), Xv() && (t.sampleRate = void 0), t;\n  }\n  const Wx = e => {\n      const t = e._encoderConfig;\n      if (!t) return;\n      const _e$getMediaStreamTrac = e.getMediaStreamTrackSettings(),\n        i = _e$getMediaStreamTrac.frameRate,\n        n = _e$getMediaStreamTrac.width,\n        r = _e$getMediaStreamTrac.height;\n      let _t$frameRate = t.frameRate,\n        o = _t$frameRate === void 0 ? i : _t$frameRate,\n        _t$width = t.width,\n        s = _t$width === void 0 ? n : _t$width,\n        _t$height = t.height,\n        a = _t$height === void 0 ? r : _t$height;\n      if (!o || !s || !a) return;\n      s = cy(s), a = cy(a), o = cy(o);\n      const _ref19 = function (e, t, i) {\n          const n = 200 * Math.pow(i / 15, .6) * Math.pow(e * t / 640 / 360, .75);\n          return {\n            min: Math.floor(n),\n            max: Math.floor(4 * n)\n          };\n        }(s, a, o),\n        c = _ref19.max,\n        d = _ref19.min,\n        _ref20 = t || {},\n        l = _ref20.bitrateMax,\n        h = _ref20.bitrateMin;\n      l || Qy.debug(\"calculate bitrate: [w: \".concat(s, \", h: \").concat(a, \", fps: \").concat(o, \"] => [brMax: \").concat(l, \", brMin: \").concat(h, \"]\"));\n      const _Dy = Dy(\"ENCODER_CONFIG_LIMIT\"),\n        u = _Dy.maxFramerate;\n      return u && \"number\" == typeof u && (o = Math.min(o, u)), {\n        frameRate: o,\n        bitrateMax: l || c,\n        bitrateMin: h || d,\n        scaleResolutionDownBy: 1,\n        scale: 0\n      };\n    },\n    Hx = async (e, t, i) => await (async (e, t, i) => {\n      const n = function (e) {\n          const t = [];\n          for (let i = 0; i < e.length; i += 2) t.push(parseInt(e.slice(i, i + 2), 16));\n          return Uint8Array.from(t);\n        }(dy(\"\" + t + i)).slice(0, 16),\n        r = n.slice(0, 12),\n        o = await window.crypto.subtle.importKey(\"raw\", n, \"AES-GCM\", !0, [\"encrypt\"]);\n      return new Uint8Array(await window.crypto.subtle.encrypt({\n        name: \"AES-GCM\",\n        iv: r\n      }, o, e));\n    })(e.buffer, t, i),\n    Kx = e => {\n      const t = document.createElement(\"canvas\");\n      return t.width = 2, t.height = 2, new Gu((i, n) => {\n        t.toBlob(async e => {\n          if (t.remove(), e) {\n            const n = await Yx(e);\n            i({\n              buffer: n,\n              width: t.width,\n              height: t.height\n            });\n          } else n(new iI(tI.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));\n        }, e, 1);\n      });\n    },\n    Yx = async e => {\n      const t = await e.arrayBuffer();\n      return new Uint8Array(t);\n    };\n  var qx, zx, Jx, Xx, Qx, Zx, $x, eV, tV, iV, nV, rV, oV, sV, aV, cV, dV, lV, hV, uV, pV, _V, EV, mV, fV, TV, SV, gV, RV, CV, vV, IV, yV, AV, bV, wV, OV, NV, DV, PV;\n  let LV = (qx = rA({\n      argsMap: (e, t) => [e.getTrackId(), t],\n      throttleTime: 300\n    }), zx = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), Jx = Lx(), Xx = py(\"LocalAudioTrack\", \"_enabledMutex\"), Qx = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), Zx = Lx(), $x = py(\"LocalAudioTrack\", \"_enabledMutex\"), eV = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), tV = Lx(), iV = Lx(), nV = Lx(), rV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), oV = Lx(), sV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), aV = Lx(), cV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), dV = rA({\n      argsMap: (e, t) => [e.getTrackId(), t.name]\n    }), lV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), nx((hV = class extends ox {\n      get _source() {\n        return this.initWebAudio();\n      }\n      set _source(e) {\n        this._trackSource = e;\n      }\n      get processorContext() {\n        return this._processorContext || (this._processorContext = this.initProcessor().processorContext), this._processorContext;\n      }\n      get processorDestination() {\n        return this._processorDestination || (this._processorDestination = this.initProcessor().processorDestination), this._processorDestination;\n      }\n      get isPlaying() {\n        return this._useAudioElement ? Px.isPlaying(this.getTrackId()) : this._source.isPlayed;\n      }\n      get __className__() {\n        return \"LocalAudioTrack\";\n      }\n      constructor(e, t, i, n) {\n        super(e, i), ix(this, \"trackMediaType\", \"audio\"), ix(this, \"_encoderConfig\", void 0), ix(this, \"_trackSource\", void 0), ix(this, \"_enabled\", !0), ix(this, \"_volume\", 100), ix(this, \"_useAudioElement\", !0), ix(this, \"_bypassWebAudio\", !1), ix(this, \"processor\", void 0), ix(this, \"_processorContext\", void 0), ix(this, \"_processorDestination\", void 0), ix(this, \"_getOriginVolumeLevel\", void 0), this._encoderConfig = t, this._getOriginVolumeLevel = !!n, this._trackSource = new Vx(), Dy(\"DISABLE_WEBAUDIO\") && (this._bypassWebAudio = !0), Dy(\"LOCAL_AUDIO_TRACK_USES_WEB_AUDIO\") && (this._useAudioElement = !1), Nv() && !ax ? setTimeout(() => this.initWebAudio()) : this.initWebAudio();\n      }\n      setVolume(e) {\n        oI(e, \"volume\", 0, 1e3), this._volume = e, this._source.setVolume(e / 100), this._useAudioElement && Px.setVolume(this.getTrackId(), e);\n        try {\n          if (this._bypassWebAudio) return void Qy.debug(\"[\".concat(this.getTrackId(), \"] setVolume returned because no pass through WebAudio.\"));\n          const e = this._source.createOutputTrack();\n          this._mediaStreamTrack !== e && (this._mediaStreamTrack = e, MI(this, PU.NEED_REPLACE_TRACK, this).then(() => {\n            Qy.debug(\"[\".concat(this.getTrackId(), \"] replace web audio track success\"));\n          }).catch(e => {\n            Qy.warning(\"[\".concat(this.getTrackId(), \"] replace web audio track failed\"), e);\n          }));\n        } catch (e) {}\n      }\n      getVolumeLevel() {\n        return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();\n      }\n      async setPlaybackDevice(e) {\n        if (!this._useAudioElement || !EU()) throw new iI(tI.NOT_SUPPORTED, \"your browser does not support setting the audio output device\");\n        await Px.setSinkID(this.getTrackId(), e);\n      }\n      async setEnabled(e, t, i) {\n        return this._setEnabled(e, t, i);\n      }\n      async _setEnabled(e, t, i) {\n        if (!i) {\n          if (e === this._enabled) return;\n          this.stateCheck(\"enabled\", e);\n        }\n        if (Qy.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), e) {\n          this._originMediaStreamTrack.enabled = !0;\n          try {\n            i || (this._enabled = !0), await MI(this, PU.NEED_ENABLE_TRACK, this), Qy.info(\"[\".concat(this.getTrackId(), \"] setEnabled to \").concat(e, \" success\"));\n          } catch (e) {\n            throw i || (this._enabled = !1), Qy.error(\"[\".concat(this.getTrackId(), \"] setEnabled to true error\"), e.toString()), e;\n          }\n        } else {\n          this._originMediaStreamTrack.enabled = !1, i || (this._enabled = !1);\n          try {\n            await MI(this, PU.NEED_DISABLE_TRACK, this);\n          } catch (e) {\n            throw i || (this._enabled = !0), Qy.error(\"[\".concat(this.getTrackId(), \"] setEnabled to false error\"), e.toString()), e;\n          }\n        }\n      }\n      async setMuted(e) {\n        e !== this._muted && (this.stateCheck(\"muted\", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, Qy.debug(\"[\".concat(this.getTrackId(), \"] start set muted: \").concat(e)), e ? await MI(this, PU.NEED_MUTE_TRACK, this) : await MI(this, PU.NEED_UNMUTE_TRACK, this));\n      }\n      getStats() {\n        KI(() => {\n          Qy.warning(\"[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead\");\n        }, \"localAudioTrackGetStatsWarning\");\n        return UI(this, PU.GET_STATS) || tx({}, jU);\n      }\n      setAudioFrameCallback(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;\n        if (!e) return this._source.removeAllListeners(BU.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();\n        this._source.startGetAudioBuffer(t), this._source.removeAllListeners(BU.ON_AUDIO_BUFFER), this._source.on(BU.ON_AUDIO_BUFFER, t => e(t));\n      }\n      play() {\n        Qy.debug(\"[\".concat(this.getTrackId(), \"] start audio playback\")), this._useAudioElement ? (Qy.debug(\"[\".concat(this.getTrackId(), \"] start audio playback in element\")), Px.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();\n      }\n      stop() {\n        Qy.debug(\"[\".concat(this.getTrackId(), \"] stop audio playback\")), this._useAudioElement ? Px.stop(this.getTrackId()) : this._source.stop();\n      }\n      close() {\n        super.close(), this._processorDestination && this.unbindProcessorDestinationEvents(this._processorDestination), this._processorContext && this.unbindProcessorContextEvents(this._processorContext), this.unpipe(), this._processorDestination && this._processorDestination._source && this._processorDestination._source.unpipe(), this._source.destroy();\n      }\n      _updatePlayerSource() {\n        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n        Qy.debug(\"[\".concat(this.getTrackId(), \"] update player source track\")), e && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && Px.updateTrack(this.getTrackId(), this._mediaStreamTrack);\n      }\n      async _updateOriginMediaStreamTrack(e, t) {\n        this._originMediaStreamTrack !== e && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener(\"ended\", this._handleTrackEnded), t && this._originMediaStreamTrack.stop()), e.addEventListener(\"ended\", this._handleTrackEnded), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = !1), this.processor && this._processorContext && this.processor.updateInput({\n          track: e,\n          context: this._processorContext\n        }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await MI(this, PU.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e));\n      }\n      renewMediaStreamTrack(e) {\n        return Gu.resolve(void 0);\n      }\n      pipe(e) {\n        if (this._bypassWebAudio) throw new iI(tI.INVALID_OPERATION, \"Can not process AudioTrack when bypassWebAudio set to true.\");\n        if (this.processor === e) return e;\n        if (e._source) throw new iI(tI.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n          track: this._originMediaStreamTrack,\n          node: this._source.processSourceNode,\n          context: this.processorContext\n        }), e;\n      }\n      unpipe() {\n        var e;\n        if (!this.processor) return;\n        const t = this.processor;\n        null === (e = this._source.processSourceNode) || void 0 === e || e.disconnect(), this.processor._source = !1, this.processor = void 0, t.reset();\n      }\n      bindProcessorDestinationEvents(e) {\n        e.on(YU.ON_TRACK, async e => {\n          e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(!1), this._source.processedNode = this._source.createMediaStreamSourceNode(e), await MI(this, PU.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await MI(this, PU.NEED_REPLACE_TRACK, this));\n        }), e.on(YU.ON_NODE, e => {\n          this._source.processedNode = e;\n        });\n      }\n      unbindProcessorDestinationEvents(e) {\n        e.removeAllListeners(YU.ON_TRACK), e.removeAllListeners(YU.ON_NODE);\n      }\n      bindProcessorContextEvents(e) {\n        e.on(qU.REQUEST_CONSTRAINTS, async e => {\n          e(this._originMediaStreamTrack.getSettings());\n        });\n      }\n      unbindProcessorContextEvents(e) {\n        e.removeAllListeners(qU.REQUEST_CONSTRAINTS);\n      }\n      initWebAudio() {\n        return this._trackSource instanceof Vx && (this._trackSource = new Ex(this._mediaStreamTrack, !1, this._getOriginVolumeLevel ? this._mediaStreamTrack : void 0)), this._trackSource;\n      }\n      initProcessor() {\n        const e = new xx(this._source.context, this.getTrackId(), \"local\"),\n          t = new Ux(e);\n        return this._processorContext = e, this._processorDestination = t, this.bindProcessorContextEvents(e), this.bindProcessorDestinationEvents(t), this._source.on(BU.UPDATE_SOURCE, () => {\n          this.processor && this.processor.updateInput({\n            node: this._source.processSourceNode,\n            context: e\n          });\n        }), this._useAudioElement && (this._useAudioElement = !1, this.isPlaying && (Px.stop(this.getTrackId()), this._source.play()), MI(this, PU.NEED_REPLACE_MIXING_TRACK, this).then(() => {\n          Qy.debug(\"[\".concat(this.getTrackId(), \"] replace from origin track to web audio track success\"));\n        }).catch(e => {\n          Qy.warning(\"[\".concat(this.getTrackId(), \"] replace from origin track to web audio track failed\"), e);\n        })), {\n          processorContext: e,\n          processorDestination: t\n        };\n      }\n    }).prototype, \"setVolume\", [qx], Object.getOwnPropertyDescriptor(hV.prototype, \"setVolume\"), hV.prototype), nx(hV.prototype, \"setPlaybackDevice\", [zx, Jx], Object.getOwnPropertyDescriptor(hV.prototype, \"setPlaybackDevice\"), hV.prototype), nx(hV.prototype, \"setEnabled\", [Xx, Qx, Zx], Object.getOwnPropertyDescriptor(hV.prototype, \"setEnabled\"), hV.prototype), nx(hV.prototype, \"setMuted\", [$x, eV, tV], Object.getOwnPropertyDescriptor(hV.prototype, \"setMuted\"), hV.prototype), nx(hV.prototype, \"getStats\", [iV], Object.getOwnPropertyDescriptor(hV.prototype, \"getStats\"), hV.prototype), nx(hV.prototype, \"setAudioFrameCallback\", [nV], Object.getOwnPropertyDescriptor(hV.prototype, \"setAudioFrameCallback\"), hV.prototype), nx(hV.prototype, \"play\", [rV, oV], Object.getOwnPropertyDescriptor(hV.prototype, \"play\"), hV.prototype), nx(hV.prototype, \"stop\", [sV, aV], Object.getOwnPropertyDescriptor(hV.prototype, \"stop\"), hV.prototype), nx(hV.prototype, \"close\", [cV], Object.getOwnPropertyDescriptor(hV.prototype, \"close\"), hV.prototype), nx(hV.prototype, \"pipe\", [dV], Object.getOwnPropertyDescriptor(hV.prototype, \"pipe\"), hV.prototype), nx(hV.prototype, \"unpipe\", [lV], Object.getOwnPropertyDescriptor(hV.prototype, \"unpipe\"), hV.prototype), hV),\n    kV = (uV = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), pV = Lx(), _V = py(\"MicrophoneAudioTrack\", \"_enabledMutex\"), EV = rA({\n      argsMap: (e, t, i) => [e.getTrackId(), t, i]\n    }), mV = Lx(), fV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), nx((TV = class extends LV {\n      get __className__() {\n        return \"MicrophoneAudioTrack\";\n      }\n      constructor(e, t, i, n) {\n        super(e, t.encoderConfig ? OU(t.encoderConfig) : {}, n, Dy(\"GET_VOLUME_OF_MUTED_AUDIO_TRACK\")), ix(this, \"_config\", void 0), ix(this, \"_deviceName\", \"default\"), ix(this, \"_constraints\", void 0), ix(this, \"_originalConstraints\", void 0), ix(this, \"_enabled\", !0), this._config = t, this._constraints = i, this._originalConstraints = i, this._deviceName = e.label, \"boolean\" == typeof t.bypassWebAudio && (this._bypassWebAudio = t.bypassWebAudio), (Gv() || Wv()) && cx.bindInterruptDetectorTrack(this);\n      }\n      async setDevice(e) {\n        if (Qy.info(\"[\".concat(this.getTrackId(), \"] start set device to \").concat(e)), this._enabled) try {\n          const t = await Ax.getDeviceById(e),\n            i = {};\n          i.audio = tx({}, this._constraints), i.audio.deviceId = {\n            exact: e\n          }, this._originMediaStreamTrack.stop();\n          let n = null;\n          try {\n            n = await Cx(i, this.getTrackId());\n          } catch (e) {\n            throw Qy.error(\"[\".concat(this.getTrackId(), \"] setDevice failed\"), e.toString()), n = await Cx({\n              audio: this._constraints\n            }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n.getAudioTracks()[0], !1), e;\n          }\n          await this._updateOriginMediaStreamTrack(n.getAudioTracks()[0], !1), this._deviceName = t.label, this._config.microphoneId = e, this._constraints.deviceId = {\n            exact: e\n          };\n        } catch (e) {\n          throw Qy.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n        } else try {\n          const t = await Ax.getDeviceById(e);\n          this._deviceName = t.label, this._config.microphoneId = e, this._constraints.deviceId = {\n            exact: e\n          };\n        } catch (e) {\n          throw Qy.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n        }\n        Qy.info(\"[\".concat(this.getTrackId(), \"] set device to \").concat(e, \" success\"));\n      }\n      async setEnabled(e, t, i) {\n        if (t) return Qy.debug(\"[\".concat(this.getTrackId(), \"] setEnabled false (do not close microphone)\")), await super._setEnabled(e);\n        if (!i) {\n          if (e === this._enabled) return;\n          this.stateCheck(\"enabled\", e);\n        }\n        if (Qy.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), Dy(\"AUTO_RESET_AUDIO_ROUTE\") && (Lv() || Kv())) {\n          const t = navigator.audioSession;\n          t && (e || (t.type = \"playback\"), t.type = \"auto\");\n        }\n        if (!e) {\n          var n;\n          this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n = this._source.clonedTrack) || void 0 === n || n.stop(), i || (this._enabled = !1);\n          try {\n            await MI(this, PU.NEED_DISABLE_TRACK, this);\n          } catch (e) {\n            throw Qy.error(\"[\".concat(this.getTrackId(), \"] setEnabled false failed\"), e.toString()), e;\n          }\n          return;\n        }\n        const r = tx({}, this._constraints),\n          o = Ax.searchDeviceIdByName(this._deviceName);\n        o && !r.deviceId && (r.deviceId = o);\n        try {\n          i || (this._enabled = !0);\n          const e = await Cx({\n            audio: this._constraints\n          }, this.getTrackId());\n          await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !1), await MI(this, PU.NEED_ENABLE_TRACK, this);\n        } catch (e) {\n          throw i || (this._enabled = !1), Qy.error(\"[\".concat(this.getTrackId(), \"] setEnabled true failed\"), e.toString()), e;\n        }\n        Qy.info(\"[\".concat(this.getTrackId(), \"] setEnabled success\"));\n      }\n      close() {\n        super.close(), (Gv() || Wv()) && cx.unbindInterruptDetectorTrack(this);\n      }\n      onTrackEnded() {\n        if ((Lv() || Kv()) && this._enabled && !this._isClosed && cx.duringInterruption) {\n          const e = async () => {\n            cx.off(mU.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (Qy.debug(\"[\".concat(this.getTrackId(), \"] try capture microphone media device for interrupted iOS device.\")), await this.setEnabled(!1), await this.setEnabled(!0));\n          };\n          cx.on(mU.IOS_INTERRUPTION_END, e);\n        } else Qy.debug(\"[\".concat(this.getTrackId(), \"] track ended\")), this.safeEmit(VU.TRACK_ENDED);\n      }\n      async renewMediaStreamTrack(e) {\n        const t = e || this._constraints,\n          i = Ax.searchDeviceIdByName(this._deviceName);\n        if (i && !t.deviceId && (t.deviceId = i), this._constraints = t, this._enabled) {\n          this._originMediaStreamTrack.stop();\n          const e = await Cx({\n            audio: this._constraints\n          }, this.getTrackId());\n          await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !0);\n        }\n      }\n      bindProcessorContextEvents(e) {\n        super.bindProcessorContextEvents(e), e.on(qU.REQUEST_UPDATE_CONSTRAINTS, async (e, t, i) => {\n          try {\n            const i = Object.assign({}, this._originalConstraints, ...e);\n            await this.renewMediaStreamTrack(i), t();\n          } catch (e) {\n            i(e);\n          }\n        });\n      }\n      unbindProcessorContextEvents(e) {\n        super.unbindProcessorContextEvents(e), e.removeAllListeners(qU.REQUEST_UPDATE_CONSTRAINTS);\n      }\n    }).prototype, \"setDevice\", [uV, pV], Object.getOwnPropertyDescriptor(TV.prototype, \"setDevice\"), TV.prototype), nx(TV.prototype, \"setEnabled\", [_V, EV, mV], Object.getOwnPropertyDescriptor(TV.prototype, \"setEnabled\"), TV.prototype), nx(TV.prototype, \"close\", [fV], Object.getOwnPropertyDescriptor(TV.prototype, \"close\"), TV.prototype), TV),\n    MV = (SV = rA({\n      argsMap: (e, t) => [e.getTrackId(), t, e.duration]\n    }), gV = Lx(), RV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), CV = Lx(), vV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), IV = Lx(), yV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), AV = Lx(), bV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), wV = Lx(), OV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), NV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), DV = Lx(), nx((PV = class extends LV {\n      get __className__() {\n        return \"BufferSourceAudioTrack\";\n      }\n      constructor(e, t, i, n) {\n        super(t.createOutputTrack(), i, n), ix(this, \"source\", void 0), ix(this, \"_bufferSource\", void 0), this._useAudioElement = !1, this.source = e, this._bufferSource = t, this._bufferSource.on(BU.AUDIO_SOURCE_STATE_CHANGE, e => {\n          this.safeEmit(VU.SOURCE_STATE_CHANGE, e);\n        });\n        try {\n          this._mediaStreamTrack = this._source.createOutputTrack();\n        } catch (e) {}\n      }\n      get currentState() {\n        return this._bufferSource.currentState;\n      }\n      get duration() {\n        return this._bufferSource.duration;\n      }\n      get playbackSpeed() {\n        return this._bufferSource.playbackSpeed;\n      }\n      getCurrentTime() {\n        return this._bufferSource.currentTime;\n      }\n      startProcessAudioBuffer(e) {\n        e && this._bufferSource.updateOptions(e), this._bufferSource.startProcessAudioBuffer();\n      }\n      pauseProcessAudioBuffer() {\n        this._bufferSource.pauseProcessAudioBuffer();\n      }\n      seekAudioBuffer(e) {\n        this._bufferSource.seekAudioBuffer(e);\n      }\n      resumeProcessAudioBuffer() {\n        this._bufferSource.resumeProcessAudioBuffer();\n      }\n      stopProcessAudioBuffer() {\n        this._bufferSource.stopProcessAudioBuffer();\n      }\n      close() {\n        this.source = null, this._bufferSource.destroy(), super.close();\n      }\n      setAudioBufferPlaybackSpeed(e) {\n        oI(e, \"speed\", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e);\n      }\n    }).prototype, \"startProcessAudioBuffer\", [SV, gV], Object.getOwnPropertyDescriptor(PV.prototype, \"startProcessAudioBuffer\"), PV.prototype), nx(PV.prototype, \"pauseProcessAudioBuffer\", [RV, CV], Object.getOwnPropertyDescriptor(PV.prototype, \"pauseProcessAudioBuffer\"), PV.prototype), nx(PV.prototype, \"seekAudioBuffer\", [vV, IV], Object.getOwnPropertyDescriptor(PV.prototype, \"seekAudioBuffer\"), PV.prototype), nx(PV.prototype, \"resumeProcessAudioBuffer\", [yV, AV], Object.getOwnPropertyDescriptor(PV.prototype, \"resumeProcessAudioBuffer\"), PV.prototype), nx(PV.prototype, \"stopProcessAudioBuffer\", [bV, wV], Object.getOwnPropertyDescriptor(PV.prototype, \"stopProcessAudioBuffer\"), PV.prototype), nx(PV.prototype, \"close\", [OV], Object.getOwnPropertyDescriptor(PV.prototype, \"close\"), PV.prototype), nx(PV.prototype, \"setAudioBufferPlaybackSpeed\", [NV, DV], Object.getOwnPropertyDescriptor(PV.prototype, \"setAudioBufferPlaybackSpeed\"), PV.prototype), PV);\n  class UV extends LV {\n    get __className__() {\n      return \"MixingAudioTrack\";\n    }\n    get isActive() {\n      for (const e of this.trackList) if (e._enabled && !e._isClosed && !e.muted) return !0;\n      return !1;\n    }\n    constructor() {\n      const e = dx().createMediaStreamDestination();\n      super(e.stream.getAudioTracks()[0], void 0, ey(8, \"track-mix-\")), ix(this, \"trackList\", void 0), ix(this, \"destNode\", void 0), this._useAudioElement = !1;\n      try {\n        this._mediaStreamTrack = this._source.createOutputTrack();\n      } catch (e) {}\n      this.destNode = e, this.trackList = [];\n    }\n    hasAudioTrack(e) {\n      return -1 !== this.trackList.indexOf(e);\n    }\n    addAudioTrack(e) {\n      -1 === this.trackList.indexOf(e) ? (Qy.debug(\"add \".concat(e.getTrackId(), \" to mixing track\")), e._source.outputNode.connect(this.destNode), this.trackList.push(e), this.updateEncoderConfig()) : Qy.debug(\"track \".concat(e.getTrackId(), \" is already added\"));\n    }\n    removeAudioTrack(e) {\n      if (-1 !== this.trackList.indexOf(e)) {\n        Qy.debug(\"remove \".concat(e.getTrackId(), \" from mixing track\"));\n        try {\n          e._source.outputNode.disconnect(this.destNode);\n        } catch (e) {}\n        FI(this.trackList, e), this.updateEncoderConfig();\n      }\n    }\n    updateEncoderConfig() {\n      const e = {};\n      this.trackList.forEach(t => {\n        t._encoderConfig && ((t._encoderConfig.bitrate || 0) > (e.bitrate || 0) && (e.bitrate = t._encoderConfig.bitrate), (t._encoderConfig.sampleRate || 0) > (e.sampleRate || 0) && (e.sampleRate = t._encoderConfig.sampleRate), (t._encoderConfig.sampleSize || 0) > (e.sampleSize || 0) && (e.sampleSize = t._encoderConfig.sampleSize), t._encoderConfig.stereo && (e.stereo = !0));\n      }), this._encoderConfig = e;\n    }\n    _updateRtpTransceiver(e) {\n      this._rtpTransceiver !== e && (this._rtpTransceiver = e, this.trackList.forEach(t => {\n        t instanceof UV ? t.emit(xU.TRANSCEIVER_UPDATED, e) : t._updateRtpTransceiver(e);\n      }));\n    }\n  }\n  class xV extends _x {\n    set currentState(e) {\n      e !== this._currentState && (this._currentState = e, this.safeEmit(BU.AUDIO_SOURCE_STATE_CHANGE, this._currentState));\n    }\n    get currentState() {\n      return this._currentState;\n    }\n    constructor(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      super(), ix(this, \"audioBuffer\", void 0), ix(this, \"sourceNode\", void 0), ix(this, \"startPlayTime\", 0), ix(this, \"startPlayOffset\", 0), ix(this, \"pausePlayTime\", 0), ix(this, \"options\", void 0), ix(this, \"currentLoopCount\", 0), ix(this, \"currentPlaybackSpeed\", 100), ix(this, \"_currentState\", \"stopped\"), this.audioBuffer = e, this.options = t, this.startPlayOffset = this.options.startPlayTime || 0;\n    }\n    createWebAudioDiagram() {\n      return this.context.createGain();\n    }\n    get duration() {\n      return this.audioBuffer ? this.audioBuffer.duration : 0;\n    }\n    get playbackSpeed() {\n      return this.currentPlaybackSpeed;\n    }\n    get currentTime() {\n      return this.audioBuffer ? \"stopped\" === this.currentState ? 0 : \"paused\" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration : 0;\n    }\n    updateOptions(e) {\n      \"stopped\" === this.currentState ? (this.options = e, this.startPlayOffset = this.options.startPlayTime || 0) : Qy.warning(\"can not set audio source options\");\n    }\n    startProcessAudioBuffer() {\n      this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = \"playing\";\n    }\n    pauseProcessAudioBuffer() {\n      this.sourceNode && \"playing\" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = \"paused\");\n    }\n    seekAudioBuffer(e) {\n      this.sourceNode && (this.sourceNode.onended = null, \"playing\" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), \"playing\" === this.currentState ? (this.startPlayOffset = e, this.startSourceNode()) : \"paused\" === this.currentState && (this.pausePlayTime = e));\n    }\n    resumeProcessAudioBuffer() {\n      \"paused\" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = \"playing\");\n    }\n    stopProcessAudioBuffer() {\n      if (this.sourceNode) {\n        this.sourceNode.onended = null;\n        try {\n          this.sourceNode.stop();\n        } catch (e) {}\n        this.reset();\n      }\n    }\n    destroy() {\n      this.audioBuffer = null, super.destroy();\n    }\n    setAudioBufferPlaybackSpeed(e) {\n      this.sourceNode && (\"playing\" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e / 100), this.currentPlaybackSpeed = e;\n    }\n    startSourceNode() {\n      this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));\n    }\n    createSourceNode() {\n      const e = this.context.createBufferSource();\n      return e.buffer = this.audioBuffer, e.loop = !!this.options.loop, e.connect(this.outputNode), e.playbackRate.value = this.currentPlaybackSpeed / 100, e;\n    }\n    handleSourceNodeEnded() {\n      if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();\n      this.reset();\n    }\n    reset() {\n      this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = \"stopped\", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;\n    }\n  }\n  const VV = new Map();\n  class FV {\n    get rendFrameRate() {\n      if (this.renderStats && this.renderStats.curTs !== this.renderStats.lastTs) {\n        const e = this.renderStats.curTs - this.renderStats.lastTs,\n          t = (this.renderStats.renderNum - this.renderStats.lastRenderNum) / e;\n        return this.renderStats.lastRenderNum = this.renderStats.renderNum, this.renderStats.lastTs = this.renderStats.curTs, t;\n      }\n      return 0;\n    }\n    get videoElementStatus() {\n      return this._videoElementStatus;\n    }\n    set videoElementStatus(e) {\n      e !== this._videoElementStatus && (Qy.debug(\"[\".concat(this.trackId, \"] video-element-status change \").concat(this._videoElementStatus, \" => \").concat(e)), this._videoElementStatus = e);\n    }\n    get videoState() {\n      return this._videoState;\n    }\n    set videoState(e) {\n      var t;\n      e !== this._videoState && (this._videoState = e, null === (t = this.onVideoStateChanged) || void 0 === t || t.call(this, this.videoState));\n    }\n    constructor(e) {\n      ix(this, \"trackId\", void 0), ix(this, \"config\", void 0), ix(this, \"onFirstVideoFrameDecoded\", void 0), ix(this, \"onVideoStateChanged\", void 0), ix(this, \"freezeTimeCounterList\", []), ix(this, \"renderFreezeAccTime\", 0), ix(this, \"isKeepLastFrame\", !1), ix(this, \"timeUpdatedCount\", 0), ix(this, \"freezeTime\", 0), ix(this, \"playbackTime\", 0), ix(this, \"lastTimeUpdatedTime\", 0), ix(this, \"autoplayFailed\", !1), ix(this, \"videoTrack\", void 0), ix(this, \"videoElement\", void 0), ix(this, \"cacheVideoElement\", void 0), ix(this, \"renderStats\", void 0), ix(this, \"_videoState\", QU.VideoStateStopped), ix(this, \"videoElementCheckInterval\", void 0), ix(this, \"videoElementFreezeTimeout\", void 0), ix(this, \"_videoElementStatus\", XU.NONE), ix(this, \"isGettingVideoDimensions\", !1), ix(this, \"startGetVideoDimensions\", () => {\n        const e = () => {\n          if (this.isGettingVideoDimensions = !0, this.videoElement.videoWidth * this.videoElement.videoHeight > 4) return Qy.debug(\"[\".concat(this.trackId, \"] current video dimensions:\"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = !1);\n          setTimeout(e, 500);\n        };\n        !this.isGettingVideoDimensions && e();\n      }), ix(this, \"autoResumeAfterInterruption\", () => {\n        this.videoTrack && \"live\" === this.videoTrack.readyState && \"running\" === cx.curState && (Qy.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume for \").concat(bv())), Hv() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));\n      }), ix(this, \"handleVideoEvents\", e => {\n        switch (e.type) {\n          case \"play\":\n          case \"playing\":\n            this.startGetVideoDimensions(), this.videoElementStatus = XU.PLAYING;\n            break;\n          case \"loadeddata\":\n            if (this.videoState = QU.VideoStateStarting, this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {\n              try {\n                this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();\n              } catch (e) {}\n              this.cacheVideoElement = void 0;\n            }\n            break;\n          case \"canplay\":\n            this.videoElementStatus = XU.CANPLAY;\n            break;\n          case \"stalled\":\n            this.videoElementStatus = XU.STALLED;\n            break;\n          case \"suspend\":\n            this.videoElementStatus = XU.SUSPEND;\n            break;\n          case \"pause\":\n            this.videoElementStatus = XU.PAUSED, Lv() || Kv() || Nv() && this.autoplayFailed || !this.videoTrack || \"live\" !== this.videoTrack.readyState || (Qy.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume\")), this.videoElement.play());\n            break;\n          case \"waiting\":\n            this.videoElementStatus = XU.WAITING;\n            break;\n          case \"abort\":\n            this.videoElementStatus = XU.ABORT;\n            break;\n          case \"ended\":\n            this.videoElementStatus = XU.ENDED;\n            break;\n          case \"emptied\":\n            this.videoElementStatus = XU.EMPTIED;\n            break;\n          case \"error\":\n            {\n              const e = this.videoElement.error;\n              e ? (this.videoElementStatus = XU.ERROR, Qy.error(\"[\".concat(this.trackId, \"] media error: \").concat(e.message, \" (\").concat(e.code, \")\"))) : Qy.debug(\"[\".concat(this.trackId, \"] media not been an error.\"));\n              break;\n            }\n          case \"timeupdate\":\n            {\n              const e = performance.now();\n              if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10) return void (this.lastTimeUpdatedTime = e);\n              const t = e - this.lastTimeUpdatedTime,\n                i = this.lastTimeUpdatedTime;\n              if (this.lastTimeUpdatedTime = e, jF.lastVisibleTime < jF.lastHiddenTime || i < jF.lastHiddenTime || i < jF.lastVisibleTime) return;\n              for (t > Dy(\"VIDEO_FREEZE_DURATION\") && (this.freezeTime += t), this.playbackTime += t; this.playbackTime >= 6e3;) {\n                this.playbackTime -= 6e3;\n                const e = Math.min(6e3, this.freezeTime);\n                this.freezeTimeCounterList.push(e), this.freezeTime = Math.max(0, this.freezeTime - 6e3);\n              }\n              break;\n            }\n        }\n      }), ix(this, \"autoResumeAfterInterruptionOnIOS15_16\", () => {\n        this.videoTrack && \"live\" === this.videoTrack.readyState && (Qy.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume for \").concat(bv())), Hv() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));\n      }), this.trackId = e.trackId, this.config = e, e.element instanceof HTMLVideoElement ? this.videoElement = e.element : this.videoElement = document.createElement(\"video\"), cx.on(mU.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), cx.on(mU.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);\n    }\n    getVideoElement() {\n      return this.videoElement;\n    }\n    getContainerElement() {\n      var e;\n      return null !== (e = this.videoElement.parentElement) && void 0 !== e ? e : void 0;\n    }\n    updateConfig(e) {\n      this.config = e, this.trackId = e.trackId, e.element !== this.videoElement && (this.destroy(), this.videoElement = e.element), this.videoTrack && this.initVideoElement();\n    }\n    updateVideoTrack(e) {\n      this.videoTrack !== e && (this.videoTrack = e, this.initVideoElement());\n    }\n    play(e) {\n      const t = this.videoElement.play();\n      t && t.catch && t.catch(t => {\n        e && Nx(e, \"video\", t.message, this.trackId), \"NotAllowedError\" === t.name ? (Qy.warning(\"detected video element autoplay failed\", t), this.autoplayFailed = !0, this.handleAutoPlayFailed()) : Qy.warning(\"[\".concat(this.trackId, \"] play warning: \"), t);\n      });\n      const i = Iv();\n      if ((\"Safari\" === i.name && 15 === Number(i.version) || Gv()) && t && t.then) {\n        const e = () => {\n          this.config.mirror && (this.videoElement.style.transform = \"rotateY(180deg)\");\n        };\n        t.then(e).catch(e);\n      }\n    }\n    getCurrentFrame() {\n      const e = document.createElement(\"canvas\");\n      e.width = this.videoElement.videoWidth, e.height = this.videoElement.videoHeight;\n      const t = e.getContext(\"2d\");\n      if (!t) return Qy.error(\"create canvas context failed!\"), new ImageData(2, 2);\n      t.drawImage(this.videoElement, 0, 0, e.width, e.height);\n      const i = t.getImageData(0, 0, e.width, e.height);\n      return e.remove(), i;\n    }\n    async getCurrentFrameToUint8Array(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n      const i = document.createElement(\"canvas\");\n      i.width = this.videoElement.videoWidth, i.height = this.videoElement.videoHeight;\n      const n = i.getContext(\"2d\");\n      return n ? (n.drawImage(this.videoElement, 0, 0, i.width, i.height), new Gu((n, r) => {\n        i.toBlob(async e => {\n          if (i.remove(), e) {\n            const t = await Yx(e);\n            n({\n              buffer: t,\n              width: i.width,\n              height: i.height\n            });\n          } else r(new iI(tI.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));\n        }, e, t < 0 ? .1 : t > 1 ? 1 : t);\n      })) : await Kx(e);\n    }\n    destroy() {\n      this.renderStats = void 0, cx.off(mU.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), cx.off(mU.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [], this.videoState = QU.VideoStateStopped;\n    }\n    initVideoElement() {\n      if (this.videoElementStatus = XU.INIT, !this.videoElementCheckInterval && (BV.forEach(e => {\n        this.videoElement.addEventListener(e, this.handleVideoEvents);\n      }), this.videoElementCheckInterval = window.setInterval(() => {\n        (function (e) {\n          return e !== document.body && document.body.contains(e);\n        })(this.videoElement) || (this.videoElementStatus = XU.DESTROYED);\n      }, 1e3), Dy(\"ENABLE_VIDEO_FRAME_CALLBACK\"))) {\n        var e, t;\n        let i;\n        const n = () => {\n            \"visible\" === document.visibilityState && (document.removeEventListener(\"visibilitychange\", n), this.videoElementFreezeTimeout = window.setTimeout(r, Dy(\"VIDEO_FREEZE_DURATION\")));\n          },\n          r = () => {\n            this.videoElementFreezeTimeout = void 0, this.videoState === QU.VideoStateDecoding && (\"visible\" === document.visibilityState ? this.videoState = QU.VideoStateFrozen : document.addEventListener(\"visibilitychange\", n));\n          },\n          o = (e, t) => {\n            if (this.videoElementStatus === XU.PLAYING) {\n              if (this.renderStats ? (this.renderStats.renderNum++, this.renderStats.curTs = t.mediaTime) : this.renderStats = {\n                lastTs: t.mediaTime,\n                curTs: t.mediaTime,\n                lastRenderNum: 0,\n                renderNum: 0\n              }, i) {\n                const e = t.presentationTime - i.presentationTime;\n                this.videoState === QU.VideoStateStarting && (this.videoState = QU.VideoStateDecoding), this.videoState === QU.VideoStateDecoding && this.onVideoStateChanged && (this.videoElementFreezeTimeout && window.clearTimeout(this.videoElementFreezeTimeout), this.videoElementFreezeTimeout = window.setTimeout(r, Dy(\"VIDEO_FREEZE_DURATION\"))), e < Dy(\"VIDEO_FREEZE_DURATION\") && this.videoState === QU.VideoStateFrozen && (this.videoState = QU.VideoStateDecoding), e > Dy(\"VIDEO_FREEZE_DURATION\") && jF.lastVisibleTime >= jF.lastHiddenTime && i.timestamp > jF.lastVisibleTime && i.timestamp > jF.lastHiddenTime && (this.renderFreezeAccTime += e);\n              }\n              i = tx(tx({}, t), {}, {\n                timestamp: e\n              });\n            }\n            var n, s;\n            Dy(\"ENABLE_VIDEO_FRAME_CALLBACK\") && (null === (n = (s = this.videoElement).requestVideoFrameCallback) || void 0 === n || n.call(s, o));\n          };\n        null === (e = (t = this.videoElement).requestVideoFrameCallback) || void 0 === e || e.call(t, o);\n      }\n      this.videoElement.controls = !1, this.videoElement.setAttribute(\"playsinline\", \"\"), Xv() && !Dy(\"HIDE_NO_POSTER\") && (this.videoElement.poster = \"noposter\");\n      const i = Iv();\n      \"Safari\" === i.name && 15 === Number(i.version) || Gv() || !this.config.mirror || (this.videoElement.style.transform = \"rotateY(180deg)\"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = \"cover\", this.videoElement.setAttribute(\"muted\", \"\"), this.videoElement.muted = !0, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream ? this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Pv() && this.videoElement.load()) : (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Pv() && this.videoElement.load());\n      const n = this.videoElement.play();\n      void 0 !== n && n.catch(e => {\n        Qy.debug(\"[\".concat(this.trackId, \"] playback interrupted\"), e.toString());\n      });\n    }\n    resetVideoElement() {\n      BV.forEach(e => {\n        this.videoElement && this.videoElement.removeEventListener(e, this.handleVideoEvents);\n      }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.videoElementStatus = XU.NONE;\n    }\n    handleAutoPlayFailed() {\n      const e = t => {\n        t.preventDefault(), this.videoElement.play().then(() => {\n          Qy.debug(\"[\".concat(this.trackId, \"] Video element for trackId:\").concat(this.trackId, \" autoplay resumed.\"));\n        }).catch(e => {\n          Qy.error(e);\n        }), this.autoplayFailed = !1, Qv() ? document.body.removeEventListener(\"click\", e, !0) : (document.body.removeEventListener(\"touchstart\", e, !0), document.body.removeEventListener(\"mousedown\", e, !0));\n      };\n      Qv() ? document.body.addEventListener(\"click\", e, !0) : (document.body.addEventListener(\"touchstart\", e, !0), document.body.addEventListener(\"mousedown\", e, !0)), Ox();\n    }\n  }\n  const BV = [\"play\", \"playing\", \"loadeddata\", \"canplay\", \"pause\", \"stalled\", \"suspend\", \"waiting\", \"abort\", \"emptied\", \"ended\", \"timeupdate\", \"error\"];\n  class jV extends FV {\n    constructor(e) {\n      super(e), ix(this, \"container\", void 0), ix(this, \"slot\", void 0), this.slot = e.element, this.updateConfig(e);\n    }\n    updateConfig(e) {\n      this.config = e, this.trackId = e.trackId;\n      const t = e.element;\n      t !== this.slot && (this.destroy(), this.slot = t), this.createElements();\n    }\n    updateVideoTrack(e) {\n      this.videoTrack !== e && (this.videoTrack = e, this.createElements());\n    }\n    play(e) {\n      var t;\n      null !== (t = this.container) && void 0 !== t && t.contains(this.videoElement) && super.play(e);\n    }\n    getCurrentFrame() {\n      var e;\n      return null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);\n    }\n    async getCurrentFrameToUint8Array(e) {\n      var t;\n      let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n      return null !== (t = this.container) && void 0 !== t && t.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e, i) : await Kx(e);\n    }\n    destroy() {\n      if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement(\"video\"), this.container) {\n        try {\n          this.container.remove(), this.slot.removeChild(this.container);\n        } catch (e) {}\n        this.container = void 0;\n      }\n    }\n    createElements() {\n      this.container || (this.container = document.createElement(\"div\")), this.container.id = \"agora-video-player-\".concat(this.trackId), this.container.style.width = \"100%\", this.container.style.height = \"100%\", this.container.style.position = \"relative\", this.container.style.overflow = \"hidden\", this.videoTrack ? (this.container.style.backgroundColor = \"black\", Dy(\"KEEP_LAST_FRAME\") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), this.slot.appendChild(this.container);\n    }\n    mountedVideoElement() {\n      var e;\n      !this.container || null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = \"video_\".concat(this.trackId), this.videoElement.className = \"agora_video_player\", this.videoElement.style.width = \"100%\", this.videoElement.style.height = \"100%\", this.videoElement.style.position = \"absolute\", this.videoElement.style.left = \"0\", this.videoElement.style.top = \"0\";\n    }\n    unmountedVideoElement() {\n      var e;\n      if (null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement)) {\n        super.resetVideoElement();\n        try {\n          this.container && this.container.removeChild(this.videoElement);\n        } catch (e) {}\n        this.videoElement = document.createElement(\"video\");\n      }\n    }\n    resetVideoElement() {\n      var e;\n      null !== (e = this.container) && void 0 !== e && e.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement(\"video\"));\n    }\n    getContainerElement() {\n      return this.container;\n    }\n  }\n  var GV, WV, HV, KV, YV, qV, zV, JV, XV, QV, ZV, $V, eF, tF, iF, nF, rF, oF, sF, aF, cF, dF, lF, hF, uF, pF, _F, EF, mF, fF, TF, SF, gF, RF, CF;\n  let vF = (GV = rA({\n      argsMap: (e, t, i) => [e.getTrackId(), \"string\" == typeof t ? t : t instanceof HTMLVideoElement ? \"HTMLVideoElement\" : \"HTMLElement\", i]\n    }), WV = Lx(), HV = rA({\n      argsMap: e => [e.getTrackId()]\n    }), KV = py(\"LocalVideoTrack\", \"_enabledMutex\"), YV = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), qV = Lx(), zV = py(\"LocalVideoTrack\", \"_enabledMutex\"), JV = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), XV = Lx(), QV = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), ZV = Lx(), $V = Lx(), eF = rA({\n      argsMap: (e, t, i) => [e.getTrackId(), t, i]\n    }), tF = Lx(), iF = Lx(), nF = Lx(), rF = Lx(), oF = Lx(), sF = Lx(), aF = Lx(), cF = rA({\n      argsMap: (e, t) => [e.getTrackId(), t.name]\n    }), dF = rA({\n      argsMap: e => [e.getTrackId()]\n    }), lF = rA({\n      argsMap: e => [e.getTrackId()]\n    }), hF = rA({\n      argsMap: (e, t, i) => [e.getTrackId(), t.label, i]\n    }), uF = rA(), pF = class e extends ox {\n      get videoHeight() {\n        if (Nv()) {\n          const _this$_mediaStreamTra = this._mediaStreamTrack.getSettings(),\n            e = _this$_mediaStreamTra.height;\n          return this._videoHeight = e, this._videoHeight;\n        }\n        return this._videoHeight;\n      }\n      get videoWidth() {\n        if (Nv()) {\n          const _this$_mediaStreamTra2 = this._mediaStreamTrack.getSettings(),\n            e = _this$_mediaStreamTra2.width;\n          return this._videoWidth = e, this._videoWidth;\n        }\n        return this._videoWidth;\n      }\n      get isPlaying() {\n        return !(!this._player || this._player.videoElementStatus !== XU.PLAYING);\n      }\n      get processorDestination() {\n        return this._processorDestination;\n      }\n      get processorContext() {\n        return this._processorContext;\n      }\n      set processorContext(e) {\n        this._processorContext = e;\n      }\n      get __className__() {\n        return \"LocalVideoTrack\";\n      }\n      constructor(e, t, i, n, r, o) {\n        if (super(e, r), ix(this, \"trackMediaType\", \"video\"), ix(this, \"_player\", void 0), ix(this, \"isUseScaleResolutionDownBy\", !1), ix(this, \"_videoVisibleTimer\", null), ix(this, \"_statsTimer\", null), ix(this, \"_previousVideoVisibleStatus\", void 0), ix(this, \"_clearPreviousVideoVisibleStatus\", () => this._previousVideoVisibleStatus = void 0), ix(this, \"_encoderConfig\", void 0), ix(this, \"_scalabilityMode\", {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        }), ix(this, \"_optimizationMode\", void 0), ix(this, \"_videoHeight\", void 0), ix(this, \"_videoWidth\", void 0), ix(this, \"_forceBitrateLimit\", void 0), ix(this, \"_enabled\", !0), ix(this, \"_processorDestination\", void 0), ix(this, \"_processorContext\", void 0), Nv()) {\n          const _e$getSettings = e.getSettings(),\n            t = _e$getSettings.width,\n            i = _e$getSettings.height;\n          this._videoWidth = t, this._videoHeight = i;\n        } else this.updateMediaStreamTrackResolution();\n        if (this._encoderConfig = t, this._scalabilityMode = i, this._optimizationMode = n, this._hints = o || [], -1 === this._hints.indexOf(LU.SCREEN_TRACK)) this.updateBitrateFromProfile();else if (function (e, t, i) {\n          const n = Iv();\n          return !(n.name !== e || !n.osVersion) && (i ? Number(n.version) >= t && Number(n.version) <= i : Number(n.version) === t);\n        }(gv.CHROME, 115) && -1 !== Av().indexOf(\"Windows\")) {\n          const t = function (e, t) {\n            if (\"VideoFrame\" in window && \"TransformStream\" in window && _U().supportWebRTCInsertableStream) {\n              const i = new MediaStreamTrackProcessor(e),\n                n = new MediaStreamTrackGenerator({\n                  kind: \"video\"\n                });\n              let r,\n                o,\n                s = Date.now();\n              const a = () => {\n                c && (clearInterval(c), c = void 0), r && (r.close(), r = void 0), e.stop(), o = void 0, n.removeEventListener(\"ended\", a);\n              };\n              let c = window.setInterval(() => {\n                if (o && r && Date.now() - s > (null != t ? t : 1e3)) try {\n                  \"live\" === n.readyState ? o.enqueue(r.clone()) : a();\n                } catch (e) {\n                  a();\n                }\n              }, null != t ? t : 1e3);\n              const d = new TransformStream({\n                transform: (e, t) => {\n                  \"live\" === n.readyState ? (o = t, s = Date.now(), void 0 === r ? (r = e, t.enqueue(e.clone())) : (t.enqueue(r), r = e)) : e.close();\n                }\n              });\n              return n.addEventListener(\"ended\", a), i.readable.pipeThrough(d).pipeTo(n.writable), n;\n            }\n          }(e);\n          t && (Qy.info(\"local screen video track begin to inject frame\"), this._mediaStreamTrack = t);\n        }\n        t && -1 !== this._hints.indexOf(LU.CUSTOM_TRACK) && this.setEncoderConfiguration(t), this._processorContext = new Mx(this.getTrackId(), \"local\"), this._processorDestination = new kx(this.processorContext), this.bindProcessorDestinationEvents();\n      }\n      play(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        if (\"string\" == typeof e) {\n          const t = document.getElementById(e);\n          t ? e = t : (Qy.warning(\"[\".concat(this.getTrackId(), '] can not find \"#').concat(e, '\" element, use document.body')), e = document.body);\n        }\n        Qy.debug(\"[\".concat(this.getTrackId(), \"] start video playback in \").concat(e instanceof HTMLVideoElement ? \"HTMLVideoElement\" : \"HTMLElement\"), JSON.stringify(t));\n        const i = tx(tx(tx({}, this._getDefaultPlayerConfig()), t), {}, {\n          trackId: this.getTrackId(),\n          element: e\n        });\n        this._player ? this._player.updateConfig(i) : (e instanceof HTMLVideoElement ? this._player = new FV(i) : this._player = new jV(i), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {\n          try {\n            const e = this.getVideoElementVisibleStatus();\n            this.safeEmit(VU.VIDEO_ELEMENT_VISIBLE_STATUS, e);\n          } catch (e) {}\n        }, Dy(\"CHECK_VIDEO_VISIBLE_INTERVAL\"));\n      }\n      stop() {\n        this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._statsTimer && (this.isUseScaleResolutionDownBy = !1, window.clearInterval(this._statsTimer), this._statsTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, Qy.debug(\"[\".concat(this.getTrackId(), \"] stop video playback\")));\n      }\n      async setEnabled(e, t) {\n        if (!t) {\n          if (e === this._enabled) return;\n          this.stateCheck(\"enabled\", e);\n        }\n        if (Qy.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), !e) {\n          this._originMediaStreamTrack.enabled = !1;\n          try {\n            await MI(this, PU.NEED_DISABLE_TRACK, this);\n          } catch (e) {\n            throw Qy.error(\"[\".concat(this.getTrackId(), \"] setEnabled to false error\"), e.toString()), e;\n          }\n          return t || (this._enabled = !1), void Qy.info(\"[\".concat(this.getTrackId(), \"] setEnabled to false success\"));\n        }\n        this._originMediaStreamTrack.enabled = !0;\n        try {\n          await MI(this, PU.NEED_ENABLE_TRACK, this);\n        } catch (e) {\n          throw Qy.error(\"[\".concat(this.getTrackId(), \"] setEnabled to true error\"), e.toString()), e;\n        }\n        Qy.info(\"[\".concat(this.getTrackId(), \"] setEnabled to true success\")), t || (this._enabled = !0);\n      }\n      async setMuted(e) {\n        e !== this._muted && (this.stateCheck(\"muted\", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, Qy.debug(\"[\".concat(this.getTrackId(), \"] start set muted: \").concat(e)), e ? await MI(this, PU.NEED_MUTE_TRACK, this) : await MI(this, PU.NEED_UNMUTE_TRACK, this));\n      }\n      async setEncoderConfiguration(e, t) {\n        if (!this._enabled) throw new iI(tI.TRACK_IS_DISABLED, \"can not set encoder configuration when track is disabled\");\n        if (\"720p_auto\" === e ? this.startMonitorStats() : this._statsTimer && (window.clearInterval(this._statsTimer), this._statsTimer = null), e = yU(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e.bitrateMin), e.width || e.height || e.frameRate) {\n          const t = jx({\n            encoderConfig: e\n          });\n          (Nv() || Lv() || Kv()) && (t.deviceId = void 0), Qy.debug(\"[\".concat(this.getTrackId(), \"] setEncoderConfiguration applyConstraints\"), JSON.stringify(e), JSON.stringify(t));\n          try {\n            await this._originMediaStreamTrack.applyConstraints(t), this.updateMediaStreamTrackResolution();\n          } catch (e) {\n            const t = new iI(tI.UNEXPECTED_ERROR, e.toString());\n            throw Qy.error(\"[\".concat(this.getTrackId(), \"] applyConstraints error\"), t.toString()), t;\n          }\n        }\n        this._encoderConfig = e, -1 === this._hints.indexOf(LU.SCREEN_TRACK) && this.updateBitrateFromProfile();\n        try {\n          await MI(this, PU.NEED_UPDATE_VIDEO_ENCODER, this);\n        } catch (e) {\n          return e.throw(Qy);\n        }\n      }\n      getStats() {\n        KI(() => {\n          Qy.warning(\"[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead\");\n        }, \"localVideoTrackGetStatsWarning\");\n        return UI(this, PU.GET_STATS) || tx({}, GU);\n      }\n      async setBeautyEffect(e) {\n        Qy.error(\"LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect\");\n      }\n      getCurrentFrameData() {\n        return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);\n      }\n      async getCurrentFrameImage(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n        return this._player ? this._player.getCurrentFrameToUint8Array(e, t) : await Kx(e);\n      }\n      async setBitrateLimit(e) {\n        if (Qy.debug(\"[\".concat(this.getTrackId(), \"] set bitrate limit, \").concat(JSON.stringify(e))), e) {\n          this._forceBitrateLimit = e, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e.max_bitrate ? this._encoderConfig.bitrateMax : e.max_bitrate : this._encoderConfig.bitrateMax = e.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e.min_bitrate);\n          try {\n            await MI(this, PU.NEED_UPDATE_VIDEO_ENCODER, this);\n          } catch (e) {\n            return e.throw(Qy);\n          }\n        }\n      }\n      async setOptimizationMode(e) {\n        if (\"motion\" !== e && \"detail\" !== e && \"balanced\" !== e) return void Qy.error(tI.INVALID_PARAMS, \"optimization mode must be motion, detail or balanced\");\n        const t = this._optimizationMode;\n        try {\n          this._optimizationMode = e, await MI(this, PU.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this);\n        } catch (e) {\n          throw this._optimizationMode = t, Qy.error(\"[\".concat(this.getTrackId(), \"] set optimization mode failed\"), e.toString()), e;\n        }\n        Qy.info(\"[\".concat(this.getTrackId(), \"] set optimization mode success (\").concat(e, \")\"));\n      }\n      setScalabiltyMode(e) {\n        if (1 === e.numSpatialLayers && 1 !== e.numTemporalLayers) return Qy.error(tI.INVALID_PARAMS, \"scalability mode currently not supported, no SVC.\"), void (this._scalabilityMode = {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        });\n        this._scalabilityMode = e, Qy.info(\"[\".concat(this.getTrackId(), \"] set scalability mode success (\").concat(e, \")\"));\n      }\n      updateMediaStreamTrackResolution() {\n        Bx(this._originMediaStreamTrack).then(e => {\n          let _e13 = _slicedToArray(e, 2),\n            t = _e13[0],\n            i = _e13[1];\n          this._videoHeight = i, this._videoWidth = t;\n        }).catch(iy);\n      }\n      _updatePlayerSource() {\n        this._player && this._player.updateVideoTrack(this._mediaStreamTrack);\n      }\n      _getDefaultPlayerConfig() {\n        return {\n          fit: \"contain\"\n        };\n      }\n      async setSenderConfiguration(e) {\n        if (!this._enabled) throw new iI(tI.TRACK_IS_DISABLED, \"can not set encoder configuration when track is disabled\");\n        Qy.debug(\"[\".concat(this.getTrackId(), \"] setSenderConfiguration applyConstraints\"), JSON.stringify(e)), e = yU(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e.bitrateMin), this._encoderConfig = e, -1 === this._hints.indexOf(LU.SCREEN_TRACK) && this.updateBitrateFromProfile();\n        try {\n          await MI(this, PU.NEED_UPDATE_VIDEO_ENCODER, this);\n        } catch (e) {\n          return e.throw(Qy);\n        }\n      }\n      updateBitrateFromProfile() {\n        if (!this._encoderConfig) return;\n        const _this$getMediaStreamT = this.getMediaStreamTrackSettings(),\n          e = _this$getMediaStreamT.width,\n          t = _this$getMediaStreamT.height,\n          i = _this$getMediaStreamT.frameRate;\n        if (!e || !t || !i) return;\n        const _this$_encoderConfig = this._encoderConfig,\n          n = _this$_encoderConfig.bitrateMax,\n          r = _this$_encoderConfig.bitrateMin;\n        if (null == r || null == n) {\n          const _ref21 = function (e, t, i, n, r) {\n              const o = Dy(\"BITRATE_ADAPTER_TYPE\");\n              if (\"DEFAULT_BITRATE\" === o) return {\n                min: n,\n                max: r\n              };\n              if (void 0 === r) {\n                var s;\n                const a = Math.floor(200 * Math.pow(i / 15, .6) * Math.pow(e * t / 640 / 360, .75));\n                r = \"STANDARD_BITRATE\" === o ? 4 * a : 2 * a, n = null !== (s = n) && void 0 !== s ? s : a;\n              } else {\n                var a;\n                n = null !== (a = n) && void 0 !== a ? a : Math.floor(r / 10);\n              }\n              return {\n                min: n,\n                max: r\n              };\n            }(e, t, i, r, n),\n            o = _ref21.max,\n            s = _ref21.min;\n          this._encoderConfig.bitrateMin = s, this._encoderConfig.bitrateMax = o, Qy.debug(\"[\".concat(this.getTrackId(), \"] update bitrate from profile, [w: \").concat(e, \", h: \").concat(t, \", fps: \").concat(i, \"] => [brMax: \").concat(o, \", brMin: \").concat(s, \"]\"));\n        }\n      }\n      getVideoElementVisibleStatus() {\n        try {\n          var e, t;\n          const i = null == this || null === (e = this._player) || void 0 === e ? void 0 : e.getContainerElement(),\n            n = {\n              track: this,\n              element: null == this || null === (t = this._player) || void 0 === t ? void 0 : t.getVideoElement(),\n              slot: null == i ? void 0 : i.parentElement\n            },\n            r = n.element,\n            o = n.slot;\n          if (this.isPlaying && r instanceof HTMLVideoElement && o instanceof HTMLElement) {\n            const e = EI.checkOneElementVisible(r),\n              t = Object.assign({}, e);\n            if (t.visible !== this._previousVideoVisibleStatus) {\n              this._previousVideoVisibleStatus = t.visible;\n              const e = oA.reportApiInvoke(null, {\n                tag: vI.TRACER,\n                name: CI.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE,\n                options: [this.getTrackId()]\n              });\n              t.visible ? e.onSuccess(\"Video is visible\") : e.onSuccess(\"Invisible because of \".concat(t.reason));\n            }\n            return t;\n          }\n          return;\n        } catch (e) {\n          throw new iI(tI.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message);\n        }\n      }\n      async renewMediaStreamTrack(e) {}\n      pipe(e) {\n        if (this.processor === e) return e;\n        if (e._source) throw new iI(tI.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n          track: this._originMediaStreamTrack,\n          context: this.processorContext\n        }), e;\n      }\n      unpipe() {\n        if (!this.processor) return;\n        const e = this.processor;\n        this.processor._source = void 0, this.processor = void 0, e.reset();\n      }\n      close() {\n        super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();\n      }\n      clone(t) {\n        let i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],\n          n = this._encoderConfig;\n        t && (n = tx(tx({}, n), yU(t))), n = WI(n);\n        const r = ey(8, \"track-video-cloned-\"),\n          o = new e(i ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, n, WI(this._scalabilityMode), this._optimizationMode, r, WI(this._hints));\n        return t && n && o.setEncoderConfiguration(n), Qy.debug(\"clone video track from \".concat(this.getTrackId(), \" to \").concat(r, \", clone \").concat(i)), o;\n      }\n      async replaceTrack(e, t) {\n        if (!(e instanceof MediaStreamTrack)) throw new iI(tI.INVALID_PARAMS, \"track should be an instance of MediaStreamTrack\");\n        if (\"video\" !== e.kind) throw new iI(tI.INVALID_PARAMS, \"track should be a video MediaStreamTrack\");\n        await this._updateOriginMediaStreamTrack(e, t, !0), this.updateMediaStreamTrackResolution();\n      }\n      startMonitorStats() {\n        if (!Nv() && !Lv()) return;\n        this._statsTimer && window.clearInterval(this._statsTimer);\n        let e = 2,\n          t = CU[e],\n          i = -1,\n          n = Date.now();\n        const r = e => {\n          e > 2 || e < 0 || (n = Date.now(), t = CU[e], this.setSenderConfiguration(t));\n        };\n        this.isUseScaleResolutionDownBy = !0, this._statsTimer = window.setInterval(() => {\n          const o = this.getStats(),\n            s = UI(this, PU.GET_RTC_STATS);\n          if (o.sendPackets > 0 && s) {\n            -1 === i && (i = Date.now());\n            const a = Date.now();\n            if (a - i < 1e3 || a - n < Dy(\"PROFILE_SWITCH_INTERVAL\")) return;\n            const c = o.sendFrameRate,\n              d = .6 * t.frameRate,\n              l = .9 * t.frameRate;\n            \"number\" == typeof c && c > 0 && c < d ? e > 0 && (e--, r(e), Qy.debug(\"[\".concat(this.getTrackId(), \"] step down for fps \").concat(c, \", switchProfile to \").concat(e))) : s.OutgoingAvailableBandwidth < t.bitrateMin ? e > 0 && (e--, r(e), Qy.debug(\"[\".concat(this.getTrackId(), \"] step down for OutgoingAvailableBandwidth \").concat(s.OutgoingAvailableBandwidth, \", bitrateMin \").concat(t.bitrateMin, \", switchProfile to \").concat(e))) : \"number\" == typeof c && c > l && e < CU.length - 1 && s.OutgoingAvailableBandwidth > 1.2 * CU[e + 1].bitrateMin && (e++, r(e), Qy.debug(\"[\".concat(this.getTrackId(), \"] step up for fps \").concat(c, \", OutgoingAvailableBandwidth \").concat(s.OutgoingAvailableBandwidth, \", switchProfile to \").concat(e)));\n          }\n        }, Dy(\"CHECK_LOCAL_STATS_INTERVAL\"));\n      }\n      sendSeiData(e) {\n        if (KI(() => {\n          oA.reportApiInvoke(null, {\n            name: CI.LOCAL_VIDEO_SEND_SEI_DATA,\n            options: [],\n            tag: vI.TRACER\n          }).onSuccess(\"\");\n        }, this._mediaStreamTrack.id || this.getTrackId()), !Dy(\"ENABLE_VIDEO_SEI\") || !Dy(\"ENABLE_ENCODED_TRANSFORM\")) return void Qy.warning('To send/receive SEI, please call AgoraRTC.setParameter(\"ENABLE_VIDEO_SEI\", true) before instantiate IAgoraRtcClient');\n        if (e instanceof Uint8Array == 0) return new iI(tI.INVALID_PARAMS, \"Invalid argument type, ILocalVideoTrack.sendSeiData() only accept Uint8Array argument.\").throw();\n        const t = this.getRTCRtpTransceiver();\n        if (!t) return void Qy.warning(\"Video track is not published, SEI can not be send\");\n        const i = t.sender.getParameters();\n        if (0 === i.codecs.length) return;\n        const n = i.codecs[0].mimeType.toLocaleLowerCase();\n        \"video/h264\" === n ? this.safeEmit(\"sei-to-send\", e) : Qy.warning(\"SEI is not supported by \".concat(n));\n      }\n      bindProcessorDestinationEvents() {\n        this.processorDestination.on(YU.ON_TRACK, async e => {\n          e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(), await MI(this, PU.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await MI(this, PU.NEED_REPLACE_TRACK, this));\n        });\n      }\n      unbindProcessorDestinationEvents() {\n        this.processorDestination.removeAllListeners(YU.ON_TRACK);\n      }\n      unbindProcessorContextEvents() {\n        this.processorContext.removeAllListeners(qU.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(qU.REQUEST_CONSTRAINTS);\n      }\n    }, nx(pF.prototype, \"play\", [GV, WV], Object.getOwnPropertyDescriptor(pF.prototype, \"play\"), pF.prototype), nx(pF.prototype, \"stop\", [HV], Object.getOwnPropertyDescriptor(pF.prototype, \"stop\"), pF.prototype), nx(pF.prototype, \"setEnabled\", [KV, YV, qV], Object.getOwnPropertyDescriptor(pF.prototype, \"setEnabled\"), pF.prototype), nx(pF.prototype, \"setMuted\", [zV, JV, XV], Object.getOwnPropertyDescriptor(pF.prototype, \"setMuted\"), pF.prototype), nx(pF.prototype, \"setEncoderConfiguration\", [QV, ZV], Object.getOwnPropertyDescriptor(pF.prototype, \"setEncoderConfiguration\"), pF.prototype), nx(pF.prototype, \"getStats\", [$V], Object.getOwnPropertyDescriptor(pF.prototype, \"getStats\"), pF.prototype), nx(pF.prototype, \"setBeautyEffect\", [eF, tF], Object.getOwnPropertyDescriptor(pF.prototype, \"setBeautyEffect\"), pF.prototype), nx(pF.prototype, \"getCurrentFrameData\", [iF], Object.getOwnPropertyDescriptor(pF.prototype, \"getCurrentFrameData\"), pF.prototype), nx(pF.prototype, \"getCurrentFrameImage\", [nF], Object.getOwnPropertyDescriptor(pF.prototype, \"getCurrentFrameImage\"), pF.prototype), nx(pF.prototype, \"setBitrateLimit\", [rF], Object.getOwnPropertyDescriptor(pF.prototype, \"setBitrateLimit\"), pF.prototype), nx(pF.prototype, \"setOptimizationMode\", [oF], Object.getOwnPropertyDescriptor(pF.prototype, \"setOptimizationMode\"), pF.prototype), nx(pF.prototype, \"setScalabiltyMode\", [sF], Object.getOwnPropertyDescriptor(pF.prototype, \"setScalabiltyMode\"), pF.prototype), nx(pF.prototype, \"updateMediaStreamTrackResolution\", [aF], Object.getOwnPropertyDescriptor(pF.prototype, \"updateMediaStreamTrackResolution\"), pF.prototype), nx(pF.prototype, \"pipe\", [cF], Object.getOwnPropertyDescriptor(pF.prototype, \"pipe\"), pF.prototype), nx(pF.prototype, \"unpipe\", [dF], Object.getOwnPropertyDescriptor(pF.prototype, \"unpipe\"), pF.prototype), nx(pF.prototype, \"close\", [lF], Object.getOwnPropertyDescriptor(pF.prototype, \"close\"), pF.prototype), nx(pF.prototype, \"replaceTrack\", [hF], Object.getOwnPropertyDescriptor(pF.prototype, \"replaceTrack\"), pF.prototype), nx(pF.prototype, \"startMonitorStats\", [uF], Object.getOwnPropertyDescriptor(pF.prototype, \"startMonitorStats\"), pF.prototype), pF),\n    IF = (_F = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), EF = Lx(), mF = py(\"CameraVideoTrack\", \"_enabledMutex\"), fF = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), TF = Lx(), SF = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), gF = Lx(), RF = rA({\n      argsMap: e => [e.getTrackId()]\n    }), CF = class e extends vF {\n      get __className__() {\n        return \"CameraVideoTrack\";\n      }\n      constructor(e, t, i, n, r, o) {\n        super(e, yU(t.encoderConfig), n, r, o), ix(this, \"_config\", void 0), ix(this, \"_originalConstraints\", void 0), ix(this, \"_constraints\", void 0), ix(this, \"_enabled\", !0), ix(this, \"_deviceName\", \"default\"), ix(this, \"tryResumeVideoForIOS15_16WeChat\", async () => {\n          (Gv() || Wv()) && !function () {\n            const e = Iv();\n            if (e.os !== Sv.IOS || !e.osVersion) return !1;\n            const t = e.osVersion.split(\".\");\n            return 15 === Number(t[0]) && Number(t[1]) >= 2;\n          }() && Yv() && this._enabled && !this._isClosed && (Qy.debug(\"[\".concat(this.getTrackId(), \"] try capture camera media device for interrupted iOS 15 device on WeChat.\")), await this.renewMediaStreamTrack());\n        }), this._config = t, this._originalConstraints = i, this._constraints = i, this._deviceName = e.label, this._encoderConfig = yU(this._config.encoderConfig), cx.on(mU.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), cx.on(mU.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();\n      }\n      async setDevice(e) {\n        return \"string\" == typeof e ? this._setDeviceById(e) : e.deviceId ? this._setDeviceById(e.deviceId) : e.facingMode ? this._setDeviceByFacingModel(e.facingMode) : void 0;\n      }\n      async _setDeviceById(e) {\n        if (Qy.info(\"[\".concat(this.getTrackId(), \"] set device to \").concat(e)), this._enabled) try {\n          const t = await Ax.getDeviceById(e),\n            i = {};\n          i.video = tx({}, this._constraints), i.video.deviceId = {\n            exact: e\n          }, i.video.facingMode = void 0, this._originMediaStreamTrack.stop();\n          let n = null;\n          try {\n            n = await Cx(i, this.getTrackId());\n          } catch (e) {\n            throw Qy.error(\"[\".concat(this.getTrackId(), \"] setDevice failed\"), e.toString()), n = await Cx({\n              video: this._constraints\n            }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n.getVideoTracks()[0], !1), e;\n          }\n          await this._updateOriginMediaStreamTrack(n.getVideoTracks()[0], !1), this.updateMediaStreamTrackResolution(), this._deviceName = t.label, this._config.cameraId = e, this._constraints.deviceId = {\n            exact: e\n          };\n        } catch (e) {\n          throw Qy.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n        } else try {\n          const t = await Ax.getDeviceById(e);\n          this._deviceName = t.label, this._config.cameraId = e, this._constraints.deviceId = {\n            exact: e\n          };\n        } catch (e) {\n          throw Qy.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n        }\n        Qy.info(\"[\".concat(this.getTrackId(), \"] setDevice success\"));\n      }\n      async _setDeviceByFacingModel(e) {\n        Qy.info(\"[\".concat(this.getTrackId(), \"] set facingMode \").concat(e));\n        const t = {\n          video: tx(tx({}, this._constraints), {}, {\n            deviceId: void 0,\n            facingMode: {\n              exact: e\n            }\n          })\n        };\n        if (this._enabled) {\n          this._originMediaStreamTrack.stop();\n          let e = null;\n          try {\n            e = await Cx(t, this.getTrackId());\n          } catch (t) {\n            throw Qy.error(\"[\".concat(this.getTrackId(), \"] setDeviceByFacingModel failed\"), t.toString()), e = await Cx({\n              video: this._constraints\n            }, this.getTrackId()), await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !1), t;\n          }\n          await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !1), this.updateMediaStreamTrackResolution();\n        }\n        this._deviceName = \"\", this._config.facingMode = e, this._config.cameraId = void 0, this._constraints = tx({}, t.video), Qy.info(\"[\".concat(this.getTrackId(), \"] setDeviceByFacingModel success\"));\n      }\n      async setEnabled(e, t) {\n        if (!t) {\n          if (e === this._enabled) return;\n          this.stateCheck(\"enabled\", e);\n        }\n        if (Qy.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), e) {\n          try {\n            if (this.isExternalTrack) this._originMediaStreamTrack.enabled = !0;else {\n              const e = await Cx({\n                video: this._constraints\n              }, this.getTrackId());\n              await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !1);\n            }\n            await MI(this, PU.NEED_ENABLE_TRACK, this);\n          } catch (e) {\n            throw Qy.error(\"[\".concat(this.getTrackId(), \"] setEnabled true error\"), e.toString()), e;\n          }\n          this.updateMediaStreamTrackResolution(), Qy.info(\"[\".concat(this.getTrackId(), \"] setEnabled to true success\")), t || (this._enabled = !0);\n        } else {\n          this.isExternalTrack ? this._originMediaStreamTrack.enabled = !1 : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t || (this._enabled = !1);\n          try {\n            await MI(this, PU.NEED_DISABLE_TRACK, this);\n          } catch (e) {\n            throw Qy.error(\"[\".concat(this.getTrackId(), \"] setEnabled to false error\"), e.toString()), e;\n          }\n          Qy.info(\"[\".concat(this.getTrackId(), \"] setEnabled to false success\"));\n        }\n      }\n      async setEncoderConfiguration(e, t) {\n        if (!this._enabled) throw new iI(tI.TRACK_IS_DISABLED, \"can not set encoder configuration when track is disabled\");\n        \"720p_auto\" === e ? this.startMonitorStats() : this._statsTimer && (window.clearInterval(this._statsTimer), this._statsTimer = null), e = yU(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate || e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate || e.bitrateMin);\n        const i = GI(this._config);\n        i.encoderConfig = e;\n        const n = jx(i);\n        (Nv() || Lv() || Kv()) && (n.deviceId = void 0), Qy.debug(\"[\".concat(this.getTrackId(), \"] setEncoderConfiguration applyConstraints\"), JSON.stringify(e), JSON.stringify(n));\n        try {\n          await this._originMediaStreamTrack.applyConstraints(n), this.updateMediaStreamTrackResolution();\n        } catch (e) {\n          const t = new iI(tI.UNEXPECTED_ERROR, e.toString());\n          throw Qy.error(\"[\".concat(this.getTrackId(), \"] applyConstraints error\"), t.toString()), t;\n        }\n        this._config = i, this._constraints = n, this._originalConstraints = n, this._encoderConfig = e, -1 === this._hints.indexOf(LU.SCREEN_TRACK) && this.updateBitrateFromProfile();\n        try {\n          await MI(this, PU.NEED_UPDATE_VIDEO_ENCODER, this);\n        } catch (e) {\n          return e.throw(Qy);\n        }\n      }\n      _getDefaultPlayerConfig() {\n        return {\n          mirror: !0,\n          fit: \"cover\"\n        };\n      }\n      onTrackEnded() {\n        if ((Lv() || Kv()) && this._enabled && !this._isClosed && cx.duringInterruption) {\n          const e = async () => {\n            cx.off(mU.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (Qy.debug(\"[\".concat(this.getTrackId(), \"] try capture camera media device for interrupted iOS device.\")), await this.setEnabled(!1), await this.setEnabled(!0));\n          };\n          cx.on(mU.IOS_INTERRUPTION_END, e);\n        } else Qy.debug(\"[\".concat(this.getTrackId(), \"] track ended\")), this.safeEmit(VU.TRACK_ENDED);\n      }\n      async renewMediaStreamTrack(e) {\n        const t = e || this._constraints,\n          i = Ax.searchDeviceIdByName(this._deviceName);\n        if (i && !t.deviceId && (t.deviceId = {\n          exact: i\n        }), this._enabled) {\n          const e = await Cx({\n            video: t\n          }, this.getTrackId());\n          this._constraints = t, await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !0), this.updateMediaStreamTrackResolution();\n        }\n      }\n      close() {\n        super.close(), cx.off(mU.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), cx.off(mU.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);\n      }\n      clone(t) {\n        let i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],\n          n = this._encoderConfig;\n        t && (n = tx(tx({}, n), yU(t))), n = WI(n);\n        const r = ey(8, \"track-cam-cloned-\"),\n          o = new e(i ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, WI(tx(tx({}, this._config), {}, {\n            encoderConfig: n\n          })), WI(this._constraints), WI(this._scalabilityMode), this._optimizationMode, r);\n        return t && n && o.setEncoderConfiguration(n), Qy.debug(\"clone track from \".concat(this.getTrackId(), \" to \").concat(r, \", clone \").concat(i)), o;\n      }\n      bindProcessorContextEvents() {\n        this.processorContext.on(qU.REQUEST_UPDATE_CONSTRAINTS, async (e, t, i) => {\n          try {\n            const i = Object.assign({}, this._originalConstraints, ...e);\n            await this.renewMediaStreamTrack(i), t();\n          } catch (e) {\n            i(e);\n          }\n        }), this.processorContext.on(qU.REQUEST_CONSTRAINTS, async e => {\n          e(this._originMediaStreamTrack.getSettings());\n        });\n      }\n    }, nx(CF.prototype, \"setDevice\", [_F, EF], Object.getOwnPropertyDescriptor(CF.prototype, \"setDevice\"), CF.prototype), nx(CF.prototype, \"setEnabled\", [mF, fF, TF], Object.getOwnPropertyDescriptor(CF.prototype, \"setEnabled\"), CF.prototype), nx(CF.prototype, \"setEncoderConfiguration\", [SF, gF], Object.getOwnPropertyDescriptor(CF.prototype, \"setEncoderConfiguration\"), CF.prototype), nx(CF.prototype, \"close\", [RF], Object.getOwnPropertyDescriptor(CF.prototype, \"close\"), CF.prototype), CF);\n  function yF(e, t, i, n) {\n    i.optimizationMode && (n && n.width && n.height ? (i.encoderConfig = tx(tx({}, n), {}, {\n      bitrateMin: n.bitrateMin,\n      bitrateMax: n.bitrateMax\n    }), \"motion\" !== i.optimizationMode && \"detail\" !== i.optimizationMode || (t.contentHint = i.optimizationMode, t.contentHint === i.optimizationMode ? Qy.debug(\"[\".concat(e, \"] set content hint to\"), i.optimizationMode) : Qy.debug(\"[\".concat(e, \"] set content hint failed\")))) : Qy.warning(\"[\".concat(e, \"] can not apply optimization mode bitrate config, no encoderConfig\")));\n  }\n  var AF, bF, wF, OF, NF, DF, PF, LF, kF, MF, UF, xF;\n  class VF extends rx {\n    getUserId() {\n      return this._userId;\n    }\n    constructor(e, t, i, n) {\n      super(e, \"track-\".concat(e.kind, \"-\").concat(t, \"-\").concat(n.clientId, \"_\").concat(ey(5, \"\"))), ix(this, \"_userId\", void 0), ix(this, \"_uintId\", void 0), ix(this, \"_isDestroyed\", !1), ix(this, \"store\", void 0), ix(this, \"processor\", void 0), ix(this, \"processorContext\", void 0), this._userId = t, this._uintId = i, this.store = n;\n    }\n    _updateOriginMediaStreamTrack(e) {\n      this._originMediaStreamTrack = e, this._mediaStreamTrack = e, this._updatePlayerSource(), this.processor && this.processor.updateInput({\n        track: this._originMediaStreamTrack,\n        context: this.processorContext\n      });\n    }\n    _destroy() {\n      this._isDestroyed = !0, Qy.info(\"[\".concat(this.getTrackId(), \"] is destroyed\")), this.stop(), super.close();\n    }\n    getProcessorStats() {\n      return this.processorContext.gatherStats();\n    }\n    getProcessorUsage() {\n      return this.processorContext.gatherUsage();\n    }\n  }\n  let FF = (AF = rA({\n      argsMap: (e, t, i) => [e.getTrackId(), \"string\" == typeof t ? t : t instanceof HTMLVideoElement ? \"HTMLVideoElement\" : \"HTMLElement\", i]\n    }), bF = rA({\n      argsMap: e => [e.getTrackId()]\n    }), wF = rA({\n      argsMap: (e, t) => [e.getTrackId(), t.name]\n    }), OF = rA({\n      argsMap: e => [e.getTrackId()]\n    }), nx((NF = class extends VF {\n      get isPlaying() {\n        return !(!this._player || this._player.videoElementStatus !== XU.PLAYING);\n      }\n      get __className__() {\n        return \"RemoteVideoTrack\";\n      }\n      constructor(e, t, i, n) {\n        super(e, t, i, n), ix(this, \"_videoVisibleTimer\", null), ix(this, \"_previousVideoVisibleStatus\", void 0), ix(this, \"_clearPreviousVideoVisibleStatus\", () => this._previousVideoVisibleStatus = void 0), ix(this, \"trackMediaType\", \"video\"), ix(this, \"_videoWidth\", void 0), ix(this, \"_videoHeight\", void 0), ix(this, \"_player\", void 0), ix(this, \"processorDestination\", void 0), ix(this, \"processorContext\", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new Mx(this.getTrackId(), \"remote\"), this.processorDestination = new kx(this.processorContext), this.bindProcessorDestinationEvents();\n      }\n      getStats() {\n        return KI(() => {\n          Qy.warning(\"[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead\");\n        }, \"remoteVideoTrackGetStatsWarning\"), UI(this, PU.GET_STATS) || tx({}, KU);\n      }\n      play(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        if (\"string\" == typeof e) {\n          const t = document.getElementById(e);\n          t ? e = t : (Qy.warning(\"[\".concat(this.getTrackId(), '] can not find \"#').concat(e, '\" element, use document.body')), e = document.body);\n        }\n        Qy.debug(\"[\".concat(this.getTrackId(), \"] start video playback in \").concat(e instanceof HTMLVideoElement ? \"HTMLVideoElement\" : \"HTMLElement\"), JSON.stringify(t));\n        const i = tx(tx({\n          fit: \"cover\"\n        }, t), {}, {\n          trackId: this.getTrackId(),\n          element: e\n        });\n        this._player ? this._player.updateConfig(i) : (e instanceof HTMLVideoElement ? this._player = new FV(i) : this._player = new jV(i), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {\n          this.store.subscribe(this.getUserId(), \"video\", void 0, void 0, Date.now()), this.safeEmit(FU.FIRST_FRAME_DECODED);\n        }, this._player.onVideoStateChanged = e => {\n          this.safeEmit(FU.VIDEO_STATE_CHANGED, e);\n        }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {\n          try {\n            const e = this.getVideoElementVisibleStatus();\n            this.safeEmit(FU.VIDEO_ELEMENT_VISIBLE_STATUS, e);\n          } catch (e) {}\n        }, Dy(\"CHECK_VIDEO_VISIBLE_INTERVAL\"));\n      }\n      stop() {\n        this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, Qy.debug(\"[\".concat(this.getTrackId(), \"] stop video playback\")));\n      }\n      getCurrentFrameData() {\n        return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);\n      }\n      updateMediaStreamTrackResolution() {\n        Bx(this._originMediaStreamTrack).then(e => {\n          let _e14 = _slicedToArray(e, 2),\n            t = _e14[0],\n            i = _e14[1];\n          this._videoHeight = i, this._videoWidth = t;\n        }).catch(iy);\n      }\n      _updatePlayerSource() {\n        Qy.debug(\"[\".concat(this.getTrackId(), \"] update player source track\")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);\n      }\n      getVideoElementVisibleStatus() {\n        try {\n          var e, t;\n          const i = null == this || null === (e = this._player) || void 0 === e ? void 0 : e.getContainerElement(),\n            n = {\n              track: this,\n              element: null == this || null === (t = this._player) || void 0 === t ? void 0 : t.getVideoElement(),\n              slot: null == i ? void 0 : i.parentElement\n            },\n            r = n.element,\n            o = n.slot;\n          if (this.isPlaying && r instanceof HTMLVideoElement && o instanceof HTMLElement) {\n            const e = EI.checkOneElementVisible(r),\n              t = Object.assign({}, e);\n            if (t.visible !== this._previousVideoVisibleStatus) {\n              this._previousVideoVisibleStatus = t.visible;\n              const e = oA.reportApiInvoke(null, {\n                tag: vI.TRACER,\n                name: CI.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE,\n                options: [this.getTrackId()]\n              });\n              t.visible ? e.onSuccess(\"Video is visible\") : e.onSuccess(\"Invisible because of \".concat(t.reason));\n            }\n            return t;\n          }\n          return;\n        } catch (e) {\n          throw new iI(tI.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message);\n        }\n      }\n      pipe(e) {\n        if (this.processor === e) return e;\n        if (e._source) throw new iI(tI.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n          track: this._originMediaStreamTrack,\n          context: this.processorContext\n        }), e;\n      }\n      unpipe() {\n        if (!this.processor) return;\n        const e = this.processor;\n        this.processor._source = void 0, this.processor = void 0, e.reset();\n      }\n      bindProcessorDestinationEvents() {\n        this.processorDestination.on(YU.ON_TRACK, async e => {\n          e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());\n        });\n      }\n      unbindProcessorDestinationEvents() {\n        this.processorDestination.removeAllListeners(YU.ON_TRACK);\n      }\n      _destroy() {\n        super._destroy(), this.unbindProcessorDestinationEvents();\n      }\n      _onSei(e) {\n        this.emit(xU.SEI_RECEIVED, e);\n      }\n    }).prototype, \"play\", [AF], Object.getOwnPropertyDescriptor(NF.prototype, \"play\"), NF.prototype), nx(NF.prototype, \"stop\", [bF], Object.getOwnPropertyDescriptor(NF.prototype, \"stop\"), NF.prototype), nx(NF.prototype, \"pipe\", [wF], Object.getOwnPropertyDescriptor(NF.prototype, \"pipe\"), NF.prototype), nx(NF.prototype, \"unpipe\", [OF], Object.getOwnPropertyDescriptor(NF.prototype, \"unpipe\"), NF.prototype), NF),\n    BF = (DF = rA({\n      argsMap: (e, t) => [e.getTrackId(), t],\n      throttleTime: 300\n    }), PF = rA({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), LF = rA({\n      argsMap: e => [e.getTrackId()]\n    }), kF = rA({\n      argsMap: e => [e.getTrackId()]\n    }), MF = rA({\n      argsMap: (e, t) => [e.getTrackId(), t.name]\n    }), UF = rA({\n      argsMap: e => [e.getTrackId()]\n    }), nx((xF = class extends VF {\n      get isPlaying() {\n        return this._useAudioElement ? Px.isPlaying(this.getTrackId()) : this._source.isPlayed;\n      }\n      get __className__() {\n        return \"RemoteAudioTrack\";\n      }\n      constructor(e, t, i, n) {\n        super(e, t, i, n), ix(this, \"trackMediaType\", \"audio\"), ix(this, \"_source\", void 0), ix(this, \"_useAudioElement\", !0), ix(this, \"_volume\", 100), ix(this, \"processorContext\", void 0), ix(this, \"processorDestination\", void 0), ix(this, \"_played\", !1), ix(this, \"_bypassWebAudio\", !1), Dy(\"DISABLE_WEBAUDIO\") ? (this._source = new Vx(), this._bypassWebAudio = !0, this._useAudioElement = !0) : (this._source = new Ex(e, !0), Dy(\"REMOTE_AUDIO_TRACK_USES_WEB_AUDIO\") && (this._useAudioElement = !1)), this._source.once(BU.RECEIVE_TRACK_BUFFER, () => {\n          this.safeEmit(FU.FIRST_FRAME_DECODED);\n        }), this.processorContext = new xx(this._source.context, this.getTrackId(), \"remote\"), this.processorDestination = new Ux(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(BU.UPDATE_SOURCE, () => {\n          this.processor && this.processor.updateInput({\n            node: this._source.processSourceNode,\n            context: this.processorContext\n          });\n        });\n      }\n      setAudioFrameCallback(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;\n        if (!e) return this._source.removeAllListeners(BU.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();\n        this._source.startGetAudioBuffer(t), this._source.removeAllListeners(BU.ON_AUDIO_BUFFER), this._source.on(BU.ON_AUDIO_BUFFER, t => e(t));\n      }\n      setVolume(e) {\n        this._volume = e, this._useAudioElement ? Px.setVolume(this.getTrackId(), e) : this._source.setVolume(e / 100);\n      }\n      async setPlaybackDevice(e) {\n        if (!this._useAudioElement || !EU()) throw new iI(tI.NOT_SUPPORTED, \"your browser does not support setting the audio output device\");\n        await Px.setSinkID(this.getTrackId(), e);\n      }\n      getVolumeLevel() {\n        return this._source.getAccurateVolumeLevel();\n      }\n      getStats() {\n        return KI(() => {\n          Qy.warning(\"[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead\");\n        }, \"remoteAudioTrackGetStatsWarning\"), UI(this, PU.GET_STATS) || tx({}, WU);\n      }\n      play() {\n        Qy.debug(\"[\".concat(this.getTrackId(), \"] start audio playback\")), this._played = !0, this._useAudioElement ? (Qy.debug(\"[\".concat(this.getTrackId(), \"] use audio element to play\")), Px.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play();\n      }\n      stop() {\n        Qy.debug(\"[\".concat(this.getTrackId(), \"] stop audio playback\")), this._played = !1, this._useAudioElement ? Px.stop(this.getTrackId()) : this._source.stop();\n      }\n      _destroy() {\n        super._destroy(), this._played = !1, this.unbindProcessorDestinationEvents(), this._source.destroy();\n      }\n      _isFreeze() {\n        return this._source.isFreeze;\n      }\n      _updatePlayerSource() {\n        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n        Qy.debug(\"[\".concat(this.getTrackId(), \"] update player source track\")), e && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && Px.updateTrack(this.getTrackId(), this._mediaStreamTrack);\n      }\n      pipe(e) {\n        if (this._bypassWebAudio) throw new iI(tI.NOT_SUPPORTED, \"can not pipe extension when WebAudio disabled\");\n        if (this.processor === e) return e;\n        if (e._source) throw new iI(tI.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n          track: this._originMediaStreamTrack,\n          node: this._source.processSourceNode,\n          context: this.processorContext\n        }), e;\n      }\n      unpipe() {\n        var e;\n        if (this._bypassWebAudio) throw new iI(tI.NOT_SUPPORTED, \"can not unpipe extension when WebAudio disabled\");\n        if (!this.processor) return;\n        const t = this.processor;\n        null === (e = this._source.processSourceNode) || void 0 === e || e.disconnect(), this.processor._source = !1, this.processor = void 0, t.reset();\n      }\n      bindProcessorDestinationEvents() {\n        this.processorDestination.on(YU.ON_TRACK, async e => {\n          e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(!1), this._source.processedNode = this._source.createMediaStreamSourceNode(e)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());\n        }), this.processorDestination.on(YU.ON_NODE, e => {\n          this._source.processedNode = e;\n          const t = !e;\n          this._useAudioElement !== t && (this._played ? (this.stop(), this._useAudioElement = t, this.play()) : this._useAudioElement = t);\n        });\n      }\n      unbindProcessorDestinationEvents() {\n        this.processorDestination.removeAllListeners(YU.ON_TRACK), this.processorDestination.removeAllListeners(YU.ON_NODE);\n      }\n    }).prototype, \"setVolume\", [DF], Object.getOwnPropertyDescriptor(xF.prototype, \"setVolume\"), xF.prototype), nx(xF.prototype, \"setPlaybackDevice\", [PF], Object.getOwnPropertyDescriptor(xF.prototype, \"setPlaybackDevice\"), xF.prototype), nx(xF.prototype, \"play\", [LF], Object.getOwnPropertyDescriptor(xF.prototype, \"play\"), xF.prototype), nx(xF.prototype, \"stop\", [kF], Object.getOwnPropertyDescriptor(xF.prototype, \"stop\"), xF.prototype), nx(xF.prototype, \"pipe\", [MF], Object.getOwnPropertyDescriptor(xF.prototype, \"pipe\"), xF.prototype), nx(xF.prototype, \"unpipe\", [UF], Object.getOwnPropertyDescriptor(xF.prototype, \"unpipe\"), xF.prototype), xF);\n  const jF = new class extends SI {\n    get visibility() {\n      return document.visibilityState;\n    }\n    get lastHiddenTime() {\n      return this._lastHiddenTime;\n    }\n    get lastVisibleTime() {\n      return this._lastVisibleTime;\n    }\n    constructor() {\n      super(), ix(this, \"_lastHiddenTime\", 0), ix(this, \"_lastVisibleTime\", 0), document.addEventListener(\"visibilitychange\", () => {\n        \"hidden\" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), Qy.debug(\"document visibility went \".concat(document.visibilityState)), this.emit(\"VISIBILITY_CHANGE\", document.visibilityState);\n      });\n    }\n  }();\n  var GF = function (e) {\n    return e[e.ONE_BYTE = 0] = \"ONE_BYTE\", e[e.TWO_BYTE = 1] = \"TWO_BYTE\", e;\n  }(GF || {});\n  class WF {\n    constructor() {\n      ix(this, \"_sequence\", 0), ix(this, \"_startTime\", Date.now()), ix(this, \"isUseOneByte\", !0);\n    }\n    get startTime() {\n      const e = Date.now() - this._startTime;\n      return e < Math.pow(2, 16) ? e : (this._startTime += Math.pow(2, 16), this.startTime);\n    }\n    get sequence() {\n      return this._sequence < Math.pow(2, 32) ? this._sequence++ : (this._sequence -= Math.pow(2, 32), this.sequence);\n    }\n    serialize(e) {\n      const t = {\n        commonPacketHeader: {\n          length: 0,\n          reserved: 0,\n          extension: 0,\n          sequence: this.sequence\n        },\n        commonStreamHeader: this.startTime,\n        extension: void 0,\n        payload: e\n      };\n      if (e.byteLength > 128) {\n        const i = new Uint8Array(4);\n        i.set([1, 0, 0, 0]);\n        const n = {\n            id: 0,\n            length: 4,\n            data: i.buffer\n          },\n          r = {\n            profile: this.isUseOneByte ? 0 : 1,\n            length: this.isUseOneByte ? 5 : 6,\n            datas: [n]\n          };\n        t.commonPacketHeader.extension = 1, t.extension = r, t.payload = this.compress(e), t.commonPacketHeader.length = 8 + (t.extension.length + 2) + t.payload.byteLength;\n      } else t.commonPacketHeader.length = 8 + t.payload.byteLength;\n      Dy(\"SHOW_DATASTREAM2_LOG\") && Qy.debug(\"send data header: \".concat(JSON.stringify(t.commonPacketHeader)));\n      const i = new ArrayBuffer(t.commonPacketHeader.length),\n        n = new Uint8Array(i),\n        r = new DataView(i);\n      let o = 0;\n      if (r.setUint16(o, t.commonPacketHeader.extension << 15 | t.commonPacketHeader.reserved << 14 | t.commonPacketHeader.length, !0), o += 2, r.setUint32(o, t.commonPacketHeader.sequence, !0), o += 4, r.setUint16(o, t.commonStreamHeader, !0), o += 2, t.extension) {\n        const e = this.serializeExtension(t.extension);\n        n.set(new Uint8Array(e), o), o += e.byteLength;\n      }\n      if (n.set(new Uint8Array(t.payload), o), o += t.payload.byteLength, o !== t.commonPacketHeader.length) throw Error(\"serialize error!\");\n      return i;\n    }\n    deserialize(e) {\n      if (e.byteLength < 4) return new ArrayBuffer(0);\n      const t = new DataView(e);\n      let i = 0;\n      const n = t.getUint16(i, !0);\n      i += 2;\n      const r = {\n        length: 16383 & n,\n        reserved: (16384 & n) >> 14,\n        extension: (32768 & n) >> 15,\n        sequence: t.getUint16(i + 2, !0) << 16 | t.getUint16(i, !0)\n      };\n      let o, s;\n      if (i += 4, Dy(\"SHOW_DATASTREAM2_LOG\") && Qy.debug(\"receive data header: \".concat(JSON.stringify(r))), t.getUint16(i, !0), i += 2, r.extension) {\n        s = this.deserializeExtension(e.slice(i)), i += 2 + s.length, o = e.slice(i);\n        let t = !1;\n        if (s.datas.length > 0) {\n          const e = s.datas.find(e => 0 === e.id);\n          e && (t = 1 == (1 & new DataView(e.data).getUint32(0, !0)));\n        }\n        o = t ? this.decompress(o) : o;\n      } else o = e.slice(8);\n      return o;\n    }\n    serializeExtension(e) {\n      const t = e.profile,\n        i = e.length,\n        n = e.datas,\n        r = new ArrayBuffer(i + 2),\n        o = new Uint8Array(r),\n        s = new DataView(r);\n      let a = 0;\n      if (s.setUint8(a++, t), s.setUint8(a++, i), n.forEach(e => {\n        t ? (s.setUint8(a++, e.id), s.setUint8(a++, e.length), o.set(new Uint8Array(e.data), a), a += e.data.byteLength) : (s.setUint8(a++, e.id | e.length << 4), o.set(new Uint8Array(e.data), a), a += e.data.byteLength);\n      }), a !== i + 2) throw Error(\"serialize extension error, is \".concat(a, \"!==\").concat(i + 2));\n      return r;\n    }\n    deserializeExtension(e) {\n      const t = new DataView(e);\n      let i = 0;\n      const n = t.getUint8(i);\n      i++;\n      const r = t.getUint8(i);\n      i++;\n      const o = n === GF.TWO_BYTE,\n        s = [],\n        a = new DataView(e, 2);\n      let c = 0;\n      for (; c < r;) {\n        let e = 0,\n          t = 0,\n          i = new ArrayBuffer(0);\n        o ? (e = a.getUint8(c), c++, t = a.getUint8(c), c++) : (e = 15 & a.getUint8(c), t = a.getUint8(c) >> 4, c++), t > 0 && (i = a.buffer.slice(c + 2, c + 2 + t), c += i.byteLength), s.push({\n          id: e,\n          length: t,\n          data: i\n        });\n      }\n      if (c !== r) throw Error(\"parse error\");\n      return {\n        profile: n,\n        length: r,\n        datas: s\n      };\n    }\n    decompress(e) {\n      return uU(new Uint8Array(e));\n    }\n    compress(e) {\n      return hU(new Uint8Array(e));\n    }\n  }\n  class HF extends SI {\n    constructor(e, t) {\n      super(), ix(this, \"_version\", 1), ix(this, \"_type\", 3), ix(this, \"_config\", void 0), ix(this, \"_originDataChannel\", void 0), ix(this, \"_dataStreamPacketHeader\", new ArrayBuffer(4)), ix(this, \"_dataStreamPacketHandler\", void 0), ix(this, \"_datachannelEventMap\", new Map()), this._config = e, t && (this._originDataChannel = t, this._bandDataChannelEvents(t)), this._initPacketHeader(), this._dataStreamPacketHandler = new WF();\n    }\n    get id() {\n      return this._config.id;\n    }\n    get ordered() {\n      return this._config.ordered;\n    }\n    get maxRetransmits() {\n      return Dy(\"DATASTREAM_MAX_RETRANSMITS\");\n    }\n    get metadata() {\n      return this._config.metadata;\n    }\n    get readyState() {\n      var e, t;\n      return null !== (e = null === (t = this._originDataChannel) || void 0 === t ? void 0 : t.readyState) && void 0 !== e ? e : \"connecting\";\n    }\n    get _originDataChannelId() {\n      var e, t;\n      return null !== (e = null === (t = this._originDataChannel) || void 0 === t ? void 0 : t.id) && void 0 !== e ? e : null;\n    }\n    getChannelId() {\n      return this.id;\n    }\n    getConfig() {\n      return this._config;\n    }\n    _close() {\n      this._originDataChannel && (this._unbindDataChannelEvents(this._originDataChannel), this._originDataChannel = void 0);\n    }\n    async _waitTillOpen() {\n      return new Gu((e, t) => {\n        if (this._originDataChannel) {\n          \"open\" === this._originDataChannel.readyState && e();\n          const i = setTimeout(() => {\n            var e;\n            t(new iI(tI.DATACHANNEL_CONNECTION_TIMEOUT, \"Cannot create datachannel, id: \".concat(null === (e = this._originDataChannel) || void 0 === e ? void 0 : e.id)));\n          }, 1e4);\n          this._originDataChannel.onopen = () => {\n            clearTimeout(i), this._originDataChannel && this._bandDataChannelEvents(this._originDataChannel), e();\n          }, this._originDataChannel.onerror = () => {\n            throw clearTimeout(i), new iI(tI.DATACHANNEL_CONNECTION_TIMEOUT);\n          };\n        } else t(new iI(tI.DATACHANNEL_CONNECTION_TIMEOUT, \"cannot find dataChannel\"));\n      });\n    }\n    _updateOriginDataChannel(e) {\n      this._originDataChannel = e, this._bandDataChannelEvents(e);\n    }\n    _initPacketHeader() {\n      const e = new DataView(this._dataStreamPacketHeader);\n      e.setUint16(0, this._version), e.setUint8(2, this._type), e.setUint8(3, this._config.id);\n    }\n    _bandDataChannelEvents(e) {\n      this._unbindDataChannelEvents(e), [$U.OPEN, $U.CLOSE, $U.ERROR].forEach(t => {\n        const i = () => {\n          this.emit(t);\n        };\n        this._datachannelEventMap.set(t, i), e.addEventListener(t, i);\n      });\n    }\n    _unbindDataChannelEvents(e) {\n      Array.from(this._datachannelEventMap.entries()).forEach(t => {\n        let _t4 = _slicedToArray(t, 2),\n          i = _t4[0],\n          n = _t4[1];\n        e.removeEventListener(i, n);\n      }), this._datachannelEventMap.clear();\n    }\n  }\n  class KF extends HF {\n    constructor(e) {\n      super(e), ix(this, \"_messageListener\", void 0), this._messageListener = e => {\n        if (e.data.byteLength < this._dataStreamPacketHeader.byteLength) throw Error(\"invalid byteLength: the byte length must exceed \" + this._dataStreamPacketHeader.byteLength);\n        const t = e.data.slice(0, this._dataStreamPacketHeader.byteLength),\n          i = new DataView(t).getUint8(3);\n        if (i !== this.id) return void (Dy(\"SHOW_DATASTREAM2_LOG\") && Qy.debug(\"invalid datachannel id: \".concat(i, \" !== \").concat(this.id)));\n        let n = e.data.slice(this._dataStreamPacketHeader.byteLength);\n        n = this._dataStreamPacketHandler.deserialize(n), this.emit($U.MESSAGE, n);\n      };\n    }\n    _updateOriginDataChannel(e) {\n      super._updateOriginDataChannel(e), this._bandRemoteDataChannelEvents();\n    }\n    _close() {\n      this._originDataChannel && (this._originDataChannel.removeEventListener(\"message\", this._messageListener), super._close());\n    }\n    _bandRemoteDataChannelEvents() {\n      this._originDataChannel && this._originDataChannel.addEventListener(\"message\", this._messageListener);\n    }\n  }\n  class YF extends HF {\n    send(e) {\n      if (this._originDataChannel) {\n        let t = e;\n        t = this._dataStreamPacketHandler.serialize(e);\n        const i = new Uint8Array(this._dataStreamPacketHeader.byteLength + t.byteLength);\n        i.set(new Uint8Array(this._dataStreamPacketHeader), 0), i.set(new Uint8Array(t), this._dataStreamPacketHeader.byteLength), this._originDataChannel.send(i.buffer);\n      }\n    }\n  }\n  function qF() {\n    const e = new Blob([atob(\"ZnVuY3Rpb24gZShlKXtjb25zdCB0PW5ldyBEYXRhVmlldyhlLmRhdGEpO2lmKDA9PT10LmdldFVpbnQ4KDApJiYwPT09dC5nZXRVaW50OCgxKSYmMD09PXQuZ2V0VWludDgoMikmJjE9PT10LmdldFVpbnQ4KDMpJiY2PT09dC5nZXRVaW50OCg0KSl7bGV0IG49NixyPTAsbz0wO2Zvcig7MjU1PT09KG89dC5nZXRVaW50OChuKyspKTspcis9MjU1O3IrPW87Y29uc3QgYT1mdW5jdGlvbihlLHQsbil7bGV0IHI9bmV3IFVpbnQ4QXJyYXkoZSx0LG4pLG89W10sYT0wO2Zvcig7YTxuOylhKzM8biYmMD09PXJbYV0mJjA9PT1yW2ErMV0mJjM9PT1yW2ErMl0mJigwPT09clthKzNdfHwxPT09clthKzNdfHwyPT09clthKzNdfHwzPT09clthKzNdKT8oby5wdXNoKHJbYV0sclthKzFdLHJbYSszXSksYSs9NCk6KG8ucHVzaChyW2FdKSxhKyspO3JldHVybiBuZXcgVWludDhBcnJheShvKX0oZS5kYXRhLG4scik7cmV0dXJuIG5ldyBVaW50OEFycmF5KGEpfXJldHVybiBudWxsfWZ1bmN0aW9uIHQoZSx0KXtjb25zdCBuPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IG49W10scj0wO2Zvcig7cjx0OylyKzI8dCYmMD09PWVbcl0mJjA9PT1lW3IrMV0mJigwPT09ZVtyKzJdfHwxPT09ZVtyKzJdfHwyPT09ZVtyKzJdfHwzPT09ZVtyKzJdKT8obi5wdXNoKGVbcl0sZVtyKzFdLDMsZVtyKzJdKSxyKz0zKToobi5wdXNoKGVbcl0pLHIrKyk7cmV0dXJuIG5ldyBVaW50OEFycmF5KG4pfSh0KSxyPW4ubGVuZ3RoLG89TWF0aC5mbG9vcihyLzI1NSksYT1yJTI1NSxzPW5ldyBVaW50OEFycmF5KDYrbysxK3IrZS5ieXRlTGVuZ3RoKTtzWzBdPTAsc1sxXT0wLHNbMl09MCxzWzNdPTEsc1s0XT02LHNbNV09MTAxO2xldCBpPTA7Zm9yKDtpPG87KXNbNitpXT0yNTUsaSsrO3JldHVybiBzWzYraV09YSxpKysscy5zZXQobiw2K2kpLHMuc2V0KG5ldyBVaW50OEFycmF5KGUpLDYraStyKSxzLmJ1ZmZlcn1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlNhZmFyaSIpPi0xJiYtMT09PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiQ2hyb21lIikmJihzZWxmLm9ucnRjdHJhbnNmb3JtPW49Pntjb25zdCByPW4udHJhbnNmb3JtZXI7bGV0IG89W107ci5vcHRpb25zLnBvcnQub25tZXNzYWdlPWU9PntlLmRhdGEuc2VpJiZvLnB1c2goZS5kYXRhLnNlaSl9LHNlbGYucG9zdE1lc3NhZ2UoInN0YXJ0ZWQiKTtjb25zdCBhPXIucmVhZGFibGUuZ2V0UmVhZGVyKCkscz1yLndyaXRhYmxlLmdldFdyaXRlcigpOyJyeCI9PT1yLm9wdGlvbnMubmFtZT9mdW5jdGlvbiB0KG4pe2EucmVhZCgpLnRoZW4oKHI9PntpZighci5kb25lKXtpZihyLnZhbHVlIGluc3RhbmNlb2YgUlRDRW5jb2RlZFZpZGVvRnJhbWUpe2NvbnN0IHQ9ZShyLnZhbHVlKTt0JiZuLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7c2VpOnR9KX1zLndyaXRlKHIudmFsdWUpLG4ub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQobil9fSkpfShyKToidHgiPT09ci5vcHRpb25zLm5hbWUmJmZ1bmN0aW9uIGUobil7YS5yZWFkKCkudGhlbigocj0+e2lmKCFyLmRvbmUpe2lmKHIudmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgZT1vLnNoaWZ0KCk7ZSYmKHIudmFsdWUuZGF0YT10KHIudmFsdWUuZGF0YSxlKSl9cy53cml0ZShyLnZhbHVlKSxuLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7dHJhbnNmb3JtZWQ6ITB9KSxlKG4pfX0pKX0ocil9LHNlbGYucG9zdE1lc3NhZ2UoInJlZ2lzdGVyZWQiKSk7Cg==\")], {\n      type: \"text/javascript\"\n    });\n    return setTimeout(() => MP.revokeObjectURL(e), 0), new Worker(MP.createObjectURL(e));\n  }\n  const zF = new Map();\n  const JF = new Map();\n  const XF = new Map();\n  async function QF(e, t) {\n    if (!_U().supportWebRTCEncodedTransform) return void Qy.warning(\"browser not support video encoded transform\");\n    if (XF.has(e)) return;\n    if (!e.track) return;\n    const i = {\n      track: e.track\n    };\n    if (Ov()) {\n      if (!e.createEncodedStreams) return void Qy.warning(\"browser not support createEncodedStreams() API\");\n      let r = null;\n      try {\n        r = e.createEncodedStreams();\n      } catch (e) {\n        return void Qy.error(\"create video-encoded-streams error\", e && e.message);\n      }\n      let o = [];\n      t.on(\"sei-to-send\", e => {\n        o.push(e);\n      });\n      const s = new TransformStream({\n        transform(t, r) {\n          i.controller || (i.controller = r), e.track && e.track.id !== i.track.id && (Qy.debug(\"video track changed: \".concat(i.track.id, \" => \").concat(e.track.id)), i.track.removeEventListener(\"ended\", n), i.track = e.track, i.track.addEventListener(\"ended\", n));\n          const s = o.shift();\n          s && (t.data = function (e, t) {\n            const i = function (e) {\n                const t = e.length;\n                let i = [],\n                  n = 0;\n                for (; n < t;) n + 2 < t && 0 === e[n] && 0 === e[n + 1] && (0 === e[n + 2] || 1 === e[n + 2] || 2 === e[n + 2] || 3 === e[n + 2]) ? (i.push(e[n], e[n + 1], 3, e[n + 2]), n += 3) : (i.push(e[n]), n++);\n                return new Uint8Array(i);\n              }(t),\n              n = i.length,\n              r = Math.floor(n / 255),\n              o = n % 255,\n              s = new Uint8Array(6 + r + 1 + n + e.byteLength);\n            s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s[4] = 6, s[5] = 101;\n            let a = 0;\n            for (; a < r;) s[6 + a] = 255, a++;\n            return s[6 + a] = o, a++, s.set(i, 6 + a), s.set(new Uint8Array(e), 6 + a + n), s.buffer;\n          }(t.data, s)), r.enqueue(t);\n        }\n      });\n      r.readable.pipeThrough(s).pipeTo(r.writable);\n    } else {\n      if (!Nv()) return;\n      {\n        if (\"undefined\" == typeof RTCRtpScriptTransform) return void Qy.warning(\"browser not support RTCRtpScriptTransform\");\n        const r = qF(),\n          o = new MessageChannel();\n        await new Gu(e => r.onmessage = t => {\n          \"registered\" === t.data && e(void 0);\n        });\n        const s = new RTCRtpScriptTransform(r, {\n          name: \"tx\",\n          port: o.port2\n        }, [o.port2]);\n        e.transform = s, await new Gu(e => r.onmessage = t => {\n          \"started\" === t.data && e(void 0);\n        }), t.on(\"sei-to-send\", e => {\n          o.port1.postMessage({\n            sei: e\n          });\n        }), o.port1.onmessage = t => {\n          var r;\n          t.data.transformed && e.track && (null === (r = e.track) || void 0 === r ? void 0 : r.id) !== i.track.id && (Qy.debug(\"video track changed: \".concat(i.track.id, \" => \").concat(e.track.id)), i.track.removeEventListener(\"ended\", n), i.track = e.track, i.track.addEventListener(\"ended\", n));\n        }, i.worker = r;\n      }\n    }\n    function n() {\n      if (e.track) {\n        if (this.id !== e.track.id) return;\n        e.track.removeEventListener(\"ended\", n);\n      }\n      const t = XF.get(e);\n      if (t) {\n        XF.delete(e);\n        try {\n          var i, r;\n          null === (i = t.controller) || void 0 === i || i.terminate(), null === (r = t.worker) || void 0 === r || r.terminate();\n        } catch (e) {\n          Qy.warning(e && e.message);\n        }\n      }\n    }\n    XF.set(e, i), e.track.addEventListener(\"ended\", n);\n  }\n  const ZF = new Map();\n  async function $F(e) {\n    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n    if (!_U().supportWebRTCEncodedTransform) return void Qy.warning(\"browser not support video encoded transform\");\n    if (!e.track) return;\n    if (ZF.has(e)) {\n      const i = ZF.get(e);\n      return void (i && (i.onSei = t.onSei));\n    }\n    const i = {\n      track: e.track,\n      onSei: t.onSei\n    };\n    if (Ov()) {\n      if (!e.createEncodedStreams) return void Qy.warning(\"browser not support createEncodedStreams() API\");\n      let t = null;\n      try {\n        t = e.createEncodedStreams();\n      } catch (e) {\n        return void Qy.error(\"create video-encoded-streams error\", e && e.message);\n      }\n      const r = new TransformStream({\n        transform(t, r) {\n          i.controller || (i.controller = r), e.track && e.track.id !== i.track.id && (Qy.debug(\"video track changed: \".concat(i.track.id, \" => \").concat(e.track.id)), i.track.removeEventListener(\"ended\", n), i.track = e.track, i.track.addEventListener(\"ended\", n));\n          const o = function (e) {\n            const t = new DataView(e.data);\n            if (0 === t.getUint8(0) && 0 === t.getUint8(1) && 0 === t.getUint8(2) && 1 === t.getUint8(3) && 6 === t.getUint8(4)) {\n              let i = 6,\n                n = 0,\n                r = 0;\n              for (; 255 === (r = t.getUint8(i++));) n += 255;\n              n += r;\n              const o = function (e, t, i) {\n                let n = new Uint8Array(e, t, i),\n                  r = [],\n                  o = 0;\n                for (; o < i;) o + 3 < i && 0 === n[o] && 0 === n[o + 1] && 3 === n[o + 2] && (0 === n[o + 3] || 1 === n[o + 3] || 2 === n[o + 3] || 3 === n[o + 3]) ? (r.push(n[o], n[o + 1], n[o + 3]), o += 4) : (r.push(n[o]), o++);\n                return new Uint8Array(r);\n              }(e.data, i, n);\n              return new Uint8Array(o);\n            }\n            return null;\n          }(t);\n          o && i.onSei && i.onSei(o), r.enqueue(t);\n        }\n      });\n      t.readable.pipeThrough(r).pipeTo(t.writable);\n    } else if (Nv()) {\n      if (\"undefined\" == typeof RTCRtpScriptTransform) return void Qy.warning(\"browser not support RTCRtpScriptTransform\");\n      const t = qF(),\n        r = new MessageChannel();\n      await new Gu(e => t.onmessage = t => {\n        \"registered\" === t.data && e(void 0);\n      });\n      const o = new RTCRtpScriptTransform(t, {\n        name: \"rx\",\n        port: r.port2\n      }, [r.port2]);\n      e.transform = o, await new Gu(e => t.onmessage = t => {\n        \"started\" === t.data && e(void 0);\n      }), r.port1.onmessage = t => {\n        var r;\n        t.data.transformed && e.track && (null === (r = e.track) || void 0 === r ? void 0 : r.id) !== i.track.id ? (Qy.debug(\"video track changed: \".concat(i.track.id, \" => \").concat(e.track.id)), i.track.removeEventListener(\"ended\", n), i.track = e.track, i.track.addEventListener(\"ended\", n)) : t.data.sei && i.onSei && i.onSei(t.data.sei);\n      }, i.worker = t;\n    }\n    function n() {\n      if (e.track) {\n        if (this.id !== e.track.id) return;\n        e.track.removeEventListener(\"ended\", n);\n      }\n      !function (e) {\n        const t = ZF.get(e);\n        if (t) {\n          ZF.delete(e);\n          try {\n            var i, n;\n            null === (i = t.controller) || void 0 === i || i.terminate(), null === (n = t.worker) || void 0 === n || n.terminate();\n          } catch (e) {\n            Qy.warning(e && e.message);\n          }\n        }\n      }(e);\n    }\n    ZF.set(e, i), e.track.addEventListener(\"ended\", n);\n  }\n  !function () {\n    const e = Iv();\n    pU.getDisplayMedia = !(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia), pU.getStreamFromExtension = e.name === gv.CHROME && Number(e.version) > 34, pU.supportUnifiedPlan = function () {\n      if (!window.RTCRtpTransceiver) return !1;\n      if (!(\"currentDirection\" in RTCRtpTransceiver.prototype)) return !1;\n      const e = new RTCPeerConnection();\n      let t = !1;\n      try {\n        e.addTransceiver(\"audio\"), t = !0;\n      } catch (e) {}\n      return e.close(), t;\n    }(), pU.supportMinBitrate = e.name === gv.CHROME || e.name === gv.EDGE, pU.supportSetRtpSenderParameters = function () {\n      const e = Iv();\n      return !!(window.RTCRtpSender && window.RTCRtpSender.prototype.setParameters && window.RTCRtpSender.prototype.getParameters) && (!!Jv() || !(!Nv() && !wv()) || e.name === gv.FIREFOX && Number(e.version) >= 64);\n    }(), e.name === gv.SAFARI && (Number(e.version) >= 14 ? pU.supportDualStream = !0 : pU.supportDualStream = !1), pU.webAudioMediaStreamDest = function () {\n      const e = Iv();\n      return !(e.name === gv.SAFARI && Number(e.version) < 12);\n    }(), pU.supportReplaceTrack = !!window.RTCRtpSender && \"function\" == typeof RTCRtpSender.prototype.replaceTrack, pU.supportWebGL = \"undefined\" != typeof WebGLRenderingContext, pU.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, Jv() || (pU.webAudioWithAEC = !0), pU.supportShareAudio = function () {\n      const e = Iv();\n      return (e.os === Sv.WIN_10 || e.os === Sv.WIN_81 || e.os === Sv.WIN_7 || e.os === Sv.LINUX || e.os === Sv.MAC_OS || e.os === Sv.CHROMIUM_OS) && e.name === gv.CHROME && Number(e.version) >= 74;\n    }(), pU.supportDataChannel = !!(kv(76) || function (e) {\n      const t = Iv();\n      return !(t.name !== gv.FIREFOX || !t.osVersion) && Number(t.version) >= e;\n    }(68) || Uv(14)), pU.supportPCSetConfiguration = function () {\n      const e = window.RTCPeerConnection;\n      return !Pv() && !!e && e.prototype.setConfiguration instanceof Function;\n    }(), pU.supportWebRTCEncodedTransform = function () {\n      const e = Iv();\n      return \"Chrome\" === e.name && Number(e.version) >= 86 || \"Safari\" === e.name && Number(e.version) >= 15;\n    }(), pU.supportWebRTCInsertableStream = function () {\n      const e = Iv();\n      return (e.name === gv.CHROME || e.name === gv.EDGE) && Number(e.version) >= 94 && \"MediaStreamTrackGenerator\" in window && \"MediaStreamTrackProcessor\" in window;\n    }(), pU.supportRequestVideoFrameCallback = \"requestVideoFrameCallback\" in HTMLVideoElement.prototype, pU.supportWebCrypto = \"undefined\" != typeof window && void 0 !== window.crypto && void 0 !== window.crypto.subtle, jI(() => {\n      pU.supportDualStreamEncoding = function () {\n        const e = Iv();\n        return !!Dy(\"DISABLE_WEBAUDIO\") || \"Safari\" === e.name && Number(e.version) >= 14 || !!(\"Chrome\" === e.name && /Windows/i.test(e.os || \"\") && Number(e.version) >= 100 && Dy(\"CHROME_DUAL_STREAM_USE_ENCODING\"));\n      }(), Qy.info(\"browser compatibility\", JSON.stringify(pU), JSON.stringify(e));\n    });\n  }();\n  class eB extends SI {\n    constructor() {\n      super(...arguments), ng(this, \"resultStorage\", new Map());\n    }\n    setLocalAudioStats(e, t, i) {\n      this.record(\"AUDIO_INPUT_LEVEL_TOO_LOW\", e, this.checkAudioInputLevel(i, t)), this.record(\"SEND_AUDIO_BITRATE_TOO_LOW\", e, this.checkSendAudioBitrate(i, t));\n    }\n    setLocalVideoStats(e, t, i) {\n      this.record(\"SEND_VIDEO_BITRATE_TOO_LOW\", e, this.checkSendVideoBitrate(i, t)), this.record(\"FRAMERATE_INPUT_TOO_LOW\", e, this.checkFramerateInput(i, t)), this.record(\"FRAMERATE_SENT_TOO_LOW\", e, this.checkFramerateSent(i));\n    }\n    setRemoteAudioStats(e, t) {\n      const i = e.getUserId();\n      this.record(\"AUDIO_OUTPUT_LEVEL_TOO_LOW\", i, this.checkAudioOutputLevel(t));\n    }\n    setRemoteVideoStats(e, t) {\n      const i = e.getUserId();\n      this.record(\"RECV_VIDEO_DECODE_FAILED\", i, this.checkVideoDecode(t));\n    }\n    record(e, t, i) {\n      if (Dy(\"STATS_UPDATE_INTERVAL\") > 500) return;\n      this.resultStorage.has(e) || this.resultStorage.set(e, {\n        result: [],\n        isPrevNormal: !0\n      });\n      const n = this.resultStorage.get(e);\n      if (n && (n.result.push(i), n.result.length >= 5)) {\n        var r;\n        const i = Dn(r = n.result).call(r, !0);\n        n.isPrevNormal && !i && this.emit(\"exception\", tB[e], e, t), !n.isPrevNormal && i && this.emit(\"exception\", tB[e] + 2e3, e + \"_RECOVER\", t), n.isPrevNormal = i, n.result = [];\n      }\n    }\n    checkAudioOutputLevel(e) {\n      return !(e.receiveBitrate > 0 && 0 === e.receiveLevel);\n    }\n    checkAudioInputLevel(e, t) {\n      return t instanceof UV && !t.isActive || !!t.muted || 0 !== e.sendVolumeLevel;\n    }\n    checkFramerateInput(e, t) {\n      let i = null;\n      t._encoderConfig && t._encoderConfig.frameRate && (i = Yw(t._encoderConfig.frameRate));\n      const n = e.captureFrameRate;\n      return !i || !n || !(i > 10 && n < 5 || i < 10 && i >= 5 && n <= 1);\n    }\n    checkFramerateSent(e) {\n      return !(e.captureFrameRate && e.sendFrameRate && e.captureFrameRate > 5 && e.sendFrameRate <= 1);\n    }\n    checkSendVideoBitrate(e, t) {\n      return !!t.muted || 0 !== e.sendBitrate;\n    }\n    checkSendAudioBitrate(e, t) {\n      return t instanceof UV && !t.isActive || !!t.muted || 0 !== e.sendBitrate;\n    }\n    checkVideoDecode(e) {\n      return 0 === e.receiveBitrate || 0 !== e.decodeFrameRate;\n    }\n  }\n  const tB = {\n    FRAMERATE_INPUT_TOO_LOW: 1001,\n    FRAMERATE_SENT_TOO_LOW: 1002,\n    SEND_VIDEO_BITRATE_TOO_LOW: 1003,\n    RECV_VIDEO_DECODE_FAILED: 1005,\n    AUDIO_INPUT_LEVEL_TOO_LOW: 2001,\n    AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002,\n    SEND_AUDIO_BITRATE_TOO_LOW: 2003\n  };\n  const iB = new class {\n    markSubscribeStart(e, t) {\n      performance.mark(\"agora-web-sdk/\".concat(e, \"/subscribe-\").concat(t));\n    }\n    markPublishStart(e, t) {\n      performance.mark(\"agora-web-sdk/\".concat(e, \"/publish-\").concat(t));\n    }\n    measureFromSubscribeStart(e, t) {\n      const i = performance.getEntriesByName(\"agora-web-sdk/\".concat(e, \"/subscribe-\").concat(t));\n      if (i.length > 0) {\n        const e = i[i.length - 1];\n        return Math.round(performance.now() - e.startTime);\n      }\n      return 0;\n    }\n    measureFromPublishStart(e, t) {\n      const i = performance.getEntriesByName(\"agora-web-sdk/\".concat(e, \"/publish-\").concat(t));\n      if (i.length > 0) {\n        const e = i[i.length - 1];\n        return Math.round(performance.now() - e.startTime);\n      }\n      return 0;\n    }\n  }();\n  function nB(e, t) {\n    this.v = e, this.k = t;\n  }\n  function rB(e) {\n    return new nB(e, 0);\n  }\n  var oB = ju,\n    sB = Sl;\n  wi({\n    target: \"Promise\",\n    stat: !0,\n    forced: !0\n  }, {\n    withResolvers: function () {\n      var e = sB.f(this);\n      return {\n        promise: e.promise,\n        resolve: e.resolve,\n        reject: e.reject\n      };\n    }\n  });\n  var aB = Sl,\n    cB = el;\n  wi({\n    target: \"Promise\",\n    stat: !0,\n    forced: !0\n  }, {\n    try: function (e) {\n      var t = aB.f(this),\n        i = cB(e);\n      return (i.error ? t.reject : t.resolve)(i.value), t.promise;\n    }\n  });\n  var dB = i(oB),\n    lB = tf.f(\"asyncIterator\"),\n    hB = i(lB);\n  function uB(e) {\n    var t, i;\n    function n(t, i) {\n      try {\n        var o = e[t](i),\n          s = o.value,\n          a = s instanceof nB;\n        dB.resolve(a ? s.v : s).then(function (i) {\n          if (a) {\n            var c = \"return\" === t ? \"return\" : \"next\";\n            if (!s.k || i.done) return n(c, i);\n            i = e[c](i).value;\n          }\n          r(o.done ? \"return\" : \"normal\", i);\n        }, function (e) {\n          n(\"throw\", e);\n        });\n      } catch (e) {\n        r(\"throw\", e);\n      }\n    }\n    function r(e, r) {\n      switch (e) {\n        case \"return\":\n          t.resolve({\n            value: r,\n            done: !0\n          });\n          break;\n        case \"throw\":\n          t.reject(r);\n          break;\n        default:\n          t.resolve({\n            value: r,\n            done: !1\n          });\n      }\n      (t = t.next) ? n(t.key, t.arg) : i = null;\n    }\n    this._invoke = function (e, r) {\n      return new dB(function (o, s) {\n        var a = {\n          key: e,\n          arg: r,\n          resolve: o,\n          reject: s,\n          next: null\n        };\n        i ? i = i.next = a : (t = i = a, n(e, r));\n      });\n    }, \"function\" != typeof e.return && (this.return = void 0);\n  }\n  function pB(e) {\n    return function () {\n      return new uB(e.apply(this, arguments));\n    };\n  }\n  uB.prototype[\"function\" == typeof ZS && hB || \"@@asyncIterator\"] = function () {\n    return this;\n  }, uB.prototype.next = function (e) {\n    return this._invoke(\"next\", e);\n  }, uB.prototype.throw = function (e) {\n    return this._invoke(\"throw\", e);\n  }, uB.prototype.return = function (e) {\n    return this._invoke(\"return\", e);\n  };\n  var _B = i(ie.Object.getOwnPropertySymbols),\n    EB = wi,\n    mB = qi.indexOf,\n    fB = Bn,\n    TB = I([].indexOf),\n    SB = !!TB && 1 / TB([1], 1, -0) < 0;\n  EB({\n    target: \"Array\",\n    proto: !0,\n    forced: SB || !fB(\"indexOf\")\n  }, {\n    indexOf: function (e) {\n      var t = arguments.length > 1 ? arguments[1] : void 0;\n      return SB ? TB(this, e, t) || 0 : mB(this, e, t);\n    }\n  });\n  var gB = Xi(\"Array\").indexOf,\n    RB = l,\n    CB = gB,\n    vB = Array.prototype,\n    IB = function (e) {\n      var t = e.indexOf;\n      return e === vB || RB(vB, e) && t === vB.indexOf ? CB : t;\n    },\n    yB = i(IB);\n  function AB(e, t) {\n    if (null == e) return {};\n    var i,\n      n,\n      r = function (e, t) {\n        if (null == e) return {};\n        var i,\n          n,\n          r = {},\n          o = IA(e);\n        for (n = 0; n < o.length; n++) i = o[n], yB(t).call(t, i) >= 0 || (r[i] = e[i]);\n        return r;\n      }(e, t);\n    if (_B) {\n      var o = _B(e);\n      for (n = 0; n < o.length; n++) i = o[n], yB(t).call(t, i) >= 0 || Object.prototype.propertyIsEnumerable.call(e, i) && (r[i] = e[i]);\n    }\n    return r;\n  }\n  var bB = {\n    exports: {}\n  };\n  !function (e, t) {\n    e.exports = (() => {\n      var e = {\n          8: (e, t, i) => {\n            i.r(t), i.d(t, {\n              Parser: () => C,\n              Printer: () => b,\n              parse: () => D,\n              print: () => P\n            });\n            const n = \"\\n\",\n              r = \"\".concat(\"\\r\").concat(n),\n              o = \" \";\n            let s;\n            function a(e) {\n              return e >= \"0\" && e <= \"9\";\n            }\n            function c(e) {\n              return e >= \"!\" && e <= \"~\";\n            }\n            function d(e) {\n              return c(e) || e >= \"Â\" && e <= \"Ã¿\";\n            }\n            function l(e) {\n              return \"!\" === e || e >= \"#\" && e <= \"'\" || e >= \"*\" && e <= \"+\" || e >= \"-\" && e <= \".\" || e >= \"0\" && e <= \"9\" || e >= \"A\" && e <= \"Z\" || e >= \"^\" && e <= \"~\";\n            }\n            function h(e) {\n              return e >= \"1\" && e <= \"9\";\n            }\n            function u(e) {\n              return e >= \"A\" && e <= \"Z\" || e >= \"a\" && e <= \"z\";\n            }\n            function p(e) {\n              return \"d\" === e || \"h\" === e || \"m\" === e || \"s\" === e;\n            }\n            function _(e) {\n              return e > \"\u0001\" && e < \"\\t\" || e > \"\\v\" && e < \"\\f\" || e > \"\u000e\" && e < \"Ã¿\";\n            }\n            function E(e) {\n              return u(e) || a(e) || \"+\" === e || \"/\" === e;\n            }\n            function m(e) {\n              return a(e) || u(e) || \"+\" === e || \"/\" === e || \"-\" === e || \"_\" === e;\n            }\n            function f(e) {\n              return u(e) || a(e) || \"+\" === e || \"/\" === e;\n            }\n            function T(e, t) {\n              var i = Object.keys(e);\n              if (Object.getOwnPropertySymbols) {\n                var n = Object.getOwnPropertySymbols(e);\n                t && (n = n.filter(function (t) {\n                  return Object.getOwnPropertyDescriptor(e, t).enumerable;\n                })), i.push.apply(i, n);\n              }\n              return i;\n            }\n            function S(e) {\n              for (var t = 1; t < arguments.length; t++) {\n                var i = null != arguments[t] ? arguments[t] : {};\n                t % 2 ? T(Object(i), !0).forEach(function (t) {\n                  g(e, t, i[t]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : T(Object(i)).forEach(function (t) {\n                  Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n                });\n              }\n              return e;\n            }\n            function g(e, t, i) {\n              return t in e ? Object.defineProperty(e, t, {\n                value: i,\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n              }) : e[t] = i, e;\n            }\n            !function (e) {\n              e.VERSION = \"v\", e.ORIGIN = \"o\", e.SESSION_NAME = \"s\", e.INFORMATION = \"i\", e.URI = \"u\", e.EMAIL = \"e\", e.PHONE = \"p\", e.CONNECTION = \"c\", e.BANDWIDTH = \"b\", e.TIME = \"t\", e.REPEAT = \"r\", e.ZONE_ADJUSTMENTS = \"z\", e.KEY = \"k\", e.ATTRIBUTE = \"a\", e.MEDIA = \"m\";\n            }(s || (s = {}));\n            class R {\n              consumeText(e, t) {\n                let i = t;\n                for (; i < e.length;) {\n                  const t = e[i];\n                  if (\"\\0\" === t || \"\\r\" === t || t === n) break;\n                  i += 1;\n                }\n                if (i - t == 0) throw new Error(\"Invalid text, at \".concat(e));\n                return i;\n              }\n              consumeUnicastAddress(e, t, i) {\n                return this.consumeTill(e, t, o);\n              }\n              consumeOneOrMore(e, t, i) {\n                let n = t;\n                for (; i(e[n]);) n++;\n                if (n - t == 0) throw new Error(\"Invalid rule at \".concat(t, \".\"));\n                return n;\n              }\n              consumeSpace(e, t) {\n                if (e[t] === o) return t + 1;\n                throw new Error(\"Invalid space at \".concat(t, \".\"));\n              }\n              consumeIP4Address(e, t) {\n                let i = t;\n                for (let t = 0; t < 4; t++) if (i = this.consumeDecimalUChar(e, i), 3 !== t) {\n                  if (\".\" !== e[i]) throw new Error(\"Invalid IP4 address.\");\n                  i++;\n                }\n                return i;\n              }\n              consumeDecimalUChar(e, t) {\n                let i = t;\n                for (let t = 0; t < 3 && a(e[i]); t++, i++);\n                if (i - t == 0) throw new Error(\"Invalid decimal uchar.\");\n                const n = parseInt(e.slice(t, i));\n                if (n >= 0 && n <= 255) return i;\n                throw new Error(\"Invalid decimal uchar\");\n              }\n              consumeIP6Address(e, t) {\n                let i = this.consumeHexpart(e, t);\n                return \":\" === e[i] ? (i += 1, i = this.consumeIP4Address(e, i), i) : i;\n              }\n              consumeHexpart(e, t) {\n                let i = t;\n                if (\":\" === e[i] && \":\" === e[i + 1]) {\n                  i += 2;\n                  try {\n                    i = this.consumeHexseq(e, i);\n                  } catch (e) {}\n                  return i;\n                }\n                if (i = this.consumeHexseq(e, i), \":\" === e[i] && \":\" === e[i + 1]) {\n                  i += 2;\n                  try {\n                    i = this.consumeHexseq(e, i);\n                  } catch (e) {}\n                  return i;\n                }\n                return i;\n              }\n              consumeHexseq(e, t) {\n                let i = t;\n                for (; i = this.consumeHex4(e, i), \":\" === e[i] && \":\" !== e[i + 1];) i += 1;\n                return i;\n              }\n              consumeHex4(e, t) {\n                let i = 0;\n                for (; i < 4; i++) if (!((n = e[t + i]) >= \"0\" && n <= \"9\" || n >= \"a\" && n <= \"f\" || n >= \"A\" && n <= \"F\")) {\n                  if (0 === i) throw new Error(\"Invalid hex 4\");\n                  break;\n                }\n                var n;\n                return t + i;\n              }\n              consumeFQDN(e, t) {\n                let i = t;\n                for (; a(e[i]) || u(e[i]) || \"-\" === e[i] || \".\" === e[i];) i += 1;\n                if (i - t < 4) throw new Error(\"Invalid FQDN\");\n                return i;\n              }\n              consumeExtnAddr(e, t) {\n                return this.consumeOneOrMore(e, t, d);\n              }\n              consumeMulticastAddress(e, t, i) {\n                switch (i) {\n                  case \"IP4\":\n                  case \"ip4\":\n                    return this.consumeIP4MulticastAddress(e, t);\n                  case \"IP6\":\n                  case \"ip6\":\n                    return this.consumeIP6MulticastAddress(e, t);\n                  default:\n                    try {\n                      return this.consumeFQDN(e, t);\n                    } catch (i) {\n                      return this.consumeExtnAddr(e, t);\n                    }\n                }\n              }\n              consumeIP6MulticastAddress(e, t) {\n                const i = this.consumeHexpart(e, t);\n                return \"/\" === e[i] ? this.consumeInteger(e, i + 1) : i;\n              }\n              consumeIP4MulticastAddress(e, t) {\n                let i = t + 3;\n                const n = e.slice(t, i),\n                  r = parseInt(n);\n                if (r < 224 || r > 239) throw new Error(\"Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.\");\n                for (let t = 0; t < 3; t++) {\n                  if (\".\" !== e[i]) throw new Error(\"Invalid IP4 multicast address.\");\n                  i += 1, i = this.consumeDecimalUChar(e, i);\n                }\n                return \"/\" === e[i] && (i += 1), i = this.consumeTTL(e, i), \"/\" === e[i] && (i = this.consumeInteger(e, i)), i;\n              }\n              consumeInteger(e, t) {\n                if (!h(e[t])) throw new Error(\"Invalid integer.\");\n                for (t += 1; a(e[t]);) t += 1;\n                return t;\n              }\n              consumeTTL(e, t) {\n                if (\"0\" === e[t]) return t + 1;\n                if (!h(e[t])) throw new Error(\"Invalid TTL.\");\n                t += 1;\n                for (let i = 0; i < 2 && a(e[t]); i++) t += 1;\n                return t;\n              }\n              consumeToken(e, t) {\n                return this.consumeOneOrMore(e, t, l);\n              }\n              consumeTime(e, t) {\n                let i = t;\n                if (\"0\" === e[i]) return i + 1;\n                for (h(e[i]) && (i += 1); a(e[i]);) i++;\n                if (i - t < 10) throw new Error(\"Invalid time\");\n                return i;\n              }\n              consumeAddress(e, t) {\n                return this.consumeTill(e, t, o);\n              }\n              consumeTypedTime(e, t) {\n                let i = t;\n                return i = this.consumeOneOrMore(e, i, a), p(e[i]) ? i + 1 : i;\n              }\n              consumeRepeatInterval(e, t) {\n                if (!h(e[t])) throw new Error(\"Invalid repeat interval\");\n                for (t += 1; a(e[t]);) t += 1;\n                return p(e[t]) && (t += 1), t;\n              }\n              consumePort(e, t) {\n                return this.consumeOneOrMore(e, t, a);\n              }\n              consume(e, t, i) {\n                for (let n = 0; n < i.length; n++) {\n                  if (t + n >= e.length) throw new Error(\"consume exceeding value length\");\n                  if (e[t + n] !== i[n]) throw new Error(\"consume \".concat(i, \" failed at \").concat(n));\n                }\n                return t + i.length;\n              }\n              consumeTill(e, t, i) {\n                let n = t;\n                for (; n < e.length && (\"string\" != typeof i || e[n] !== i) && (\"function\" != typeof i || !i(e[n]));) n++;\n                return n;\n              }\n            }\n            class C extends R {\n              constructor() {\n                super(), g(this, \"records\", []), g(this, \"currentLine\", 0);\n              }\n              parse(e) {\n                const t = this.probeEOL(e);\n                this.records = e.split(t).filter(e => !!jp(e).call(e)).map(this.parseLine), this.currentLine = 0;\n                const i = this.parseVersion(),\n                  n = this.parseOrigin(),\n                  r = this.parseSessionName(),\n                  o = this.parseInformation(),\n                  s = this.parseUri(),\n                  a = this.parseEmail(),\n                  c = this.parsePhone(),\n                  d = this.parseConnection(),\n                  l = this.parseBandWidth(),\n                  h = this.parseTimeFields(),\n                  u = this.parseKey(),\n                  p = this.parseSessionAttribute(),\n                  _ = this.parseMediaDescription();\n                if (this.currentLine !== this.records.length) throw new Error(\"parsing failed, non exhaustive sdp lines.\");\n                return {\n                  version: i,\n                  origin: n,\n                  sessionName: r,\n                  information: o,\n                  uri: s,\n                  emails: a,\n                  phones: c,\n                  connection: d,\n                  bandwidths: l,\n                  timeFields: h,\n                  key: u,\n                  attributes: p,\n                  mediaDescriptions: _\n                };\n              }\n              getCurrentRecord() {\n                const e = this.records[this.currentLine];\n                if (!e) throw new Error(\"Record doesn't exit.\");\n                return e;\n              }\n              probeEOL(e) {\n                for (let t = 0; t < e.length; t++) if (e[t] === n) return \"\\r\" === e[t - 1] ? r : n;\n                throw new Error(\"Invalid newline character.\");\n              }\n              parseLine(e, t) {\n                if (e.length < 2) throw new Error(\"Invalid sdp line, sdp line should be of form <type>=<value>.\");\n                const i = e[0];\n                if (\"=\" !== e[1]) throw new Error('Invalid sdp line, <type> should be a single character followed by an \"=\" sign.');\n                return {\n                  type: i,\n                  value: e.slice(2),\n                  line: t,\n                  cur: 0\n                };\n              }\n              parseSessionAttribute() {\n                const e = new I();\n                for (; this.currentLine < this.records.length;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.ATTRIBUTE) break;\n                  const i = {\n                    attField: this.extractOneOrMore(t, e => l(e) && \":\" !== e),\n                    _cur: 0\n                  };\n                  \":\" === t.value[t.cur] && (t.cur += 1, i.attValue = this.extractOneOrMore(t, _)), e.parse(i), this.currentLine++;\n                }\n                return e.digest();\n              }\n              parseMediaAttributes(e) {\n                const t = new y(e);\n                for (; this.currentLine < this.records.length;) {\n                  const e = this.getCurrentRecord();\n                  if (e.type !== s.ATTRIBUTE) break;\n                  const i = {\n                    attField: this.extractOneOrMore(e, e => l(e) && \":\" !== e),\n                    _cur: 0\n                  };\n                  \":\" === e.value[e.cur] && (e.cur += 1, i.attValue = this.extractOneOrMore(e, _)), t.parse(i), this.currentLine++;\n                }\n                return t.digest();\n              }\n              parseKey() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.KEY) {\n                  if (\"prompt\" === e.value || \"clear:\" === e.value || \"base64:\" === e.value || \"uri:\" === e.value) return e.value;\n                  throw this.currentLine++, new Error(\"Invalid key.\");\n                }\n              }\n              parseZone() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.ZONE_ADJUSTMENTS) {\n                  const t = [];\n                  for (;;) try {\n                    const i = this.extract(e, this.consumeTime);\n                    this.consumeSpaceForRecord(e);\n                    let n = !1;\n                    \"-\" === e.value[e.cur] && (n = !0, e.cur += 1);\n                    const r = this.extract(e, this.consumeTypedTime);\n                    t.push({\n                      time: i,\n                      typedTime: r,\n                      back: n\n                    });\n                  } catch (e) {\n                    break;\n                  }\n                  if (0 === t.length) throw new Error(\"Invalid zone adjustments\");\n                  return this.currentLine++, t;\n                }\n                return [];\n              }\n              parseRepeat() {\n                const e = [];\n                for (;;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.REPEAT) break;\n                  {\n                    const i = this.extract(t, this.consumeRepeatInterval),\n                      n = this.parseTypedTime(t);\n                    e.push({\n                      repeatInterval: i,\n                      typedTimes: n\n                    }), this.currentLine++;\n                  }\n                }\n                return e;\n              }\n              parseTypedTime(e) {\n                const t = [];\n                for (;;) try {\n                  this.consumeSpaceForRecord(e), t.push(this.extract(e, this.consumeTypedTime));\n                } catch (e) {\n                  break;\n                }\n                if (0 === t.length) throw new Error(\"Invalid typed time.\");\n                return t;\n              }\n              parseTime() {\n                const e = this.getCurrentRecord(),\n                  t = this.extract(e, this.consumeTime);\n                this.consumeSpaceForRecord(e);\n                const i = this.extract(e, this.consumeTime);\n                return this.currentLine++, {\n                  startTime: t,\n                  stopTime: i\n                };\n              }\n              parseBandWidth() {\n                const e = [];\n                for (; this.currentLine < this.records.length;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.BANDWIDTH) break;\n                  {\n                    const i = this.extractOneOrMore(t, l);\n                    if (\":\" !== t.value[t.cur]) throw new Error(\"Invalid bandwidth field.\");\n                    t.cur++;\n                    const n = this.extractOneOrMore(t, a);\n                    e.push({\n                      bwtype: i,\n                      bandwidth: n\n                    }), this.currentLine++;\n                  }\n                }\n                return e;\n              }\n              parseVersion() {\n                const e = this.getCurrentRecord();\n                if (e.type !== s.VERSION) throw new Error(\"first sdp record must be version\");\n                const t = e.value.slice(0, this.consumeOneOrMore(e.value, 0, a));\n                if (t.length !== e.value.length) throw new Error('invalid proto version, \"v='.concat(e.value, '\"'));\n                return this.currentLine++, t;\n              }\n              parseOrigin() {\n                const e = this.getCurrentRecord();\n                if (e.type !== s.ORIGIN) throw new Error(\"second line of sdp must be origin\");\n                const t = this.extractOneOrMore(e, d);\n                this.consumeSpaceForRecord(e);\n                const i = this.extractOneOrMore(e, a);\n                this.consumeSpaceForRecord(e);\n                const n = this.extractOneOrMore(e, a);\n                this.consumeSpaceForRecord(e);\n                const r = this.extractOneOrMore(e, l);\n                this.consumeSpaceForRecord(e);\n                const o = this.extractOneOrMore(e, l);\n                this.consumeSpaceForRecord(e);\n                const c = this.extract(e, this.consumeUnicastAddress);\n                return this.currentLine++, {\n                  username: t,\n                  sessId: i,\n                  sessVersion: n,\n                  nettype: r,\n                  addrtype: o,\n                  unicastAddress: c\n                };\n              }\n              parseSessionName() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.SESSION_NAME) {\n                  const t = this.extract(e, this.consumeText);\n                  return this.currentLine++, t;\n                }\n              }\n              parseInformation() {\n                const e = this.getCurrentRecord();\n                if (e.type !== s.INFORMATION) return;\n                const t = this.extract(e, this.consumeText);\n                return this.currentLine++, t;\n              }\n              parseUri() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.URI) return this.currentLine++, e.value;\n              }\n              parseEmail() {\n                const e = [];\n                for (;;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.EMAIL) break;\n                  e.push(t.value), this.currentLine++;\n                }\n                return e;\n              }\n              parsePhone() {\n                const e = [];\n                for (;;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.PHONE) break;\n                  e.push(t.value), this.currentLine++;\n                }\n                return e;\n              }\n              parseConnection() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.CONNECTION) {\n                  const t = this.extractOneOrMore(e, l);\n                  this.consumeSpaceForRecord(e);\n                  const i = this.extractOneOrMore(e, l);\n                  this.consumeSpaceForRecord(e);\n                  const n = this.extract(e, this.consumeAddress);\n                  return this.currentLine++, {\n                    nettype: t,\n                    addrtype: i,\n                    address: n\n                  };\n                }\n              }\n              parseMedia() {\n                const e = this.getCurrentRecord(),\n                  t = this.extract(e, this.consumeToken);\n                this.consumeSpaceForRecord(e);\n                let i = this.extract(e, this.consumePort);\n                \"/\" === e.value[e.cur] && (e.cur += 1, i += this.extract(e, this.consumeInteger)), this.consumeSpaceForRecord(e);\n                const n = [];\n                for (n.push(this.extract(e, this.consumeToken)); \"/\" === e.value[e.cur];) e.cur += 1, n.push(this.extract(e, this.consumeToken));\n                if (0 === n.length) throw new Error(\"Invalid proto\");\n                const r = this.parseFmt(e);\n                return this.currentLine++, {\n                  mediaType: t,\n                  port: i,\n                  protos: n,\n                  fmts: r\n                };\n              }\n              parseTimeFields() {\n                const e = [];\n                for (; this.getCurrentRecord().type === s.TIME;) {\n                  const t = this.parseTime(),\n                    i = this.parseRepeat(),\n                    n = this.parseZone();\n                  e.push({\n                    time: t,\n                    repeats: i,\n                    zones: n\n                  });\n                }\n                return e;\n              }\n              parseMediaDescription() {\n                const e = [];\n                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s.MEDIA;) {\n                  const t = this.parseMedia(),\n                    i = this.parseInformation(),\n                    n = this.parseConnections(),\n                    r = this.parseBandWidth(),\n                    o = this.parseKey(),\n                    s = this.parseMediaAttributes(t);\n                  e.push({\n                    media: t,\n                    information: i,\n                    connections: n,\n                    bandwidths: r,\n                    key: o,\n                    attributes: s\n                  });\n                }\n                return e;\n              }\n              parseConnections() {\n                const e = [];\n                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s.CONNECTION;) e.push(this.parseConnection());\n                return e;\n              }\n              parseFmt(e) {\n                const t = [];\n                for (;;) try {\n                  this.consumeSpaceForRecord(e), t.push(this.extract(e, this.consumeToken));\n                } catch (e) {\n                  break;\n                }\n                if (0 === t.length) throw new Error(\"Invalid fmts\");\n                return t;\n              }\n              extract(e, t) {\n                for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), r = 2; r < i; r++) n[r - 2] = arguments[r];\n                const o = t.call(this, e.value, e.cur, ...n),\n                  s = e.value.slice(e.cur, o);\n                return e.cur = o, s;\n              }\n              extractOneOrMore(e, t) {\n                const i = this.consumeOneOrMore(e.value, e.cur, t),\n                  n = e.value.slice(e.cur, i);\n                return e.cur = i, n;\n              }\n              consumeSpaceForRecord(e) {\n                if (e.value[e.cur] !== o) throw new Error(\"Invalid space at \".concat(e.cur, \".\"));\n                e.cur += 1;\n              }\n            }\n            class v extends R {\n              constructor() {\n                super(...arguments), g(this, \"attributes\", void 0), g(this, \"digested\", !1);\n              }\n              extractOneOrMore(e, t, i) {\n                const n = this.consumeOneOrMore(e.attValue, e._cur, t),\n                  r = e.attValue.slice(e._cur, n),\n                  _ref22 = i || [],\n                  _ref23 = _slicedToArray(_ref22, 2),\n                  o = _ref23[0],\n                  s = _ref23[1];\n                if (\"number\" == typeof o && r.length < o) throw new Error(\"error in length, should be more or equal than \".concat(o, \" characters.\"));\n                if (\"number\" == typeof s && r.length > s) throw new Error(\"error in length, should be less or equal than \".concat(s, \" characters.\"));\n                return e._cur = n, r;\n              }\n              consumeAttributeSpace(e) {\n                if (e.attValue[e._cur] !== o) throw new Error(\"Invalid space at \".concat(e._cur, \".\"));\n                e._cur += 1;\n              }\n              extract(e, t) {\n                if (!e.attValue) throw new Error(\"Nothing to extract from attValue.\");\n                for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), r = 2; r < i; r++) n[r - 2] = arguments[r];\n                const o = t.call(this, e.attValue, e._cur, ...n),\n                  s = e.attValue.slice(e._cur, o);\n                return e._cur = o, s;\n              }\n              atEnd(e) {\n                if (!e.attValue) throw new Error();\n                return e._cur >= e.attValue.length;\n              }\n              peekChar(e) {\n                if (!e.attValue) throw new Error();\n                return e.attValue[e._cur];\n              }\n              peek(e, t) {\n                if (!e.attValue) throw new Error();\n                for (let i = 0; i < t.length; i++) if (t[i] !== e.attValue[e._cur + i]) return !1;\n                return !0;\n              }\n              parseIceUfrag(e) {\n                if (this.attributes.iceUfrag) throw new Error(\"Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'\");\n                this.attributes.iceUfrag = this.extractOneOrMore(e, E, [4, 256]);\n              }\n              parseIcePwd(e) {\n                if (this.attributes.icePwd) throw new Error(\"Invalid ice-pwd, should be only a single line if 'a=ice-pwd'\");\n                this.attributes.icePwd = this.extractOneOrMore(e, E, [22, 256]);\n              }\n              parseIceOptions(e) {\n                if (this.attributes.iceOptions) throw new Error(\"Invalid ice-options, should be only one 'ice-options' line\");\n                const t = [];\n                for (; !this.atEnd(e);) {\n                  t.push(this.extractOneOrMore(e, E));\n                  try {\n                    this.consumeAttributeSpace(e);\n                  } catch (t) {\n                    if (this.atEnd(e)) break;\n                    throw t;\n                  }\n                }\n                this.attributes.iceOptions = t;\n              }\n              parseFingerprint(e) {\n                const t = this.extract(e, this.consumeToken);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill);\n                this.attributes.fingerprints.push({\n                  hashFunction: t,\n                  fingerprint: i\n                });\n              }\n              parseExtmap(e) {\n                const t = this.extractOneOrMore(e, a);\n                let i;\n                \"/\" === this.peekChar(e) && (this.extract(e, this.consume, \"/\"), i = this.extract(e, this.consumeToken)), this.consumeAttributeSpace(e);\n                const n = this.extract(e, this.consumeTill, o),\n                  r = S(S({\n                    entry: parseInt(t, 10)\n                  }, i && {\n                    direction: i\n                  }), {}, {\n                    extensionName: n\n                  });\n                this.peekChar(e) === o && (this.consumeAttributeSpace(e), r.extensionAttributes = this.extract(e, this.consumeTill)), this.attributes.extmaps.push(r);\n              }\n              parseSetup(e) {\n                if (this.attributes.setup) throw new Error(\"must only be one single 'a=setup' line.\");\n                const t = this.extract(e, this.consumeTill);\n                if (\"active\" !== t && \"passive\" !== t && \"actpass\" !== t && \"holdconn\" !== t) throw new Error(\"role must be one of 'active', 'passive', 'actpass', 'holdconn'.\");\n                this.attributes.setup = t;\n              }\n            }\n            class I extends v {\n              constructor() {\n                super(...arguments), g(this, \"attributes\", {\n                  unrecognized: [],\n                  groups: [],\n                  extmaps: [],\n                  fingerprints: [],\n                  identities: []\n                });\n              }\n              parse(e) {\n                if (this.digested) throw new Error(\"already digested\");\n                try {\n                  switch (e.attField) {\n                    case \"group\":\n                      this.parseGroup(e);\n                      break;\n                    case \"ice-lite\":\n                      this.parseIceLite();\n                      break;\n                    case \"ice-ufrag\":\n                      this.parseIceUfrag(e);\n                      break;\n                    case \"ice-pwd\":\n                      this.parseIcePwd(e);\n                      break;\n                    case \"ice-options\":\n                      this.parseIceOptions(e);\n                      break;\n                    case \"fingerprint\":\n                      this.parseFingerprint(e);\n                      break;\n                    case \"setup\":\n                      this.parseSetup(e);\n                      break;\n                    case \"tls-id\":\n                      this.parseTlsId(e);\n                      break;\n                    case \"identity\":\n                      this.parseIdentity(e);\n                      break;\n                    case \"extmap\":\n                      this.parseExtmap(e);\n                      break;\n                    case \"msid-semantic\":\n                      this.parseMsidSemantic(e);\n                      break;\n                    default:\n                      e.ignored = !0, this.attributes.unrecognized.push(e);\n                  }\n                } catch (t) {\n                  throw console.error(\"parsing session attribute \".concat(e.attField, ' error, \"a=').concat(e.attField, \":\").concat(e.attValue, '\"')), t;\n                }\n                if (!e.ignored && e.attValue && !this.atEnd(e)) throw new Error(\"attribute parsing error\");\n              }\n              digest() {\n                return this.digested = !0, this.attributes;\n              }\n              parseGroup(e) {\n                const t = this.extract(e, this.consumeToken),\n                  i = [];\n                for (; !this.atEnd(e) && this.peekChar(e) === o;) this.consumeAttributeSpace(e), i.push(this.extract(e, this.consumeToken));\n                this.attributes.groups.push({\n                  semantic: t,\n                  identificationTag: i\n                });\n              }\n              parseIceLite() {\n                if (this.attributes.iceLite) throw new Error(\"Invalid ice-lite, should be only a single line of 'a=ice-lite'\");\n                this.attributes.iceLite = !0;\n              }\n              parseTlsId(e) {\n                if (this.attributes.tlsId) throw new Error(\"must be only one tld-id line\");\n                this.attributes.tlsId = this.extractOneOrMore(e, m);\n              }\n              parseIdentity(e) {\n                const t = this.extractOneOrMore(e, f),\n                  i = [];\n                for (; !this.atEnd(e) && this.peekChar(e) === o;) {\n                  this.consumeAttributeSpace(e);\n                  const t = this.extract(e, this.consumeToken);\n                  this.extract(e, this.consume, \"=\");\n                  const n = this.extractOneOrMore(e, e => e !== o && _(e));\n                  i.push({\n                    name: t,\n                    value: n\n                  });\n                }\n                this.attributes.identities.push({\n                  assertionValue: t,\n                  extensions: i\n                });\n              }\n              parseMsidSemantic(e) {\n                this.peekChar(e) === o && this.consumeAttributeSpace(e);\n                const t = {\n                  semantic: this.extract(e, this.consumeToken),\n                  identifierList: []\n                };\n                for (;;) {\n                  try {\n                    this.consumeAttributeSpace(e);\n                  } catch (e) {\n                    break;\n                  }\n                  if (\"*\" === this.peekChar(e)) {\n                    this.extract(e, this.consume, \"*\"), t.applyForAll = !0;\n                    break;\n                  }\n                  {\n                    const i = this.extract(e, this.consumeTill, o);\n                    t.identifierList.push(i);\n                  }\n                }\n                this.attributes.msidSemantic = t;\n              }\n            }\n            class y extends v {\n              constructor(e) {\n                super(), g(this, \"attributes\", void 0), -1 !== e.protos.indexOf(\"RTP\") || e.protos.indexOf(\"rtp\"), this.attributes = {\n                  unrecognized: [],\n                  candidates: [],\n                  extmaps: [],\n                  fingerprints: [],\n                  imageattr: [],\n                  msids: [],\n                  remoteCandidatesList: [],\n                  rids: [],\n                  ssrcs: [],\n                  ssrcGroups: [],\n                  rtcpFeedbackWildcards: [],\n                  payloads: []\n                };\n              }\n              parse(e) {\n                if (this.digested) throw new Error(\"already digested\");\n                try {\n                  switch (e.attField) {\n                    case \"extmap\":\n                      this.parseExtmap(e);\n                      break;\n                    case \"setup\":\n                      this.parseSetup(e);\n                      break;\n                    case \"ice-ufrag\":\n                      this.parseIceUfrag(e);\n                      break;\n                    case \"ice-pwd\":\n                      this.parseIcePwd(e);\n                      break;\n                    case \"ice-options\":\n                      this.parseIceOptions(e);\n                      break;\n                    case \"candidate\":\n                      this.parseCandidate(e);\n                      break;\n                    case \"remote-candidate\":\n                      this.parseRemoteCandidate(e);\n                      break;\n                    case \"end-of-candidates\":\n                      this.parseEndOfCandidates();\n                      break;\n                    case \"fingerprint\":\n                      this.parseFingerprint(e);\n                      break;\n                    case \"rtpmap\":\n                      this.parseRtpmap(e);\n                      break;\n                    case \"ptime\":\n                      this.parsePtime(e);\n                      break;\n                    case \"maxptime\":\n                      this.parseMaxPtime(e);\n                      break;\n                    case \"sendrecv\":\n                    case \"recvonly\":\n                    case \"sendonly\":\n                    case \"inactive\":\n                      this.parseDirection(e);\n                      break;\n                    case \"ssrc\":\n                      this.parseSSRC(e);\n                      break;\n                    case \"fmtp\":\n                      this.parseFmtp(e);\n                      break;\n                    case \"rtcp-fb\":\n                      this.parseRtcpFb(e);\n                      break;\n                    case \"rtcp-mux\":\n                      this.parseRTCPMux();\n                      break;\n                    case \"rtcp-mux-only\":\n                      this.parseRTCPMuxOnly();\n                      break;\n                    case \"rtcp-rsize\":\n                      this.parseRTCPRsize();\n                      break;\n                    case \"rtcp\":\n                      this.parseRTCP(e);\n                      break;\n                    case \"mid\":\n                      this.parseMid(e);\n                      break;\n                    case \"msid\":\n                      this.parseMsid(e);\n                      break;\n                    case \"imageattr\":\n                      this.parseImageAttr(e);\n                      break;\n                    case \"rid\":\n                      this.parseRid(e);\n                      break;\n                    case \"simulcast\":\n                      this.parseSimulcast(e);\n                      break;\n                    case \"sctp-port\":\n                      this.parseSctpPort(e);\n                      break;\n                    case \"max-message-size\":\n                      this.parseMaxMessageSize(e);\n                      break;\n                    case \"ssrc-group\":\n                      this.parseSSRCGroup(e);\n                      break;\n                    default:\n                      e.ignored = !0, this.attributes.unrecognized.push(e);\n                  }\n                } catch (t) {\n                  throw console.error(\"parsing media attribute \".concat(e.attField, ' error, \"a=').concat(e.attField, \":\").concat(e.attValue, '\"')), t;\n                }\n                if (!e.ignored && e.attValue && !this.atEnd(e)) throw new Error(\"attribute parsing error\");\n              }\n              parseCandidate(e) {\n                const t = this.extractOneOrMore(e, E, [1, 32]);\n                this.consumeAttributeSpace(e);\n                const i = this.extractOneOrMore(e, a, [1, 5]);\n                this.consumeAttributeSpace(e);\n                const n = this.extract(e, this.consumeToken);\n                this.consumeAttributeSpace(e);\n                const r = this.extractOneOrMore(e, a, [1, 10]);\n                this.consumeAttributeSpace(e);\n                const s = this.extract(e, this.consumeAddress);\n                this.consumeAttributeSpace(e);\n                const d = this.extract(e, this.consumePort);\n                this.consumeAttributeSpace(e), this.extract(e, this.consume, \"typ\"), this.consumeAttributeSpace(e);\n                const l = {\n                  foundation: t,\n                  componentId: i,\n                  transport: n,\n                  priority: r,\n                  connectionAddress: s,\n                  port: d,\n                  type: this.extract(e, this.consumeToken),\n                  extension: {}\n                };\n                for (this.peek(e, \" raddr\") && (this.extract(e, this.consume, \" raddr\"), this.consumeAttributeSpace(e), l.relAddr = this.extract(e, this.consumeAddress)), this.peek(e, \" rport\") && (this.extract(e, this.consume, \" rport\"), this.consumeAttributeSpace(e), l.relPort = this.extract(e, this.consumePort)); this.peekChar(e) === o;) {\n                  this.consumeAttributeSpace(e);\n                  const t = this.extract(e, this.consumeToken);\n                  this.consumeAttributeSpace(e), l.extension[t] = this.extractOneOrMore(e, c);\n                }\n                this.attributes.candidates.push(l);\n              }\n              parseRemoteCandidate(e) {\n                const t = [];\n                for (;;) {\n                  const i = this.extractOneOrMore(e, a, [1, 5]);\n                  this.consumeAttributeSpace(e);\n                  const n = this.extract(e, this.consumeAddress);\n                  this.consumeAttributeSpace(e);\n                  const r = this.extract(e, this.consumePort);\n                  t.push({\n                    componentId: i,\n                    connectionAddress: n,\n                    port: r\n                  });\n                  try {\n                    this.consumeAttributeSpace(e);\n                  } catch (e) {\n                    break;\n                  }\n                }\n                this.attributes.remoteCandidatesList.push(t);\n              }\n              parseEndOfCandidates() {\n                if (this.attributes.endOfCandidates) throw new Error(\"must be only one line of end-of-candidates\");\n                this.attributes.endOfCandidates = !0;\n              }\n              parseRtpmap(e) {\n                const t = this.extract(e, this.consumeToken);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill, \"/\");\n                this.extract(e, this.consume, \"/\");\n                const n = {\n                  encodingName: i,\n                  clockRate: this.extractOneOrMore(e, a)\n                };\n                this.atEnd(e) || \"/\" !== this.peekChar(e) || (this.extract(e, this.consume, \"/\"), n.encodingParameters = parseInt(this.extract(e, this.consumeTill), 10));\n                const r = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));\n                r ? r.rtpMap = n : this.attributes.payloads.push({\n                  payloadType: parseInt(t, 10),\n                  rtpMap: n,\n                  rtcpFeedbacks: []\n                });\n              }\n              parsePtime(e) {\n                if (this.attributes.ptime) throw new Error(\"must be only one line of ptime\");\n                this.attributes.ptime = this.extract(e, this.consumeTill);\n              }\n              parseMaxPtime(e) {\n                if (this.attributes.maxPtime) throw new Error(\"must be only one line of ptime\");\n                this.attributes.maxPtime = this.extract(e, this.consumeTill);\n              }\n              parseDirection(e) {\n                if (this.attributes.direction) throw new Error(\"must be only one line of direction info\");\n                this.attributes.direction = e.attField;\n              }\n              parseSSRC(e) {\n                const t = this.extractOneOrMore(e, a);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill, \":\");\n                let n;\n                \":\" === this.peekChar(e) && (this.extract(e, this.consume, \":\"), n = this.extract(e, this.consumeTill));\n                const r = this.attributes.ssrcs.find(e => e.ssrcId === parseInt(t, 10));\n                r ? r.attributes[i] = n : this.attributes.ssrcs.push({\n                  ssrcId: parseInt(t, 10),\n                  attributes: {\n                    [i]: n\n                  }\n                });\n              }\n              parseFmtp(e) {\n                const t = this.extract(e, this.consumeTill, o);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill),\n                  n = {};\n                i.split(\";\").forEach(e => {\n                  let _e$split3 = e.split(\"=\"),\n                    _e$split4 = _slicedToArray(_e$split3, 2),\n                    t = _e$split4[0],\n                    i = _e$split4[1];\n                  t = jp(t).call(t);\n                  const r = \"string\" == typeof i ? jp(i).call(i) : null;\n                  \"string\" == typeof t && t.length > 0 && (n[t] = r);\n                });\n                const r = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));\n                r ? r.fmtp = {\n                  parameters: n\n                } : this.attributes.payloads.push({\n                  payloadType: parseInt(t, 10),\n                  rtcpFeedbacks: [],\n                  fmtp: {\n                    parameters: n\n                  }\n                });\n              }\n              parseFmtParameters(e) {\n                const t = {},\n                  i = this.extract(e, this.consumeTill, \"=\");\n                e._cur++;\n                const n = this.extract(e, this.consumeTill, \";\");\n                for (t[i] = n; \";\" === e.attValue[e._cur];) {\n                  const i = this.extract(e, this.consumeTill, \"=\");\n                  e._cur++;\n                  const n = this.extract(e, this.consumeTill, \";\");\n                  t[i] = n;\n                }\n                return t;\n              }\n              parseRtcpFb(e) {\n                let t = \"\";\n                t = \"*\" === this.peekChar(e) ? this.extract(e, this.consume, \"*\") : this.extract(e, this.consumeTill, o), this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill, o);\n                let n;\n                if (\"trr-int\" === i) n = {\n                  type: i,\n                  interval: this.extract(e, this.consumeTill)\n                };else {\n                  const t = {\n                    type: i\n                  };\n                  this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.parameter = this.extract(e, this.consumeToken), this.peekChar(e) === o && (t.additional = this.extract(e, this.consumeTill))), n = t;\n                }\n                if (\"*\" === t) this.attributes.rtcpFeedbackWildcards.push(n);else {\n                  const e = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));\n                  e ? e.rtcpFeedbacks.push(n) : this.attributes.payloads.push({\n                    payloadType: parseInt(t, 10),\n                    rtcpFeedbacks: [n]\n                  });\n                }\n              }\n              parseRTCPMux() {\n                if (this.attributes.rtcpMux) throw new Error(\"must be single line of rtcp-mux\");\n                this.attributes.rtcpMux = !0;\n              }\n              parseRTCPMuxOnly() {\n                if (this.attributes.rtcpMuxOnly) throw new Error(\"must be single line of rtcp-only\");\n                this.attributes.rtcpMuxOnly = !0;\n              }\n              parseRTCPRsize() {\n                if (this.attributes.rtcpRsize) throw new Error(\"must be single line of rtcp-rsize\");\n                this.attributes.rtcpRsize = !0;\n              }\n              parseRTCP(e) {\n                if (this.attributes.rtcp) throw new Error(\"must be single line of rtcp\");\n                const t = {\n                  port: this.extract(e, this.consumePort)\n                };\n                this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.netType = this.extractOneOrMore(e, l), this.consumeAttributeSpace(e), t.addressType = this.extractOneOrMore(e, l), this.consumeAttributeSpace(e), t.address = this.extract(e, this.consumeAddress)), this.attributes.rtcp = t;\n              }\n              parseMsid(e) {\n                const t = {\n                  id: this.extractOneOrMore(e, l, [1, 64])\n                };\n                this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.appdata = this.extractOneOrMore(e, l, [1, 64])), this.attributes.msids.push(t);\n              }\n              parseImageAttr(e) {\n                this.attributes.imageattr.push(e.attValue);\n              }\n              parseRid(e) {\n                const t = this.extractOneOrMore(e, e => u(e) || a(e) || \"_\" === e || \"-\" === e);\n                this.consumeAttributeSpace(e);\n                const i = {\n                  id: t,\n                  direction: this.extract(e, this.consumeToken),\n                  params: []\n                };\n                if (this.peekChar(e) === o) {\n                  if (this.consumeAttributeSpace(e), this.peek(e, \"pt=\")) {\n                    this.extract(e, this.consume, \"pt=\");\n                    const t = [];\n                    for (;;) {\n                      const i = this.extract(e, this.consumeToken);\n                      t.push(i);\n                      try {\n                        this.extract(e, this.consume, \",\");\n                      } catch (e) {\n                        break;\n                      }\n                    }\n                    i.payloads = t, this.peekChar(e) === o && this.extract(e, this.consume, o);\n                  }\n                  for (;;) {\n                    const t = this.extract(e, this.consumeToken);\n                    switch (t) {\n                      case \"depend\":\n                        {\n                          const n = {\n                            type: t,\n                            rids: this.extract(e, this.consume, \"=\").split(\",\")\n                          };\n                          i.params.push(n);\n                          break;\n                        }\n                      default:\n                        {\n                          const n = {\n                            type: t\n                          };\n                          \"=\" === this.peekChar(e) && (this.extract(e, this.consume, \"=\"), n.val = this.extract(e, this.consumeTill, \";\")), i.params.push(n);\n                        }\n                    }\n                    try {\n                      this.extract(e, this.consume, \";\");\n                    } catch (e) {\n                      break;\n                    }\n                  }\n                }\n                this.attributes.rids.push(i);\n              }\n              parseSimulcast(e) {\n                if (this.attributes.simulcast) throw new Error(\"must be single line of simulcast\");\n                this.attributes.simulcast = e.attValue, this.extract(e, this.consumeTill);\n              }\n              parseSctpPort(e) {\n                this.attributes.sctpPort = this.extractOneOrMore(e, a, [1, 5]);\n              }\n              parseMaxMessageSize(e) {\n                this.attributes.maxMessageSize = this.extractOneOrMore(e, a, [1, void 0]);\n              }\n              digest() {\n                return this.digested = !0, this.attributes;\n              }\n              parseMid(e) {\n                this.attributes.mid = this.extract(e, this.consumeToken);\n              }\n              parseSSRCGroup(e) {\n                const t = this.extract(e, this.consumeToken),\n                  i = [];\n                for (;;) try {\n                  this.consumeAttributeSpace(e);\n                  const t = this.extract(e, this.consumeInteger);\n                  i.push(parseInt(t, 10));\n                } catch (e) {\n                  break;\n                }\n                this.attributes.ssrcGroups.push({\n                  semantic: t,\n                  ssrcIds: i\n                });\n              }\n            }\n            function A(e, t, i) {\n              return t in e ? Object.defineProperty(e, t, {\n                value: i,\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n              }) : e[t] = i, e;\n            }\n            class b {\n              constructor() {\n                A(this, \"eol\", r);\n              }\n              print(e, t) {\n                let i = \"\";\n                return t && (this.eol = t), i += this.printVersion(e.version), i += this.printOrigin(e.origin), i += this.printSessionName(e.sessionName), i += this.printInformation(e.information), i += this.printUri(e.uri), i += this.printEmail(e.emails), i += this.printPhone(e.phones), i += this.printConnection(e.connection), i += this.printBandwidth(e.bandwidths), i += this.printTimeFields(e.timeFields), i += this.printKey(e.key), i += this.printSessionAttributes(e.attributes), i += this.printMediaDescription(e.mediaDescriptions), i;\n              }\n              printVersion(e) {\n                return \"v=\".concat(e).concat(this.eol);\n              }\n              printOrigin(e) {\n                return \"o=\".concat(e.username, \" \").concat(e.sessId, \" \").concat(e.sessVersion, \" \").concat(e.nettype, \" \").concat(e.addrtype, \" \").concat(e.unicastAddress).concat(this.eol);\n              }\n              printSessionName(e) {\n                return e ? \"s=\".concat(e).concat(this.eol) : \"\";\n              }\n              printInformation(e) {\n                return e ? \"i=\".concat(e).concat(this.eol) : \"\";\n              }\n              printUri(e) {\n                return e ? \"u=\".concat(e).concat(this.eol) : \"\";\n              }\n              printEmail(e) {\n                let t = \"\";\n                for (const i of e) t += \"e=\".concat(i).concat(this.eol);\n                return t;\n              }\n              printPhone(e) {\n                let t = \"\";\n                for (const i of e) t += \"e=\".concat(i).concat(this.eol);\n                return t;\n              }\n              printConnection(e) {\n                return e ? \"c=\".concat(e.nettype, \" \").concat(e.addrtype, \" \").concat(e.address).concat(this.eol) : \"\";\n              }\n              printBandwidth(e) {\n                let t = \"\";\n                for (const i of e) t += \"b=\".concat(i.bwtype, \":\").concat(i.bandwidth).concat(this.eol);\n                return t;\n              }\n              printTimeFields(e) {\n                let t = \"\";\n                for (const i of e) {\n                  t += \"t=\".concat(i.time.startTime, \" \").concat(i.time.startTime).concat(this.eol);\n                  for (const e of i.repeats) t += \"r=\".concat(e.repeatInterval, \" \").concat(e.typedTimes.join(\" \")).concat(this.eol);\n                  i.zoneAdjustments && (t += \"z=\", t += \"z=\".concat(i.zoneAdjustments.map(e => \"\".concat(e.time, \" \").concat(e.back ? \"-\" : \"\", \" \").concat(e.typedTime)).join(\" \")).concat(this.eol), t += this.eol);\n                }\n                return t;\n              }\n              printKey(e) {\n                return e ? \"k=\".concat(e).concat(this.eol) : \"\";\n              }\n              printAttributes(e) {\n                let t = \"\";\n                for (const i of e) t += \"a=\".concat(i.attField).concat(i.attValue ? \":\".concat(i.attValue) : \"\").concat(this.eol);\n                return t;\n              }\n              printMediaDescription(e) {\n                let t = \"\";\n                for (const i of e) t += this.printMedia(i.media), t += this.printInformation(i.information), t += this.printConnections(i.connections), t += this.printBandwidth(i.bandwidths), t += this.printKey(i.key), t += this.printMediaAttributes(i);\n                return t;\n              }\n              printConnections(e) {\n                let t = \"\";\n                for (const i of e) t += this.printConnection(i);\n                return t;\n              }\n              printMedia(e) {\n                return \"m=\".concat(e.mediaType, \" \").concat(e.port, \" \").concat(e.protos.join(\"/\"), \" \").concat(e.fmts.join(\" \")).concat(this.eol);\n              }\n              printSessionAttributes(e) {\n                return new O(this.eol).print(e);\n              }\n              printMediaAttributes(e) {\n                return new N(this.eol).print(e);\n              }\n            }\n            class w {\n              constructor(e) {\n                A(this, \"eol\", void 0), this.eol = e;\n              }\n              printIceUfrag(e) {\n                return void 0 === e ? \"\" : \"a=ice-ufrag:\".concat(e).concat(this.eol);\n              }\n              printIcePwd(e) {\n                return void 0 === e ? \"\" : \"a=ice-pwd:\".concat(e).concat(this.eol);\n              }\n              printIceOptions(e) {\n                return void 0 === e ? \"\" : \"a=ice-options:\".concat(e.join(o)).concat(this.eol);\n              }\n              printFingerprints(e) {\n                return e.length > 0 ? e.map(e => \"a=fingerprint:\".concat(e.hashFunction).concat(o).concat(e.fingerprint)).join(this.eol) + this.eol : \"\";\n              }\n              printExtmap(e) {\n                return e.map(e => \"a=extmap:\".concat(e.entry).concat(e.direction ? \"/\".concat(e.direction) : \"\").concat(o).concat(e.extensionName).concat(e.extensionAttributes ? \"\".concat(o).concat(e.extensionAttributes) : \"\").concat(this.eol)).join(\"\");\n              }\n              printSetup(e) {\n                return void 0 === e ? \"\" : \"a=setup:\".concat(e).concat(this.eol);\n              }\n              printUnrecognized(e) {\n                return e.map(e => \"a=\".concat(e.attField).concat(e.attValue ? \":\".concat(e.attValue) : \"\").concat(this.eol)).join(\"\");\n              }\n            }\n            class O extends w {\n              print(e) {\n                let t = \"\";\n                return t += this.printGroups(e.groups), t += this.printMsidSemantic(e.msidSemantic), t += this.printIceLite(e.iceLite), t += this.printIceUfrag(e.iceUfrag), t += this.printIcePwd(e.icePwd), t += this.printIceOptions(e.iceOptions), t += this.printFingerprints(e.fingerprints), t += this.printSetup(e.setup), t += this.printTlsId(e.tlsId), t += this.printIdentity(e.identities), t += this.printExtmap(e.extmaps), t += this.printUnrecognized(e.unrecognized), t;\n              }\n              printGroups(e) {\n                let t = \"\";\n                return e.length > 0 && (t += e.map(e => \"a=group:\".concat(e.semantic).concat(e.identificationTag.map(e => \"\".concat(o).concat(e)).join(\"\")).concat(this.eol)).join(\"\")), t;\n              }\n              printIceLite(e) {\n                return void 0 === e ? \"\" : \"a=ice-lite\" + this.eol;\n              }\n              printTlsId(e) {\n                return e ? \"a=tls-id:\".concat(e).concat(this.eol) : \"\";\n              }\n              printIdentity(e) {\n                return 0 === e.length ? \"\" : e.map(e => \"a=identity:\".concat(e.assertionValue).concat(e.extensions.map(e => \"\".concat(o).concat(e.name).concat(e.value ? \"=\".concat(e.value) : \"\")))).join(this.eol) + this.eol;\n              }\n              printMsidSemantic(e) {\n                if (!e) return \"\";\n                let t = \"a=msid-semantic:\".concat(e.semantic);\n                return e.applyForAll ? t += \"\".concat(o, \"*\") : e.identifierList.length > 0 && (t += e.identifierList.map(e => \"\".concat(o).concat(e))), t + this.eol;\n              }\n            }\n            class N extends w {\n              print(e) {\n                const t = e.attributes;\n                let i = \"\";\n                return i += this.printRTCP(t.rtcp), i += this.printIceUfrag(t.iceUfrag), i += this.printIcePwd(t.icePwd), i += this.printIceOptions(t.iceOptions), i += this.printCandidates(t.candidates), i += this.printRemoteCandidatesList(t.remoteCandidatesList), i += this.printEndOfCandidates(t.endOfCandidates), i += this.printFingerprints(t.fingerprints), i += this.printSetup(t.setup), i += this.printMid(t.mid), i += this.printExtmap(t.extmaps), i += this.printRTPRelated(t), i += this.printPtime(t.ptime), i += this.printMaxPtime(t.maxPtime), i += this.printDirection(t.direction), i += this.printSSRCGroups(t.ssrcGroups), i += this.printSSRC(t.ssrcs), i += this.printRTCPMux(t.rtcpMux), i += this.printRTCPMuxOnly(t.rtcpMuxOnly), i += this.printRTCPRsize(t.rtcpRsize), i += this.printMSId(t.msids), i += this.printImageattr(t.imageattr), i += this.printRid(t.rids), i += this.printSimulcast(t.simulcast), i += this.printSCTPPort(t.sctpPort), i += this.printMaxMessageSize(t.maxMessageSize), i += this.printUnrecognized(t.unrecognized), i;\n              }\n              printCandidates(e) {\n                return e.map(e => \"a=candidate:\".concat(e.foundation).concat(o).concat(e.componentId).concat(o).concat(e.transport).concat(o).concat(e.priority).concat(o).concat(e.connectionAddress).concat(o).concat(e.port).concat(o, \"typ\").concat(o).concat(e.type).concat(e.relAddr ? \"\".concat(o, \"raddr\").concat(o).concat(e.relAddr) : \"\").concat(e.relPort ? \"\".concat(o, \"rport\").concat(o).concat(e.relPort) : \"\").concat(Object.keys(e.extension).map(t => \"\".concat(o).concat(t).concat(o).concat(e.extension[t])).join(\"\")).concat(this.eol)).join(\"\");\n              }\n              printRemoteCandidatesList(e) {\n                return e.map(e => \"a=remote-candidates:\".concat(e.join(o)).concat(this.eol)).join(\"\");\n              }\n              printEndOfCandidates(e) {\n                return void 0 === e ? \"\" : \"a=end-of-candidates\" + this.eol;\n              }\n              printRTPRelated(e) {\n                if (!e.payloads) return \"\";\n                const t = e.payloads;\n                let i = \"\";\n                i += e.rtcpFeedbackWildcards.map(e => this.printRTCPFeedback(\"*\", e)).join(\"\");\n                for (const e of t) i += this.printRtpMap(e.payloadType, e.rtpMap), i += this.printFmtp(e.payloadType, e.fmtp), i += e.rtcpFeedbacks.map(t => this.printRTCPFeedback(e.payloadType, t)).join(\"\");\n                return i;\n              }\n              printFmtp(e, t) {\n                if (!t) return \"\";\n                const i = Object.keys(t.parameters);\n                return 1 === i.length && null === t.parameters[i[0]] ? \"a=fmtp:\".concat(e).concat(o).concat(i[0]).concat(this.eol) : \"a=fmtp:\".concat(e).concat(o).concat(Object.keys(t.parameters).map(e => \"\".concat(e, \"=\").concat(t.parameters[e])).join(\";\")).concat(this.eol);\n              }\n              printRtpMap(e, t) {\n                return t ? \"a=rtpmap:\".concat(e).concat(o).concat(t.encodingName, \"/\").concat(t.clockRate).concat(t.encodingParameters ? \"/\".concat(t.encodingParameters) : \"\").concat(this.eol) : \"\";\n              }\n              printRTCPFeedback(e, t) {\n                let i = \"a=rtcp-fb:\".concat(e).concat(o),\n                  n = t;\n                return \"trr-int\" === n.type ? i += \"ttr-int\".concat(o).concat(n.interval) : (i += \"\".concat(n.type), n.parameter && (i += \"\".concat(o).concat(n.parameter), n.additional && (i += \"\".concat(o).concat(n.additional)))), i + this.eol;\n              }\n              printPtime(e) {\n                return void 0 === e ? \"\" : \"a=ptime:\".concat(e).concat(this.eol);\n              }\n              printMaxPtime(e) {\n                return void 0 === e ? \"\" : \"a=maxptime:\".concat(e).concat(this.eol);\n              }\n              printDirection(e) {\n                return void 0 === e ? \"\" : \"a=\".concat(e).concat(this.eol);\n              }\n              printSSRC(e) {\n                return e.map(e => Object.keys(e.attributes).map(t => \"a=ssrc:\".concat(e.ssrcId.toString(10)).concat(o).concat(t).concat(e.attributes[t] ? \":\".concat(e.attributes[t]) : \"\").concat(this.eol)).join(\"\")).join(\"\");\n              }\n              printRTCPMux(e) {\n                return void 0 === e ? \"\" : \"a=rtcp-mux\".concat(this.eol);\n              }\n              printRTCPMuxOnly(e) {\n                return void 0 === e ? \"\" : \"a=rtcp-mux-only\".concat(this.eol);\n              }\n              printRTCPRsize(e) {\n                return void 0 === e ? \"\" : \"a=rtcp-rsize\".concat(this.eol);\n              }\n              printRTCP(e) {\n                if (void 0 === e) return \"\";\n                let t = \"a=rtcp:\".concat(e.port);\n                return e.netType && (t += \"\".concat(o).concat(e.netType)), e.addressType && (t += \"\".concat(o).concat(e.addressType)), e.address && (t += \"\".concat(o).concat(e.address)), t + this.eol;\n              }\n              printMSId(e) {\n                return e.map(e => \"a=msid:\".concat(e.id).concat(e.appdata ? \"\".concat(o).concat(e.appdata) : \"\").concat(this.eol)).join(\"\");\n              }\n              printImageattr(e) {\n                return e.map(e => \"a=imageattr:\".concat(e).concat(this.eol)).join(\"\");\n              }\n              printRid(e) {\n                return e.map(e => {\n                  let t = \"a=rid:\".concat(e.id).concat(o).concat(e.direction);\n                  return e.payloads && (t += \"\".concat(o, \"pt=\").concat(e.payloads.join(\",\"))), e.params.length > 0 && (t += \"\".concat(o).concat(e.params.map(e => \"depend\" === e.type ? \"depend=\".concat(e.rids.join(\",\")) : \"\".concat(e.type, \"=\").concat(e.val)).join(\";\"))), t + this.eol;\n                }).join(\"\");\n              }\n              printSimulcast(e) {\n                return void 0 === e ? \"\" : \"a=simulcast:\".concat(e).concat(this.eol);\n              }\n              printSCTPPort(e) {\n                return void 0 === e ? \"\" : \"a=sctp-port:\".concat(e).concat(this.eol);\n              }\n              printMaxMessageSize(e) {\n                return void 0 === e ? \"\" : \"a=max-message-size:\".concat(e).concat(this.eol);\n              }\n              printMid(e) {\n                return void 0 === e ? \"\" : \"a=mid:\".concat(e).concat(this.eol);\n              }\n              printSSRCGroups(e) {\n                return e.map(e => \"a=ssrc-group:\".concat(e.semantic).concat(e.ssrcIds.map(e => \"\".concat(o).concat(e.toString(10))).join(\"\")).concat(this.eol)).join(\"\");\n              }\n            }\n            function D(e) {\n              return new C().parse(e);\n            }\n            function P(e, t) {\n              return new b().print(e, t);\n            }\n          }\n        },\n        t = {};\n      function i(n) {\n        if (t[n]) return t[n].exports;\n        var r = t[n] = {\n          exports: {}\n        };\n        return e[n](r, r.exports, i), r.exports;\n      }\n      return i.d = (e, t) => {\n        for (var n in t) i.o(t, n) && !i.o(e, n) && Object.defineProperty(e, n, {\n          enumerable: !0,\n          get: t[n]\n        });\n      }, i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i.r = e => {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n          value: \"Module\"\n        }), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n      }, i(8);\n    })();\n  }(bB);\n  var wB = bB.exports;\n  function OB(e) {\n    if (Array.isArray(e)) return e.map(e => e);\n    if (!NB(e)) return e;\n    const t = {};\n    for (const i in e) {\n      const n = e[i];\n      NB(n) || Array.isArray(n) ? t[i] = OB(n) : t[i] = n;\n    }\n    return t;\n  }\n  function NB(e) {\n    return !(\"object\" != typeof e || Array.isArray(e) || !e);\n  }\n  class DB {\n    constructor(e) {\n      ng(this, \"input\", []), ng(this, \"size\", void 0), this.size = e;\n    }\n    add(e) {\n      this.input.push(e), this.input.length > this.size && this.input.splice(0, 1);\n    }\n    diffMean() {\n      return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;\n    }\n  }\n  const PB = {\n      address: \"unknown\",\n      candidateType: \"unknown\",\n      id: \"unknown\",\n      port: 0,\n      priority: 0,\n      protocol: \"unknown\",\n      type: \"unknown\"\n    },\n    LB = {\n      timestamp: 0,\n      bitrate: {\n        actualEncoded: 0,\n        transmit: 0\n      },\n      sendPacketLossRate: 0,\n      recvPacketLossRate: 0,\n      videoRecv: [],\n      videoSend: [],\n      audioRecv: [],\n      audioSend: [],\n      selectedCandidatePair: {\n        id: \"unknown\",\n        localCandidate: PB,\n        remoteCandidate: PB\n      }\n    },\n    kB = {\n      firsCount: 0,\n      nacksCount: 0,\n      plisCount: 0,\n      framesDecodeCount: 0,\n      framesDecodeInterval: 0,\n      framesDecodeFreezeTime: 0,\n      decodeFrameRate: 0,\n      bytes: 0,\n      packetsLost: 0,\n      packetLostRate: 0,\n      packets: 0,\n      ssrc: 0,\n      qpSumPerFrame: 0,\n      framesDroppedCount: 0,\n      outputFrameRate: 0\n    },\n    MB = {\n      firsCount: 0,\n      nacksCount: 0,\n      plisCount: 0,\n      frameCount: 0,\n      bytes: 0,\n      packets: 0,\n      packetsLost: 0,\n      packetLostRate: 0,\n      ssrc: 0,\n      rttMs: 0,\n      jitterMs: 0,\n      qpSumPerFrame: 0\n    },\n    UB = {\n      bytes: 0,\n      packets: 0,\n      packetsLost: 0,\n      packetLostRate: 0,\n      ssrc: 0,\n      rttMs: 0,\n      jitterMs: 0\n    },\n    xB = {\n      jitterBufferMs: 0,\n      jitterMs: 0,\n      bytes: 0,\n      packetsLost: 0,\n      packetLostRate: 0,\n      packets: 0,\n      ssrc: 0,\n      receivedFrames: 0,\n      droppedFrames: 0,\n      concealedSamples: 0\n    };\n  function VB(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function FB(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? VB(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : VB(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class BB {\n    constructor(e, t) {\n      ng(this, \"onFirstVideoReceived\", void 0), ng(this, \"onFirstVideoDecoded\", void 0), ng(this, \"onFirstAudioReceived\", void 0), ng(this, \"onFirstVideoDecodedTimeout\", void 0), ng(this, \"onFirstAudioDecoded\", void 0), ng(this, \"onSelectedLocalCandidateChanged\", void 0), ng(this, \"onSelectedRemoteCandidateChanged\", void 0), ng(this, \"videoIsReady\", !1), ng(this, \"videoIsReady2\", {}), ng(this, \"pc\", void 0), ng(this, \"options\", void 0), ng(this, \"intervalTimer\", void 0), ng(this, \"stats\", OB(LB)), ng(this, \"isFirstVideoReceived\", {}), ng(this, \"isFirstVideoDecoded\", {}), ng(this, \"isFirstAudioReceived\", {}), ng(this, \"isFirstAudioDecoded\", {}), ng(this, \"isFirstVideoDecodedTimeout\", {}), ng(this, \"lossRateWindowStats\", []), this.pc = e, this.options = t, this.intervalTimer = window.setInterval(async () => {\n        this.updateStats();\n      }, this.options.updateInterval);\n    }\n    getStats() {\n      return this.stats;\n    }\n    getSelectedCandidatePair() {\n      return new Gu(e => {\n        e({\n          local: FB({}, PB),\n          remote: FB({}, PB)\n        });\n      });\n    }\n    setVideoIsReady(e) {\n      this.videoIsReady = e;\n    }\n    setVideoIsReady2(e, t) {\n      this.videoIsReady2[e] = t;\n    }\n    getVideoIsReady(e) {\n      return this.videoIsReady2[e] || !1;\n    }\n    setIsFirstAudioDecoded(e) {}\n    destroy() {\n      window.clearInterval(this.intervalTimer), this.pc = void 0;\n    }\n    calcLossRate(e) {\n      this.lossRateWindowStats.push(e), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);\n      const t = this.lossRateWindowStats.length,\n        i = [\"videoSend\", \"audioSend\", \"videoRecv\", \"audioRecv\"];\n      let n = 0,\n        r = 0,\n        o = 0,\n        s = 0;\n      for (const a of i) e[a].forEach((e, i) => {\n        if (!this.lossRateWindowStats[t - 1][a][i] || !this.lossRateWindowStats[0][a][i]) return;\n        const c = this.lossRateWindowStats[t - 1][a][i].packets - this.lossRateWindowStats[0][a][i].packets,\n          d = this.lossRateWindowStats[t - 1][a][i].packetsLost - this.lossRateWindowStats[0][a][i].packetsLost;\n        \"videoSend\" === a || \"audioSend\" === a ? (n += c, o += d) : (r += c, s += d), Number.isNaN(c) || Number.isNaN(c) ? e.packetLostRate = 0 : e.packetLostRate = c <= 0 || d <= 0 ? 0 : d / (c + d);\n      });\n      e.sendPacketLossRate = n <= 0 || o <= 0 ? 0 : o / (n + o), e.recvPacketLossRate = r <= 0 || s <= 0 ? 0 : s / (r + s);\n    }\n  }\n  function jB(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function GB(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? jB(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : jB(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class WB extends BB {\n    constructor() {\n      super(...arguments), ng(this, \"_stats\", LB), ng(this, \"lastDecodeVideoReceiverStats\", new Map());\n    }\n    async updateStats() {\n      const e = await this._getStats(),\n        t = this.statsResponsesToObjects(e);\n      this._stats = OB(LB);\n      const i = t.filter(e => \"ssrc\" === e.type);\n      this.processSSRCStats(i);\n      const n = t.find(e => \"VideoBwe\" === e.type);\n      n && this.processBandwidthStats(n), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;\n    }\n    processBandwidthStats(e) {\n      this._stats.bitrate = {\n        actualEncoded: Number(e.googActualEncBitrate),\n        targetEncoded: Number(e.googTargetEncBitrate),\n        retransmit: Number(e.googRetransmitBitrate),\n        transmit: Number(e.googTransmitBitrate)\n      }, this._stats.sendBandwidth = Number(e.googAvailableSendBandwidth);\n    }\n    processSSRCStats(e) {\n      e.forEach(e => {\n        var t;\n        const i = Dn(t = e.id).call(t, \"send\");\n        switch (\"\".concat(e.mediaType, \"_\").concat(i ? \"send\" : \"recv\")) {\n          case \"video_send\":\n            {\n              const t = OB(MB);\n              t.codec = e.googCodecName, t.adaptionChangeReason = \"none\", e.googCpuLimitedResolution && (t.adaptionChangeReason = \"cpu\"), e.googBandwidthLimitedResolution && (t.adaptionChangeReason = \"bandwidth\"), t.avgEncodeMs = Number(e.googAvgEncodeMs), t.inputFrame = {\n                width: Number(e.googFrameWidthInput) || Number(e.googFrameWidthSent),\n                height: Number(e.googFrameHeightInput) || Number(e.googFrameHeightSent),\n                frameRate: Number(e.googFrameRateInput)\n              }, t.sentFrame = {\n                width: Number(e.googFrameWidthSent),\n                height: Number(e.googFrameHeightSent),\n                frameRate: Number(e.googFrameRateInput)\n              }, t.firsCount = Number(e.googFirReceived), t.nacksCount = Number(e.googNacksReceived), t.plisCount = Number(e.googPlisReceived), t.frameCount = Number(e.framesEncoded), t.bytes = Number(e.bytesSent), t.packets = Number(e.packetsSent), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.rttMs = Number(e.googRtt || 0), this._stats.videoSend.push(t), this._stats.rtt = t.rttMs;\n              break;\n            }\n          case \"video_recv\":\n            {\n              const t = OB(kB),\n                i = this.lastDecodeVideoReceiverStats.get(Number(e.ssrc));\n              if (t.codec = e.googCodecName, t.targetDelayMs = Number(e.googTargetDelayMs), t.renderDelayMs = Number(e.googRenderDelayMs), t.currentDelayMs = Number(e.googCurrentDelayMs), t.minPlayoutDelayMs = Number(e.googMinPlayoutDelayMs), t.decodeMs = Number(e.googDecodeMs), t.maxDecodeMs = Number(e.googMaxDecodeMs), t.receivedFrame = {\n                width: Number(e.googFrameWidthReceived),\n                height: Number(e.googFrameHeightReceived),\n                frameRate: Number(e.googFrameRateReceived)\n              }, t.decodedFrame = {\n                width: Number(e.googFrameWidthReceived),\n                height: Number(e.googFrameHeightReceived),\n                frameRate: Number(e.googFrameRateDecoded)\n              }, t.decodeFrameRate = Number(e.googFrameRateDecoded), t.outputFrame = {\n                width: Number(e.googFrameWidthReceived),\n                height: Number(e.googFrameHeightReceived),\n                frameRate: Number(e.googFrameRateOutput)\n              }, t.jitterBufferMs = Number(e.googJitterBufferMs), t.firsCount = Number(e.googFirsSent), t.nacksCount = Number(e.googNacksSent), t.plisCount = Number(e.googPlisSent), t.framesDecodeCount = Number(e.framesDecoded), t.bytes = Number(e.bytesReceived), t.packets = Number(e.packetsReceived), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.packets > 0 && !this.isFirstVideoReceived[t.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t.ssrc), this.isFirstVideoReceived[t.ssrc] = !0), t.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t.ssrc, t.decodedFrame.width, t.decodedFrame.height), this.isFirstVideoDecoded[t.ssrc] = !0), i) {\n                const n = i.stats,\n                  r = Date.now() - i.lts;\n                t.framesDecodeFreezeTime = n.framesDecodeFreezeTime, t.framesDecodeInterval = n.framesDecodeInterval, t.framesDecodeCount > n.framesDecodeCount && this.isFirstVideoDecoded[t.ssrc] ? (i.lts = Date.now(), t.framesDecodeInterval = r, t.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e.ssrc, 10)) ? t.framesDecodeFreezeTime += t.framesDecodeInterval : this.setVideoIsReady2(parseInt(e.ssrc, 10), !0))) : t.framesDecodeCount < i.stats.framesDecodeCount && (t.framesDecodeInterval = 0);\n              }\n              this.lastDecodeVideoReceiverStats.set(t.ssrc, {\n                stats: GB({}, t),\n                lts: Date.now()\n              }), this._stats.videoRecv.push(t);\n              break;\n            }\n          case \"audio_recv\":\n            {\n              const t = OB(xB);\n              t.codec = e.googCodecName, t.outputLevel = Math.abs(Number(e.audioOutputLevel)) / 32767, t.decodingCNG = Number(e.googDecodingCNG), t.decodingCTN = Number(e.googDecodingCTN), t.decodingCTSG = Number(e.googDecodingCTSG), t.decodingNormal = Number(e.googDecodingNormal), t.decodingPLC = Number(e.googDecodingPLC), t.decodingPLCCNG = Number(e.googDecodingPLCCNG), t.expandRate = Number(e.googExpandRate), t.accelerateRate = Number(e.googAccelerateRate), t.preemptiveExpandRate = Number(e.googPreemptiveExpandRate), t.secondaryDecodedRate = Number(e.googSecondaryDecodedRate), t.speechExpandRate = Number(e.googSpeechExpandRate), t.preferredJitterBufferMs = Number(e.googPreferredJitterBufferMs), t.jitterBufferMs = Number(e.googJitterBufferMs), t.jitterMs = Number(e.googJitterReceived), t.bytes = Number(e.bytesReceived), t.packets = Number(e.packetsReceived), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.receivedFrames = Number(e.googDecodingCTN) || Number(e.packetsReceived), t.droppedFrames = Number(e.googDecodingPLC) + Number(e.googDecodingPLCCNG) || Number(e.packetsLost), t.receivedFrames > 0 && !this.isFirstAudioReceived[t.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t.ssrc), this.isFirstAudioReceived[t.ssrc] = !0), t.decodingNormal > 0 && !this.isFirstAudioDecoded[t.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t.ssrc), this.isFirstAudioDecoded[t.ssrc] = !0), this._stats.audioRecv.push(t);\n              break;\n            }\n          case \"audio_send\":\n            {\n              const t = OB(UB);\n              t.codec = e.googCodecName, t.inputLevel = Math.abs(Number(e.audioInputLevel)) / 32767, t.aecReturnLoss = Number(e.googEchoCancellationReturnLoss || 0), t.aecReturnLossEnhancement = Number(e.googEchoCancellationReturnLossEnhancement || 0), t.residualEchoLikelihood = Number(e.googResidualEchoLikelihood || 0), t.residualEchoLikelihoodRecentMax = Number(e.googResidualEchoLikelihoodRecentMax || 0), t.bytes = Number(e.bytesSent), t.packets = Number(e.packetsSent), t.packetsLost = Number(e.packetsLost), t.ssrc = Number(e.ssrc), t.rttMs = Number(e.googRtt || 0), this._stats.rtt = t.rttMs, this._stats.audioSend.push(t);\n              break;\n            }\n        }\n      });\n    }\n    _getStats() {\n      return new Gu((e, t) => {\n        this.pc.getStats(e, t);\n      });\n    }\n    statsResponsesToObjects(e) {\n      const t = [];\n      return e.result().forEach(e => {\n        const i = {\n          id: e.id,\n          timestamp: e.timestamp.valueOf().toString(),\n          type: e.type\n        };\n        e.names().forEach(t => {\n          i[t] = e.stat(t);\n        }), t.push(i);\n      }), t;\n    }\n  }\n  function HB(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function KB(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? HB(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : HB(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class YB extends BB {\n    constructor() {\n      super(...arguments), ng(this, \"_stats\", LB), ng(this, \"report\", void 0), ng(this, \"lastDecodeVideoReceiverStats\", new Map()), ng(this, \"lastVideoFramesRecv\", new Map()), ng(this, \"lastVideoFramesSent\", new Map()), ng(this, \"lastVideoFramesDecode\", new Map()), ng(this, \"lastVideoFramesOutput\", new Map()), ng(this, \"lastVideoJBDelay\", new Map()), ng(this, \"lastAudioJBDelay\", new Map()), ng(this, \"mediaBytesSent\", new Map()), ng(this, \"mediaBytesRetransmit\", new Map()), ng(this, \"mediaBytesTargetEncode\", new Map()), ng(this, \"lastEncoderMs\", new Map());\n    }\n    async updateStats() {\n      this.report = await this.pc.getStats(), this._stats = OB(LB), this.report.forEach(e => {\n        switch (e.type) {\n          case _b.OUTBOUND:\n          case _b.INBOUND:\n            {\n              const t = e.mediaType || e.kind,\n                i = !t && \"frameWidth\" in e,\n                n = !t && !(\"frameWidth\" in e);\n              e.type === _b.OUTBOUND ? \"audio\" === t || n ? this.processAudioOutboundStats(e) : (\"video\" === t || i) && this.processVideoOutboundStats(e) : e.type === _b.INBOUND && (\"audio\" === t || n ? this.processAudioInboundStats(e) : (\"video\" === t || i) && this.processVideoInboundStats(e));\n              break;\n            }\n          case _b.TRANSPORT:\n            {\n              const t = this.report.get(e.selectedCandidatePairId);\n              t && this.processCandidatePairStats(t);\n              break;\n            }\n          case _b.CANDIDATE_PAIR:\n            e.selected && this.processCandidatePairStats(e);\n        }\n      }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;\n    }\n    async getSelectedCandidatePair() {\n      const e = await this.pc.getStats(),\n        t = {\n          local: KB({}, PB),\n          remote: KB({}, PB)\n        };\n      return e.forEach(i => {\n        let n;\n        if (i.type === _b.TRANSPORT && (n = e.get(i.selectedCandidatePairId)), i.type === _b.CANDIDATE_PAIR && i.selected && (n = i), n) {\n          const i = (e, t) => {\n            e.type = t.type, e.id = t.id, t.address && (e.address = t.address), t.candidateType && (e.candidateType = t.candidateType), t.port && (e.port = t.port), t.priority && (e.priority = t.priority), t.protocol && (e.protocol = t.protocol), t.relayProtocol && (e.relayProtocol = t.relayProtocol);\n          };\n          if (n.localCandidateId) {\n            const r = e.get(n.localCandidateId);\n            r && i(t.local, r);\n          }\n          if (n.remoteCandidateId) {\n            const r = e.get(n.remoteCandidateId);\n            r && i(t.remote, r);\n          }\n        }\n      }), t;\n    }\n    processCandidatePairStats(e) {\n      if (this._stats.sendBandwidth = e.availableOutgoingBitrate || 0, e.currentRoundTripTime && (this._stats.rtt = 1e3 * e.currentRoundTripTime), this._stats.videoSend.forEach(t => {\n        e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime);\n      }), this._stats.audioSend.forEach(t => {\n        e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime);\n      }), this._stats.selectedCandidatePair.id = e.id, e.localCandidateId) {\n        const t = this.report.get(e.localCandidateId);\n        t && this.processCandidateStats(t);\n      }\n      if (e.remoteCandidateId) {\n        const t = this.report.get(e.remoteCandidateId);\n        t && this.processCandidateStats(t);\n      }\n    }\n    processCandidateStats(e) {\n      let t;\n      e.type === _b.LOCAL_CANDIDATE && (t = this._stats.selectedCandidatePair.localCandidate), e.type === _b.REMOTE_CANDIDATE && (t = this._stats.selectedCandidatePair.remoteCandidate), t && (t.type = e.type, t.id = e.id, e.address && (t.address = e.address), e.candidateType && (t.candidateType = e.candidateType), e.port && (t.port = e.port), e.priority && (t.priority = e.priority), e.protocol && (t.protocol = e.protocol), e.relayProtocol && (t.relayProtocol = e.relayProtocol), e.type === _b.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(KB({}, t), KB({}, this.stats.selectedCandidatePair.localCandidate)), e.type === _b.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(KB({}, t), KB({}, this.stats.selectedCandidatePair.remoteCandidate)));\n    }\n    processAudioInboundStats(e) {\n      let t = this._stats.audioRecv.find(t => t.ssrc === e.ssrc);\n      t || (t = OB(xB), this._stats.audioRecv.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsReceived, t.packetsLost = e.packetsLost, t.bytes = e.bytesReceived, t.jitterMs = 1e3 * e.jitter, this.processAudioTrackReceiverStats(e, e.trackId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), t.receivedFrames || (t.receivedFrames = e.packetsReceived), t.droppedFrames || (t.droppedFrames = e.packetsLost), t.receivedFrames > 0 && !this.isFirstAudioReceived[t.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t.ssrc), this.isFirstAudioReceived[t.ssrc] = !0), t.outputLevel && t.outputLevel > 0 && !this.isFirstAudioDecoded[t.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t.ssrc), this.isFirstAudioDecoded[t.ssrc] = !0), \"number\" == typeof e.concealedSamples && (t.concealedSamples = e.concealedSamples);\n    }\n    processVideoInboundStats(e) {\n      let t = this._stats.videoRecv.find(t => t.ssrc === e.ssrc);\n      t || (t = OB(kB), this._stats.videoRecv.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsReceived, t.packetsLost = e.packetsLost, t.bytes = e.bytesReceived, t.firsCount = e.firCount, t.nacksCount = e.nackCount, t.plisCount = e.pliCount, t.framesDecodeCount = e.framesDecoded, t.framesDroppedCount = e.framesDropped, t.totalInterFrameDelay = e.totalInterFrameDelay, t.totalSquaredInterFrameDelay = e.totalSquaredInterFrameDelay, t.totalFreezesDuration = e.totalFreezesDuration;\n      const i = this.lastDecodeVideoReceiverStats.get(t.ssrc),\n        n = this.lastVideoFramesDecode.get(t.ssrc),\n        r = this.lastVideoFramesOutput.get(t.ssrc),\n        o = Date.now();\n      if (t.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t.ssrc]) {\n        const e = t.decodedFrame ? t.decodedFrame.width : 0,\n          i = t.decodedFrame ? t.decodedFrame.height : 0;\n        this.onFirstVideoDecoded && this.onFirstVideoDecoded(t.ssrc, e, i), this.isFirstVideoDecoded[t.ssrc] = !0;\n      }\n      if (i) {\n        const n = i.stats,\n          r = o - i.lts;\n        t.framesDecodeFreezeTime = n.framesDecodeFreezeTime, t.framesDecodeInterval = n.framesDecodeInterval, !this.isFirstVideoDecoded[t.ssrc] && r > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t.ssrc), this.isFirstVideoDecodedTimeout[t.ssrc] = !0), t.framesDecodeCount > n.framesDecodeCount && this.isFirstVideoDecoded[t.ssrc] ? (i.lts = Date.now(), t.framesDecodeInterval = r, t.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e.ssrc)) ? t.framesDecodeFreezeTime += t.framesDecodeInterval : this.setVideoIsReady2(parseInt(e.ssrc, 10), !0))) : t.framesDecodeCount < n.framesDecodeCount && (t.framesDecodeInterval = 0), e.framesDecoded && e.qpSum && (i.stats.framesDecodeCount > e.framesDecoded ? t.qpSumPerFrame = e.qpSum / e.framesDecoded : t.qpSumPerFrame = (e.qpSum - i.qpSum) / (e.framesDecoded - i.stats.framesDecodeCount));\n      }\n      n && o - n.lts >= 800 ? (t.decodeFrameRate = Math.round((t.framesDecodeCount - n.count) / ((o - n.lts) / 1e3)), this.lastVideoFramesDecode.set(t.ssrc, {\n        count: t.framesDecodeCount,\n        lts: o,\n        rate: t.decodeFrameRate\n      })) : n ? t.decodeFrameRate = n.rate : this.lastVideoFramesDecode.set(t.ssrc, {\n        count: t.framesDecodeCount,\n        lts: o,\n        rate: 0\n      }), t.framesDroppedCount && e.framesReceived && (r && o - r.lts >= 800 ? (t.outputFrameRate = Math.round((e.framesReceived - t.framesDroppedCount - r.count) / ((o - r.lts) / 1e3)), this.lastVideoFramesOutput.set(t.ssrc, {\n        count: e.framesReceived - t.framesDroppedCount,\n        lts: o,\n        rate: Math.max(t.outputFrameRate, 0)\n      })) : r ? t.outputFrameRate = r.rate : this.lastVideoFramesOutput.set(t.ssrc, {\n        count: e.framesReceived - t.framesDroppedCount,\n        lts: o,\n        rate: 0\n      })), e.totalDecodeTime && (t.decodeMs = 1e3 * e.totalDecodeTime), this.processVideoTrackReceiverStats(e, e.trackId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), e.framerateMean && (t.framesRateFirefox = e.framerateMean), t.packets > 0 && !this.isFirstVideoReceived[t.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t.ssrc), this.isFirstVideoReceived[t.ssrc] = !0), this.lastDecodeVideoReceiverStats.set(t.ssrc, {\n        stats: KB({}, t),\n        lts: i ? i.lts : Date.now(),\n        qpSum: e.qpSum\n      });\n    }\n    processVideoOutboundStats(e) {\n      let t = this._stats.videoSend.find(t => t.ssrc === e.ssrc);\n      t || (t = OB(MB), this._stats.videoSend.push(t));\n      const i = this.mediaBytesSent.get(e.ssrc);\n      if (i) i.add(e.bytesSent);else {\n        const t = new DB(10);\n        t.add(e.bytesSent), this.mediaBytesSent.set(e.ssrc, t);\n      }\n      if (void 0 !== e.retransmittedBytesSent) {\n        const t = this.mediaBytesRetransmit.get(e.ssrc);\n        if (t) t.add(e.retransmittedBytesSent);else {\n          const t = new DB(10);\n          t.add(e.retransmittedBytesSent), this.mediaBytesRetransmit.set(e.ssrc, t);\n        }\n      }\n      if (e.totalEncodedBytesTarget) {\n        const t = this.mediaBytesTargetEncode.get(e.ssrc);\n        if (t) t.add(e.totalEncodedBytesTarget);else {\n          const t = new DB(10);\n          t.add(e.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e.ssrc, t);\n        }\n      }\n      if (t.ssrc = e.ssrc, t.bytes = e.bytesSent, t.packets = e.packetsSent, t.firsCount = e.firCount, t.nacksCount = e.nackCount, t.plisCount = e.pliCount, t.frameCount = e.framesEncoded, t.adaptionChangeReason = e.qualityLimitationReason, t.scalabilityMode = e.scalabilityMode, e.totalEncodeTime && e.framesEncoded) {\n        const i = this.lastEncoderMs.get(e.ssrc);\n        if (!i || i.lastFrameCount > e.framesEncoded) t.avgEncodeMs = 1e3 * e.totalEncodeTime / e.framesEncoded;else {\n          const n = e.framesEncoded - i.lastFrameCount,\n            r = e.totalEncodeTime - i.lastEncoderTime;\n          t.avgEncodeMs = 1e3 * r / n;\n        }\n      }\n      if (e.framesEncoded && e.qpSum) {\n        const i = this.lastEncoderMs.get(e.ssrc);\n        !i || i.lastFrameCount > e.framesEncoded ? t.qpSumPerFrame = e.qpSum / e.framesEncoded : t.qpSumPerFrame = (e.qpSum - i.lastQpSum) / (e.framesEncoded - i.lastFrameCount);\n      }\n      if (this.lastEncoderMs.set(e.ssrc, {\n        lastFrameCount: e.framesEncoded,\n        lastEncoderTime: e.totalEncodeTime,\n        lastQpSum: e.qpSum,\n        lts: Date.now()\n      }), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), e.mediaSourceId && this.processVideoMediaSource(e.mediaSourceId, t), this.processVideoTrackSenderStats(e, e.trackId, t), e.remoteId) this.processRemoteInboundStats(e.remoteId, t);else {\n        const i = this.findRemoteStatsId(e.ssrc, _b.REMOTE_INBOUND);\n        i && this.processRemoteInboundStats(i, t);\n      }\n    }\n    processAudioOutboundStats(e) {\n      let t = this._stats.audioSend.find(t => t.ssrc === e.ssrc);\n      if (t || (t = OB(UB), this._stats.audioSend.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsSent, t.bytes = e.bytesSent, e.mediaSourceId && this.processAudioMediaSource(e.mediaSourceId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), this.processAudioTrackSenderStats(e, e.trackId, t), e.remoteId) this.processRemoteInboundStats(e.remoteId, t);else {\n        const i = this.findRemoteStatsId(e.ssrc, _b.REMOTE_INBOUND);\n        i && this.processRemoteInboundStats(i, t);\n      }\n    }\n    findRemoteStatsId(e, t) {\n      var i;\n      const n = Array.from(ub(i = this.report).call(i)).find(i => i.type === t && i.ssrc === e);\n      return n ? n.id : null;\n    }\n    processVideoMediaSource(e, t) {\n      const i = this.report.get(e);\n      i && i.width && i.height && i.framesPerSecond && (t.inputFrame = {\n        width: i.width,\n        height: i.height,\n        frameRate: i.framesPerSecond\n      });\n    }\n    processAudioMediaSource(e, t) {\n      const i = this.report.get(e);\n      i && (t.inputLevel = i.audioLevel);\n    }\n    processVideoTrackSenderStats(e, t, i) {\n      var n, r, o, s;\n      const a = t ? this.report.get(t) : void 0,\n        c = null !== (n = null == a ? void 0 : a.framesSent) && void 0 !== n ? n : e.framesSent;\n      if (\"number\" != typeof c) return;\n      let d = null !== (r = null == a ? void 0 : a.frameWidth) && void 0 !== r ? r : e.frameWidth,\n        l = null !== (o = null == a ? void 0 : a.frameHeight) && void 0 !== o ? o : e.frameHeight,\n        h = null !== (s = null == a ? void 0 : a.framesPerSecond) && void 0 !== s ? s : e.framesPerSecond;\n      if (\"number\" == typeof d && \"number\" == typeof l || (d = 0, l = 0), null == h) {\n        const e = Date.now(),\n          t = this.lastVideoFramesSent.get(i.ssrc);\n        t && e - t.lts >= 800 ? (h = Math.round((c - t.count) / ((e - t.lts) / 1e3)), this.lastVideoFramesSent.set(i.ssrc, {\n          count: c,\n          lts: e,\n          rate: h\n        })) : t ? h = t.rate : this.lastVideoFramesSent.set(i.ssrc, {\n          count: c,\n          lts: e,\n          rate: 0\n        });\n      }\n      i.sentFrame = {\n        width: d,\n        height: l,\n        frameRate: Math.max(0, h)\n      };\n    }\n    processVideoTrackReceiverStats(e, t, i) {\n      var n, r, o, s, a;\n      const c = t ? this.report.get(t) : void 0,\n        d = null !== (n = null == c ? void 0 : c.framesReceived) && void 0 !== n ? n : e.framesReceived,\n        l = null !== (r = null == c ? void 0 : c.frameWidth) && void 0 !== r ? r : e.frameWidth,\n        h = null !== (o = null == c ? void 0 : c.frameHeight) && void 0 !== o ? o : e.frameHeight,\n        u = null !== (s = null == c ? void 0 : c.jitterBufferDelay) && void 0 !== s ? s : e.jitterBufferDelay,\n        p = null !== (a = null == c ? void 0 : c.jitterBufferEmittedCount) && void 0 !== a ? a : e.jitterBufferEmittedCount;\n      if (\"number\" == typeof d) {\n        const e = this.lastVideoFramesRecv.get(i.ssrc),\n          t = Date.now();\n        i.framesReceivedCount = d;\n        let n = 0;\n        e && t - e.lts >= 800 ? (n = Math.round((d - e.count) / ((t - e.lts) / 1e3)), this.lastVideoFramesRecv.set(i.ssrc, {\n          count: d,\n          lts: t,\n          rate: n\n        })) : e ? n = e.rate : this.lastVideoFramesRecv.set(i.ssrc, {\n          count: d,\n          lts: t,\n          rate: 0\n        }), i.receivedFrame = {\n          width: l || 0,\n          height: h || 0,\n          frameRate: n || 0\n        }, i.decodedFrame = {\n          width: l || 0,\n          height: h || 0,\n          frameRate: i.decodeFrameRate || 0\n        }, i.outputFrame = {\n          width: l || 0,\n          height: h || 0,\n          frameRate: i.outputFrameRate || i.decodeFrameRate || 0\n        };\n      }\n      if (u && p) {\n        const e = this.lastVideoJBDelay.get(i.ssrc) || {\n          jitterBufferDelay: 0,\n          jitterBufferEmittedCount: 0,\n          jitterBufferMs: 0\n        };\n        let t = e.jitterBufferMs;\n        const n = p - e.jitterBufferEmittedCount;\n        n > 0 && (t = 1e3 * (u - e.jitterBufferDelay) / n), i.jitterBufferMs = t, i.currentDelayMs = Math.round(t), this.lastVideoJBDelay.set(i.ssrc, {\n          jitterBufferDelay: u,\n          jitterBufferEmittedCount: p,\n          jitterBufferMs: i.currentDelayMs\n        });\n      }\n    }\n    processAudioTrackSenderStats(e, t, i) {\n      var n, r, o, s;\n      const a = t ? this.report.get(t) : void 0,\n        c = null !== (n = null !== (r = null == a ? void 0 : a.echoReturnLoss) && void 0 !== r ? r : e.echoReturnLoss) && void 0 !== n ? n : 0,\n        d = null !== (o = null !== (s = null == a ? void 0 : a.echoReturnLossEnhancement) && void 0 !== s ? s : e.echoReturnLossEnhancement) && void 0 !== o ? o : 0;\n      i.aecReturnLoss = c, i.aecReturnLossEnhancement = d;\n    }\n    processAudioTrackReceiverStats(e, t, i) {\n      var n, r, o, s, a, c, d;\n      const l = t ? this.report.get(t) : void 0,\n        h = null !== (n = null == l ? void 0 : l.removedSamplesForAcceleration) && void 0 !== n ? n : e.removedSamplesForAcceleration,\n        u = null !== (r = null == l ? void 0 : l.totalSamplesReceived) && void 0 !== r ? r : e.totalSamplesReceived,\n        p = null !== (o = null == l ? void 0 : l.jitterBufferDelay) && void 0 !== o ? o : e.jitterBufferDelay,\n        _ = null !== (s = null == l ? void 0 : l.jitterBufferEmittedCount) && void 0 !== s ? s : e.jitterBufferEmittedCount,\n        E = null !== (a = null == l ? void 0 : l.audioLevel) && void 0 !== a ? a : null == e ? void 0 : e.audioLevel,\n        m = null !== (c = null == l ? void 0 : l.totalSamplesDuration) && void 0 !== c ? c : null == e ? void 0 : e.totalSamplesDuration,\n        f = null !== (d = null == l ? void 0 : l.concealedSamples) && void 0 !== d ? d : e.concealedSamples;\n      if (h && u && (i.accelerateRate = h / u), p && _) {\n        const e = this.lastAudioJBDelay.get(i.ssrc) || {\n          jitterBufferDelay: 0,\n          jitterBufferEmittedCount: 0,\n          jitterBufferMs: 0\n        };\n        let t = e.jitterBufferMs;\n        const n = _ - e.jitterBufferEmittedCount;\n        n > 0 && (t = 1e3 * (p - e.jitterBufferDelay) / n), i.jitterBufferMs = Math.round(t), this.lastAudioJBDelay.set(i.ssrc, {\n          jitterBufferDelay: p,\n          jitterBufferEmittedCount: _,\n          jitterBufferMs: i.jitterBufferMs\n        });\n      }\n      i.outputLevel = E;\n      let T = 1920;\n      m && u && (T = u / m / 50, i.receivedFrames = Math.round(u / T)), f && (i.droppedFrames = Math.round(f / T));\n    }\n    processRemoteInboundStats(e, t) {\n      const i = this.report.get(e);\n      i && (t.packetsLost = i.packetsLost, i.roundTripTime && (t.rttMs = 1e3 * i.roundTripTime), i.jitter && (t.jitterMs = 1e3 * i.jitter), i.timestamp && (t.timestamp = i.timestamp));\n    }\n    getCodecFromCodecStats(e) {\n      const t = this.report.get(e);\n      if (!t) return \"\";\n      const i = t.mimeType.match(/\\/(.*)$/);\n      return i && i[1] ? i[1] : \"\";\n    }\n    updateSendBitrate() {\n      let e = 0,\n        t = null,\n        i = null;\n      this.mediaBytesSent.forEach(t => {\n        e += t.diffMean();\n      }), this.mediaBytesRetransmit.forEach(e => {\n        t = null === t ? e.diffMean() : t + e.diffMean();\n      }), this.mediaBytesTargetEncode.forEach(e => {\n        i = null === i ? e.diffMean() : i + e.diffMean();\n      });\n      const n = null !== t ? e - t : e;\n      this._stats.bitrate = {\n        actualEncoded: 8 * n / (this.options.updateInterval / 1e3),\n        transmit: 8 * e / (this.options.updateInterval / 1e3)\n      }, null !== t && (this._stats.bitrate.retransmit = 8 * t / (this.options.updateInterval / 1e3)), null !== i && (this._stats.bitrate.targetEncoded = 8 * i / (this.options.updateInterval / 1e3));\n    }\n  }\n  class qB extends BB {\n    updateStats() {\n      return Gu.resolve();\n    }\n  }\n  function zB(e) {\n    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250,\n      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8,\n      n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500,\n      r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4;\n    const o = function () {\n      const e = navigator.userAgent.toLocaleLowerCase().match(/chrome\\/[\\d]*/i);\n      return e && e[0] ? Number(e[0].split(\"/\")[1]) : null;\n    }();\n    return o ? o < 76 ? new WB(e, {\n      updateInterval: t,\n      lossRateInterval: i,\n      freezeRateLimit: n,\n      firstVideoDecodedTimeout: r\n    }) : new YB(e, {\n      updateInterval: t,\n      lossRateInterval: i,\n      freezeRateLimit: n,\n      firstVideoDecodedTimeout: r\n    }) : function (e) {\n      return !!window.RTCStatsReport && e.getStats() instanceof Gu;\n    }(e) ? new YB(e, {\n      updateInterval: t,\n      lossRateInterval: i,\n      freezeRateLimit: n,\n      firstVideoDecodedTimeout: r\n    }) : new qB(e, {\n      updateInterval: t,\n      lossRateInterval: i,\n      freezeRateLimit: n,\n      firstVideoDecodedTimeout: r\n    });\n  }\n  function JB(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function XB(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? JB(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : JB(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function QB(e) {\n    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n      n = arguments.length > 3 ? arguments[3] : void 0;\n    const r = t.filterRTX,\n      o = t.filterVideoFec,\n      s = t.filterAudioFec,\n      a = t.filterAudioCodec,\n      c = t.filterVideoCodec,\n      d = i.useXR;\n    let l = [],\n      h = [],\n      u = [],\n      p = [],\n      _ = !1,\n      E = !1;\n    if (wB.parse(e).mediaDescriptions.forEach(e => {\n      n && n !== e.attributes.direction || (\"video\" !== e.media.mediaType || _ || (h = e.attributes.payloads, p = e.attributes.extmaps, _ = !0), \"audio\" !== e.media.mediaType || E || (l = e.attributes.payloads, u = e.attributes.extmaps, E = !0));\n    }), !p || 0 === h.length) throw new Error(\"Cannot get video capabilities from SDP.\");\n    if (!u || 0 === l.length) throw new Error(\"Cannot get audio capabilities from SDP.\");\n    if (h.forEach(e => {\n      var t;\n      null !== (t = e.rtpMap) && void 0 !== t && t.clockRate && (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate)), d && e.rtcpFeedbacks.push({\n        type: \"rrtr\"\n      });\n    }), l.forEach(e => {\n      var t;\n      null !== (t = e.rtpMap) && void 0 !== t && t.clockRate && (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate)), d && e.rtcpFeedbacks.push({\n        type: \"rrtr\"\n      });\n    }), r && (l = l.filter(e => {\n      var t;\n      return \"rtx\" !== (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase());\n    }), h = h.filter(e => {\n      var t;\n      return \"rtx\" !== (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase());\n    })), o && (h = h.filter(e => {\n      var t;\n      return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName) || \"\");\n    })), s && (l = l.filter(e => {\n      var t;\n      return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName) || \"\");\n    })), a && (null == a ? void 0 : a.length) > 0 && (l = l.filter(e => {\n      var t;\n      return Dn(a).call(a, (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\");\n    })), c && (null == c ? void 0 : c.length) > 0) {\n      const e = h.filter(e => {\n        var t;\n        return Dn(c).call(c, (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\");\n      });\n      h = e.concat(r ? [] : Ej(e, h));\n    }\n    const m = Dy(\"UNSUPPORTED_VIDEO_CODEC\");\n    return m && m.length > 0 && (h = h.filter(e => !(e.rtpMap && Dn(m).call(m, e.rtpMap.encodingName.toLowerCase())))), {\n      audioCodecs: l,\n      videoCodecs: h,\n      audioExtensions: u,\n      videoExtensions: p\n    };\n  }\n  function ZB(e) {\n    const t = wB.parse(e);\n    let i, n;\n    for (const e of t.mediaDescriptions) {\n      if (!i) {\n        const t = e.attributes.iceUfrag,\n          n = e.attributes.icePwd;\n        if (!t || !n) throw new Error(\"Cannot get iceUfrag or icePwd from SDP.\");\n        i = {\n          iceUfrag: t,\n          icePwd: n\n        };\n      }\n      if (!n) {\n        const t = e.attributes.fingerprints;\n        t.length > 0 && (n = {\n          fingerprints: t\n        });\n      }\n    }\n    if (!n && t.attributes.fingerprints.length > 0 && (n = {\n      fingerprints: t.attributes.fingerprints\n    }), !n || !i) throw new Error(\"Cannot get iceParameters or dtlsParameters from SDP.\");\n    return {\n      iceParameters: i,\n      dtlsParameters: n\n    };\n  }\n  function $B(e, t) {\n    const i = [],\n      n = e.attributes.ssrcGroups.filter(e => \"FID\" === e.semantic),\n      r = e.attributes.ssrcGroups.find(e => \"SIM\" === e.semantic),\n      o = e.attributes.ssrcs;\n    if (r) r.ssrcIds.forEach(e => {\n      var r;\n      const o = null === (r = n.find(t => t.ssrcIds[0] === e)) || void 0 === r ? void 0 : r.ssrcIds[1];\n      i.push({\n        ssrcId: e,\n        rtx: t ? o : void 0\n      });\n    });else if (n.length > 0) {\n      const e = n[0].ssrcIds[0],\n        r = n[0].ssrcIds[1];\n      i.push({\n        ssrcId: e,\n        rtx: t ? r : void 0\n      });\n    } else {\n      if (0 === o.length) throw new Error(\"No ssrcs found on local media description.\");\n      i.push({\n        ssrcId: o[0].ssrcId\n      });\n    }\n    return i;\n  }\n  function ej(e, t) {\n    const i = e.cname;\n    let n;\n    t && t.ip && \"number\" == typeof t.port ? (n = [{\n      foundation: \"udpcandidate\",\n      componentId: \"1\",\n      transport: \"udp\",\n      priority: \"2103266323\",\n      connectionAddress: t.ip,\n      port: t.port.toString(),\n      type: \"host\",\n      extension: {}\n    }], Qy.debug(\"Using remote candidate from AP \".concat(t.ip, \":\").concat(t.port)), t.ip6 && (n.push({\n      foundation: \"udpcandidate\",\n      componentId: \"1\",\n      transport: \"udp\",\n      priority: \"2103266323\",\n      connectionAddress: t.ip6,\n      port: t.port.toString(),\n      type: \"host\",\n      extension: {}\n    }), Qy.debug(\"Using IPV6 remote candidate from AP \".concat(t.ip6, \":\").concat(t.port)))) : n = e.iceParameters.candidates.map(e => ({\n      foundation: e.foundation,\n      componentId: \"1\",\n      transport: e.protocol,\n      priority: e.priority.toString(),\n      connectionAddress: e.ip,\n      port: e.port.toString(),\n      type: e.type,\n      extension: {}\n    }));\n    const r = {\n        fingerprints: e.dtlsParameters.fingerprints.map(e => ({\n          hashFunction: e.algorithm,\n          fingerprint: e.fingerprint\n        }))\n      },\n      o = {\n        iceUfrag: e.iceParameters.iceUfrag,\n        icePwd: e.iceParameters.icePwd\n      };\n    let s;\n    switch (e.dtlsParameters.role) {\n      case \"server\":\n        s = \"passive\";\n        break;\n      case \"client\":\n        s = \"active\";\n        break;\n      case \"auto\":\n        s = \"actpass\";\n    }\n    return {\n      dtlsParameters: r,\n      iceParameters: o,\n      candidates: n,\n      rtpCapabilities: hj(e.rtpCapabilities),\n      setup: s,\n      cname: i\n    };\n  }\n  function tj(e, t, i) {\n    const n = [],\n      r = [];\n    return e.forEach(e => {\n      let o = e.ssrcId,\n        s = e.rtx;\n      const a = ey(8, \"track-\"),\n        c = {\n          ssrcId: o,\n          attributes: XB({\n            label: a,\n            mslabel: i = i || ey(10, \"\"),\n            msid: \"\".concat(i, \" \").concat(a)\n          }, t && {\n            cname: t\n          })\n        };\n      if (n.push(c), void 0 !== s) {\n        const e = {\n          ssrcId: s,\n          attributes: XB({\n            label: a,\n            mslabel: i,\n            msid: \"\".concat(i, \" \").concat(a)\n          }, t && {\n            cname: t\n          })\n        };\n        n.push(e), r.push({\n          semantic: \"FID\",\n          ssrcIds: [o, s]\n        });\n      }\n    }), e.length > 1 && r.push({\n      semantic: \"SIM\",\n      ssrcIds: e.map(e => {\n        let t = e.ssrcId;\n        return t;\n      })\n    }), {\n      ssrcs: n,\n      ssrcGroups: r\n    };\n  }\n  function ij(e, t) {\n    t instanceof LV && e.attributes.payloads.forEach(e => {\n      var i;\n      const n = null === (i = e.rtpMap) || void 0 === i ? void 0 : i.encodingName.toLowerCase();\n      if (!n || -1 === [\"opus\", \"pcmu\", \"pcma\", \"g722\"].indexOf(n)) return;\n      e.fmtp || (e.fmtp = {\n        parameters: {}\n      }), e.fmtp.parameters.minptime = \"10\", e.fmtp.parameters.useinbandfec = \"1\";\n      const r = t._encoderConfig;\n      r && \"pcmu\" !== n && \"pcma\" !== n && \"g722\" !== n && (r.bitrate && !Pv() && (e.fmtp.parameters.maxaveragebitrate = \"\".concat(Math.floor(1e3 * r.bitrate))), r.sampleRate && (e.fmtp.parameters.maxplaybackrate = \"\".concat(r.sampleRate), e.fmtp.parameters[\"sprop-maxcapturerate\"] = \"\".concat(r.sampleRate)), r.stereo && (e.fmtp.parameters.stereo = \"1\", e.fmtp.parameters[\"sprop-stereo\"] = \"1\"));\n    });\n  }\n  function nj(e) {\n    const t = e.attributes.unrecognized.findIndex(e => \"x-google-flag\" === e.attField && \"conference\" === e.attValue);\n    -1 !== t && e.attributes.unrecognized.splice(t, 1);\n  }\n  function rj(e, t) {\n    var i;\n    if (!(t instanceof vF && t._encoderConfig && -1 === t._hints.indexOf(LU.SCREEN_TRACK))) return;\n    const n = t._encoderConfig;\n    _U().supportMinBitrate && n.bitrateMin && e.attributes.payloads.forEach(e => {\n      var t, i;\n      Dn(t = [\"h264\", \"h265\", \"vp8\", \"vp9\", \"av1\"]).call(t, (null === (i = e.rtpMap) || void 0 === i ? void 0 : i.encodingName.toLowerCase()) || \"\") && (e.fmtp || (e.fmtp = {\n        parameters: {}\n      }), e.fmtp.parameters[\"x-google-min-bitrate\"] = \"\".concat(n.bitrateMin));\n    }), _U().supportMinBitrate && !Dn(i = t._hints).call(i, LU.LOW_STREAM) && n.bitrateMax && e.attributes.payloads.forEach(e => {\n      var t, i;\n      Dn(t = [\"h264\", \"h265\", \"vp8\", \"vp9\", \"av1\"]).call(t, (null === (i = e.rtpMap) || void 0 === i ? void 0 : i.encodingName.toLowerCase()) || \"\") && (e.fmtp || (e.fmtp = {\n        parameters: {}\n      }), e.fmtp.parameters[\"x-google-start-bitrate\"] = \"\".concat(Dy(\"X_GOOGLE_START_BITRATE\") || Math.floor(n.bitrateMax)));\n    });\n  }\n  function oj(e) {\n    if (\"video\" !== e.media.mediaType) return;\n    const t = Iv();\n    if (t.name !== gv.SAFARI && t.os !== Sv.IOS) return;\n    const i = e.attributes.extmaps.findIndex(e => /video-orientation/g.test(e.extensionName));\n    -1 !== i && e.attributes.extmaps.splice(i, 1);\n  }\n  function sj(e, t, i) {\n    if (!t) return;\n    let n, r;\n    if (\"video\" === e.media.mediaType ? (n = i.videoExtensions, r = i.videoCodecs) : (n = i.audioExtensions, r = i.audioCodecs), !0 === t.twcc) {\n      const t = n.find(e => \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\" === e.extensionName);\n      if (t) {\n        e.attributes.extmaps.find(e => \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\" === e.extensionName) || e.attributes.extmaps.push({\n          entry: t.entry,\n          extensionName: \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\"\n        });\n        const i = function (e, t) {\n          return t.filter(t => !!e.find(e => e.payloadType === t.payloadType && !!e.rtcpFeedbacks.find(e => \"transport-cc\" === e.type)));\n        }(r, e.attributes.payloads);\n        i.forEach(e => {\n          e.rtcpFeedbacks.find(e => \"transport-cc\" === e.type) || e.rtcpFeedbacks.push({\n            type: \"transport-cc\"\n          });\n        });\n      }\n    } else if (!1 === t.twcc) {\n      const t = e.attributes.extmaps.findIndex(e => \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\" === e.extensionName);\n      -1 !== t && e.attributes.extmaps.splice(t, 1), e.attributes.payloads.forEach(e => {\n        const t = e.rtcpFeedbacks.findIndex(e => \"transport-cc\" === e.type);\n        -1 !== t && e.rtcpFeedbacks.splice(t, 1);\n      });\n    }\n    if (!0 === t.remb) {\n      const t = n.find(e => \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\" === e.extensionName);\n      if (t) {\n        e.attributes.extmaps.find(e => \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\" === e.extensionName) || e.attributes.extmaps.push({\n          entry: t.entry,\n          extensionName: \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\"\n        });\n        const i = function (e, t) {\n          return t.filter(t => !!e.find(e => e.payloadType === t.payloadType && !!e.rtcpFeedbacks.find(e => \"goog-remb\" === e.type)));\n        }(r, e.attributes.payloads);\n        i.forEach(e => {\n          e.rtcpFeedbacks.find(e => \"goog-remb\" === e.type) || e.rtcpFeedbacks.push({\n            type: \"goog-remb\"\n          });\n        });\n      }\n    } else if (!1 === t.remb) {\n      const t = e.attributes.extmaps.findIndex(e => \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\" === e.extensionName);\n      -1 !== t && e.attributes.extmaps.splice(t, 1), e.attributes.payloads.forEach(e => {\n        const t = e.rtcpFeedbacks.findIndex(e => \"goog-remb\" === e.type);\n        -1 !== t && e.rtcpFeedbacks.splice(t, 1);\n      });\n    }\n  }\n  function aj(e, t, i) {\n    if (Pv()) return;\n    if (\"video\" !== e.media.mediaType) return;\n    if (!(t instanceof vF)) return;\n    if (\"vp9\" !== i && \"vp8\" !== i) return;\n    if (\"vp8\" === i && !Dy(\"SIMULCAST\")) return;\n    if (void 0 === t._scalabilityMode || t._scalabilityMode.numSpatialLayers <= 1) return;\n    const n = \"vp8\" === i ? 2 : t._scalabilityMode.numSpatialLayers,\n      r = e.attributes.ssrcs[0],\n      o = e.attributes.ssrcGroups.find(e => \"FID\" === e.semantic && e.ssrcIds[0] === r.ssrcId),\n      s = {\n        semantic: \"SIM\",\n        ssrcIds: [r.ssrcId]\n      };\n    for (let t = 1; t < n; t++) e.attributes.ssrcs.push({\n      ssrcId: r.ssrcId + t,\n      attributes: GI(r.attributes)\n    }), s.ssrcIds.push(r.ssrcId + t), o && (e.attributes.ssrcs.push({\n      ssrcId: o.ssrcIds[1] + t,\n      attributes: GI(r.attributes)\n    }), e.attributes.ssrcGroups.push({\n      semantic: \"FID\",\n      ssrcIds: [r.ssrcId + t, o.ssrcIds[1] + t]\n    }));\n    e.attributes.ssrcGroups.unshift(s);\n  }\n  async function cj() {\n    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n      t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n    const i = new RTCPeerConnection();\n    i.addTransceiver(\"video\", {\n      direction: \"sendonly\"\n    }), i.addTransceiver(\"audio\", {\n      direction: \"sendonly\"\n    }), i.addTransceiver(\"video\", {\n      direction: \"recvonly\"\n    }), i.addTransceiver(\"audio\", {\n      direction: \"recvonly\"\n    });\n    const n = (await i.createOffer()).sdp,\n      _ref24 = function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n          t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n          i = arguments.length > 2 ? arguments[2] : void 0;\n        const n = QB(i, e, t, \"sendonly\"),\n          r = QB(i, e, t, \"recvonly\"),\n          o = {\n            audioCodecs: [],\n            audioExtensions: [],\n            videoCodecs: [],\n            videoExtensions: []\n          },\n          s = {\n            audioCodecs: [],\n            audioExtensions: [],\n            videoCodecs: [],\n            videoExtensions: []\n          },\n          a = {\n            audioCodecs: [],\n            audioExtensions: [],\n            videoCodecs: [],\n            videoExtensions: []\n          };\n        if (lj(n, r, \"videoExtensions\", o, s, a), lj(n, r, \"videoCodecs\", o, s, a), lj(n, r, \"audioExtensions\", o, s, a), lj(n, r, \"audioCodecs\", o, s, a), Dy(\"RAISE_H264_BASELINE_PRIORITY\")) {\n          const e = a.videoCodecs.findIndex(e => {\n            var t, i;\n            return \"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && \"42001f\" === (null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters[\"profile-level-id\"]);\n          });\n          if (-1 !== e) {\n            const t = a.videoCodecs.findIndex(e => {\n              var t;\n              return \"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase());\n            });\n            if (t < e) {\n              Qy.debug(\"raising H264 baseline profile priority\");\n              const i = a.videoCodecs[e];\n              a.videoCodecs.splice(e, 1), a.videoCodecs.splice(t, 0, i);\n            }\n            -1 !== t && (s.videoCodecs = s.videoCodecs.filter(e => {\n              var t, i;\n              return !(\"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && \"42001f\" !== (null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters[\"profile-level-id\"]));\n            })), -1 !== t && Dy(\"FILTER_SEND_H264_BASELINE\") && (o.videoCodecs = o.videoCodecs.filter(e => {\n              var t, i;\n              return !(\"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && \"42001f\" !== (null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters[\"profile-level-id\"]));\n            }));\n          }\n        }\n        return {\n          send: o,\n          recv: s,\n          sendrecv: a\n        };\n      }(e, t, n),\n      r = _ref24.send,\n      o = _ref24.recv,\n      s = _ref24.sendrecv;\n    try {\n      i.close();\n    } catch (e) {}\n    return {\n      send: r,\n      recv: o,\n      sendrecv: s\n    };\n  }\n  function dj() {\n    const e = {\n        audioCodecs: [],\n        videoCodecs: [],\n        audioExtensions: [],\n        videoExtensions: []\n      },\n      t = QB(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, \"recvonly\"),\n      i = {\n        audioCodecs: [],\n        audioExtensions: [],\n        videoCodecs: [],\n        videoExtensions: []\n      },\n      n = {\n        audioCodecs: [],\n        audioExtensions: [],\n        videoCodecs: [],\n        videoExtensions: []\n      },\n      r = {\n        audioCodecs: [],\n        audioExtensions: [],\n        videoCodecs: [],\n        videoExtensions: []\n      };\n    if (lj(e, t, \"videoExtensions\", i, n, r), lj(e, t, \"videoCodecs\", i, n, r), lj(e, t, \"audioExtensions\", i, n, r), lj(e, t, \"audioCodecs\", i, n, r), Dy(\"RAISE_H264_BASELINE_PRIORITY\")) {\n      const e = r.videoCodecs.findIndex(e => e.rtpMap && \"h264\" === e.rtpMap.encodingName.toLocaleLowerCase() && e.fmtp && \"42001f\" === e.fmtp.parameters[\"profile-level-id\"]);\n      if (-1 !== e) {\n        const t = r.videoCodecs.findIndex(e => e.rtpMap && \"h264\" === e.rtpMap.encodingName.toLocaleLowerCase());\n        if (t < e) {\n          Qy.debug(\"raising H264 baseline profile priority\");\n          const i = r.videoCodecs[e];\n          r.videoCodecs.splice(e, 1), r.videoCodecs.splice(t, 0, i);\n        }\n        -1 !== t && (n.videoCodecs = n.videoCodecs.filter(e => !(e.rtpMap && \"h264\" === e.rtpMap.encodingName.toLocaleLowerCase() && e.fmtp && \"42001f\" !== e.fmtp.parameters[\"profile-level-id\"])));\n      }\n    }\n    return {\n      send: i,\n      recv: n,\n      sendrecv: r\n    };\n  }\n  function lj(e, t, i, n, r, o) {\n    if (\"videoExtensions\" === i || \"audioExtensions\" === i) {\n      const s = [];\n      return e[i].forEach(e => {\n        t[i].some((t, i) => {\n          if (e.entry === t.entry && e.extensionName === t.extensionName) return s.push(i), !0;\n        }) ? o[i].push(e) : n[i].push(e);\n      }), void t[i].forEach((e, t) => {\n        -1 === s.indexOf(t) && r[i].push(e);\n      });\n    }\n    if (\"videoCodecs\" === i || \"audioCodecs\" === i) {\n      const s = [];\n      return e[i].forEach(e => {\n        t[i].some((t, i) => {\n          if (e.payloadType === t.payloadType && JSON.stringify(e) === JSON.stringify(t)) return s.push(i), !0;\n        }) ? o[i].push(e) : n[i].push(e);\n      }), void t[i].forEach((e, t) => {\n        -1 === s.indexOf(t) && r[i].push(e);\n      });\n    }\n  }\n  function hj(e) {\n    const t = e.send,\n      i = e.recv,\n      n = e.sendrecv;\n    if (!n) {\n      if (!t || !i) throw new Error(\"cannot merge rtp capabilities because one of send or recv is empty!\");\n      return {\n        send: t,\n        recv: i\n      };\n    }\n    let r, o;\n    return t ? (r = {\n      audioCodecs: [],\n      audioExtensions: [],\n      videoCodecs: [],\n      videoExtensions: []\n    }, r.audioCodecs = [...t.audioCodecs, ...n.audioCodecs], r.videoCodecs = [...t.videoCodecs, ...n.videoCodecs], r.audioExtensions = [...t.audioExtensions, ...n.audioExtensions], r.videoExtensions = [...t.videoExtensions, ...n.videoExtensions]) : r = n, i ? (o = {\n      audioCodecs: [],\n      audioExtensions: [],\n      videoCodecs: [],\n      videoExtensions: []\n    }, o.audioCodecs = [...i.audioCodecs, ...n.audioCodecs], o.videoCodecs = [...i.videoCodecs, ...n.videoCodecs], o.audioExtensions = [...i.audioExtensions, ...n.audioExtensions], o.videoExtensions = [...i.videoExtensions, ...n.videoExtensions]) : o = n, {\n      send: r,\n      recv: o\n    };\n  }\n  function uj(e) {\n    if (\"audio\" !== e.media.mediaType) return;\n    e.attributes.payloads.filter(e => {\n      var t;\n      return \"opus\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase());\n    }).forEach(e => {\n      e.fmtp || (e.fmtp = {\n        parameters: {}\n      }), e.fmtp.parameters.stereo = \"1\", e.fmtp.parameters[\"sprop-stereo\"] = \"1\";\n    });\n  }\n  function pj(e) {\n    e.mediaDescriptions.forEach(e => {\n      \"video\" !== e.media.mediaType && \"audio\" !== e.media.mediaType || e.attributes.payloads.forEach(e => {\n        -1 === e.rtcpFeedbacks.findIndex(e => \"rrtr\" === e.type) && e.rtcpFeedbacks.push({\n          type: \"rrtr\"\n        });\n      });\n    });\n  }\n  function _j(e, t, i, n) {\n    let r = [];\n    if (e === nw.VIDEO) {\n      if (Dy(\"H264_PROFILE_LEVEL_ID\") && \"h264\" === n && (r = t.videoCodecs.filter(e => {\n        var t;\n        return Dn(t = e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").call(t, n) && e && e.fmtp && e.fmtp.parameters[\"profile-level-id\"] === Dy(\"H264_PROFILE_LEVEL_ID\");\n      })), !Array.isArray(r) || 0 === r.length) {\n        let e = [];\n        const o = [],\n          s = [],\n          a = [];\n        if (i.videoCodecs.forEach(t => {\n          const i = t.rtpMap && t.rtpMap.encodingName.toLowerCase() || \"\";\n          Dn(i).call(i, n) ? e.push(t) : Dn(i).call(i, \"vp9\") ? o.push(t) : Dn(i).call(i, \"vp8\") ? s.push(t) : Dn(i).call(i, \"h264\") && a.push(t);\n        }), 0 === e.length) {\n          let t = \"\";\n          0 !== o.length ? (e = o, t = \"vp9\") : 0 !== s.length ? (e = s, t = \"vp8\") : 0 !== a.length && (e = a, t = \"h264\"), Qy.warning(\"codec \".concat(n, \" not included in rtpCapabilities, fallback to default payloads: \").concat(t));\n        }\n        0 !== e.length && (r = t.videoCodecs.filter(t => e.some(e => e.payloadType === t.payloadType)));\n      }\n      if (0 === r.length && (Qy.warning(\"codec \".concat(n, \" not included in rtpCapabilities, fallback to default payloads: \").concat(t.videoCodecs[0].rtpMap && t.videoCodecs[0].rtpMap.encodingName)), r = t.videoCodecs), Dy(\"USE_PUB_RTX\") || Dy(\"USE_SUB_RTX\")) {\n        const e = Ej(r, t.videoCodecs);\n        r = [...r, ...e];\n      }\n    } else r = t.audioCodecs.filter(e => {\n      var t;\n      return Dn(t = e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").call(t, n);\n    }), 0 === r.length && (Qy.warning(\"codec \".concat(n, \" not included in rtpCapabilities, fallback to opus\")), r = t.audioCodecs.filter(e => {\n      var t;\n      return Dn(t = e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").call(t, \"opus\");\n    }));\n    return r;\n  }\n  function Ej(e, t) {\n    const i = e.map(e => e.payloadType.toString());\n    return t.filter(e => e.rtpMap && \"rtx\" === e.rtpMap.encodingName && e.fmtp && e.fmtp.parameters.apt && Dn(i).call(i, e.fmtp && e.fmtp.parameters.apt));\n  }\n  let mj = class {\n    get localCapabilities() {\n      return GI(this._localCapabilities);\n    }\n    get rtpCapabilities() {\n      return GI(this._rtpCapabilities);\n    }\n    get candidates() {\n      return GI(this._candidates);\n    }\n    get iceParameters() {\n      return GI(this._iceParameters);\n    }\n    get dtlsParameters() {\n      return GI(this._dtlsParameters);\n    }\n    constructor(e) {\n      ng(this, \"sessionDesc\", void 0), ng(this, \"_localCapabilities\", void 0), ng(this, \"_rtpCapabilities\", void 0), ng(this, \"_candidates\", void 0), ng(this, \"_iceParameters\", void 0), ng(this, \"_dtlsParameters\", void 0), ng(this, \"setup\", void 0), ng(this, \"currentMidIndex\", void 0), ng(this, \"cname\", \"o/i14u9pJrxRKAsu\"), ng(this, \"firefoxSsrcMidMap\", new Map()), e = GI(e);\n      const _e15 = e,\n        t = _e15.remoteIceParameters,\n        i = _e15.remoteDtlsParameters,\n        n = _e15.candidates,\n        r = _e15.remoteRTPCapabilities,\n        o = _e15.localCapabilities,\n        s = _e15.direction,\n        a = _e15.setup,\n        c = _e15.videoCodec,\n        d = _e15.audioCodec;\n      let l;\n      this.setup = a, l = s === yb.RECEIVE_ONLY ? wB.parse(\"v=0\\no=- 0 0 IN IP4 127.0.0.1\\ns=AgoraGateway\\nt=0 0\\na=group:BUNDLE 0 1\\na=msid-semantic: WMS\\na=extmap-allow-mixed\\nm=video 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=sendonly\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:0\\nm=audio 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=sendonly\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:1\\n\") : wB.parse(\"v=0\\no=- 0 0 IN IP4 127.0.0.1\\ns=AgoraGateway\\nt=0 0\\na=group:BUNDLE 0 1\\na=msid-semantic: WMS\\na=extmap-allow-mixed\\nm=video 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=recvonly\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:0\\nm=audio 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=recvonly\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:1\\n\"), this._rtpCapabilities = r, this._candidates = n, this._iceParameters = t, this._dtlsParameters = i, this._localCapabilities = o;\n      const h = s === yb.RECEIVE_ONLY ? this.rtpCapabilities.send : this.rtpCapabilities.recv,\n        u = s === yb.RECEIVE_ONLY ? this._localCapabilities.recv : this._localCapabilities.send,\n        p = s === yb.RECEIVE_ONLY ? r.send.videoCodecs : _j(nw.VIDEO, h, u, c),\n        _ = s === yb.RECEIVE_ONLY ? r.send.audioCodecs : _j(nw.AUDIO, h, u, d);\n      for (const e of l.mediaDescriptions) e.attributes.iceUfrag = t.iceUfrag, e.attributes.icePwd = t.icePwd, e.attributes.fingerprints = i.fingerprints, e.attributes.candidates = n, e.attributes.setup = this.setup, \"application\" === e.media.mediaType && (e.attributes.sctpPort = \"5000\"), \"video\" === e.media.mediaType && (e.media.fmts = p.map(e => e.payloadType.toString(10)), e.attributes.payloads = p, e.attributes.extmaps = h.videoExtensions), \"audio\" === e.media.mediaType && (e.media.fmts = _.map(e => e.payloadType.toString(10)), e.attributes.payloads = _, e.attributes.extmaps = h.audioExtensions, uj(e));\n      this.sessionDesc = l, this.currentMidIndex = l.mediaDescriptions.length - 1;\n    }\n    toString() {\n      return wB.print(this.sessionDesc);\n    }\n    hasMid(e) {\n      return Array.isArray(e) ? e.every(e => this.hasMid(e)) : this.sessionDesc.mediaDescriptions.some(t => t.attributes.mid === e);\n    }\n    send(e, t, i, n, r) {\n      i = i.replace(/ /g, \"-\");\n      const _tj = tj(t, this.cname, Dy(\"SYNC_GROUP\") ? i : void 0),\n        o = _tj.ssrcs,\n        s = _tj.ssrcGroups,\n        a = this.findPreloadMediaDesc(o);\n      if (a) {\n        if (Pv() && this.firefoxSsrcMidMap.set(o[0].ssrcId, a.attributes.mid), r && (r.twcc || r.remb)) {\n          const e = this.sessionDesc.mediaDescriptions.indexOf(a);\n          return this.sessionDesc.mediaDescriptions[e] = this.mungSendMediaDesc(a, r), {\n            mid: a.attributes.mid,\n            needExchangeSDP: !0\n          };\n        }\n        return {\n          mid: a.attributes.mid,\n          needExchangeSDP: !1\n        };\n      }\n      {\n        const t = this.findAvailableMediaIndex(e, o, n);\n        let i;\n        return -1 === t ? (i = this.createOrRecycleSendMedia(e, o, s, \"sendonly\", n, r), this.updateBundleMids()) : (i = GI(this.sessionDesc.mediaDescriptions[t]), i.attributes.direction = \"sendonly\", i.attributes.ssrcs = o, i.attributes.ssrcGroups = s, this.sessionDesc.mediaDescriptions[t] = this.mungSendMediaDesc(i, r)), Pv() && this.firefoxSsrcMidMap.set(o[0].ssrcId, i.attributes.mid), {\n          needExchangeSDP: !0,\n          mid: i.attributes.mid\n        };\n      }\n    }\n    stopSending(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => t.attributes.mid && -1 !== e.indexOf(t.attributes.mid));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.\");\n      t.forEach(e => {\n        e.attributes.ssrcs = [];\n      }), this.updateBundleMids();\n    }\n    receive(e, t, i) {\n      const n = [];\n      return e.forEach(e => {\n        const r = e._mediaStreamTrack.kind,\n          o = this.findAvailableRecvMediaIndex(r);\n        let s,\n          a = !1;\n        -1 === o ? (a = !0, s = this.createOrRecycleRecvMedia(e, [], \"recvonly\", t, i), this.updateBundleMids()) : (s = GI(this.sessionDesc.mediaDescriptions[o]), s.attributes.direction = \"recvonly\"), n.push({\n          mid: s.attributes.mid,\n          needCreateTransceiver: a\n        });\n      }), n;\n    }\n    stopReceiving(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => -1 !== e.indexOf(t.attributes.mid));\n      if (t.length !== e.length) throw new Error(\"MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.\");\n      t.forEach(e => {\n        e.media.port = \"0\", e.attributes.direction = \"inactive\";\n      }), this.updateBundleMids();\n    }\n    addRemoteCandidate(e) {\n      const _RTCIceCandidate = new RTCIceCandidate(e),\n        t = _RTCIceCandidate.foundation,\n        i = _RTCIceCandidate.protocol,\n        n = _RTCIceCandidate.address,\n        r = _RTCIceCandidate.port,\n        o = _RTCIceCandidate.type,\n        s = _RTCIceCandidate.relatedAddress,\n        a = _RTCIceCandidate.relatedPort,\n        c = _RTCIceCandidate.priority,\n        d = {\n          foundation: null != t ? t : \"\",\n          componentId: \"1\",\n          transport: null != i ? i : \"\",\n          priority: c ? c + \"\" : \"\",\n          connectionAddress: null != n ? n : \"\",\n          port: r ? r + \"\" : \"\",\n          type: o ? o + \"\" : \"\",\n          relAddr: null != s ? s : \"\",\n          relPort: a ? a + \"\" : \"\",\n          extension: {}\n        };\n      this.candidates.some(e => e.priority === d.priority && e.connectionAddress === d.connectionAddress && e.port === d.port) || (this._candidates.push(d), this.sessionDesc.mediaDescriptions.forEach(e => {\n        e.attributes.candidates = this.candidates;\n      }));\n    }\n    clearRemoteCandidate() {\n      this._candidates = [], this.sessionDesc.mediaDescriptions[0].attributes.candidates = this._candidates;\n    }\n    createOrRecycleRecvMedia(e, t, i, n, r) {\n      const o = e._mediaStreamTrack.kind,\n        s = this.rtpCapabilities.recv,\n        a = _j(o, s, this.localCapabilities.send, o === nw.AUDIO ? r : n),\n        c = o === nw.VIDEO ? s.videoExtensions : s.audioExtensions,\n        d = \"\".concat(++this.currentMidIndex);\n      let l = {\n        media: {\n          mediaType: o,\n          port: \"9\",\n          protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n          fmts: a.map(e => e.payloadType.toString(10))\n        },\n        connections: [{\n          nettype: \"IN\",\n          addrtype: \"IP4\",\n          address: \"127.0.0.1\"\n        }],\n        bandwidths: [],\n        attributes: {\n          iceUfrag: this.iceParameters.iceUfrag,\n          icePwd: this.iceParameters.icePwd,\n          unrecognized: [],\n          candidates: [],\n          extmaps: c,\n          fingerprints: this.dtlsParameters.fingerprints,\n          imageattr: [],\n          msids: [],\n          remoteCandidatesList: [],\n          rids: [],\n          ssrcs: t,\n          ssrcGroups: [],\n          rtcpFeedbackWildcards: [],\n          payloads: a,\n          rtcp: {\n            port: \"9\",\n            netType: \"IN\",\n            addressType: \"IP4\",\n            address: \"0.0.0.0\"\n          },\n          setup: this.setup,\n          direction: i,\n          rtcpMux: !0,\n          rtcpRsize: !0,\n          mid: \"\".concat(d)\n        }\n      };\n      l = this.mungRecvMediaDsec(l, e);\n      const h = this.findFirstClosedMedia(o);\n      if (h) {\n        const e = this.sessionDesc.mediaDescriptions.indexOf(h);\n        this.sessionDesc.mediaDescriptions[e] = l;\n      } else this.sessionDesc.mediaDescriptions.push(l);\n      return l;\n    }\n    muteRemote(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => Dn(e).call(e, t.attributes.mid || \"\"));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.\");\n      t.forEach(e => {\n        e.attributes.direction = \"inactive\";\n      });\n    }\n    unmuteRemote(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => Dn(e).call(e, t.attributes.mid || \"\"));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.\");\n      t.forEach(e => {\n        e.attributes.direction = \"recvonly\";\n      });\n    }\n    findAvailableMediaIndex(e, t, i) {\n      return this.sessionDesc.mediaDescriptions.findIndex(n => {\n        const r = n.media.mediaType === e && \"0\" !== n.media.port && (\"sendonly\" === n.attributes.direction || \"sendrecv\" === n.attributes.direction) && 0 === n.attributes.ssrcs.length;\n        if (Pv()) {\n          if (r) {\n            const e = this.firefoxSsrcMidMap.get(t[0].ssrcId);\n            return !(e || \"0\" !== n.attributes.mid && \"1\" !== n.attributes.mid) || !(!e || e !== n.attributes.mid);\n          }\n          return !1;\n        }\n        return r && n.attributes.mid === i;\n      });\n    }\n    findAvailableRecvMediaIndex(e) {\n      return this.sessionDesc.mediaDescriptions.findIndex(t => {\n        const i = t.media.mediaType === e && \"0\" !== t.media.port && (\"recvonly\" === t.attributes.direction || \"sendrecv\" === t.attributes.direction);\n        return \"0\" !== t.attributes.mid && \"1\" !== t.attributes.mid && i;\n      });\n    }\n    predictReceivingMids(e) {\n      const t = [];\n      for (let i = 0; i < e; i++) t.push((this.currentMidIndex + i + 1).toString(10));\n      return t;\n    }\n    restartICE(e) {\n      e = GI(e), this._iceParameters = e, this.sessionDesc.mediaDescriptions.forEach(t => {\n        t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd;\n      });\n    }\n    createOrRecycleSendMedia(e, t, i, n, r, o) {\n      const s = this.rtpCapabilities.send,\n        a = e === nw.VIDEO ? s.videoCodecs : s.audioCodecs,\n        c = e === nw.VIDEO ? s.videoExtensions : s.audioExtensions;\n      Pv() && (r = \"\".concat(++this.currentMidIndex));\n      let d = {\n        media: {\n          mediaType: e,\n          port: \"9\",\n          protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n          fmts: a.map(e => e.payloadType.toString(10))\n        },\n        connections: [{\n          nettype: \"IN\",\n          addrtype: \"IP4\",\n          address: \"127.0.0.1\"\n        }],\n        bandwidths: [],\n        attributes: {\n          iceUfrag: this.iceParameters.iceUfrag,\n          icePwd: this.iceParameters.icePwd,\n          unrecognized: [],\n          candidates: [],\n          extmaps: c,\n          fingerprints: this.dtlsParameters.fingerprints,\n          imageattr: [],\n          msids: [],\n          remoteCandidatesList: [],\n          rids: [],\n          ssrcs: t,\n          ssrcGroups: i,\n          rtcpFeedbackWildcards: [],\n          payloads: a,\n          rtcp: {\n            port: \"9\",\n            netType: \"IN\",\n            addressType: \"IP4\",\n            address: \"0.0.0.0\"\n          },\n          setup: this.setup,\n          direction: n,\n          rtcpMux: !0,\n          rtcpRsize: !0,\n          mid: r\n        }\n      };\n      d = this.mungSendMediaDesc(d, o);\n      const l = this.findFirstClosedMedia(e);\n      if (l) {\n        const e = this.sessionDesc.mediaDescriptions.indexOf(l);\n        this.sessionDesc.mediaDescriptions[e] = d;\n      } else this.sessionDesc.mediaDescriptions.push(d);\n      return d;\n    }\n    mungRecvMediaDsec(e, t, i) {\n      const n = GI(e);\n      return nj(n), ij(n, t), rj(n, t), oj(n), sj(n, i, this.localCapabilities.send), n;\n    }\n    mungSendMediaDesc(e, t) {\n      const i = GI(e);\n      return sj(i, t, this.localCapabilities.recv), uj(i), i;\n    }\n    updateRecvMedia(e, t) {\n      const i = this.sessionDesc.mediaDescriptions.findIndex(t => t.attributes.mid === e);\n      if (-1 !== i) {\n        const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i], t);\n        this.sessionDesc.mediaDescriptions[i] = e;\n      }\n    }\n    updateBundleMids() {\n      this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter(e => \"0\" !== e.media.port).map(e => e.attributes.mid);\n    }\n    findPreloadMediaDesc(e) {\n      return this.sessionDesc.mediaDescriptions.find(t => {\n        var i;\n        return (null === (i = t.attributes) || void 0 === i || null === (i = i.ssrcs[0]) || void 0 === i ? void 0 : i.ssrcId) === e[0].ssrcId;\n      });\n    }\n    findFirstClosedMedia(e) {\n      return this.sessionDesc.mediaDescriptions.find(t => Pv() ? \"0\" === t.media.port && t.media.mediaType === e : \"0\" === t.media.port);\n    }\n  };\n  const fj = [\"sdp\"];\n  var Tj;\n  function Sj(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function gj(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? Sj(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Sj(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let Rj = (Tj = class e extends tw {\n    get currentLocalDescription() {\n      return this.peerConnection.currentLocalDescription;\n    }\n    get currentRemoteDescription() {\n      return this.peerConnection.currentRemoteDescription;\n    }\n    get peerConnectionState() {\n      return this.peerConnection.connectionState;\n    }\n    get iceConnectionState() {\n      return this.peerConnection.iceConnectionState;\n    }\n    get dtlsTransportState() {\n      var e, t;\n      return null !== (e = null === (t = this.peerConnection.getReceivers()[0]) || void 0 === t || null === (t = t.transport) || void 0 === t ? void 0 : t.state) && void 0 !== e ? e : null;\n    }\n    get localCodecs() {\n      return [];\n    }\n    set isInRestartIce(e) {\n      this._isInRestartIce = e;\n    }\n    get isInRestartIce() {\n      return this._isInRestartIce;\n    }\n    constructor(t, i, n) {\n      super(t, i), ng(this, \"direction\", void 0), ng(this, \"name\", void 0), ng(this, \"store\", void 0), ng(this, \"spec\", void 0), ng(this, \"peerConnection\", void 0), ng(this, \"initialOffer\", void 0), ng(this, \"transport\", void 0), ng(this, \"statsFilter\", void 0), ng(this, \"localCandidateCount\", 0), ng(this, \"_isInRestartIce\", !1), ng(this, \"mutex\", new uy(\"P2PConnection-mutex\")), ng(this, \"onLocalCandidate\", void 0), ng(this, \"remoteSDP\", void 0), ng(this, \"pendingCandidates\", []), ng(this, \"localCapabilities\", void 0), ng(this, \"isReady\", !1), ng(this, \"restartCnt\", 0), ng(this, \"curTurnServerIndex\", 0), this.store = i, this.spec = t, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t, i.p2pTransport), {\n        optional: [{\n          googDscp: !0\n        }]\n      }), this.direction = null != n ? n : yb.SEND_ONLY, this.name = this.direction === yb.SEND_ONLY ? \"sendP2PConnection\" : \"recvP2PConnection\", this.statsFilter = zB(this.peerConnection, Dy(\"STATS_UPDATE_INTERVAL\"), void 0, Pv() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;\n    }\n    async establish(e) {\n      try {\n        const t = await cj();\n        if (this.localCapabilities = hj(t), e) {\n          const t = e.sdp,\n            i = AB(e, fj),\n            n = function () {\n              const e = {\n                  audioCodecs: [],\n                  videoCodecs: [],\n                  audioExtensions: [],\n                  videoExtensions: []\n                },\n                t = QB(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, \"sendonly\"),\n                i = {\n                  audioCodecs: [],\n                  audioExtensions: [],\n                  videoCodecs: [],\n                  videoExtensions: []\n                },\n                n = {\n                  audioCodecs: [],\n                  audioExtensions: [],\n                  videoCodecs: [],\n                  videoExtensions: []\n                },\n                r = {\n                  audioCodecs: [],\n                  audioExtensions: [],\n                  videoCodecs: [],\n                  videoExtensions: []\n                };\n              if (lj(t, e, \"videoExtensions\", i, n, r), lj(t, e, \"videoCodecs\", i, n, r), lj(t, e, \"audioExtensions\", i, n, r), lj(t, e, \"audioCodecs\", i, n, r), Dy(\"RAISE_H264_BASELINE_PRIORITY\")) {\n                const e = r.videoCodecs.findIndex(e => e.rtpMap && \"h264\" === e.rtpMap.encodingName.toLocaleLowerCase() && e.fmtp && \"42001f\" === e.fmtp.parameters[\"profile-level-id\"]);\n                if (-1 !== e) {\n                  const t = r.videoCodecs.findIndex(e => e.rtpMap && \"h264\" === e.rtpMap.encodingName.toLocaleLowerCase());\n                  if (t < e) {\n                    Qy.debug(\"raising H264 baseline profile priority\");\n                    const i = r.videoCodecs[e];\n                    r.videoCodecs.splice(e, 1), r.videoCodecs.splice(t, 0, i);\n                  }\n                  -1 !== t && Dy(\"FILTER_SEND_H264_BASELINE\") && (i.videoCodecs = i.videoCodecs.filter(e => !(e.rtpMap && \"h264\" === e.rtpMap.encodingName.toLocaleLowerCase() && e.fmtp && \"42001f\" !== e.fmtp.parameters[\"profile-level-id\"])));\n                }\n              }\n              return {\n                send: i,\n                recv: n,\n                sendrecv: r\n              };\n            }({}, {}, t);\n          this.remoteSDP = new mj({\n            remoteIceParameters: i.iceParameters,\n            remoteDtlsParameters: i.dtlsParameters,\n            candidates: [],\n            remoteRTPCapabilities: n,\n            localCapabilities: this.localCapabilities,\n            direction: this.direction,\n            setup: \"actpass\",\n            videoCodec: this.store.codec,\n            audioCodec: this.store.audioCodec\n          }), await this.setRemoteDescription({\n            type: \"offer\",\n            sdp: this.remoteSDP.toString()\n          }), this.isReady = !0;\n          const r = await this.peerConnection.createAnswer();\n          if (!r.sdp) throw new Error(\"Cannot get answer sdp when trying to establish PeerConnection.\");\n          const o = ZB(r.sdp);\n          await this.peerConnection.setLocalDescription(r);\n          const s = await dj({}, {}, r.sdp);\n          this.localCapabilities = hj(s);\n          const a = this.peerConnection.getTransceivers()[0];\n          return null != a && a.receiver && a.receiver.transport && this.tryBindTransportEvents(a.receiver.transport), gj(gj({}, o), {}, {\n            sdp: r.sdp\n          });\n        }\n        {\n          this.peerConnection.addTransceiver(\"video\", {\n            direction: \"sendonly\"\n          }), this.peerConnection.addTransceiver(\"audio\", {\n            direction: \"sendonly\"\n          });\n          const e = await this.peerConnection.createOffer();\n          if (!e.sdp) throw new Error(\"Cannot get initialOffer.sdp when trying to establish PeerConnection.\");\n          const t = ZB(e.sdp);\n          return this.initialOffer = e, gj(gj({}, t), {}, {\n            sdp: e.sdp\n          });\n        }\n      } catch (e) {\n        throw new iI(tI.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString());\n      }\n    }\n    async connect(e) {\n      try {\n        if (!this.initialOffer) throw new Error(\"Cannot establish P2PConnection without initial offer.\");\n        await this.peerConnection.setLocalDescription(this.initialOffer);\n        const t = e.sdp,\n          i = e.iceParameters,\n          n = e.dtlsParameters,\n          r = await dj({}, {}, t);\n        this.remoteSDP = new mj({\n          remoteIceParameters: i,\n          remoteDtlsParameters: n,\n          candidates: [],\n          remoteRTPCapabilities: r,\n          localCapabilities: this.localCapabilities,\n          direction: this.direction,\n          setup: \"active\",\n          videoCodec: this.store.codec,\n          audioCodec: this.store.audioCodec\n        }), await this.setRemoteDescription({\n          type: \"answer\",\n          sdp: this.remoteSDP.toString()\n        });\n        const o = this.peerConnection.getTransceivers()[0];\n        null != o && o.sender && o.sender.transport && this.tryBindTransportEvents(o.sender.transport);\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.connect failed; \".concat(e.toString()));\n      }\n    }\n    async addRemoteCandidate(e) {\n      try {\n        e && this.pendingCandidates.push(e), this.peerConnection.remoteDescription && this.isReady && (this.pendingCandidates.forEach(e => {\n          this.peerConnection.addIceCandidate(e);\n        }), this.pendingCandidates = []);\n      } catch (e) {\n        throw new iI(tI.ADD_CANDIDATE_FAILED, \"P2PConnection.addRemoteCandidate failed; \".concat(e.toString()));\n      }\n    }\n    send(e, t, i) {\n      var n = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var r, o, s, a, c, d, l, h, u, t, p, _;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return rB(n.mutex.lock(\"From P2PConnection.send\"));\n            case 2:\n              r = _context.sent;\n              _context.prev = 3;\n              if (n.remoteSDP) {\n                _context.next = 6;\n                break;\n              }\n              throw new Error(\"Cannot call P2PConnection.send before remote SDP created\");\n            case 6:\n              o = [], s = n.remoteSDP.receive(e, t, i);\n              e.forEach((e, t) => {\n                if (s[t].needCreateTransceiver) {\n                  const t = n.peerConnection.addTransceiver(e._mediaStreamTrack, {\n                    direction: \"sendonly\"\n                  });\n                  o.push(t), e._updateRtpTransceiver(t);\n                } else {\n                  const i = n.peerConnection.getTransceivers().find(e => e.mid === s[t].mid);\n                  if (!i) throw new Error(\"cannot find transceiver when sendPeerconnection send, mid is \".concat(s[t].mid));\n                  o.push(i), e._updateRtpTransceiver(i);\n                }\n              });\n              _context.t0 = Pv() && !0 === Dy(\"SIMULCAST\");\n              if (!_context.t0) {\n                _context.next = 12;\n                break;\n              }\n              _context.next = 12;\n              return rB(n.applySimulcastForFirefox(o, e));\n            case 12:\n              a = s.map(e => e.mid);\n              _context.next = 15;\n              return rB(n.peerConnection.createOffer());\n            case 15:\n              c = _context.sent;\n              d = n.mungSendOfferSDP(c.sdp, e, a);\n              l = wB.parse(d);\n              h = a.map(e => {\n                const t = l.mediaDescriptions.find(t => t.attributes.mid === e);\n                if (!t) throw new Error(\"Cannot extract ssrc from mediaDescription.\");\n                return $B(t, Dy(\"USE_PUB_RTX\"));\n              });\n              u = o.map((e, t) => {\n                const i = a[t];\n                return {\n                  localSSRC: h[t],\n                  id: i\n                };\n              });\n              _context.next = 22;\n              return rB(n.peerConnection.setLocalDescription({\n                type: \"offer\",\n                sdp: d\n              }));\n            case 22:\n              _context.prev = 22;\n              _context.next = 25;\n              return u;\n            case 25:\n              _context.next = 37;\n              break;\n            case 27:\n              _context.prev = 27;\n              _context.t1 = _context[\"catch\"](22);\n              t = n.remoteSDP.toString();\n              _context.next = 32;\n              return rB(n.peerConnection.setLocalDescription({\n                type: \"offer\",\n                sdp: d\n              }));\n            case 32:\n              _context.next = 34;\n              return rB(n.peerConnection.setRemoteDescription({\n                type: \"answer\",\n                sdp: t\n              }));\n            case 34:\n              _context.next = 36;\n              return rB(n.stopSending(a, !0));\n            case 36:\n              throw _context.t1;\n            case 37:\n              _context.next = 39;\n              return rB(n.applySimulcastEncodings(o, e));\n            case 39:\n              _context.next = 41;\n              return rB(n.applySendEncodings(o, e));\n            case 41:\n              p = n.remoteSDP.toString(), _ = n.logSDPExchange(d, \"offer\", \"local\", \"send\");\n              null == _ || _(p);\n              _context.next = 45;\n              return rB(n.setRemoteDescription({\n                type: \"answer\",\n                sdp: p\n              }));\n            case 45:\n              return _context.abrupt(\"return\", o.map((e, t) => {\n                const i = a[t];\n                return {\n                  localSSRC: h[t],\n                  id: i\n                };\n              }));\n            case 48:\n              _context.prev = 48;\n              _context.t2 = _context[\"catch\"](3);\n              throw _context.t2 instanceof iI ? _context.t2 : new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.send failed; \".concat(_context.t2.toString()));\n            case 51:\n              _context.prev = 51;\n              r();\n              return _context.finish(51);\n            case 54:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[3, 48, 51, 54], [22, 27]]);\n      }))();\n    }\n    async stopSending(e, t) {\n      const i = t ? void 0 : await this.mutex.lock(\"From P2PConnection.stopSending\");\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopSending before remote SDP created\");\n        const t = this.peerConnection.getTransceivers().filter(t => -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length (\".concat(t.length, \") doesn't match mids' length (\").concat(e.length, \") when trying to call P2PConnection.stopSending.\"));\n        t.map(e => {\n          var t;\n          e.direction = \"inactive\", null === (t = e.stop) || void 0 === t || t.call(e);\n        });\n        const n = await this.peerConnection.createOffer(),\n          r = this.logSDPExchange(n.sdp || \"\", \"offer\", \"local\", \"stopSending\");\n        await this.peerConnection.setLocalDescription(n), this.remoteSDP.stopReceiving(e);\n        const o = this.remoteSDP.toString();\n        null == r || r(o), await this.setRemoteDescription({\n          type: \"answer\",\n          sdp: o\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.stopSending failed; \".concat(e.toString()));\n      } finally {\n        i && i();\n      }\n    }\n    async receive(e, t, i, n) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.receive \".concat(e, \" before remoteSDP created.\"));\n        const _this$remoteSDP$send = this.remoteSDP.send(e, t, i, n),\n          r = _this$remoteSDP$send.mid,\n          o = _this$remoteSDP$send.needExchangeSDP;\n        if (o) {\n          const t = this.remoteSDP.toString(),\n            i = this.logSDPExchange(t, \"offer\", \"remote\", \"receive\");\n          await this.setRemoteDescription({\n            type: \"offer\",\n            sdp: t\n          });\n          const n = await this.peerConnection.createAnswer(),\n            o = this.mungReceiveAnswerSDP(n.sdp, r, e);\n          null == i || i(o || \"\"), await this.peerConnection.setLocalDescription({\n            type: \"answer\",\n            sdp: o\n          }), Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PConnection] receive \").concat(e, \" by exchanging SDP.\"));\n        } else Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PConnection] receive \").concat(e, \" no need to exchange SDP.\"));\n        const s = this.peerConnection.getTransceivers().find(e => e.mid === r);\n        if (!s || null === s.mid) throw new Error(\"Cannot get transceiver after setLocalDescription.\");\n        return {\n          track: s.receiver.track,\n          mid: s.mid,\n          transceiver: s\n        };\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async mockReceive(e, t, i, n) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.receive \".concat(e, \" before remoteSDP created.\"));\n        const _this$remoteSDP$send2 = this.remoteSDP.send(e, t, i, n),\n          r = _this$remoteSDP$send2.mid,\n          o = _this$remoteSDP$send2.needExchangeSDP;\n        if (o) {\n          const t = this.remoteSDP.toString(),\n            i = this.logSDPExchange(t, \"offer\", \"remote\", \"receive\");\n          await this.setRemoteDescription({\n            type: \"offer\",\n            sdp: t\n          });\n          const n = await this.peerConnection.createAnswer(),\n            o = this.mungReceiveAnswerSDP(n.sdp, r, e);\n          null == i || i(o || \"\"), await this.peerConnection.setLocalDescription({\n            type: \"answer\",\n            sdp: o\n          }), Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PConnection] receive \").concat(e, \" by exchanging SDP.\"));\n        } else Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PConnection] receive \").concat(e, \" no need to exchange SDP.\"));\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async stopReceiving(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopReceiving before remote SDP created.\");\n        this.remoteSDP.stopSending(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"stopReceiving\");\n        await this.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const n = await this.peerConnection.createAnswer();\n        null == i || i(n.sdp || \"\"), await this.peerConnection.setLocalDescription(n);\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection stopReceiving failed; \".concat(e.toString()));\n      }\n    }\n    async restartICE(t) {\n      try {\n        if (this.store.p2pTransport === Ay.Auto && (this.store.p2pTransport = Ay.SdRtn, _U().supportPCSetConfiguration && this.peerConnection.setConfiguration(e.resolvePCConfiguration(this.spec, this.store.p2pTransport))), this.restartCnt > 3 && (this.restartCnt = 0, _U().supportPCSetConfiguration && this.peerConnection.setConfiguration(e.resolvePCConfiguration(this.spec, this.store.p2pTransport, ++this.curTurnServerIndex))), !t) {\n          this.restartCnt++, this.isReady = !1;\n          const e = await this.peerConnection.createOffer({\n            iceRestart: !0\n          });\n          if (!e.sdp) throw new Error(\"Cannot restartICE because restart offer SDP does not exist.\");\n          const _ZB = ZB(e.sdp),\n            t = _ZB.iceParameters;\n          return this.store.descriptionStart(), this.direction === yb.SEND_ONLY && (await this.peerConnection.setLocalDescription(e)), t;\n        }\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopReceiving before remote SDP created.\");\n        if (this.remoteSDP.restartICE(t), this.store.descriptionStart(), this.direction === yb.RECEIVE_ONLY) {\n          this.restartCnt++, await this.setRemoteDescription({\n            type: \"offer\",\n            sdp: this.remoteSDP.toString()\n          });\n          const e = await this.peerConnection.createAnswer();\n          if (!e.sdp) throw new Error(\"Cannot get answer sdp when trying to iceRestart.\");\n          const _ZB2 = ZB(e.sdp),\n            t = _ZB2.iceParameters;\n          return await this.peerConnection.setLocalDescription(e), t;\n        }\n        await this.setRemoteDescription({\n          type: \"answer\",\n          sdp: this.remoteSDP.toString()\n        }), this.isReady = !0;\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection stopReceiving failed; \".concat(e.toString()));\n      }\n    }\n    close() {\n      var e;\n      this.peerConnection.close(), this.peerConnection.onicecandidate = null, null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, \"closed\"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.transport = void 0, this.statsFilter.destroy();\n    }\n    getStats() {\n      return this.statsFilter.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      return this.statsFilter.getVideoIsReady(e);\n    }\n    async updateEncoderConfig(e, t) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.updateEncoderConfig before remote SDP created.\");\n        const i = await this.peerConnection.createOffer(),\n          n = this.mungSendOfferSDP(i.sdp, [t], [e]);\n        this.remoteSDP.updateRecvMedia(e, t);\n        const r = this.remoteSDP.toString(),\n          o = this.logSDPExchange(n, \"offer\", \"local\", \"updateEncoderConfig\");\n        await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: n\n        }), null == o || o(r), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, e.toString());\n      }\n    }\n    async updateSendParameters(e, t) {\n      const i = this.peerConnection.getTransceivers().filter(t => t.mid === e);\n      1 === i.length && (this.isVP8Simulcast(t) ? Pv() || (await this.applySimulcastEncodings(i, [t])) : await this.applySendEncodings(i, [t]));\n    }\n    setStatsRemoteVideoIsReady(e, t) {\n      this.statsFilter.setVideoIsReady2(e, t);\n    }\n    async replaceTrack(e, t) {\n      const i = this.peerConnection.getTransceivers().find(e => e.mid === t);\n      i && (await i.sender.replaceTrack(e._mediaStreamTrack));\n    }\n    async getSelectedCandidatePair() {\n      const e = this.peerConnection.getReceivers();\n      if (e.length > 0 && e[0].transport && e[0].transport.iceTransport && e[0].transport.iceTransport.getSelectedCandidatePair && e[0].transport.iceTransport.getSelectedCandidatePair()) {\n        const t = e[0].transport.iceTransport,\n          _t$getSelectedCandida = t.getSelectedCandidatePair(),\n          i = _t$getSelectedCandida.local,\n          n = _t$getSelectedCandida.remote;\n        return {\n          local: gj(gj({}, PB), {}, {\n            candidateType: i.type,\n            protocol: i.protocol,\n            address: i.address,\n            port: i.port\n          }),\n          remote: gj(gj({}, PB), {}, {\n            candidateType: n.type,\n            protocol: n.protocol,\n            address: n.address,\n            port: n.port\n          })\n        };\n      }\n      return this.statsFilter.getSelectedCandidatePair();\n    }\n    bindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = () => {\n        var e, t;\n        Dn(e = [\"connected\", \"completed\"]).call(e, this.peerConnection.iceConnectionState) && (this.isReady = !1), null === (t = this.onICEConnectionStateChange) || void 0 === t || t.call(this, this.peerConnection.iceConnectionState);\n      }, this.peerConnection.onconnectionstatechange = () => {\n        var e;\n        \"connected\" === this.peerConnection.connectionState && (this.restartCnt = 0), null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState);\n      }, this.startICECandidate();\n    }\n    startICECandidate() {\n      this.peerConnection.onicecandidate || (this.localCandidateCount = 0, this.peerConnection.onicecandidate = e => {\n        if (e.candidate) {\n          var t;\n          if (e.candidate.candidate) null === (t = this.onLocalCandidate) || void 0 === t || t.call(this, e.candidate.toJSON());\n          this.localCandidateCount += 1;\n        } else Qy.debug(\"[\".concat(this.store.clientId, \"] [pc-\").concat(this.store.p2pId, \"] local candidate count\"), this.localCandidateCount);\n      });\n    }\n    unbindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;\n    }\n    static resolvePCConfiguration(t, i) {\n      let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;\n      const r = {\n        iceServers: []\n      };\n      var o;\n      t.iceServers ? r.iceServers = t.iceServers : t.turnServer && \"off\" !== t.turnServer.mode && (bI(t.turnServer.servers) ? r.iceServers = t.turnServer.servers : (r.iceServers && r.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers, i, n)), Dy(\"USE_TURN_SERVER_OF_GATEWAY\") && r.iceServers && t.turnServer.serversFromGateway && r.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway, i, n)), Dn(o = [Ay.Relay, Ay.SdRtn]).call(o, i) && (r.iceTransportPolicy = \"relay\"), Dy(\"FORCE_TURN_TCP\") ? r.iceTransportPolicy = \"relay\" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {\n        e.forceturn && (r.iceTransportPolicy = \"relay\");\n      })));\n      return Dy(\"ENABLE_ENCODED_TRANSFORM\") && _U().supportWebRTCEncodedTransform && (r.encodedInsertableStreams = !0), Qy.debug(\"P2PConnection p2pTransport is \".concat(i)), r;\n    }\n    static turnServerConfigToIceServers(e, t) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;\n      const n = [],\n        r = e.filter(e => e.tcpport);\n      Qy.debug(\"P2PConnection turnServers is \".concat(r, \", current index is \").concat(i));\n      const o = r.length > i ? r[i] : r[0];\n      switch (t) {\n        case Ay.SdRtn:\n          const t = e.filter(e => {\n              var t;\n              return Dn(t = e.username).call(t, \"glb:\") && e.turnServerURL == e.turnServerURL;\n            }),\n            r = t.length > i ? t[i] : t[0];\n          r && (n.push({\n            username: r.username,\n            credential: r.password,\n            credentialType: \"password\",\n            urls: \"turn:\".concat(Hw(r.turnServerURL), \":\").concat(r.tcpport, \"?transport=udp\")\n          }), n.push({\n            username: r.username,\n            credential: r.password,\n            credentialType: \"password\",\n            urls: \"turns:\".concat(Hw(r.turnServerURL), \":\").concat(r.tcpport, \"?transport=tcp\")\n          }));\n          break;\n        case Ay.Relay:\n          o && (n.push({\n            username: o.username,\n            credential: o.password,\n            credentialType: \"password\",\n            urls: \"turn:\".concat(o.turnServerURL, \":\").concat(o.tcpport, \"?transport=udp\")\n          }), n.push({\n            username: o.username,\n            credential: o.password,\n            credentialType: \"password\",\n            urls: \"turns:\".concat(Hw(o.turnServerURL), \":\").concat(o.tcpport, \"?transport=tcp\")\n          }));\n          break;\n        default:\n          o && (n.push({\n            username: o.username,\n            credential: o.password,\n            credentialType: \"password\",\n            urls: \"turn:\".concat(o.turnServerURL, \":\").concat(o.tcpport, \"?transport=udp\")\n          }), n.push({\n            username: o.username,\n            credential: o.password,\n            credentialType: \"password\",\n            urls: \"turns:\".concat(Hw(o.turnServerURL), \":\").concat(o.tcpport, \"?transport=tcp\")\n          }), n.push({\n            username: o.username,\n            credential: o.password,\n            credentialType: \"password\",\n            urls: \"stun:\".concat(o.turnServerURL, \":\").concat(o.tcpport)\n          }));\n      }\n      return n;\n    }\n    tryBindTransportEvents(e) {\n      if (e) {\n        this.transport = e, e.onstatechange = () => {\n          var t;\n          null != e && e.state && (null === (t = this.onDTLSTransportStateChange) || void 0 === t || t.call(this, e.state));\n        }, e.onerror = e => {\n          var t;\n          null === (t = this.onDTLSTransportError) || void 0 === t || t.call(this, \"error\" in e ? e.error : e);\n        };\n        const t = e.iceTransport;\n        t && (t.onstatechange = () => {\n          const t = null == e ? void 0 : e.iceTransport.state;\n          var i;\n          t && (null === (i = this.onICETransportStateChange) || void 0 === i || i.call(this, t));\n        }, t.getSelectedCandidatePair && (t.onselectedcandidatepairchange = () => {\n          if (t.getSelectedCandidatePair()) {\n            const _t$getSelectedCandida2 = t.getSelectedCandidatePair(),\n              e = _t$getSelectedCandida2.local,\n              i = _t$getSelectedCandida2.remote;\n            Qy.info(\"[\".concat(this.store.clientId, \"] [pc-\").concat(this.store.p2pId, \"] selectedcandidatepairchange: local \").concat(JSON.stringify({\n              candidateType: e.type,\n              protocol: e.protocol\n            }), \", remote \").concat(JSON.stringify({\n              candidateType: i.type,\n              protocol: i.protocol,\n              address: i.address,\n              port: i.port\n            }), \" )\"));\n          }\n        }));\n      }\n    }\n    tryUnbindTransportEvents() {\n      this.transport && (this.transport.onstatechange = null, this.transport.onerror = null, this.transport.iceTransport && (this.transport.iceTransport.onstatechange = null));\n    }\n    async updateRtpSenderEncodings(e, t) {\n      var i;\n      if (!t) {\n        t = this.peerConnection.getSenders().find(t => t.track === e._mediaStreamTrack);\n      }\n      if (!t) return Qy.warn(\"[\".concat(e.getTrackId(), \"] no rtpSender found}\"));\n      if (this.isVP8Simulcast(e)) return Qy.warn(\"[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings\");\n      if (!_U().supportSetRtpSenderParameters) return Qy.warn(\"[updateRtpSenderEncodings] Browser not support set rtp-sender parameters\");\n      const n = {},\n        r = {};\n      switch (e._optimizationMode) {\n        case \"motion\":\n          n.degradationPreference = \"maintain-framerate\";\n          break;\n        case \"detail\":\n          n.degradationPreference = \"maintain-resolution\";\n          break;\n        default:\n          n.degradationPreference = \"balanced\";\n      }\n      if (e._encoderConfig) {\n        var o;\n        const _e$_encoderConfig = e._encoderConfig,\n          t = _e$_encoderConfig.bitrateMax,\n          i = _e$_encoderConfig.frameRate,\n          n = _e$_encoderConfig.scaleResolutionDownBy;\n        t && (r.maxBitrate = 1e3 * t), Dn(o = e._hints).call(o, LU.LOW_STREAM) && (i && (r.maxFramerate = Yw(i)), n && n >= 1 && (r.scaleResolutionDownBy = n));\n      }\n      if (Dy(\"DSCP_TYPE\") && Jv()) {\n        var s;\n        const e = Dy(\"DSCP_TYPE\");\n        Dn(s = [\"very-low\", \"low\", \"medium\", \"high\"]).call(s, e) && (r.networkPriority = e);\n      }\n      const a = t.getParameters(),\n        c = null === (i = a.encodings) || void 0 === i ? void 0 : i[0];\n      Pv() && !c && (n.encodings = [r]), c && Object.assign(c, r), Object.assign(a, n), Qy.debug(\"[\".concat(e.getTrackId(), \"] updateRtpSenderEncodings: \").concat(JSON.stringify(a.encodings))), await t.setParameters(a);\n    }\n    async applySendEncodings(e, t) {\n      try {\n        if (!_U().supportSetRtpSenderParameters) return;\n        if (e.length !== t.length) return;\n        for (let i = 0; i < e.length; i++) {\n          const n = e[i],\n            r = t[i];\n          r instanceof vF && !this.isVP8Simulcast(r) && (await this.updateRtpSenderEncodings(r, n.sender));\n        }\n      } catch (e) {\n        Qy.debug(\"[\".concat(this.store.clientId, \"] Apply RTPSendEncodings failed.\"));\n      }\n    }\n    mungSendOfferSDP(e, t, i) {\n      const n = wB.parse(e);\n      return t.forEach((e, t) => {\n        const r = i[t],\n          o = n.mediaDescriptions.find(e => e.attributes.mid === r);\n        o && (ij(o, e), aj(o, e, this.store.codec));\n      }), wB.print(n);\n    }\n    bindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = e => {\n        var t;\n        null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoReceived = e => {\n        var t;\n        null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstAudioDecoded = e => {\n        var t;\n        null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoDecoded = (e, t, i) => {\n        var n;\n        null === (n = this.onFirstVideoDecoded) || void 0 === n || n.call(this, e, t, i);\n      }, this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedLocalCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedRemoteCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onFirstVideoDecodedTimeout = e => {\n        var t;\n        null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t || t.call(this, e);\n      };\n    }\n    unbindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;\n    }\n    async applySimulcastForFirefox(e, t) {\n      if (e.length === t.length) for (let a = 0; a < e.length; a++) {\n        var i, n, r, o, s;\n        const c = e[a],\n          d = t[a];\n        if (d instanceof vF && !Dn(i = d._hints).call(i, LU.LOW_STREAM) && null !== (n = d._encoderConfig) && void 0 !== n && n.bitrateMax && (null === (r = d._encoderConfig) || void 0 === r ? void 0 : r.bitrateMax) > 200 && null !== (o = d._scalabilityMode) && void 0 !== o && o.numSpatialLayers && (null === (s = d._scalabilityMode) || void 0 === s ? void 0 : s.numSpatialLayers) > 1 && \"vp8\" === this.store.codec) {\n          const e = {},\n            t = {\n              high: 1e3 * (d._encoderConfig.bitrateMax - 50),\n              medium: 5e4\n            };\n          e.encodings = [{\n            rid: \"m\",\n            active: !0,\n            maxBitrate: t.medium,\n            scaleResolutionDownBy: 4\n          }, {\n            rid: \"h\",\n            active: !0,\n            maxBitrate: t.high\n          }];\n          const i = c.sender.getParameters();\n          await c.sender.setParameters(Object.assign(i, e));\n        }\n      }\n    }\n    async applySimulcastEncodings(e, t) {\n      if (!Pv() && e.length === t.length) for (let i = 0; i < e.length; i++) {\n        const n = t[i];\n        if (n instanceof vF && this.isVP8Simulcast(n)) {\n          const t = e[i],\n            r = {},\n            o = {\n              high: 1e3 * (n._encoderConfig.bitrateMax - 50),\n              medium: 5e4\n            };\n          r.encodings = [{\n            active: !0,\n            adaptivePtime: !1,\n            networkPriority: \"high\",\n            priority: \"high\",\n            maxBitrate: o.high\n          }, {\n            active: !0,\n            adaptivePtime: !1,\n            networkPriority: \"low\",\n            priority: \"low\",\n            maxBitrate: o.medium,\n            scaleResolutionDownBy: 4\n          }];\n          const s = t.sender.getParameters();\n          await t.sender.setParameters(Object.assign(s, r));\n        }\n      }\n    }\n    isVP8Simulcast(e) {\n      var t, i, n, r, o;\n      return !!(e instanceof vF && Dy(\"SIMULCAST\") && \"vp8\" === this.store.codec && !Dn(t = e._hints).call(t, LU.LOW_STREAM) && null !== (i = e._encoderConfig) && void 0 !== i && i.bitrateMax && (null === (n = e._encoderConfig) || void 0 === n ? void 0 : n.bitrateMax) > 200 && null !== (r = e._scalabilityMode) && void 0 !== r && r.numSpatialLayers && (null === (o = e._scalabilityMode) || void 0 === o ? void 0 : o.numSpatialLayers) > 1);\n    }\n    logSDPExchange(e, t, i, n) {\n      if (Dy(\"SDP_LOGGING\")) return Qy.upload(\"[\".concat(this.store.clientId, \"] exchanging \").concat(i, \" \").concat(t, \" SDP during P2PConnection.\").concat(n, \"\\n\"), e), \"offer\" === t ? e => {\n        this.logSDPExchange(e, \"answer\", \"local\" === i ? \"remote\" : \"local\", n);\n      } : void 0;\n    }\n    async muteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.muteLocal before remote SDP created.\");\n        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length.\");\n        t.map(e => {\n          e.direction = \"inactive\";\n        });\n        const i = await this.peerConnection.createOffer(),\n          n = this.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"muteLocal\");\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.muteRemote(e);\n        const r = this.remoteSDP.toString();\n        null == n || n(r), await this.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.muteLocal failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.unmuteLocal before remote SDP created.\");\n        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length.\");\n        t.map(async e => {\n          e.direction = \"sendonly\";\n        });\n        const i = await this.peerConnection.createOffer(),\n          n = this.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"unmuteLocal\");\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.unmuteRemote(e);\n        const r = this.remoteSDP.toString();\n        null == n || n(r), await this.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.unmuteLocal failed; \".concat(e.toString()));\n      }\n    }\n    async getRemoteSSRC(e, t) {\n      var i, n;\n      if (t = null !== (i = t) && void 0 !== i ? i : null === (n = this.currentRemoteDescription) || void 0 === n ? void 0 : n.sdp) {\n        var r;\n        const i = null === (r = wB.parse(t).mediaDescriptions.find(t => t.attributes.mid === e)) || void 0 === r ? void 0 : r.attributes.ssrcs;\n        return null == i ? void 0 : i[0].ssrcId;\n      }\n    }\n    async setRemoteDescription(e) {\n      var t;\n      await this.peerConnection.setRemoteDescription(e), Dn(t = [\"connected\", \"completed\"]).call(t, this.peerConnection.iceConnectionState) || (this.isReady = !0, this.addRemoteCandidate());\n    }\n    mungReceiveAnswerSDP(e, t, i) {\n      const n = wB.parse(e),\n        r = n.mediaDescriptions.find(e => e.attributes.mid === t);\n      return r && i === nw.AUDIO && \"audio\" === r.media.mediaType && uj(r), wB.print(n);\n    }\n  }, nb(Tj.prototype, \"establish\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"establish\"), Tj.prototype), nb(Tj.prototype, \"connect\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"connect\"), Tj.prototype), nb(Tj.prototype, \"receive\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"receive\"), Tj.prototype), nb(Tj.prototype, \"mockReceive\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"mockReceive\"), Tj.prototype), nb(Tj.prototype, \"stopReceiving\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"stopReceiving\"), Tj.prototype), nb(Tj.prototype, \"restartICE\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"restartICE\"), Tj.prototype), nb(Tj.prototype, \"close\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"close\"), Tj.prototype), nb(Tj.prototype, \"updateEncoderConfig\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"updateEncoderConfig\"), Tj.prototype), nb(Tj.prototype, \"updateSendParameters\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"updateSendParameters\"), Tj.prototype), nb(Tj.prototype, \"replaceTrack\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"replaceTrack\"), Tj.prototype), nb(Tj.prototype, \"muteLocal\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"muteLocal\"), Tj.prototype), nb(Tj.prototype, \"unmuteLocal\", [Cj], Object.getOwnPropertyDescriptor(Tj.prototype, \"unmuteLocal\"), Tj.prototype), Tj);\n  function Cj(e, t, i) {\n    const n = e[t];\n    if (\"function\" != typeof n) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"From P2PConnection.\".concat(t));\n      try {\n        for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];\n        return await n.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  function vj(e, t) {\n    let i = document.createElement(\"video\"),\n      n = document.createElement(\"canvas\");\n    i.setAttribute(\"style\", \"display:none\"), n.setAttribute(\"style\", \"display:none\"), i.setAttribute(\"muted\", \"\"), i.muted = !0, i.setAttribute(\"autoplay\", \"\"), i.autoplay = !0, i.setAttribute(\"playsinline\", \"\"), n.width = Yw(t.width), n.height = Yw(t.height);\n    const r = Yw(t.framerate || 15);\n    document.body.append(i), document.body.append(n);\n    let o = e._mediaStreamTrack;\n    i.srcObject = new MediaStream([o]), i.play();\n    const s = n.getContext(\"2d\");\n    if (!s) throw new bb(tI.UNEXPECTED_ERROR, \"can not get canvas context\");\n    const a = _U(),\n      c = n.captureStream(a.supportRequestFrame ? 0 : r).getVideoTracks()[0];\n    c.canvas || (c.canvas = n), n.startCapture = () => {\n      if (!i) return n.stopCapture && n.stopCapture();\n      if (i.paused && i.play(), i.videoHeight > 2 && i.videoWidth > 2) {\n        const e = i.videoWidth,\n          t = i.videoHeight / e,\n          r = n.width * t;\n        Math.abs(r - n.height) >= 2 && (Qy.debug(\"adjust low stream resolution\", \"\".concat(n.width, \"x\").concat(n.height, \" -> \").concat(n.width, \"x\").concat(r)), n.height = r);\n      }\n      s.drawImage(i, 0, 0, n.width, n.height), c.requestFrame && c.requestFrame(), o !== e._mediaStreamTrack && (o = e._mediaStreamTrack, i.srcObject = new MediaStream([o]));\n    }, n.stopCapture = ux(() => n.startCapture && n.startCapture(), r);\n    const d = c.stop;\n    return c.stop = () => {\n      d.call(c), i && (i.remove(), i.srcObject = null, i = null), n && (n.width = 0, n.remove(), n.stopCapture && n.stopCapture(), n.startCapture = void 0, n.stopCapture = void 0, n = null), Qy.debug(\"clean low stream renderer\");\n    }, c;\n  }\n  var Ij = function (e) {\n      return e[e.HEIGHT = 2033] = \"HEIGHT\", e[e.FRAME_RATE = 2034] = \"FRAME_RATE\", e[e.WIDTH = 2035] = \"WIDTH\", e;\n    }(Ij || {}),\n    yj = function (e) {\n      return e[e.FRAME_RATE = 2002] = \"FRAME_RATE\", e[e.WIDTH = 2003] = \"WIDTH\", e[e.HEIGHT = 2004] = \"HEIGHT\", e[e.PACKAGE_LOST = 2005] = \"PACKAGE_LOST\", e[e.AVG_ENCODE = 2007] = \"AVG_ENCODE\", e[e.NACKS = 2009] = \"NACKS\", e[e.PLIS = 2010] = \"PLIS\", e[e.FIRS = 2011] = \"FIRS\", e[e.BITRATE = 2012] = \"BITRATE\", e[e.PACKAGE_RATE = 2031] = \"PACKAGE_RATE\", e[e.ADAPTATION = 2032] = \"ADAPTATION\", e[e.ACTUAL_ENCODED = 2060] = \"ACTUAL_ENCODED\", e[e.BANDWIDTH = 2061] = \"BANDWIDTH\", e[e.RETRANSMIT = 2062] = \"RETRANSMIT\", e[e.TARGET_ENCODED = 2064] = \"TARGET_ENCODED\", e[e.TRANSMIT = 2066] = \"TRANSMIT\", e[e.FREEZE = 2082] = \"FREEZE\", e[e.DISABLED = 2095] = \"DISABLED\", e[e.PLAYER_STATUS = 2128] = \"PLAYER_STATUS\", e[e.QP_SUM = 2143] = \"QP_SUM\", e;\n    }(yj || {}),\n    Aj = function (e) {\n      return e[e.BITRATE = 2069] = \"BITRATE\", e[e.PACKAGE_LOST = 2070] = \"PACKAGE_LOST\", e[e.PACKAGE_RATE = 2071] = \"PACKAGE_RATE\", e[e.HEIGHT = 2073] = \"HEIGHT\", e[e.FRAME_RATE = 2075] = \"FRAME_RATE\", e[e.WIDTH = 2077] = \"WIDTH\", e;\n    }(Aj || {}),\n    bj = function (e) {\n      return e[e.JITTER = -1] = \"JITTER\", e[e.PACKAGE_LOST = 2014] = \"PACKAGE_LOST\", e[e.WIDTH = 2018] = \"WIDTH\", e[e.HEIGHT = 2019] = \"HEIGHT\", e[e.FRAME_RATE = 2020] = \"FRAME_RATE\", e[e.JITTER_BUFFER = 2023] = \"JITTER_BUFFER\", e[e.CURRENT_DELAY = 2024] = \"CURRENT_DELAY\", e[e.NACKS = 2026] = \"NACKS\", e[e.PLIS = 2027] = \"PLIS\", e[e.FIRS = 2028] = \"FIRS\", e[e.BITRATE = 2029] = \"BITRATE\", e[e.PACKAGE_RATE = 2078] = \"PACKAGE_RATE\", e[e.FREEZE = 2084] = \"FREEZE\", e[e.DISABLED = 2101] = \"DISABLED\", e[e.PLAYER_STATUS = 2129] = \"PLAYER_STATUS\", e[e.QP_SUM = 2144] = \"QP_SUM\", e[e.I_FRAME_DELAY = 2149] = \"I_FRAME_DELAY\", e;\n    }(bj || {}),\n    wj = function (e) {\n      return e[e.FRAME_RATE_DECODE = 2021] = \"FRAME_RATE_DECODE\", e[e.FRAME_RATE_RENDER = 2022] = \"FRAME_RATE_RENDER\", e[e.FRAME_RATE_OUTPUT = 2155] = \"FRAME_RATE_OUTPUT\", e[e.FREEZE_TIME = 2109] = \"FREEZE_TIME\", e[e.FREEZE_TIME_RENDER = 2147] = \"FREEZE_TIME_RENDER\", e[e.FREEZE_DURATION = 2156] = \"FREEZE_DURATION\", e;\n    }(wj || {}),\n    Oj = function (e) {\n      return e[e.PCM_LEVEL = 2104] = \"PCM_LEVEL\", e;\n    }(Oj || {}),\n    Nj = function (e) {\n      return e[e.PACKAGE_LOST = -1] = \"PACKAGE_LOST\", e[e.LEVEL = 2038] = \"LEVEL\", e[e.BITRATE = 2039] = \"BITRATE\", e[e.PACKAGE_RATE = 2040] = \"PACKAGE_RATE\", e[e.AEC_RETURN_LOSS = 2041] = \"AEC_RETURN_LOSS\", e[e.AEC_RETURN_LOSS_ENH = 2042] = \"AEC_RETURN_LOSS_ENH\", e[e.FREEZE = 2081] = \"FREEZE\", e[e.DISABLED = 2096] = \"DISABLED\", e;\n    }(Nj || {}),\n    Dj = function (e) {\n      return e[e.BITRATE = 2044] = \"BITRATE\", e[e.PACKAGE_LOST = 2045] = \"PACKAGE_LOST\", e[e.PACKAGE_RATE = 2046] = \"PACKAGE_RATE\", e[e.CURRENT_DELAY = 2047] = \"CURRENT_DELAY\", e[e.JITTER_BUFFER = 2054] = \"JITTER_BUFFER\", e[e.JITTER = 2055] = \"JITTER\", e[e.FREEZE = 2083] = \"FREEZE\", e[e.DISABLED = 2102] = \"DISABLED\", e[e.PCM_LEVEL = 2105] = \"PCM_LEVEL\", e[e.PLAYER_STATUS = 2130] = \"PLAYER_STATUS\", e[e.CONCEALED_SAMPLES = 2148] = \"CONCEALED_SAMPLES\", e;\n    }(Dj || {}),\n    Pj = function (e) {\n      return e[e.FREEZE_TIME = -1] = \"FREEZE_TIME\", e[e.LEVEL = 2043] = \"LEVEL\", e;\n    }(Pj || {}),\n    Lj = function (e) {\n      return e[e.RTT = 2006] = \"RTT\", e[e.CONN_TYPE = 801] = \"CONN_TYPE\", e;\n    }(Lj || {});\n  const kj = 1e3,\n    Mj = 3;\n  function Uj(e, t, i) {\n    null != i && Number.isFinite(i) && (e[t] = Math.round(Math.max(0, i)));\n  }\n  function xj(e) {\n    const t = {\n      [Lj.CONN_TYPE]: 0,\n      [Lj.RTT]: e.rtt\n    };\n    switch (e.selectedCandidatePair.localCandidate.candidateType) {\n      case \"relay\":\n        {\n          const i = e.selectedCandidatePair.localCandidate.relayProtocol;\n          \"udp\" === i && (t[Lj.CONN_TYPE] = 1), \"tcp\" === i && (t[Lj.CONN_TYPE] = 3), \"tls\" === i && (t[Lj.CONN_TYPE] = 4);\n          break;\n        }\n      case \"srflx\":\n        t[Lj.CONN_TYPE] = 2;\n    }\n    return t;\n  }\n  function Vj(e) {\n    let t = 0;\n    switch (e) {\n      case \"none\":\n        t = 0;\n        break;\n      case \"cpu\":\n        t = 1;\n        break;\n      case \"bandwidth\":\n        t = 2;\n        break;\n      case \"other\":\n        t = 3;\n    }\n    return t;\n  }\n  class Fj extends SI {\n    constructor(e) {\n      super(), ng(this, \"store\", void 0), ng(this, \"uploadWRTCStatsTimer\", void 0), ng(this, \"uploadOutboundDenoiserStatsTimer\", void 0), ng(this, \"uploadExtStatsTimer\", void 0), ng(this, \"uploadExtUsageStatsTimer\", void 0), ng(this, \"uploadInboundExtStatsTimer\", void 0), ng(this, \"requestStats\", void 0), ng(this, \"requestTransportStats\", void 0), ng(this, \"requestLocalMedia\", void 0), ng(this, \"requestRemoteMedia\", void 0), ng(this, \"requestAllTracks\", void 0), ng(this, \"requestVideoIsReady\", void 0), ng(this, \"requestUploadStats\", void 0), ng(this, \"requestUpload\", void 0), ng(this, \"uploadOutboundStarted\", !1), ng(this, \"uploadInboundStarted\", !1), ng(this, \"uploadTransportStarted\", !1), ng(this, \"uploadExtensionUsageStarted\", !1), ng(this, \"lastRecvStats\", void 0), ng(this, \"lastSendStats\", void 0), ng(this, \"lastFullRecvStats\", void 0), ng(this, \"lastFullSendStats\", void 0), ng(this, \"needUploadRenderFreezeTime\", !0), this.store = e;\n    }\n    uploadWRTCStats(e) {\n      if (!this.requestStats || !this.requestUploadStats) return;\n      let t, i;\n      if (this.uploadTransportStarted && (t = this.requestStats(), this.store.useP2P && (i = this.requestStats(!0))), !t && this.uploadOutboundStarted && (t = this.requestStats()), !i && this.uploadInboundStarted && (i = this.requestStats(!0)), t || i) {\n        const n = {};\n        if (this.uploadTransportStarted && t) {\n          const r = this.getTransportStats(t, i, e);\n          r && (n.misc = [r]);\n        }\n        if (this.uploadOutboundStarted && t) {\n          const i = this.getOutboundStats(t, e ? this.lastSendStats : this.lastFullSendStats, e);\n          i && (n.outbound = [i]);\n        }\n        if (this.uploadInboundStarted && i) {\n          const t = this.getInboundStats(i, e ? this.lastRecvStats : this.lastFullRecvStats, e);\n          t && (n.inbound = t);\n        }\n        this.requestUploadStats(n);\n      }\n      this.lastRecvStats = i, this.lastSendStats = t, e || (this.lastFullRecvStats = i, this.lastFullSendStats = t);\n    }\n    startUploadWRTCStats() {\n      if (this.uploadWRTCStatsTimer) return;\n      let e = 1;\n      this.uploadWRTCStatsTimer = window.setInterval(() => {\n        if (!this.uploadTransportStarted && !this.uploadInboundStarted && !this.uploadOutboundStarted) return this.stopUploadWRTCStats();\n        this.uploadWRTCStats(e !== Mj), ++e === Mj + 1 && (e = 1);\n      }, kj);\n    }\n    stopUploadWRTCStats() {\n      window.clearInterval(this.uploadWRTCStatsTimer), this.uploadWRTCStatsTimer = void 0, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0);\n    }\n    getTransportStats(e, t, i) {\n      if (!this.requestStats) return;\n      if (i) return null == e.rtt ? void 0 : {\n        addition: {\n          [Lj.RTT]: e.rtt,\n          [Lj.CONN_TYPE]: void 0\n        }\n      };\n      const n = xj(e);\n      if (this.store.useP2P) {\n        if (t) {\n          const e = xj(t);\n          n[Lj.CONN_TYPE] += e[Lj.CONN_TYPE] << 3;\n        }\n        n[Lj.CONN_TYPE] += 110;\n      } else n[Lj.CONN_TYPE] += 100;\n      return {\n        addition: n\n      };\n    }\n    getOutboundStats(e, t, i) {\n      if (!this.requestUploadStats || !this.requestLocalMedia) return;\n      const n = this.requestLocalMedia();\n      if (!n || 0 === n.length) return;\n      let r, o, s;\n      return n.forEach(n => {\n        let _n2 = _slicedToArray(n, 2),\n          a = _n2[0],\n          _n2$ = _n2[1],\n          c = _n2$.track,\n          d = _n2$.ssrcs;\n        switch (a) {\n          case sw.LocalVideoLowTrack:\n          case sw.LocalVideoTrack:\n            if (a === sw.LocalVideoTrack) {\n              const n = function (e, t, i, n, r) {\n                  const o = t.videoSend.find(t => t.ssrc === e);\n                  if (!o) return;\n                  const s = {},\n                    a = o.sentFrame,\n                    c = o.inputFrame;\n                  if (c && a) {\n                    const e = c.frameRate,\n                      t = a.frameRate;\n                    s[yj.FREEZE] = function (e, t) {\n                      let i = !0;\n                      return i = !(e <= 5) && (e <= 10 ? t < 3 : e <= 20 ? t < 4 : t < 5), i;\n                    }(e, t) ? 1 : 0;\n                  }\n                  if (Uj(s, yj.QP_SUM, o.qpSumPerFrame), r) return s;\n                  switch (a && (Uj(s, yj.HEIGHT, a.height), Uj(s, yj.WIDTH, a.width), Uj(s, yj.FRAME_RATE, a.frameRate)), s[yj.DISABLED] = n._originMediaStreamTrack && !n._originMediaStreamTrack.enabled || n._mediaStreamTrack && !n._mediaStreamTrack.enabled ? 1 : 0, o.adaptionChangeReason) {\n                    case \"none\":\n                      s[yj.ADAPTATION] = 0;\n                      break;\n                    case \"cpu\":\n                      s[yj.ADAPTATION] = 1;\n                      break;\n                    case \"bandwidth\":\n                      s[yj.ADAPTATION] = 2;\n                      break;\n                    case \"other\":\n                      s[yj.ADAPTATION] = 3;\n                  }\n                  let d = 0;\n                  o.adaptionChangeReason && (d += Vj(o.adaptionChangeReason)), t.qualityLimitationReason && (d += Vj(t.qualityLimitationReason) << 3), s[yj.ADAPTATION] = d, s[yj.PLAYER_STATUS] = ZU[n._player ? n._player.videoElementStatus : \"uninit\"], Uj(s, yj.NACKS, o.nacksCount), Uj(s, yj.PLIS, o.plisCount), Uj(s, yj.FIRS, o.firsCount), Uj(s, yj.AVG_ENCODE, o.avgEncodeMs);\n                  const l = i && i.videoSend.find(t => t.ssrc === e);\n                  if (l) {\n                    let e = r ? kj : kj * Mj;\n                    l.timestamp && o.timestamp && (e = o.timestamp - l.timestamp), null != l.packets && null != o.packets && Uj(s, yj.PACKAGE_RATE, 1e3 * (o.packets - l.packets) / e), null != o.packetsLost && null != l.packetsLost && Uj(s, yj.PACKAGE_LOST, o.packetsLost - l.packetsLost), null != l.bytes && null != o.bytes && Uj(s, yj.BITRATE, 8 * (o.bytes - l.bytes) / e);\n                  }\n                  return s;\n                }(d[0].ssrcId, e, t, c, i),\n                r = i ? null : function (e, t, i) {\n                  const n = t.videoSend.find(t => t.ssrc === e);\n                  if (!n) return null;\n                  const r = {},\n                    o = n.inputFrame,\n                    s = o && o.height || i && i.videoHeight || 0,\n                    a = o && o.width || i && i.videoWidth || 0,\n                    c = o && o.frameRate || 0;\n                  return Uj(r, Ij.HEIGHT, s), Uj(r, Ij.WIDTH, a), Uj(r, Ij.FRAME_RATE, c), r;\n                }(d[0].ssrcId, e, c),\n                s = i ? null : function (e) {\n                  const t = {};\n                  return Uj(t, yj.RETRANSMIT, e.bitrate.retransmit), Uj(t, yj.TARGET_ENCODED, e.bitrate.targetEncoded), Uj(t, yj.ACTUAL_ENCODED, e.bitrate.actualEncoded), Uj(t, yj.TRANSMIT, e.bitrate.transmit), Uj(t, yj.BANDWIDTH, e.sendBandwidth), t;\n                }(e);\n              o = Object.assign({}, n, r, s);\n            } else s = i ? void 0 : function (e, t, i) {\n              const n = t.videoSend.find(t => t.ssrc === e);\n              if (!n) return;\n              const r = {},\n                o = n.sentFrame;\n              if (o && (Uj(r, Aj.HEIGHT, o.height), Uj(r, Aj.WIDTH, o.width), Uj(r, Aj.FRAME_RATE, o.frameRate)), i) {\n                const t = i.videoSend.find(t => t.ssrc === e);\n                if (t) {\n                  let e = kj * Mj;\n                  t.timestamp && n.timestamp && (e = n.timestamp - t.timestamp), null != t.packets && null != n.packets && Uj(r, Aj.PACKAGE_RATE, 1e3 * (n.packets - t.packets) / e), null != n.packetsLost && null != t.packetsLost && Uj(r, Aj.PACKAGE_LOST, n.packetsLost - t.packetsLost), null != t.bytes && null != n.bytes && Uj(r, Aj.BITRATE, 8 * (n.bytes - t.bytes) / e);\n                }\n              }\n              return r;\n            }(d[0].ssrcId, e, t);\n            break;\n          case sw.LocalAudioTrack:\n            r = i ? void 0 : function (e, t, i, n) {\n              const r = t.audioSend.find(t => t.ssrc === e);\n              if (!r) return;\n              const o = {};\n              o[Nj.DISABLED] = n._originMediaStreamTrack && !n._originMediaStreamTrack.enabled || n._mediaStreamTrack && !n._mediaStreamTrack.enabled ? 1 : 0;\n              const s = 100 * n._source.getAccurateVolumeLevel(),\n                a = r.inputLevel;\n              if (null != a) {\n                const e = Math.ceil(50 * Math.log10(100 * a + 1));\n                Uj(o, Nj.LEVEL, e);\n              }\n              Uj(o, Oj.PCM_LEVEL, s), Uj(o, Nj.AEC_RETURN_LOSS, r.aecReturnLoss), Uj(o, Nj.AEC_RETURN_LOSS_ENH, r.aecReturnLossEnhancement), o[Nj.FREEZE] = 0;\n              const c = i && i.audioSend.find(t => t.ssrc === e);\n              if (c) {\n                let e = kj * Mj;\n                c.timestamp && r.timestamp && (e = r.timestamp - c.timestamp), null != c.bytes && null != r.bytes && Uj(o, Nj.BITRATE, 8 * (r.bytes - c.bytes) / e), null != c.packets && null != r.packets && Uj(o, Nj.PACKAGE_RATE, 1e3 * (r.packets - c.packets) / e);\n              }\n              return o;\n            }(d[0].ssrcId, e, t, c);\n        }\n      }), {\n        high: o,\n        low: s,\n        audio: r\n      };\n    }\n    getInboundStats(e, t, i) {\n      if (!this.requestRemoteMedia) return;\n      const n = this.requestRemoteMedia() || [],\n        r = [];\n      return n.forEach(n => {\n        let _n3 = _slicedToArray(n, 2),\n          o = _n3[0],\n          s = _n3[1];\n        const a = {\n          peer: o.uid\n        };\n        if (s.has(nw.VIDEO) && o.videoTrack) {\n          const n = o._videoSSRC && this.requestVideoIsReady && this.requestVideoIsReady(o._videoSSRC) || !1,\n            r = o.videoTrack ? function (e, t, i, n, r, o, s) {\n              var a;\n              const c = t.videoRecv.find(t => t.ssrc === e);\n              if (!c) return;\n              const d = {},\n                l = c.receivedFrame,\n                h = c.outputFrame,\n                u = c.decodeFrameRate,\n                p = i && i.videoRecv.find(t => t.ssrc === e);\n              if (d[bj.FREEZE] = r && dG.isRemoteVideoFreeze(n, c, p) ? 1 : 0, Uj(d, wj.FRAME_RATE_DECODE, u), Uj(d, bj.QP_SUM, c.qpSumPerFrame), c.framesRateFirefox && Uj(d, bj.FRAME_RATE, c.framesRateFirefox), l && Uj(d, bj.FRAME_RATE, l.frameRate), p) {\n                const e = t.timestamp - i.timestamp || (s ? kj : Mj * kj);\n                null != c.packetsLost && null != p.packetsLost && Uj(d, bj.PACKAGE_LOST, c.packetsLost - p.packetsLost), null != p.bytes && null != c.bytes && Uj(d, bj.BITRATE, 8 * (c.bytes - p.bytes) / e), null != p.packets && null != c.packets && Uj(d, bj.PACKAGE_RATE, 1e3 * (c.packets - p.packets) / e);\n              }\n              if (s) return d;\n              l ? (Uj(d, bj.HEIGHT, l.height), Uj(d, bj.WIDTH, l.width)) : n && (Uj(d, bj.HEIGHT, n._videoHeight || 0), Uj(d, bj.WIDTH, n._videoWidth || 0)), h && Uj(d, wj.FRAME_RATE_OUTPUT, h.frameRate);\n              const _ = null === (a = n._player) || void 0 === a ? void 0 : a.rendFrameRate.toFixed(0);\n              if (_ && Uj(d, wj.FRAME_RATE_RENDER, +_), Uj(d, bj.JITTER_BUFFER, c.jitterBufferMs), Uj(d, bj.CURRENT_DELAY, c.currentDelayMs), Uj(d, bj.FIRS, c.firsCount), Uj(d, bj.NACKS, c.nacksCount), Uj(d, bj.PLIS, c.plisCount), n) {\n                d[bj.DISABLED] = n._originMediaStreamTrack.enabled && n._mediaStreamTrack.enabled ? 0 : 1;\n                const e = n._player;\n                if (e) {\n                  const t = e.freezeTimeCounterList,\n                    i = e.renderFreezeAccTime,\n                    n = e.videoElementStatus;\n                  if (t && t.length > 0 && Uj(d, wj.FREEZE_TIME, t.splice(0, 1)[0]), o && \"visible\" === jF.visibility && n === XU.PLAYING && _U().supportRequestVideoFrameCallback) {\n                    const t = Math.min(6e3, i);\n                    e.renderFreezeAccTime = Math.max(0, i - t), Uj(d, wj.FREEZE_TIME_RENDER, t);\n                  }\n                  if (\"number\" == typeof c.totalFreezesDuration) {\n                    const e = p && p.totalFreezesDuration ? c.totalFreezesDuration - p.totalFreezesDuration : c.totalFreezesDuration;\n                    Uj(d, wj.FREEZE_DURATION, 1e3 * e);\n                  }\n                }\n              }\n              if (d[bj.PLAYER_STATUS] = ZU[n._player ? n._player.videoElementStatus : \"uninit\"], p && void 0 !== c.totalInterFrameDelay && void 0 !== c.totalSquaredInterFrameDelay && void 0 !== p.totalInterFrameDelay && void 0 !== p.totalSquaredInterFrameDelay) {\n                const e = c.totalInterFrameDelay - p.totalInterFrameDelay,\n                  t = c.totalSquaredInterFrameDelay - p.totalSquaredInterFrameDelay,\n                  i = c.framesDecodeCount - p.framesDecodeCount,\n                  n = e / i * 1e3,\n                  r = Math.round(1e3 * Math.sqrt((t - Math.pow(e, 2) / i) / i));\n                !isNaN(r) && n + r > Math.max(3 * n, n + 150) && (d[bj.I_FRAME_DELAY] = r);\n              }\n              return d;\n            }(o._videoSSRC, e, t, o.videoTrack, !0 === n, this.needUploadRenderFreezeTime, i) : void 0;\n          r && (a.video = r);\n        }\n        if (s.has(nw.AUDIO) && o.audioTrack) {\n          const n = o.audioTrack ? function (e, t, i, n, r) {\n            const o = t.audioRecv.find(t => t.ssrc === e);\n            if (!o) return;\n            const s = {},\n              a = i && i.audioRecv.find(t => t.ssrc === e),\n              c = o.receivedFrames,\n              d = o.droppedFrames;\n            var l, h;\n            if (Uj(s, Dj.JITTER, o.jitterMs), null != c && null != d && (s[Dj.FREEZE] = (h = d, 0 === (l = c) || 100 * h / l > 20 ? 1 : 0)), a) {\n              const e = t.timestamp - i.timestamp || (r ? kj : kj * Mj);\n              null != o.packets && null != a.packets && Uj(s, Dj.PACKAGE_RATE, 1e3 * (o.packets - a.packets) / e), null != a.bytes && null != o.bytes && Uj(s, Dj.BITRATE, 8 * (o.bytes - a.bytes) / e), null != o.packetsLost && null != a.packetsLost && Uj(s, Dj.PACKAGE_LOST, o.packetsLost - a.packetsLost);\n            }\n            if (r) return s;\n            const u = 100 * n._source.getAccurateVolumeLevel(),\n              p = o.outputLevel;\n            if (null != p) {\n              const e = Math.ceil(50 * Math.log10(100 * p + 1));\n              Uj(s, Pj.LEVEL, e);\n            }\n            if (Uj(s, Dj.PCM_LEVEL, u), n && (s[Dj.DISABLED] = n._originMediaStreamTrack.enabled && n._mediaStreamTrack.enabled ? 0 : 1), Uj(s, Dj.JITTER_BUFFER, o.jitterBufferMs), Uj(s, Dj.CURRENT_DELAY, o.jitterBufferMs), s[Dj.PLAYER_STATUS] = ZU[Px.getPlayerState(n.getTrackId())], a) {\n              const e = o.concealedSamples - a.concealedSamples;\n              e > 0 && Uj(s, Dj.CONCEALED_SAMPLES, e);\n            }\n            return s;\n          }(o._audioSSRC, e, t, o.audioTrack, i) : void 0;\n          n && (a.audio = n);\n        }\n        (a.video || a.audio) && r.push(a);\n      }), this.needUploadRenderFreezeTime = !this.needUploadRenderFreezeTime, r;\n    }\n    startUploadTransportStats() {\n      this.uploadTransportStarted = !0, this.uploadWRTCStatsTimer || this.startUploadWRTCStats();\n    }\n    stopUploadTransportStats() {\n      this.uploadTransportStarted = !1;\n    }\n    startUploadOutboundStats() {\n      this.uploadOutboundStarted || (this.uploadOutboundStarted = !0, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = window.setInterval(() => {\n        if (!this.requestAllTracks || !this.requestUpload) return;\n        const e = (this.requestAllTracks() || []).find(e => e instanceof kV);\n        if (e && e._external.getDenoiserStats) {\n          const t = e._external.getDenoiserStats();\n          t && this.requestUpload(vb.DENOISER_STATS, t);\n        }\n      }, 2e3), this.uploadExtStatsTimer && window.clearInterval(this.uploadExtStatsTimer), this.uploadExtStatsTimer = window.setInterval(() => {\n        if (!this.requestAllTracks || !this.requestUpload) return;\n        this.requestAllTracks().forEach(e => {\n          e.getProcessorStats().forEach(e => {\n            this.requestUpload && this.requestUpload(e.type, e.stats);\n          });\n        });\n      }, 2e3));\n    }\n    stopUploadOutboundStats() {\n      this.uploadOutboundStarted && (this.uploadOutboundStarted = !1, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = void 0);\n    }\n    startUploadInboundStats() {\n      this.uploadInboundStarted || (this.uploadInboundStarted = !0, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadInboundExtStatsTimer && window.clearInterval(this.uploadInboundExtStatsTimer), this.uploadInboundExtStatsTimer = window.setInterval(() => {\n        if (!this.requestUpload || !this.requestRemoteMedia) return;\n        (this.requestRemoteMedia() || []).forEach(e => {\n          let _e16 = _slicedToArray(e, 2),\n            t = _e16[0],\n            i = _e16[1];\n          if (i.has(nw.VIDEO) && t.videoTrack) {\n            t.videoTrack.getProcessorStats().forEach(e => {\n              this.requestUpload && this.requestUpload(e.type, e.stats);\n            });\n          }\n          if (i.has(nw.AUDIO) && t.audioTrack) {\n            t.audioTrack.getProcessorStats().forEach(e => {\n              this.requestUpload && this.requestUpload(e.type, e.stats);\n            });\n          }\n        });\n      }, 2e3));\n    }\n    stopUploadInboundStats() {\n      this.uploadInboundStarted && (this.uploadInboundStarted = !1, this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0));\n    }\n    startUploadExtensionUsageStats() {\n      if (this.uploadExtensionUsageStarted) return;\n      this.uploadExtensionUsageStarted = !0, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer);\n      const e = new Map();\n      this.uploadExtUsageStatsTimer = window.setInterval(async () => {\n        const t = Date.now(),\n          i = {\n            connectionInterval: Dy(\"EXTENSION_USAGE_UPLOAD_INTERVAL\") / 1e3,\n            details: [],\n            lts: t\n          };\n        let n = [];\n        const r = this.requestAllTracks && this.requestAllTracks() || [];\n        for (const e of r) !e.muted && e.enabled && (n = n.concat(await e.getProcessorUsage()));\n        const o = this.requestRemoteMedia && this.requestRemoteMedia() || [];\n        for (const _ref25 of o) {\n          var _ref26 = _slicedToArray(_ref25, 2);\n          const e = _ref26[0];\n          const t = _ref26[1];\n          t.has(nw.VIDEO) && e.videoTrack && (n = n.concat(await e.videoTrack.getProcessorUsage())), t.has(nw.AUDIO) && e.audioTrack && (n = n.concat(await e.audioTrack.getProcessorUsage()));\n        }\n        if (0 === n.length) return;\n        i.details = function (e, t) {\n          const i = {};\n          for (const _ref27 of e) {\n            const s = _ref27.id;\n            const a = _ref27.value;\n            const c = _ref27.level;\n            const d = _ref27.direction;\n            {\n              var n;\n              const e = null !== (n = t.get(s)) && void 0 !== n ? n : 0,\n                l = 2 === a ? e + Dy(\"EXTENSION_USAGE_UPLOAD_INTERVAL\") / 1e3 : e;\n              var r, o;\n              t.set(s, l), i[s] ? (2 === a && (i[s].value = a), c > i[s].level && (i[s].level = c), \"remote\" === d && (i[s].remoteUidCount += 1), i[s].totalTs = null !== (r = t.get(s)) && void 0 !== r ? r : 0) : i[s] = {\n                value: a,\n                level: c,\n                remoteUidCount: \"local\" === d ? 0 : 1,\n                totalTs: null !== (o = t.get(s)) && void 0 !== o ? o : 0\n              };\n            }\n          }\n          return Object.keys(i).map(e => {\n            const _i$e = i[e],\n              t = _i$e.level,\n              n = _i$e.value,\n              r = _i$e.totalTs;\n            return {\n              id: e,\n              level: t,\n              value: n,\n              totalTs: r\n            };\n          });\n        }(n, e);\n        const s = Date.now(),\n          a = s > t ? s : t + 1;\n        this.requestUpload && this.requestUpload(vb.EXTENSION_USAGE_STATS, {\n          usageStats: i,\n          sendTs: a\n        });\n      }, Dy(\"EXTENSION_USAGE_UPLOAD_INTERVAL\"));\n    }\n    stopUploadExtensionUsageStats() {\n      this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = !1, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer), this.uploadExtUsageStatsTimer = void 0);\n    }\n  }\n  class Bj {\n    get hasVideo() {\n      return this._video_enabled_ && !this._video_muted_ && this._video_added_;\n    }\n    get hasAudio() {\n      return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;\n    }\n    get audioTrack() {\n      if (this.hasAudio || this._audio_pre_subscribed) return this._audioTrack;\n    }\n    get videoTrack() {\n      if (this.hasVideo || this._video_pre_subscribed) return this._videoTrack;\n    }\n    get dataChannels() {\n      return this._dataChannels;\n    }\n    constructor(e, t) {\n      ng(this, \"uid\", void 0), ng(this, \"_uintid\", void 0), ng(this, \"_trust_in_room_\", !0), ng(this, \"_trust_audio_enabled_state_\", !0), ng(this, \"_trust_video_enabled_state_\", !0), ng(this, \"_trust_audio_mute_state_\", !0), ng(this, \"_trust_video_mute_state_\", !0), ng(this, \"_audio_muted_\", !1), ng(this, \"_video_muted_\", !1), ng(this, \"_audio_enabled_\", !0), ng(this, \"_video_enabled_\", !0), ng(this, \"_audio_added_\", !1), ng(this, \"_video_added_\", !1), ng(this, \"_is_pre_created\", !1), ng(this, \"_video_pre_subscribed\", !1), ng(this, \"_audio_pre_subscribed\", !1), ng(this, \"_trust_video_stream_added_state_\", !0), ng(this, \"_trust_audio_stream_added_state_\", !0), ng(this, \"_audioTrack\", void 0), ng(this, \"_videoTrack\", void 0), ng(this, \"_dataChannels\", []), ng(this, \"_audioSSRC\", void 0), ng(this, \"_videoSSRC\", void 0), ng(this, \"_audioOrtc\", void 0), ng(this, \"_videoOrtc\", void 0), ng(this, \"_cname\", void 0), ng(this, \"_rtxSsrcId\", void 0), ng(this, \"_videoMid\", void 0), ng(this, \"_audioMid\", void 0), this.uid = e, this._uintid = t;\n    }\n  }\n  let jj = function (e) {\n    return e.SEND_ONLY = \"SEND_ONLY\", e.RECEIVE_ONLY = \"RECEIVE_ONLY\", e;\n  }({});\n  function Gj(e, t) {\n    var i;\n    let n;\n    switch (t) {\n      case sw.LocalAudioTrack:\n        n = Kb.Audio;\n        break;\n      case sw.LocalVideoTrack:\n        n = Dn(i = e._hints).call(i, LU.SCREEN_TRACK) ? Kb.Screen : Kb.High;\n        break;\n      case sw.LocalVideoLowTrack:\n        n = Kb.Low;\n    }\n    return n;\n  }\n  function Wj(e) {\n    const t = _U();\n    if (e.some(e => e._bypassWebAudio)) throw new iI(tI.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio\");\n    if (!t.webAudioMediaStreamDest) throw new iI(tI.NOT_SUPPORTED, \"cannot publish multiple tracks because your browser does not support audio mixing\");\n  }\n  function Hj(e, t) {\n    Wj(e);\n    const i = t || new UV();\n    return e.forEach(e => i.addAudioTrack(e)), i;\n  }\n  var Kj, Yj, qj, zj, Jj, Xj, Qj, Zj, $j, eG, tG, iG;\n  function nG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function rG(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? nG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : nG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let oG = (Kj = sG(jj.SEND_ONLY), Yj = sG(jj.SEND_ONLY), qj = sG(), zj = sG(jj.RECEIVE_ONLY), Jj = sG(jj.RECEIVE_ONLY), Xj = sG(jj.RECEIVE_ONLY), Qj = sG(jj.RECEIVE_ONLY), Zj = sG(jj.RECEIVE_ONLY), $j = sG(jj.RECEIVE_ONLY), eG = sG(), tG = sG(jj.RECEIVE_ONLY), iG = class extends SI {\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      const t = this._state;\n      this._state = e, this.emit(cw.StateChange, t, this._state);\n    }\n    constructor(e, t) {\n      super(), ng(this, \"store\", void 0), ng(this, \"statsUploader\", void 0), ng(this, \"sendConnection\", void 0), ng(this, \"recvConnection\", void 0), ng(this, \"localTrackMap\", new Map()), ng(this, \"remoteUserMap\", new Map()), ng(this, \"localDataChannels\", []), ng(this, \"pendingLocalTracks\", []), ng(this, \"pendingRemoteTracks\", []), ng(this, \"statsCollector\", void 0), ng(this, \"dtlsFailedCount\", 0), ng(this, \"sendMutex\", new uy(\"P2PChannel2-send-mutex\")), ng(this, \"recvMutex\", new uy(\"P2PChannel2-recv-mutex\")), ng(this, \"_state\", aw.Disconnected), ng(this, \"_restartStates\", [\"disconnected\", \"failed\"]), ng(this, \"reconnectInterval\", void 0), ng(this, \"uploadUnplinkStarted\", !1), ng(this, \"uploadDownlinkStarted\", !1), ng(this, \"uplinkStateUploadInterval\", void 0), ng(this, \"downlinkStatsUploadInterval\", void 0), ng(this, \"handleMuteLocalTrack\", async (e, t, i) => {\n        const n = await this.sendMutex.lock(\"Locking from P2PChannel2.handleMuteLocalTrack\");\n        try {\n          if (!this.sendConnection || this.state !== aw.Connected) return void i(new iI(tI.INVALID_OPERATION, \"Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established.\"));\n          const s = this.filterTobeMutedTracks(e);\n          if (0 === s.length) return void t();\n          const a = s.find(e => \"videoLowTrack\" === e[0]);\n          if (a) {\n            a[1].track._originMediaStreamTrack.stop();\n          }\n          await this.sendConnection.muteLocal(s.map(e => {\n            let _e17 = _slicedToArray(e, 2),\n              t = _e17[1].id;\n            return t;\n          }));\n          let c = !1;\n          var r, o;\n          if (\"video\" === e.trackMediaType) c = !(null === (r = this.localTrackMap.get(sw.LocalAudioTrack)) || void 0 === r || !r.track._muted);else c = void 0 === (null === (o = this.localTrackMap.get(sw.LocalVideoTrack)) || void 0 === o ? void 0 : o.id);\n          const d = this.createMuteMessage(s);\n          await MI(this, cw.RequestMuteLocal, d);\n          const l = \"video\" === e.trackMediaType ? gw.MUTE_LOCAL_VIDEO : gw.MUTE_LOCAL_AUDIO;\n          await MI(this, cw.RequestP2PMuteLocal, {\n            action: l,\n            message: d,\n            isMuteAll: c\n          }), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          n();\n        }\n      }), ng(this, \"handleUnmuteLocalTrack\", async (e, t, i) => {\n        const n = await this.sendMutex.lock(\"Locking from P2PChannel2.handleUnmuteLocalTrack\");\n        try {\n          if (!this.sendConnection || this.state !== aw.Connected) return void i(new iI(tI.INVALID_OPERATION, \"Cannot call P2PChannel2.handleUnmuteLocalTrack before sendConnection established.\"));\n          const r = this.filterTobeUnmutedTracks(e);\n          if (0 === r.length) return void t();\n          await this.sendConnection.unmuteLocal(r.map(e => {\n            let _e18 = _slicedToArray(e, 2),\n              t = _e18[1].id;\n            return t;\n          }));\n          const o = this.createUnmuteMessage(r),\n            s = \"video\" === e.trackMediaType ? gw.UNMUTE_LOCAL_VIDEO : gw.UNMUTE_LOCAL_AUDIO;\n          await MI(this, cw.RequestP2PMuteLocal, {\n            action: s,\n            message: o\n          }), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          n();\n        }\n      }), ng(this, \"handleUpdateVideoEncoder\", async (e, t, i) => {\n        const n = await this.sendMutex.lock(\"Locking from P2PChannel2.handleSetVideoEncoder\");\n        try {\n          const i = this.localTrackMap.get(sw.LocalVideoTrack);\n          if (!this.sendConnection || !i || i.track !== e || this.state !== aw.Connected) return void t();\n          const r = i.id,\n            o = i.track;\n          r && (await this.sendConnection.updateSendParameters(r, o), await this.sendConnection.updateEncoderConfig(r, o), this.emit(cw.UpdateVideoEncoder, o)), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          n();\n        }\n      }), ng(this, \"handleUpdateVideoSendParameters\", async (e, t, i) => {\n        const n = await this.sendMutex.lock(\"Locking from P2PChannel2.handleUpdateVideoSendParameters\");\n        try {\n          const i = this.localTrackMap.get(sw.LocalVideoTrack);\n          if (!this.sendConnection || !i || i.track !== e || this.state !== aw.Connected) return void t();\n          const r = i.id,\n            o = i.track;\n          r && (await this.sendConnection.updateSendParameters(r, o)), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          n();\n        }\n      }), ng(this, \"handleReplaceTrack\", async (e, t, i, n) => {\n        let r;\n        Qy.debug(\"[\".concat(this.store.clientId, \"] P2PChannel2 handleReplaceTrack for [track-id-\").concat(e.getTrackId(), \"]\")), \"boolean\" == typeof n && n || (r = await this.sendMutex.lock(\"From P2PChannel2.handleReplaceTrack\"));\n        try {\n          var o;\n          const i = Array.from(this.localTrackMap.entries()).find(t => {\n            let _t5 = _slicedToArray(t, 2),\n              i = _t5[1].track;\n            return e === i;\n          });\n          if (!this.sendConnection || !i || void 0 === i[1].id || this.state !== aw.Connected) return void t();\n          if (await (null === (o = this.sendConnection) || void 0 === o ? void 0 : o.replaceTrack(e, i[1].id)), i[0] === sw.LocalVideoTrack && _U().supportDualStreamEncoding) {\n            const t = this.localTrackMap.get(sw.LocalVideoLowTrack);\n            if (t) {\n              const i = e._mediaStreamTrack.clone();\n              t.track._originMediaStreamTrack.stop(), t.track._mediaStreamTrack = i, t.track._originMediaStreamTrack = i, await new Gu((e, i) => {\n                this.handleReplaceTrack(t.track, e, i, !0);\n              });\n            }\n          }\n          t();\n        } catch (e) {\n          i(e);\n        } finally {\n          var s;\n          null === (s = r) || void 0 === s || s();\n        }\n      }), ng(this, \"handleGetLocalVideoStats\", e => {\n        e(this.statsCollector.getLocalVideoTrackStats());\n      }), ng(this, \"handleGetLocalAudioStats\", e => {\n        e(this.statsCollector.getLocalAudioTrackStats());\n      }), ng(this, \"handleGetRemoteVideoStats\", e => this.statsCollector.getRemoteVideoTrackStats(e.uid)[e.uid]), ng(this, \"handleGetRemoteAudioStats\", e => this.statsCollector.getRemoteAudioTrackStats(e.uid)[e.uid]), this.store = e, this.statsCollector = t, this.statsCollector.addP2PChannel(this), this.statsUploader = new Fj(e), this.bindStatsUploaderEvents(), this.reconnectInterval = window.setInterval(() => {\n        [this.sendConnection, this.recvConnection].forEach(e => {\n          e && (\"disconnected\" !== e.iceConnectionState && \"failed\" !== e.iceConnectionState || this.handleDisconnect(e.direction));\n        });\n      }, Dy(\"ICE_RESTART_INTERVAL\"));\n    }\n    async startP2PConnection(e, t) {\n      throw new iI(tI.NOT_SUPPORTED, \"p2p mode does not support startP2PConnection.\");\n    }\n    async connect(e, t, i, n, r, o) {\n      throw new iI(tI.NOT_SUPPORTED, \"p2p mode does not support connect.\");\n    }\n    async startP2P(e, t) {\n      let i;\n      try {\n        if (t) {\n          this.recvConnection && (Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel.startP2P reset recvConnection.\")), this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection)), i = await this.recvMutex.lock(\"From P2PChannel.startP2P\"), this.recvConnection = new Rj(e, this.store, yb.RECEIVE_ONLY), this.bindConnectionEvents(this.recvConnection);\n          const n = await this.recvConnection.establish(t);\n          return {\n            iceParameters: n.iceParameters,\n            dtlsParameters: n.dtlsParameters,\n            sdp: n.sdp\n          };\n        }\n        {\n          this.state = aw.New, this.sendConnection && (Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel.startP2P reset sendConnection.\")), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection)), i = await this.sendMutex.lock(\"From P2PChannel.startP2P\"), this.sendConnection = new Rj(e, this.store), this.store.peerConnectionStart(), this.bindConnectionEvents(this.sendConnection);\n          const t = await this.sendConnection.establish();\n          return {\n            iceParameters: t.iceParameters,\n            dtlsParameters: t.dtlsParameters,\n            sdp: t.sdp\n          };\n        }\n      } finally {\n        i && i();\n      }\n    }\n    async p2pConnect(e) {\n      if (!this.sendConnection) throw new iI(tI.UNEXPECTED_ERROR, \"Cannot P2PChannel2.p2pConnect before P2PChannel2.startP2PConnection .\");\n      this.store.peerConnectionStart(), await this.sendConnection.connect(e), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = aw.Connected;\n    }\n    async addRemoteCandidate(e, t) {\n      if (t === yb.RECEIVE_ONLY) {\n        if (!this.sendConnection) throw new iI(tI.UNEXPECTED_ERROR, \"Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .\");\n        await this.sendConnection.addRemoteCandidate(e);\n      } else {\n        if (!this.recvConnection) throw new iI(tI.UNEXPECTED_ERROR, \"Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .\");\n        await this.recvConnection.addRemoteCandidate(e);\n      }\n    }\n    publish(e, t, i) {\n      var n = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var r, t, o, s, a, c;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return rB(n.sendMutex.lock(\"From P2PChannel.publish\"));\n            case 2:\n              r = _context2.sent;\n              _context2.prev = 3;\n              if (!(!n.sendConnection || n.state !== aw.Connected)) {\n                _context2.next = 8;\n                break;\n              }\n              n.throwIfTrackTypeNotMatch(e);\n              t = e.filter(e => -1 === n.pendingLocalTracks.indexOf(e));\n              return _context2.abrupt(\"return\", void (n.pendingLocalTracks = n.pendingLocalTracks.concat(t)));\n            case 8:\n              n.store.pubId = n.store.pubId + 1, iB.markPublishStart(n.store.clientId, n.store.pubId);\n              o = n.filterTobePublishedTracks(e, t, i);\n              if (!(0 === o.length)) {\n                _context2.next = 14;\n                break;\n              }\n              _context2.next = 13;\n              return rB(n.tryToUnmuteAudio(e));\n            case 13:\n              return _context2.abrupt(\"return\", void _context2.sent);\n            case 14:\n              o.forEach(e => {\n                let t = e.track,\n                  i = e.type;\n                const r = Date.now();\n                n.store.publish(t.getTrackId(), i === sw.LocalAudioTrack ? \"audio\" : \"video\", r);\n              }), n.bindLocalTrackEvents(o);\n              _context2.next = 17;\n              return rB(n.sendConnection.send(o.map(e => {\n                let t = e.track;\n                return t;\n              }), n.store.codec, n.store.audioCodec));\n            case 17:\n              s = _context2.sent;\n              _context2.next = 20;\n              return rB(s.next());\n            case 20:\n              a = _context2.sent.value;\n              c = n.createGatewayPublishMessage(o, a);\n              _context2.prev = 22;\n              _context2.next = 25;\n              return c;\n            case 25:\n              _context2.next = 30;\n              break;\n            case 27:\n              _context2.prev = 27;\n              _context2.t0 = _context2[\"catch\"](22);\n              throw s.throw(_context2.t0), (null == _context2.t0 ? void 0 : _context2.t0.code) === tI.WS_ABORT && o.forEach(e => {\n                let t = e.track;\n                -1 === n.pendingLocalTracks.indexOf(t) && n.pendingLocalTracks.push(t);\n              }), n.unbindLocalTrackEvents(o), _context2.t0;\n            case 30:\n              _context2.next = 32;\n              return rB(s.next());\n            case 32:\n              o.forEach(e => {\n                let t = e.type;\n                n.statsCollector.addLocalStats(t);\n              });\n              n.statsUploader.startUploadOutboundStats();\n              n.assignLocalTracks(o, a);\n              o.forEach(e => {\n                let t = e.track,\n                  i = e.type;\n                const r = Date.now();\n                n.store.publish(t.getTrackId(), i === sw.LocalAudioTrack ? \"audio\" : \"video\", void 0, r);\n              });\n              n.startUploadUplinkState();\n            case 37:\n              _context2.prev = 37;\n              r();\n              return _context2.finish(37);\n            case 40:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[3,, 37, 40], [22, 27]]);\n      }))();\n    }\n    async unpublish(e) {\n      if (!this.sendConnection || this.state !== aw.Connected) return void (0 === e.length ? this.pendingLocalTracks.length = 0 : this.pendingLocalTracks = this.pendingLocalTracks.filter(t => !Dn(e).call(e, t)));\n      const t = this.filterTobeUnpublishedTracks(e);\n      if (0 === t.length) return;\n      const i = t.find(e => \"videoLowTrack\" === e[0]);\n      if (i) {\n        i[1].track.close();\n      }\n      const n = this.createGatewayUnpublishMessage(t);\n      if (await this.sendConnection.stopSending(t.map(e => {\n        let _e19 = _slicedToArray(e, 2),\n          t = _e19[1].id;\n        return t;\n      })), this.withdrawLocalTracks(t), this.unbindLocalTrackEvents(t.map(e => {\n        let _e20 = _slicedToArray(e, 2),\n          t = _e20[0],\n          i = _e20[1].track;\n        return {\n          type: t,\n          track: i\n        };\n      })), t.forEach(e => {\n        let _e21 = _slicedToArray(e, 1),\n          t = _e21[0];\n        this.statsCollector.removeLocalStats(t);\n      }), 0 === this.localTrackMap.size && (this.statsUploader.stopUploadOutboundStats(), this.stopUploadUplinkState()), this.sendConnection && this.state === aw.Connected) {\n        if (i) {\n          i[1].track.close();\n        }\n        return n;\n      }\n      e.forEach(e => {\n        const t = this.pendingLocalTracks.indexOf(e);\n        -1 !== t && this.pendingLocalTracks.splice(t, 1);\n      });\n    }\n    startUploadUplinkState() {\n      if (this.uploadUnplinkStarted) return;\n      this.uploadUnplinkStarted = !0, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval);\n      const e = () => {\n        const e = [],\n          t = [];\n        Array.from(this.localTrackMap.entries()).forEach(i => {\n          let _i3 = _slicedToArray(i, 2),\n            n = _i3[0],\n            _i3$ = _i3[1],\n            r = _i3$.track,\n            o = _i3$.ssrcs;\n          const s = {\n            stream_type: Gj(r, n),\n            ssrcs: o\n          };\n          r._muted || !r._enabled ? e.push(s) : t.push(s);\n        }), e.length > 0 && e.forEach(e => {\n          MI(this, cw.RequestMuteLocal, [e]);\n        }), t.length > 0 && t.forEach(e => {\n          MI(this, cw.RequestUnmuteLocal, [e]);\n        });\n      };\n      e(), this.uplinkStateUploadInterval = window.setInterval(() => {\n        e();\n      }, 3e3);\n    }\n    stopUploadUplinkState() {\n      this.uploadUnplinkStarted && (this.uploadUnplinkStarted = !1, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval));\n    }\n    publishLowStream(e) {\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              throw new iI(tI.NOT_SUPPORTED, \"p2p mode does not support publishLowStream.\");\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }))();\n    }\n    async republish() {\n      this.pendingLocalTracks.length > 0 && (Qy.debug(\"[\".concat(this.store.clientId, \"] Emit P2PChannelEvents.RequestRePublish to republish tracks.\")), await kI(this, cw.RequestRePublish, this.pendingLocalTracks), this.emit(cw.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);\n    }\n    async unpublishLowStream() {\n      throw new iI(tI.NOT_SUPPORTED, \"p2p mode does not support unpublishLowStream.\");\n    }\n    async subscribe(e, t, i, n) {\n      var r;\n      if (!this.recvConnection) throw new iI(tI.INVALID_OPERATION, \"Cannot subscribe remote user when recvConnection disconnected.\");\n      if (null !== (r = this.remoteUserMap.get(e)) && void 0 !== r && r.has(t)) return;\n      const _await$this$recvConne = await this.recvConnection.receive(t, [{\n          ssrcId: i\n        }], String(e.uid), n),\n        o = _await$this$recvConne.track,\n        s = _await$this$recvConne.mid,\n        a = _await$this$recvConne.transceiver;\n      t === nw.AUDIO ? (e._audioTrack ? e._audioTrack._updateOriginMediaStreamTrack(o) : (e._audioTrack = new BF(o, e.uid, e._uintid, this.store), Qy.info(\"[\".concat(this.store.clientId, \"] [\").concat(this.store.p2pId, \"] create remote audio track: \").concat(e._audioTrack.getTrackId()))), a && e._audioTrack._updateRtpTransceiver(a), this.bindRemoteTrackEvents(e, e._audioTrack)) : (e._videoSSRC = i, e._videoTrack ? e._videoTrack._updateOriginMediaStreamTrack(o) : (e._videoTrack = new FF(o, e.uid, e._uintid, this.store), Qy.info(\"[\".concat(this.store.clientId, \"] [\").concat(this.store.p2pId, \"] create remote video track: \").concat(e._videoTrack.getTrackId()))), a && e._videoTrack._updateRtpTransceiver(a), this.bindRemoteTrackEvents(e, e._videoTrack));\n      const c = this.remoteUserMap.get(e);\n      c ? c.set(t, s) : this.remoteUserMap.set(e, new Map([[t, s]])), this.statsCollector.addRemoteStats(e.uid), this.statsUploader.startUploadInboundStats(), this.startUploadDownlinkState();\n      const d = this.pendingRemoteTracks.findIndex(i => {\n        let n = i.user,\n          r = i.kind;\n        return n.uid === e.uid && t === r;\n      });\n      -1 !== d && (this.pendingRemoteTracks.splice(d, 1), this.emit(cw.MediaReconnectEnd, e.uid));\n    }\n    async mockSubscribe(e, t, i, n) {\n      if (!this.recvConnection) throw new iI(tI.INVALID_OPERATION, \"Cannot subscribe remote user when recvConnection disconnected.\");\n      await this.recvConnection.mockReceive(t, [{\n        ssrcId: i\n      }], String(e.uid), n);\n    }\n    async unsubscribe(e, t, i) {\n      const n = this.pendingRemoteTracks.filter(i => {\n        let n = i.user,\n          r = i.kind;\n        return void 0 !== t ? n.uid === e.uid && t === r : n.uid === e.uid;\n      });\n      if (n.forEach(e => {\n        const t = this.pendingRemoteTracks.indexOf(e);\n        this.pendingRemoteTracks.splice(t, 1);\n      }), this.recvConnection || i || n.forEach(t => {\n        let i = t.kind;\n        var n;\n        if (i === nw.AUDIO) null === (n = e._audioTrack) || void 0 === n || n._destroy(), e._audioTrack = void 0;else if (i === nw.VIDEO) {\n          var r;\n          null === (r = e._videoTrack) || void 0 === r || r._destroy(), e._videoTrack = void 0;\n        }\n      }), !this.recvConnection) return;\n      const r = this.filterTobeUnSubscribedTracks(e, t);\n      0 !== r.length && (await this.recvConnection.stopReceiving(r.map(e => {\n        let _e22 = _slicedToArray(e, 2),\n          t = _e22[1].id;\n        return t;\n      })), this.withdrawRemoteTracks(r), 0 === this.remoteUserMap.size && (this.statsUploader.stopUploadInboundStats(), this.stopUploadDownlinkState()), r.forEach(e => {\n        let _e23 = _slicedToArray(e, 2),\n          t = _e23[0],\n          n = _e23[1].kind;\n        var r, o;\n        n === nw.VIDEO && t._videoSSRC && (null === (r = this.recvConnection) || void 0 === r || r.setStatsRemoteVideoIsReady(t._videoSSRC, !1));\n        if (n === nw.VIDEO) this.unbindRemoteTrackEvents(t._videoTrack), i || (null === (o = t._videoTrack) || void 0 === o || o._destroy(), t._videoTrack = void 0);else if (n === nw.AUDIO) {\n          var s;\n          if (this.unbindRemoteTrackEvents(t._audioTrack), !i) null === (s = t._audioTrack) || void 0 === s || s._destroy(), t._audioTrack = void 0;\n        }\n      }), r.forEach(e => {\n        let _e24 = _slicedToArray(e, 2),\n          t = _e24[1].kind;\n        MI(this, cw.RequestP2PMuteRemote, t);\n      }));\n    }\n    startUploadDownlinkState() {\n      if (this.uploadDownlinkStarted) return;\n      this.uploadDownlinkStarted = !0, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);\n      const e = () => Array.from(this.remoteUserMap.entries()).forEach(e => {\n        let _e25 = _slicedToArray(e, 2),\n          t = _e25[1];\n        [nw.VIDEO, nw.AUDIO].forEach(e => {\n          t.has(e) ? MI(this, cw.RequestP2PUnmuteRemote, e) : MI(this, cw.RequestP2PMuteRemote, e);\n        });\n      });\n      e(), this.downlinkStatsUploadInterval = window.setInterval(() => {\n        e();\n      }, 3e3);\n    }\n    stopUploadDownlinkState() {\n      this.uploadDownlinkStarted && (this.uploadDownlinkStarted = !1, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval));\n    }\n    getAllDataChannels() {\n      return this.localDataChannels;\n    }\n    async massSubscribe(e) {\n      throw new iI(tI.NOT_SUPPORTED, \"p2p mode does not support massSubscribe.\");\n    }\n    async massSubscribeNoLock(e) {\n      throw new iI(tI.NOT_SUPPORTED, \"p2p mode does not support massSubscribeNoLock.\");\n    }\n    async massUnsubscribe(e) {\n      throw new iI(tI.NOT_SUPPORTED, \"p2p mode does not support massUnsubscribe.\");\n    }\n    async massUnsubscribeNoLock(e) {\n      throw new iI(tI.NOT_SUPPORTED, \"p2p mode does not support massUnsubscribeNoLock.\");\n    }\n    async muteRemote(e, t) {\n      if (!this.recvConnection) return;\n      const i = this.remoteUserMap.get(e);\n      if (!i) return void Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel2.muteRemote has no remote user \").concat(e.uid, \".\"));\n      if (!i.get(t)) return void Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel2.muteRemote has no remote user \").concat(e.uid, \" media type \").concat(t, \".\"));\n      const n = t === nw.VIDEO ? e._videoSSRC : e._audioSSRC;\n      void 0 !== n && this.recvConnection.setStatsRemoteVideoIsReady(n, !1);\n    }\n    async unmuteRemote(e, t) {\n      return this.unmuteRemoteNoLock(e, t);\n    }\n    async unmuteRemoteNoLock(e, t) {\n      if (!this.recvConnection) return;\n      const i = this.remoteUserMap.get(e);\n      if (!i) return void Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel2.unmuteRemote has no remote user \").concat(e.uid, \".\"));\n      i.get(t) || Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel2.unmuteRemote has no remote user \").concat(e.uid, \" media type \").concat(t, \".\"));\n    }\n    getAllTracks(e) {\n      const t = this.localTrackMap.get(sw.LocalAudioTrack);\n      if ((null == t ? void 0 : t.track) instanceof UV) {\n        const i = t.track;\n        return Array.from(this.localTrackMap.entries()).filter(e => {\n          let _e26 = _slicedToArray(e, 1),\n            t = _e26[0];\n          return t !== sw.LocalAudioTrack;\n        }).filter(t => {\n          let _t6 = _slicedToArray(t, 1),\n            i = _t6[0];\n          return !(e && i === sw.LocalVideoLowTrack);\n        }).map(e => {\n          let _e27 = _slicedToArray(e, 2),\n            t = _e27[1].track;\n          return t;\n        }).concat(i.trackList);\n      }\n      return Array.from(this.localTrackMap.entries()).filter(t => {\n        let _t7 = _slicedToArray(t, 1),\n          i = _t7[0];\n        return !(e && i === sw.LocalVideoLowTrack);\n      }).map(e => {\n        let _e28 = _slicedToArray(e, 2),\n          t = _e28[1].track;\n        return t;\n      });\n    }\n    reportPublishEvent(e, t, i, n, r) {\n      if (e) {\n        const i = this.localTrackMap.get(sw.LocalAudioTrack),\n          o = n ? this.localTrackMap.get(sw.LocalVideoLowTrack) : this.localTrackMap.get(sw.LocalVideoTrack);\n        oA.publish(this.store.sessionId, {\n          eventElapse: iB.measureFromPublishStart(this.store.clientId, this.store.pubId),\n          succ: e,\n          ec: t,\n          audioName: null == i ? void 0 : i.track.getTrackLabel(),\n          videoName: null == o ? void 0 : o.track.getTrackLabel(),\n          screenshare: -1 !== (null == o ? void 0 : o.track._hints.indexOf(LU.SCREEN_TRACK)),\n          audio: !!i,\n          video: !!o,\n          p2pid: this.store.p2pId,\n          publishRequestid: this.store.pubId,\n          extend: r\n        });\n      } else {\n        var o;\n        i || (i = []);\n        const s = i.find(e => e instanceof LV),\n          a = n ? null === (o = this.localTrackMap.get(sw.LocalVideoTrack)) || void 0 === o ? void 0 : o.track : i.find(e => e instanceof vF);\n        oA.publish(this.store.sessionId, {\n          eventElapse: iB.measureFromPublishStart(this.store.clientId, this.store.pubId),\n          succ: e,\n          ec: t,\n          audioName: null == s ? void 0 : s.getTrackLabel(),\n          videoName: null == a ? void 0 : a.getTrackLabel(),\n          screenshare: -1 !== (null == a ? void 0 : a._hints.indexOf(LU.SCREEN_TRACK)),\n          audio: !!s,\n          video: !!a,\n          p2pid: this.store.p2pId,\n          publishRequestid: this.store.pubId,\n          extend: r\n        });\n      }\n    }\n    reportSubscribeEvent(e, t, i, n) {\n      const r = n === nw.VIDEO ? i._videoSSRC : i._audioSSRC;\n      r && oA.subscribe(this.store.sessionId, {\n        succ: e,\n        ec: t,\n        video: n === nw.VIDEO,\n        audio: n === nw.AUDIO,\n        peerid: i.uid,\n        subscribeRequestid: n === nw.VIDEO ? i._videoSSRC : i._audioSSRC,\n        p2pid: this.store.p2pId,\n        eventElapse: iB.measureFromSubscribeStart(this.store.clientId, r)\n      });\n    }\n    reset() {\n      Qy.debug(\"[\".concat(this.store.clientId, \"] P2PChannel2.reset\")), this.sendMutex = new uy(\"P2PChannel2-send-mutex\"), this.sendMutex = new uy(\"P2PChannel2-recv-mutex\"), this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();\n      const e = this.localTrackMap.get(sw.LocalAudioTrack);\n      if ((null == e ? void 0 : e.track) instanceof UV) {\n        if (e.track.trackList.length > 0) {\n          const t = e.track;\n          e.track.trackList.forEach(e => {\n            t.removeAudioTrack(e);\n          });\n        }\n        e.track.close();\n      }\n      this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.reconnectInterval && (window.clearInterval(this.reconnectInterval), this.reconnectInterval = void 0), this.state = aw.Disconnected;\n    }\n    getStats(e) {\n      var t, i;\n      return e ? null === (i = this.recvConnection) || void 0 === i ? void 0 : i.getStats() : null === (t = this.sendConnection) || void 0 === t ? void 0 : t.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      var t;\n      return (null === (t = this.recvConnection) || void 0 === t ? void 0 : t.getRemoteVideoIsReady(e)) || !1;\n    }\n    getLocalAudioVolume() {\n      const e = this.localTrackMap.get(sw.LocalAudioTrack);\n      if (e) return e.track.getVolumeLevel();\n    }\n    getLocalVideoSize() {\n      const e = this.localTrackMap.get(sw.LocalVideoTrack);\n      if (e) return {\n        width: e.track.videoWidth || 0,\n        height: e.track.videoHeight || 0\n      };\n    }\n    getEncoderConfig(e) {\n      const t = this.localTrackMap.get(e);\n      return t && t.track instanceof vF || t && t.track instanceof LV ? t.track._encoderConfig : void 0;\n    }\n    getLocalMedia(e) {\n      return this.localTrackMap.get(e);\n    }\n    hasLocalMedia() {\n      return this.localTrackMap.size > 0;\n    }\n    hasRemoteMedia(e, t) {\n      if (!e) return this.remoteUserMap.size > 0;\n      const i = this.remoteUserMap.get(e);\n      return !!i && (!t || i.has(t));\n    }\n    async hasRemoteMediaWithLock(e, t) {\n      if (!e) return this.remoteUserMap.size > 0;\n      const i = this.remoteUserMap.get(e);\n      return !!i && (!t || i.has(t));\n    }\n    getRemoteMedia(e) {\n      var t;\n      const i = Array.from(d_(t = this.remoteUserMap).call(t)).find(t => t.uid === e);\n      return i ? {\n        audioTrack: i.audioTrack,\n        audioSSRC: i._audioSSRC,\n        videoTrack: i.videoTrack,\n        videoSSRC: i._videoSSRC\n      } : {};\n    }\n    getAudioLevels() {\n      let e = Array.from(this.remoteUserMap.entries()).map(e => {\n        let _e29 = _slicedToArray(e, 1),\n          t = _e29[0];\n        return {\n          uid: t.uid,\n          level: t.audioTrack ? 100 * t.audioTrack._source.getAccurateVolumeLevel() : 0\n        };\n      });\n      const t = this.localTrackMap.get(sw.LocalAudioTrack);\n      return t && e.push({\n        level: 100 * t.track._source.getAccurateVolumeLevel(),\n        uid: this.store.uid\n      }), e = oE(e).call(e, (e, t) => e.level - t.level), e;\n    }\n    async disconnectForReconnect() {\n      this.sendConnection && this.recvConnection && (Qy.debug(\"[\".concat(this.store.clientId, \"] P2PChannel2.disconnectForReconnect closing P2PConnection\")), this.state = aw.Reconnecting, Dy(\"KEEP_LAST_FRAME\") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach(e => {\n        let _e30 = _slicedToArray(e, 1),\n          t = _e30[0];\n        var i;\n        t._videoTrack && t._videoTrack._player && (null === (i = t._videoTrack._player.getVideoElement()) || void 0 === i || i.pause(), t._videoTrack._player.isKeepLastFrame = !0, t._videoTrack._originMediaStreamTrack.stop());\n      }), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0, this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0, 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach(e => {\n        var t;\n        let _e31 = _slicedToArray(e, 2),\n          i = _e31[0],\n          n = _e31[1].track;\n        switch (i) {\n          case sw.LocalVideoTrack:\n            Dn(t = n._hints).call(t, LU.LOW_STREAM) ? n.close() : this.pendingLocalTracks.push(n);\n            break;\n          case sw.LocalAudioTrack:\n            n instanceof UV ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n.trackList) : this.pendingLocalTracks.push(n);\n          case sw.LocalVideoLowTrack:\n        }\n      }), this.emit(cw.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach(e => {\n        let _e32 = _slicedToArray(e, 2),\n          t = _e32[0],\n          i = _e32[1];\n        Array.from(d_(i).call(i)).forEach(e => {\n          this.setPendingRemoteMedia(t, e);\n        }), this.emit(cw.MediaReconnectStart, t.uid);\n      }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), Qy.debug(\"[\".concat(this.store.clientId, \"] P2PChannel2 disconnected, waiting to reconnect.\")));\n    }\n    hasPendingRemoteMedia(e, t) {\n      for (const i of this.pendingRemoteTracks) {\n        const n = i.user,\n          r = i.kind;\n        if ((e instanceof Bj ? e.uid : e) === n.uid && t === r) return !0;\n      }\n      return !1;\n    }\n    setPendingRemoteMedia(e, t) {\n      this.hasPendingRemoteMedia(e, t) || this.pendingRemoteTracks.push({\n        user: e,\n        kind: t\n      });\n    }\n    async restartICE(e, t) {\n      let i, n;\n      if (e === yb.SEND_ONLY) {\n        if (!this.sendConnection) throw new iI(tI.INVALID_OPERATION, \"Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established.\");\n        i = await this.sendMutex.lock(\"From P2PChannel.restartICE\"), n = this.sendConnection;\n      } else {\n        if (!this.recvConnection) throw new iI(tI.INVALID_OPERATION, \"Cannot call P2PChannel2.handleMuteLocalTrack before recvConnection established.\");\n        i = await this.recvMutex.lock(\"From P2PChannel.restartICE\"), n = this.recvConnection;\n      }\n      try {\n        if (t) {\n          const e = await n.restartICE(t);\n          return n.isInRestartIce = !1, e;\n        }\n        {\n          const e = await n.restartICE();\n          if (e) {\n            const t = await kI(this, cw.RequestP2PRestartICE, {\n              direction: yb.RECEIVE_ONLY,\n              iceParameter: e\n            });\n            await n.restartICE(t), n.isInRestartIce = !1;\n          }\n        }\n      } finally {\n        i();\n      }\n    }\n    getUplinkNetworkQuality() {\n      if (!this.sendConnection) return 0;\n      const e = this.sendConnection.getStats(),\n        t = this.localTrackMap.get(sw.LocalVideoTrack),\n        i = this.localTrackMap.get(sw.LocalAudioTrack),\n        n = e.videoSend.find(e => {\n          var i;\n          return e.ssrc === (null == t || null === (i = t.ssrcs) || void 0 === i ? void 0 : i[0].ssrcId);\n        }),\n        r = e.audioSend.find(e => {\n          var t;\n          return e.ssrc === (null == i || null === (t = i.ssrcs) || void 0 === t ? void 0 : t[0].ssrcId);\n        });\n      if (!n || !r) return 1;\n      const o = UI(this, cw.NeedSignalRTT),\n        s = n ? n.rttMs : void 0,\n        a = r ? r.rttMs : void 0,\n        c = s && a ? (s + a) / 2 : s || a,\n        d = (c && o ? (c + o) / 2 : c || o) || 0,\n        l = 100 * e.sendPacketLossRate * .7 / 50 + .3 * d / 1500,\n        h = l < .17 ? 1 : l < .36 ? 2 : l < .59 ? 3 : l < .1 ? 4 : 5,\n        u = null == t ? void 0 : t.track;\n      if (u && u._encoderConfig && -1 === u._hints.indexOf(LU.SCREEN_TRACK)) {\n        const t = u._encoderConfig.bitrateMax,\n          i = e.bitrate.actualEncoded;\n        if (t && i) {\n          const e = (1e3 * t - i) / (1e3 * t);\n          return cA[e < .15 ? 0 : e < .3 ? 1 : e < .45 ? 2 : e < .6 ? 3 : 4][h];\n        }\n      }\n      return h;\n    }\n    getDownlinkNetworkQuality() {\n      if (!this.recvConnection) return 0;\n      const e = this.recvConnection.getStats();\n      let t = 0;\n      return Array.from(this.remoteUserMap.entries()).forEach(i => {\n        let _i4 = _slicedToArray(i, 1),\n          n = _i4[0];\n        const r = n._audioSSRC,\n          o = n._videoSSRC,\n          s = e.audioRecv.find(e => e.ssrc === r),\n          a = e.videoRecv.find(e => e.ssrc === o);\n        if (!s && !a) return void (t += 1);\n        const c = UI(this, cw.NeedSignalRTT),\n          d = e.rtt,\n          l = (d && c ? (d + c) / 2 : d || c) || 0,\n          h = s ? s.jitterMs : void 0,\n          u = e.recvPacketLossRate;\n        let p = .7 * u * 100 / 50 + .3 * l / 1500;\n        h && (p = .6 * u * 100 / 50 + .2 * l / 1500 + .2 * h / 400);\n        t += p < .1 ? 1 : p < .17 ? 2 : p < .36 ? 3 : p < .59 ? 4 : 5;\n      }), this.remoteUserMap.size > 0 ? Math.round(t / this.remoteUserMap.size) : t;\n    }\n    async muteLocalTrack(e) {\n      return new Gu((t, i) => {\n        this.handleMuteLocalTrack(e, t, i);\n      });\n    }\n    filterTobePublishedTracks(e, t, i) {\n      const n = [],\n        r = _U(),\n        o = this.getAllTracks();\n      e = BI(e = e.filter(e => -1 === o.indexOf(e)));\n      let s = !1,\n        a = !1;\n      for (const o of e) {\n        if (o instanceof vF && (this.localTrackMap.has(sw.LocalVideoTrack) || s ? new iI(tI.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n.push({\n          track: o,\n          type: sw.LocalVideoTrack\n        }), s = !0), t)) {\n          const e = this.getLowVideoTrack(o, i);\n          n.push({\n            track: e,\n            type: sw.LocalVideoLowTrack\n          });\n        }\n        if (o instanceof LV) {\n          const e = this.localTrackMap.get(sw.LocalAudioTrack);\n          if (e) {\n            if (!(e.track instanceof UV)) throw new iI(tI.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing\");\n            if (o._bypassWebAudio) throw new iI(tI.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio\");\n            e.track.addAudioTrack(o), this.bindLocalAudioTrackEvents(o, !0);\n          } else if (a) {\n            const e = n.find(e => {\n              let t = e.type;\n              return t === sw.LocalAudioTrack;\n            });\n            if (!(e.track instanceof UV)) throw new iI(tI.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing\");\n            if (o._bypassWebAudio) throw new iI(tI.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio\");\n            e.track.addAudioTrack(o);\n          } else {\n            if (!r.webAudioMediaStreamDest || o instanceof UV || o._bypassWebAudio) n.push({\n              track: o,\n              type: sw.LocalAudioTrack\n            });else {\n              const e = new UV();\n              e.addAudioTrack(o), n.push({\n                track: e,\n                type: sw.LocalAudioTrack\n              });\n            }\n            a = !0;\n          }\n        }\n      }\n      return n;\n    }\n    filterTobeUnpublishedTracks(e) {\n      const t = [],\n        i = this.getAllTracks();\n      e = BI(e = e.filter(e => -1 !== i.indexOf(e)));\n      for (const i of e) {\n        if (i instanceof LV) {\n          const e = this.localTrackMap.get(sw.LocalAudioTrack);\n          if (!e) continue;\n          e.track instanceof UV ? (e.track.removeAudioTrack(i), this.unbindLocalAudioTrackEvents(i), 0 === e.track.trackList.length && (t.push([sw.LocalAudioTrack, e]), e.track.close())) : t.push([sw.LocalAudioTrack, e]);\n        }\n        if (i instanceof vF) {\n          const e = this.localTrackMap.get(sw.LocalVideoTrack);\n          if (!e) continue;\n          t.push([sw.LocalVideoTrack, e]);\n          const i = this.localTrackMap.get(sw.LocalVideoLowTrack);\n          i && t.push([sw.LocalVideoLowTrack, i]);\n        }\n      }\n      return t;\n    }\n    bindLocalTrackEvents(e) {\n      e.forEach(e => {\n        let t = e.track,\n          i = e.type;\n        switch (i) {\n          case sw.LocalVideoTrack:\n            t.addListener(PU.GET_STATS, this.handleGetLocalVideoStats), t.addListener(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t.addListener(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t.addListener(PU.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t.addListener(PU.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t.addListener(PU.NEED_REPLACE_TRACK, this.handleReplaceTrack), t.addListener(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t.addListener(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n            break;\n          case sw.LocalAudioTrack:\n            this.bindLocalAudioTrackEvents(t);\n          case sw.LocalVideoLowTrack:\n        }\n      });\n    }\n    bindLocalAudioTrackEvents(e, t) {\n      e instanceof UV ? e.trackList.forEach(e => {\n        e.addListener(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.addListener(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.addListener(PU.GET_STATS, this.handleGetLocalAudioStats), e.addListener(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.addListener(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n      }) : (e.addListener(PU.GET_STATS, this.handleGetLocalAudioStats), e.addListener(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.addListener(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.addListener(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.addListener(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t || e.addListener(PU.NEED_REPLACE_TRACK, this.handleReplaceTrack));\n    }\n    unbindLocalTrackEvents(e) {\n      e || (e = Array.from(this.localTrackMap.entries()).map(e => {\n        let _e33 = _slicedToArray(e, 2),\n          t = _e33[0],\n          i = _e33[1].track;\n        return {\n          track: i,\n          type: t\n        };\n      })), e.forEach(e => {\n        let t = e.track,\n          i = e.type;\n        switch (i) {\n          case sw.LocalVideoTrack:\n            t.off(PU.GET_STATS, this.handleGetLocalVideoStats), t.off(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t.off(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t.off(PU.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t.off(PU.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t.off(PU.NEED_REPLACE_TRACK, this.handleReplaceTrack), t.off(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t.off(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n            break;\n          case sw.LocalAudioTrack:\n            this.unbindLocalAudioTrackEvents(t);\n          case sw.LocalVideoLowTrack:\n        }\n      });\n    }\n    unbindLocalAudioTrackEvents(e) {\n      e instanceof UV ? e.trackList.forEach(e => {\n        e.off(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(PU.GET_STATS, this.handleGetLocalAudioStats), e.off(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n      }) : (e.off(PU.GET_STATS, this.handleGetLocalAudioStats), e.off(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(PU.NEED_REPLACE_TRACK, this.handleReplaceTrack), e.off(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));\n    }\n    bindRemoteTrackEvents(e, t) {\n      t instanceof FF && t.addListener(PU.GET_STATS, t => {\n        t(this.handleGetRemoteVideoStats(e));\n      }), t instanceof BF && t.addListener(PU.GET_STATS, t => {\n        t(this.handleGetRemoteAudioStats(e));\n      });\n    }\n    unbindRemoteTrackEvents(e) {\n      e && e.removeAllListeners(PU.GET_STATS);\n    }\n    unbindAllRemoteTrackEvents() {\n      Array.from(this.remoteUserMap.entries()).forEach(e => {\n        let _e34 = _slicedToArray(e, 2),\n          t = _e34[0],\n          i = _e34[1];\n        i.has(nw.AUDIO) && this.unbindRemoteTrackEvents(t._audioTrack), i.has(nw.VIDEO) && this.unbindRemoteTrackEvents(t._videoTrack);\n      });\n    }\n    createGatewayPublishMessage(e, t) {\n      return e.map((e, i) => {\n        var n;\n        let r,\n          o = e.track,\n          s = e.type;\n        switch (s) {\n          case sw.LocalAudioTrack:\n            r = Kb.Audio;\n            break;\n          case sw.LocalVideoTrack:\n            r = Dn(n = o._hints).call(n, LU.SCREEN_TRACK) ? Kb.Screen : Kb.High;\n            break;\n          case sw.LocalVideoLowTrack:\n            r = Kb.Low;\n        }\n        return {\n          kind: s === sw.LocalAudioTrack ? nw.AUDIO : nw.VIDEO,\n          stream_type: r,\n          mid: t[i].id,\n          ssrcs: t[i].localSSRC,\n          isMuted: o.muted || !o.enabled\n        };\n      });\n    }\n    createGatewayUnpublishMessage(e) {\n      return e.map(e => {\n        var t;\n        let i,\n          _e35 = _slicedToArray(e, 2),\n          n = _e35[0],\n          _e35$ = _e35[1],\n          r = _e35$.track,\n          o = _e35$.ssrcs,\n          s = _e35$.id;\n        switch (n) {\n          case sw.LocalVideoTrack:\n            i = Dn(t = r._hints).call(t, LU.SCREEN_TRACK) ? Kb.Screen : Kb.High;\n            break;\n          case sw.LocalAudioTrack:\n            i = Kb.Audio;\n            break;\n          case sw.LocalVideoLowTrack:\n            i = Kb.Low;\n        }\n        return {\n          stream_type: i,\n          ssrcs: o,\n          mid: s\n        };\n      });\n    }\n    assignLocalTracks(e, t) {\n      e.forEach((e, i) => {\n        let n = e.track,\n          r = e.type;\n        this.localTrackMap.set(r, {\n          track: n,\n          id: t[i].id,\n          ssrcs: t[i].localSSRC\n        });\n      });\n    }\n    withdrawLocalTracks(e) {\n      e.forEach(e => {\n        let _e36 = _slicedToArray(e, 1),\n          t = _e36[0];\n        this.localTrackMap.delete(t);\n      });\n    }\n    bindConnectionEvents(e) {\n      e.onConnectionStateChange = async t => {\n        var i;\n        Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: \").concat(e.name, \".onConnectionStateChange(\").concat(t, \")\")), this.emit(cw.PeerConnectionStateChange, t), \"connected\" !== t || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), \"connected\" === t && (e.isInRestartIce = !1), Dn(i = this._restartStates).call(i, t) && !e.isInRestartIce && (\"disconnected\" === t && (await $I(800)), \"disconnected\" !== e.iceConnectionState && \"failed\" !== e.iceConnectionState || this.handleDisconnect(e.direction));\n      }, e.onICEConnectionStateChange = e => {\n        \"connected\" !== e || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.onICEConnectionStateChange(\").concat(e, \")\")), oA.reportApiInvoke(this.store.sessionId, {\n          name: \"ICEConnectionStateChange\",\n          options: e,\n          tag: vI.TRACER\n        }).onSuccess(), this.emit(cw.IceConnectionStateChange, e);\n      }, e.onICETransportStateChange = e => {\n        Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.onICETransportStateChange(\").concat(e, \")\"));\n      }, e.onDTLSTransportStateChange = e => {\n        Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.onDTLSTransportStateChange(\").concat(e, \")\"));\n      }, e.onDTLSTransportError = e => {\n        Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.onDTLSTransportError(\").concat(e, \")\"));\n      }, e.onFirstAudioDecoded = e => {\n        var t;\n        const i = Array.from(d_(t = this.remoteUserMap).call(t)).find(t => t._audioSSRC === e);\n        var n;\n        i && (this.store.subscribe(i.uid, \"audio\", void 0, void 0, void 0, Date.now()), null === (n = i.audioTrack) || void 0 === n || n.emit(FU.FIRST_FRAME_DECODED), oA.firstRemoteFrame(this.store.sessionId, tA.FIRST_AUDIO_DECODE, iA.FIRST_AUDIO_DECODE, {\n          peer: i._uintid,\n          subscribeElapse: iB.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId\n        }));\n      }, e.onFirstAudioReceived = e => {\n        var t;\n        const i = Array.from(d_(t = this.remoteUserMap).call(t)).find(t => t._audioSSRC === e);\n        i && oA.firstRemoteFrame(this.store.sessionId, tA.FIRST_AUDIO_RECEIVED, iA.FIRST_AUDIO_RECEIVED, {\n          peer: i._uintid,\n          subscribeElapse: iB.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId\n        });\n      }, e.onFirstVideoDecoded = (e, t, i) => {\n        this.reportVideoFirstFrameDecoded(e, t, i);\n      }, e.onFirstVideoReceived = e => {\n        var t;\n        const i = Array.from(d_(t = this.remoteUserMap).call(t)).find(t => t._videoSSRC === e);\n        i && oA.firstRemoteFrame(this.store.sessionId, tA.FIRST_VIDEO_RECEIVED, iA.FIRST_VIDEO_RECEIVED, {\n          peer: i._uintid,\n          subscribeElapse: iB.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId\n        });\n      }, e.onSelectedLocalCandidateChanged = (e, t) => {\n        const i = \"relay\" === e.candidateType,\n          n = \"relay\" === t.candidateType;\n        \"unknown\" !== t.candidateType && i === n || this.emit(cw.ConnectionTypeChange, i), Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.SelectedLocalCandidateChanged(\").concat(JSON.stringify(Zw(t)), \" -> \").concat(JSON.stringify(Zw(e)), \")\"));\n      }, e.onSelectedRemoteCandidateChanged = (e, t) => {\n        Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.SelectedRemoteCandidateChanged(\").concat(JSON.stringify(Zw(t)), \" -> \").concat(JSON.stringify(Zw(e)), \")\"));\n      }, e.onFirstVideoDecodedTimeout = e => {\n        this.reportVideoFirstFrameDecoded(e, void 0, void 0, !0);\n      }, e.onLocalCandidate = t => {\n        this.emit(cw.LocalCandidate, {\n          candidate: t,\n          direction: e.direction\n        });\n      };\n    }\n    unbindConnectionEvents(e) {\n      e.onConnectionStateChange = void 0, e.onICEConnectionStateChange = void 0, e.onICETransportStateChange = void 0, e.onDTLSTransportStateChange = void 0, e.onDTLSTransportError = void 0, e.onFirstAudioDecoded = void 0, e.onFirstAudioReceived = void 0, e.onFirstVideoDecoded = void 0, e.onFirstVideoReceived = void 0, e.onSelectedLocalCandidateChanged = void 0, e.onSelectedRemoteCandidateChanged = void 0, e.onFirstVideoDecodedTimeout = void 0, e.onLocalCandidate = void 0;\n    }\n    async handleDisconnect(e) {\n      const t = e === yb.SEND_ONLY ? this.sendConnection : this.recvConnection;\n      t && !t.isInRestartIce && (t.isInRestartIce = !0, Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PChannel-\").concat(t.name, \"] start use restartICE\")), e === yb.SEND_ONLY ? this.restartICE(e) : kI(this, cw.RequestP2PRestartICE, {\n        direction: yb.SEND_ONLY\n      }));\n    }\n    filterTobeMutedTracks(e) {\n      const t = [];\n      if (-1 === this.getAllTracks().indexOf(e)) return t;\n      const i = this.localTrackMap.get(sw.LocalAudioTrack);\n      if (e instanceof LV && (null == i ? void 0 : i.track) instanceof UV) return i.track.isActive || t.push([sw.LocalAudioTrack, i]), t;\n      const n = Array.from(this.localTrackMap.entries()).find(t => {\n        let _t8 = _slicedToArray(t, 2),\n          i = _t8[1].track;\n        return e === i;\n      });\n      if (n && (t.push(n), n[0] === sw.LocalVideoTrack)) {\n        const e = this.localTrackMap.get(sw.LocalVideoLowTrack);\n        e && t.push([sw.LocalVideoLowTrack, e]);\n      }\n      return t;\n    }\n    filterTobeUnmutedTracks(e) {\n      const t = [],\n        i = this.localTrackMap.get(sw.LocalAudioTrack);\n      if (e instanceof LV && (null == i ? void 0 : i.track) instanceof UV) return i.track.isActive && t.push([sw.LocalAudioTrack, i]), t;\n      const n = Array.from(this.localTrackMap.entries()).find(t => {\n        let _t9 = _slicedToArray(t, 2),\n          i = _t9[1].track;\n        return e === i;\n      });\n      if (n) if (n[0] === sw.LocalVideoTrack) {\n        t.push(n);\n        const e = this.localTrackMap.get(sw.LocalVideoLowTrack);\n        e && t.push([sw.LocalVideoLowTrack, e]);\n      } else t.push(n);\n      return t;\n    }\n    createMuteMessage(e) {\n      return e.map(e => {\n        var t;\n        let i,\n          _e37 = _slicedToArray(e, 2),\n          n = _e37[0],\n          _e37$ = _e37[1],\n          r = _e37$.track,\n          o = _e37$.ssrcs,\n          s = _e37$.id;\n        switch (n) {\n          case sw.LocalAudioTrack:\n            i = Kb.Audio;\n            break;\n          case sw.LocalVideoTrack:\n            i = Dn(t = r._hints).call(t, LU.SCREEN_TRACK) ? Kb.Screen : Kb.High;\n            break;\n          case sw.LocalVideoLowTrack:\n            i = Kb.Low;\n        }\n        return {\n          stream_type: i,\n          ssrcs: o,\n          mid: s\n        };\n      });\n    }\n    createUnmuteMessage(e) {\n      return e.map(e => {\n        var t;\n        let i,\n          _e38 = _slicedToArray(e, 2),\n          n = _e38[0],\n          _e38$ = _e38[1],\n          r = _e38$.track,\n          o = _e38$.ssrcs,\n          s = _e38$.id;\n        switch (n) {\n          case sw.LocalAudioTrack:\n            i = Kb.Audio;\n            break;\n          case sw.LocalVideoTrack:\n            i = Dn(t = r._hints).call(t, LU.SCREEN_TRACK) ? Kb.Screen : Kb.High;\n            break;\n          case sw.LocalVideoLowTrack:\n            i = Kb.Low;\n        }\n        return {\n          stream_type: i,\n          ssrcs: o,\n          mid: s\n        };\n      });\n    }\n    filterTobeUnSubscribedTracks(e, t) {\n      const i = [],\n        n = this.remoteUserMap.get(e);\n      if (!n) return i;\n      if (t) {\n        const r = n.get(t);\n        if (!r) return i;\n        i.push([e, {\n          kind: t,\n          id: r\n        }]);\n      } else Array.from(n.entries()).forEach(t => {\n        let _t10 = _slicedToArray(t, 2),\n          n = _t10[0],\n          r = _t10[1];\n        i.push([e, {\n          kind: n,\n          id: r\n        }]);\n      });\n      return i;\n    }\n    createUnsubscribeMessage(e) {\n      const t = [];\n      return e.forEach(e => {\n        let _e39 = _slicedToArray(e, 2),\n          i = _e39[0],\n          _e39$ = _e39[1],\n          n = _e39$.kind,\n          r = _e39$.id;\n        switch (n) {\n          case nw.VIDEO:\n            return void (i._videoSSRC && t.push({\n              stream_type: nw.VIDEO,\n              ssrcId: i._videoSSRC\n            }));\n          case nw.AUDIO:\n            return void (i._audioSSRC && t.push({\n              stream_type: nw.AUDIO,\n              ssrcId: i._audioSSRC\n            }));\n        }\n      }), t;\n    }\n    withdrawRemoteTracks(e) {\n      e.forEach(e => {\n        let _e40 = _slicedToArray(e, 2),\n          t = _e40[0],\n          i = _e40[1].kind;\n        const n = this.remoteUserMap.get(t);\n        n && (n.delete(i), 0 === Array.from(n.entries()).length && this.remoteUserMap.delete(t));\n      });\n    }\n    async updateBitrateLimit(e) {\n      const t = this.localTrackMap.get(sw.LocalVideoTrack),\n        i = this.localTrackMap.get(sw.LocalVideoLowTrack);\n      t && (await t.track.setBitrateLimit(e.uplink)), i && e.low_stream_uplink && (await i.track.setBitrateLimit({\n        max_bitrate: e.low_stream_uplink.bitrate,\n        min_bitrate: e.low_stream_uplink.bitrate || 0\n      }));\n    }\n    isP2PDisconnected() {\n      if (this.sendConnection && this.recvConnection) {\n        const e = this.sendConnection.peerConnectionState,\n          t = this.recvConnection.peerConnectionState;\n        return \"connected\" !== e && \"connected\" !== t;\n      }\n      return !0;\n    }\n    async tryToUnmuteAudio(e) {\n      for (let t = 0; t < e.length; t++) if (e[t] instanceof LV) {\n        const i = this.filterTobeUnmutedTracks(e[t]);\n        if (0 === i.length) continue;\n        const n = this.createUnmuteMessage(i);\n        return void (await MI(this, cw.RequestUnmuteLocal, n));\n      }\n    }\n    bindStatsUploaderEvents() {\n      this.statsUploader.requestStats = e => this.getStats(e), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()).filter(e => {\n        let _e41 = _slicedToArray(e, 2),\n          t = _e41[1].ssrcs;\n        return !!t;\n      }), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = e => {\n        var t;\n        return !(null === (t = this.recvConnection) || void 0 === t || !t.getRemoteVideoIsReady(e));\n      }, this.statsUploader.requestUpload = (e, t) => this.emit(cw.RequestUpload, e, t), this.statsUploader.requestUploadStats = e => this.emit(cw.RequestUploadStats, e), this.statsUploader.requestAllTracks = () => this.getAllTracks();\n    }\n    unbindStatsUploaderEvents() {\n      this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;\n    }\n    async requestReconnect() {\n      this.dtlsFailedCount += 1, await $I(Ey(this.dtlsFailedCount, _y)), this.emit(cw.RequestReconnect);\n    }\n    async reconnectP2P() {}\n    canPublishLowStream() {\n      return this.localTrackMap.has(sw.LocalVideoTrack) || this.pendingLocalTracks.some(e => e instanceof vF);\n    }\n    throwIfTrackTypeNotMatch(e) {\n      if (e.filter(e => e instanceof vF).length > 1) throw new iI(tI.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);\n      if (e.filter(e => e instanceof LV).length > 1 && (e.some(e => e instanceof LV && e._bypassWebAudio) || !_U().webAudioMediaStreamDest)) throw new iI(tI.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode\");\n      for (const t of e) {\n        if (t instanceof vF && this.pendingLocalTracks.some(e => e instanceof vF)) throw new iI(tI.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);\n        if (t instanceof LV && this.pendingLocalTracks.some(e => e instanceof LV) && (!_U().webAudioMediaStreamDest || t._bypassWebAudio || this.pendingLocalTracks.some(e => e instanceof LV && e._bypassWebAudio))) throw new iI(tI.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode\");\n      }\n    }\n    getLowVideoTrack(e, t) {\n      const i = !Dy(\"DISABLE_DUAL_STREAM_USE_ENCODING\") && _U().supportDualStreamEncoding,\n        n = rG(rG({}, {\n          width: 160,\n          height: 120,\n          framerate: 15,\n          bitrate: 50\n        }), t);\n      let r;\n      r = i ? e._mediaStreamTrack.clone() : vj(e, n);\n      const o = ey(8, \"track-low-\"),\n        s = new vF(r, rG(rG({}, i && {\n          scaleResolutionDownBy: Qw(n, e)\n        }), {}, {\n          frameRate: n.framerate,\n          bitrateMax: n.bitrate,\n          bitrateMin: n.bitrate\n        }), void 0, void 0, o);\n      return s.on(xU.TRANSCEIVER_UPDATED, t => {\n        e._updateRtpTransceiver(t, kU.LOW_STREAM);\n      }), s._hints.push(LU.LOW_STREAM), e.addListener(PU.NEED_CLOSE, () => {\n        s.close();\n      }), s;\n    }\n    async globalLock() {\n      return this.recvMutex.lock(\"From P2PChannel2.globalLock\");\n    }\n    reportVideoFirstFrameDecoded(e, t, i, n) {\n      var r;\n      const o = Array.from(d_(r = this.remoteUserMap).call(r)).find(t => t._videoSSRC === e);\n      if (o) {\n        n || this.store.subscribe(o.uid, \"video\", void 0, void 0, void 0, void 0, Date.now());\n        const r = this.store.keyMetrics,\n          s = r.subscribe.find(e => e.userId === o.uid && \"video\" === e.type);\n        oA.firstRemoteVideoDecode(this.store.sessionId, tA.FIRST_VIDEO_DECODE, iA.FIRST_VIDEO_DECODE, {\n          peer: o._uintid,\n          videowidth: t,\n          videoheight: i,\n          subscribeElapse: iB.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId,\n          apEnd: r.requestAPEnd || 0,\n          apStart: r.requestAPStart || 0,\n          joinGwEnd: r.joinGatewayEnd || 0,\n          joinGwStart: r.joinGatewayStart || 0,\n          pcEnd: r.peerConnectionEnd || 0,\n          pcStart: r.peerConnectionStart || 0,\n          subscriberEnd: (null == s ? void 0 : s.subscribeEnd) || 0,\n          subscriberStart: (null == s ? void 0 : s.subscribeStart) || 0,\n          videoAddNotify: (null == s ? void 0 : s.streamAdded) || 0,\n          state: n ? 1 : 0\n        });\n      }\n    }\n    async remoteMediaSsrcChanged(e, t, i) {\n      if (!this.recvConnection) return !1;\n      const n = this.remoteUserMap.get(e);\n      if (!n) return !1;\n      const r = n.get(t);\n      if (!r) return !1;\n      const o = await this.recvConnection.getRemoteSSRC(r);\n      return void 0 !== o && o !== i;\n    }\n    resetConnection(e) {\n      Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PChannel2] reset connection to \").concat(e)), this.state === aw.Connected ? (Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PChannel2] fallback to websocket but P2PChannel2 state still connected, disconnect first\")), this.disconnectForReconnect()) : (this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0));\n    }\n    async publishDataChannel(e) {\n      throw new iI(tI.NOT_SUPPORTED);\n    }\n    async unpublishDataChannel(e) {\n      throw new iI(tI.NOT_SUPPORTED);\n    }\n    async subscribeDataChannel(e, t) {\n      throw new iI(tI.NOT_SUPPORTED);\n    }\n    async unsubscribeDataChannel(e, t) {\n      throw new iI(tI.NOT_SUPPORTED);\n    }\n    hasPendingRemoteDataChannel(e, t) {\n      throw new iI(tI.NOT_SUPPORTED);\n    }\n    setPendingRemoteDataChannel(e, t) {\n      throw new iI(tI.NOT_SUPPORTED);\n    }\n    async preConnect(e, t, i, n, r, o) {\n      throw new iI(tI.NOT_SUPPORTED);\n    }\n    getEstablishParams() {\n      throw new iI(tI.NOT_SUPPORTED);\n    }\n    async reSubscribe(e) {\n      throw new iI(tI.NOT_SUPPORTED);\n    }\n    async updateVideoStreamParameter(e, t) {\n      throw new iI(tI.NOT_SUPPORTED);\n    }\n    unbindRtpTransceiver() {\n      0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach(e => {\n        let _e42 = _slicedToArray(e, 2),\n          t = _e42[0],\n          i = _e42[1].track;\n        t === sw.LocalVideoLowTrack ? i._updateRtpTransceiver(void 0, kU.LOW_STREAM) : i._updateRtpTransceiver(void 0);\n      });\n    }\n  }, nb(iG.prototype, \"p2pConnect\", [Kj], Object.getOwnPropertyDescriptor(iG.prototype, \"p2pConnect\"), iG.prototype), nb(iG.prototype, \"unpublish\", [Yj], Object.getOwnPropertyDescriptor(iG.prototype, \"unpublish\"), iG.prototype), nb(iG.prototype, \"unpublishLowStream\", [qj], Object.getOwnPropertyDescriptor(iG.prototype, \"unpublishLowStream\"), iG.prototype), nb(iG.prototype, \"subscribe\", [zj], Object.getOwnPropertyDescriptor(iG.prototype, \"subscribe\"), iG.prototype), nb(iG.prototype, \"mockSubscribe\", [Jj], Object.getOwnPropertyDescriptor(iG.prototype, \"mockSubscribe\"), iG.prototype), nb(iG.prototype, \"unsubscribe\", [Xj], Object.getOwnPropertyDescriptor(iG.prototype, \"unsubscribe\"), iG.prototype), nb(iG.prototype, \"muteRemote\", [Qj], Object.getOwnPropertyDescriptor(iG.prototype, \"muteRemote\"), iG.prototype), nb(iG.prototype, \"unmuteRemote\", [Zj], Object.getOwnPropertyDescriptor(iG.prototype, \"unmuteRemote\"), iG.prototype), nb(iG.prototype, \"hasRemoteMediaWithLock\", [$j], Object.getOwnPropertyDescriptor(iG.prototype, \"hasRemoteMediaWithLock\"), iG.prototype), nb(iG.prototype, \"disconnectForReconnect\", [eG], Object.getOwnPropertyDescriptor(iG.prototype, \"disconnectForReconnect\"), iG.prototype), nb(iG.prototype, \"remoteMediaSsrcChanged\", [tG], Object.getOwnPropertyDescriptor(iG.prototype, \"remoteMediaSsrcChanged\"), iG.prototype), iG);\n  function sG(e) {\n    return function (t, i, n) {\n      const r = t[i];\n      if (\"function\" != typeof r) throw new Error(\"Cannot use mutex on object property.\");\n      return n.value = async function () {\n        for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++) n[o] = arguments[o];\n        switch (e) {\n          case jj.SEND_ONLY:\n            {\n              const e = await this.sendMutex.lock(\"From P2PChannel2.\".concat(i));\n              try {\n                return await r.apply(this, n);\n              } finally {\n                e();\n              }\n            }\n          case jj.RECEIVE_ONLY:\n            {\n              const e = await this.recvMutex.lock(\"From P2PChannel2.\".concat(i));\n              try {\n                return await r.apply(this, n);\n              } finally {\n                e();\n              }\n            }\n          default:\n            {\n              const e = await this.sendMutex.lock(\"From P2PChannel2.\".concat(i)),\n                t = await this.recvMutex.lock(\"From P2PChannel2.\".concat(i));\n              try {\n                return await r.apply(this, n);\n              } finally {\n                e(), t();\n              }\n            }\n        }\n      }, n;\n    };\n  }\n  function aG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function cG(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? aG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : aG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class dG {\n    constructor(e) {\n      ng(this, \"store\", void 0), ng(this, \"onStatsException\", void 0), ng(this, \"onUploadPublishDuration\", void 0), ng(this, \"onStatsChanged\", void 0), ng(this, \"localStats\", new Map()), ng(this, \"remoteStats\", new Map()), ng(this, \"updateStatsInterval\", void 0), ng(this, \"trafficStats\", void 0), ng(this, \"trafficStatsPeerList\", []), ng(this, \"uplinkStats\", void 0), ng(this, \"exceptionMonitor\", void 0), ng(this, \"p2pChannel\", void 0), ng(this, \"scalabilityMode\", pb.L1T1), ng(this, \"updateStats\", () => {\n        this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));\n      }), this.store = e, this.exceptionMonitor = new eB(), this.exceptionMonitor.on(\"exception\", (e, t, i) => {\n        this.onStatsException && this.onStatsException(e, t, i);\n      });\n    }\n    startUpdateStats() {\n      this.updateStatsInterval || (this.updateStatsInterval = window.setInterval(this.updateStats, 1e3));\n    }\n    stopUpdateStats() {\n      this.updateStatsInterval && (window.clearInterval(this.updateStatsInterval), this.updateStatsInterval = void 0);\n    }\n    reset() {\n      this.localStats = new Map(), this.remoteStats = new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;\n    }\n    getLocalAudioTrackStats() {\n      return this.localStats.get(sw.LocalAudioTrack) || cG({}, jU);\n    }\n    getLocalVideoTrackStats() {\n      return this.localStats.get(sw.LocalVideoTrack) || cG({}, GU);\n    }\n    getRemoteAudioTrackStats(e) {\n      const t = (e, t) => {\n          if (!this.trafficStats) return t;\n          const i = this.trafficStats.peer_delay.find(t => t.peer_uid === e);\n          return i && (t.publishDuration = i.B_ppad + (Date.now() - this.trafficStats.timestamp)), t;\n        },\n        i = {};\n      if (e) {\n        var n;\n        const r = null === (n = this.remoteStats.get(e)) || void 0 === n ? void 0 : n.audioStats;\n        r && (i[e] = t(e, r));\n      } else Array.from(this.remoteStats.entries()).forEach(e => {\n        let _e43 = _slicedToArray(e, 2),\n          n = _e43[0],\n          r = _e43[1].audioStats;\n        r && (i[n] = t(n, r));\n      });\n      return i;\n    }\n    getRemoteNetworkQualityStats(e) {\n      const t = {};\n      if (e) {\n        var i;\n        const n = null === (i = this.remoteStats.get(e)) || void 0 === i ? void 0 : i.networkStats;\n        n && (t[e] = n);\n      } else Array.from(this.remoteStats.entries()).forEach(e => {\n        let _e44 = _slicedToArray(e, 2),\n          i = _e44[0],\n          n = _e44[1].networkStats;\n        n && (t[i] = n);\n      });\n      return t;\n    }\n    getRemoteVideoTrackStats(e) {\n      const t = (e, t) => {\n          if (!this.trafficStats) return t;\n          const i = this.trafficStats.peer_delay.find(t => t.peer_uid === e);\n          return i && (t.publishDuration = i.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t;\n        },\n        i = {};\n      if (e) {\n        var n;\n        const r = null === (n = this.remoteStats.get(e)) || void 0 === n ? void 0 : n.videoStats;\n        r && (i[e] = t(e, r));\n      } else Array.from(this.remoteStats.entries()).forEach(e => {\n        let _e45 = _slicedToArray(e, 2),\n          n = _e45[0],\n          r = _e45[1].videoStats;\n        r && (i[n] = t(n, r));\n      });\n      return i;\n    }\n    getRTCStats() {\n      let e = 0,\n        t = 0,\n        i = 0,\n        n = 0;\n      const r = this.localStats.get(sw.LocalAudioTrack);\n      r && (e += r.sendBytes, t += r.sendBitrate);\n      const o = this.localStats.get(sw.LocalVideoTrack);\n      o && (e += o.sendBytes, t += o.sendBitrate);\n      const s = this.localStats.get(sw.LocalVideoLowTrack);\n      s && (e += s.sendBytes, t += s.sendBitrate), this.remoteStats.forEach(e => {\n        let t = e.audioStats,\n          r = e.videoStats;\n        t && (i += t.receiveBytes, n += t.receiveBitrate), r && (i += r.receiveBytes, n += r.receiveBitrate);\n      });\n      let a = 1;\n      return this.trafficStats && (a += this.trafficStats.peer_delay.length), {\n        Duration: 0,\n        UserCount: a,\n        SendBitrate: t,\n        SendBytes: e,\n        RecvBytes: i,\n        RecvBitrate: n,\n        OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0,\n        RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0\n      };\n    }\n    addLocalStats(e) {\n      this.localStats.set(e, void 0);\n    }\n    removeLocalStats(e) {\n      e ? this.localStats.delete(e) : this.localStats.clear();\n    }\n    addRemoteStats(e) {\n      this.remoteStats.set(e, {});\n    }\n    removeRemoteStats(e) {\n      e ? this.remoteStats.delete(e) : this.remoteStats.clear();\n    }\n    addP2PChannel(e) {\n      this.p2pChannel = e;\n    }\n    updateTrafficStats(e) {\n      e.peer_delay = e.peer_delay.filter(e => void 0 !== e.B_ppad || void 0 !== e.B_ppvd);\n      e.peer_delay.filter(e => -1 === this.trafficStatsPeerList.indexOf(e.peer_uid)).forEach(e => {\n        var t;\n        const i = null === (t = this.p2pChannel) || void 0 === t ? void 0 : t.getRemoteMedia(e.peer_uid),\n          n = null != i && i.videoSSRC ? iB.measureFromSubscribeStart(this.store.clientId, i.videoSSRC) : 0,\n          r = null != i && i.audioSSRC ? iB.measureFromSubscribeStart(this.store.clientId, i.audioSSRC) : 0;\n        void 0 !== e.B_ppad && void 0 !== e.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e.peer_uid, e.B_ppad, e.B_ppvd, n > r ? n : r), this.trafficStatsPeerList.push(e.peer_uid));\n      }), this.trafficStats = e;\n    }\n    updateUplinkStats(e) {\n      this.uplinkStats && this.uplinkStats.B_fir !== e.B_fir && Qy.debug(\"[\".concat(this.store.clientId, \"]: Period fir changes to \").concat(e.B_fir)), this.uplinkStats = e;\n    }\n    static isRemoteVideoFreeze(e, t, i) {\n      if (!e) return !1;\n      const n = !!i && t.framesDecodeFreezeTime > i.framesDecodeFreezeTime,\n        r = !i || t.framesDecodeCount > i.framesDecodeCount;\n      return n || !r;\n    }\n    static isRemoteAudioFreeze(e) {\n      return !!e && e._isFreeze();\n    }\n    isLocalVideoFreeze(e) {\n      return !(!e.inputFrame || !e.sentFrame) && e.inputFrame.frameRate > 5 && e.sentFrame.frameRate < 3;\n    }\n    updateLocalStats(e) {\n      Array.from(this.localStats.entries()).forEach(t => {\n        let _t11 = _slicedToArray(t, 2),\n          i = _t11[0],\n          n = _t11[1];\n        switch (i) {\n          case sw.LocalVideoTrack:\n          case sw.LocalVideoLowTrack:\n            {\n              const t = n,\n                o = cG({}, GU),\n                s = e.getStats(),\n                a = e.getLocalMedia(i);\n              if (s) {\n                const i = s.videoSend.find(e => e.ssrc === (null == a ? void 0 : a.ssrcs[0].ssrcId));\n                if (i) {\n                  const n = e.getLocalVideoSize(),\n                    r = e.getEncoderConfig(sw.LocalVideoTrack);\n                  \"H264\" !== i.codec && \"H265\" !== i.codec && \"VP8\" !== i.codec && \"VP9\" !== i.codec && \"AV1X\" !== i.codec && \"AV1\" !== i.codec || (o.codecType = i.codec), o.sendBytes = i.bytes, o.sendBitrate = t ? 8 * Math.max(0, o.sendBytes - t.sendBytes) : 0, i.inputFrame ? (o.captureFrameRate = i.inputFrame.frameRate, o.captureResolutionHeight = i.inputFrame.height, o.captureResolutionWidth = i.inputFrame.width) : n && (o.captureResolutionWidth = n.width, o.captureResolutionHeight = n.height), i.sentFrame ? (o.sendFrameRate = i.sentFrame.frameRate, o.sendResolutionHeight = i.sentFrame.height, o.sendResolutionWidth = i.sentFrame.width) : n && (o.sendResolutionWidth = n.width, o.sendResolutionHeight = n.height), i.avgEncodeMs && (o.encodeDelay = i.avgEncodeMs), r && r.bitrateMax && (o.targetSendBitrate = 1e3 * r.bitrateMax), o.sendPackets = i.packets, o.sendPacketsLost = i.packetsLost, o.sendJitterMs = i.jitterMs, o.sendRttMs = i.rttMs, o.totalDuration = t ? t.totalDuration + 1 : 1, o.totalFreezeTime = t ? t.totalFreezeTime : 0, this.isLocalVideoFreeze(i) && (o.totalFreezeTime += 1), i.scalabilityMode && this.scalabilityMode !== i.scalabilityMode && (Qy.debug(\"[\".concat(this.store.clientId, \"]: The scalabilityMode of the video sending stream is \").concat(i.scalabilityMode)), this.scalabilityMode = i.scalabilityMode);\n                }\n                this.trafficStats && (o.currentPacketLossRate = (this.trafficStats.B_pvlr4 || 0) / 100);\n              }\n              var r;\n              if (this.localStats.set(i, o), (null == t ? void 0 : t.sendResolutionWidth) !== o.sendResolutionWidth || (null == t ? void 0 : t.sendResolutionHeight) !== o.sendResolutionHeight) null === (r = this.onStatsChanged) || void 0 === r || r.call(this, \"resolution\", {\n                width: o.sendResolutionWidth,\n                height: o.sendResolutionHeight\n              });\n              o && a && this.exceptionMonitor.setLocalVideoStats(this.store.uid, a.track, o);\n              break;\n            }\n          case sw.LocalAudioTrack:\n            {\n              const t = n,\n                r = cG({}, jU),\n                o = e.getStats(),\n                s = e.getLocalMedia(i);\n              if (o) {\n                const i = o.audioSend.find(e => e.ssrc === (null == s ? void 0 : s.ssrcs[0].ssrcId));\n                if (i) {\n                  if (\"opus\" !== i.codec && \"aac\" !== i.codec && \"PCMU\" !== i.codec && \"PCMA\" !== i.codec && \"G722\" !== i.codec || (r.codecType = i.codec), i.inputLevel) r.sendVolumeLevel = Math.round(32767 * i.inputLevel);else {\n                    const t = e.getLocalAudioVolume();\n                    t && (r.sendVolumeLevel = Math.round(32767 * t));\n                  }\n                  r.sendBytes = i.bytes, r.sendPackets = i.packets, r.sendPacketsLost = i.packetsLost, r.sendJitterMs = i.jitterMs, r.sendRttMs = i.rttMs, r.sendBitrate = t ? 8 * Math.max(0, r.sendBytes - t.sendBytes) : 0;\n                }\n              }\n              this.trafficStats && (r.currentPacketLossRate = (this.trafficStats.B_palr4 || 0) / 100), this.localStats.set(sw.LocalAudioTrack, r), r && s && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s.track, r);\n              break;\n            }\n        }\n      });\n    }\n    updateRemoteStats(e) {\n      Array.from(this.remoteStats.entries()).forEach(t => {\n        var i, n;\n        let _t12 = _slicedToArray(t, 2),\n          r = _t12[0],\n          _t12$ = _t12[1],\n          o = _t12$.videoStats,\n          s = _t12$.audioStats,\n          a = _t12$.videoPcStats;\n        const c = s,\n          d = o,\n          l = a,\n          h = cG({}, WU),\n          u = cG({}, KU),\n          p = cG({}, HU),\n          _e$getRemoteMedia = e.getRemoteMedia(r),\n          _ = _e$getRemoteMedia.audioTrack,\n          E = _e$getRemoteMedia.videoTrack,\n          m = _e$getRemoteMedia.audioSSRC,\n          f = _e$getRemoteMedia.videoSSRC;\n        let T;\n        T = e instanceof oG ? e.getStats(!0) : e.getStats();\n        const S = null === (i = T) || void 0 === i ? void 0 : i.audioRecv.find(e => e.ssrc === m),\n          g = null === (n = T) || void 0 === n ? void 0 : n.videoRecv.find(e => e.ssrc === f),\n          R = this.trafficStats && this.trafficStats.peer_delay.find(e => e.peer_uid === r);\n        if (S && (\"opus\" !== S.codec && \"aac\" !== S.codec && \"PCMU\" !== S.codec && \"PCMA\" !== S.codec && \"G722\" !== S.codec || (h.codecType = S.codec), S.outputLevel ? h.receiveLevel = Math.round(32767 * S.outputLevel) : _ && (h.receiveLevel = Math.round(32767 * _.getVolumeLevel())), h.receiveBytes = S.bytes, h.receivePackets = S.packets, h.receivePacketsLost = S.packetsLost, h.packetLossRate = h.receivePacketsLost / (h.receivePackets + h.receivePacketsLost), h.receiveBitrate = c ? 8 * Math.max(0, h.receiveBytes - c.receiveBytes) : 0, h.totalDuration = c ? c.totalDuration + 1 : 1, h.totalFreezeTime = c ? c.totalFreezeTime : 0, h.freezeRate = h.totalFreezeTime / h.totalDuration, h.receiveDelay = S.jitterBufferMs, h.totalDuration > 10 && dG.isRemoteAudioFreeze(_) && (h.totalFreezeTime += 1)), g) {\n          \"H264\" !== g.codec && \"H265\" !== g.codec && \"VP8\" !== g.codec && \"VP9\" !== g.codec && \"AV1X\" !== g.codec && \"AV1\" !== g.codec || (u.codecType = g.codec), u.receiveBytes = g.bytes, u.receiveBitrate = d ? 8 * Math.max(0, u.receiveBytes - d.receiveBytes) : 0, u.decodeFrameRate = g.decodeFrameRate < 0 ? 0 : g.decodeFrameRate, u.renderFrameRate = g.decodeFrameRate < 0 ? 0 : g.decodeFrameRate, g.outputFrame && (u.renderFrameRate = g.outputFrame.frameRate), g.receivedFrame ? (u.receiveFrameRate = g.receivedFrame.frameRate, u.receiveResolutionHeight = g.receivedFrame.height, u.receiveResolutionWidth = g.receivedFrame.width) : E && (u.receiveResolutionHeight = E._videoHeight || 0, u.receiveResolutionWidth = E._videoWidth || 0), void 0 !== g.framesRateFirefox && (u.receiveFrameRate = Math.round(g.framesRateFirefox)), u.receivePackets = g.packets, u.receivePacketsLost = g.packetsLost, u.packetLossRate = u.receivePacketsLost / (u.receivePackets + u.receivePacketsLost), u.totalDuration = d ? d.totalDuration + 1 : 1, u.totalFreezeTime = d ? d.totalFreezeTime : 0, u.receiveDelay = g.jitterBufferMs || 0;\n          const t = !!f && e.getRemoteVideoIsReady(f);\n          E && t && dG.isRemoteVideoFreeze(E, g, l) && (u.totalFreezeTime += 1), u.freezeRate = u.totalFreezeTime / u.totalDuration;\n        }\n        R && (h.end2EndDelay = R.B_ad, u.end2EndDelay = R.B_vd, h.transportDelay = R.B_ed, u.transportDelay = R.B_ed, h.currentPacketLossRate = R.B_ealr4 / 100, u.currentPacketLossRate = R.B_evlr4 / 100, p.uplinkNetworkQuality = R.B_punq ? R.B_punq : 0, p.downlinkNetworkQuality = R.B_pdnq ? R.B_pdnq : 0), this.remoteStats.set(r, {\n          audioStats: h,\n          videoStats: u,\n          videoPcStats: g,\n          networkStats: p\n        }), _ && this.exceptionMonitor.setRemoteAudioStats(_, h), E && this.exceptionMonitor.setRemoteVideoStats(E, u);\n      });\n    }\n  }\n  function lG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function hG(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? lG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : lG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class uG extends SI {\n    constructor(e, t, i, n) {\n      super(), ng(this, \"spec\", void 0), ng(this, \"token\", void 0), ng(this, \"websocket\", void 0), ng(this, \"pingpongTimer\", void 0), ng(this, \"reconnectMode\", \"retry\"), ng(this, \"serviceMode\", void 0), ng(this, \"reqId\", 0), ng(this, \"commandReqId\", 0), ng(this, \"handleWebSocketOpen\", () => {\n        this.reconnectMode = \"retry\", this.startPingPong();\n      }), ng(this, \"handleWebSocketMessage\", e => {\n        if (!e.data) return;\n        const t = JSON.parse(e.data);\n        t.requestId ? this.emit(\"@\".concat(t.requestId, \"-\").concat(t.sid), t) : this.serviceMode === Nb.INJECT ? this.emit(xb.INJECT_STREAM_STATUS, t) : (oA.workerEvent(this.spec.sid, {\n          actionType: \"status\",\n          serverCode: t.code,\n          workerType: this.serviceMode === Nb.TRANSCODE ? 1 : 2\n        }), this.emit(xb.PUBLISH_STREAM_STATUS, t));\n      }), this.spec = t, this.token = e, this.serviceMode = n, this.websocket = new Fw(\"live-streaming\", i), this.websocket.on(Ab.CONNECTED, this.handleWebSocketOpen), this.websocket.on(Ab.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(Ab.REQUEST_NEW_URLS, (e, t) => {\n        kI(this, xb.REQUEST_NEW_ADDRESS).then(e).catch(t);\n      }), this.websocket.on(Ab.RECONNECTING, () => {\n        this.websocket.reconnectMode = this.reconnectMode;\n      });\n    }\n    init(e) {\n      return this.websocket.init(e);\n    }\n    async request(e, t, i, n) {\n      this.reqId += 1, \"request\" === e && (this.commandReqId += 1);\n      const r = this.commandReqId,\n        o = this.reqId;\n      if (!o || !this.websocket) throw new bb(tI.UNEXPECTED_ERROR);\n      const s = hG({\n        command: e,\n        sdkVersion: \"4.21.0\" === Iy ? \"0.0.1\" : Iy,\n        seq: o,\n        requestId: o,\n        allocate: i,\n        cname: this.spec.cname,\n        appId: this.spec.appId,\n        sid: this.spec.sid,\n        uid: this.spec.uid.toString(),\n        ts: Math.floor(Date.now() / 1e3)\n      }, t);\n      if (\"closed\" === this.websocket.state) throw new bb(tI.WS_DISCONNECT);\n      const a = () => new Gu((e, t) => {\n        this.websocket.once(Ab.CLOSED, () => t(new bb(tI.WS_ABORT))), this.websocket.once(Ab.CONNECTED, e);\n      });\n      \"connected\" !== this.websocket.state && (await a()), s.clientRequest && (s.clientRequest.workerToken = this.token);\n      const c = new Gu((e, t) => {\n        const i = () => {\n          t(new bb(tI.WS_ABORT));\n        };\n        this.websocket.once(Ab.RECONNECTING, i), this.websocket.once(Ab.CLOSED, i), this.once(\"@\".concat(o, \"-\").concat(this.spec.sid), t => {\n          e(t);\n        });\n      });\n      n && oA.workerEvent(this.spec.sid, hG(hG({}, n), {}, {\n        requestId: r,\n        actionType: \"request\",\n        payload: JSON.stringify(t.clientRequest),\n        serverCode: 0,\n        code: 0\n      }));\n      const d = Date.now();\n      this.websocket.sendMessage(s);\n      let l = null;\n      try {\n        l = await c;\n      } catch (n) {\n        if (\"closed\" === this.websocket.state) throw n;\n        return await a(), await this.request(e, t, i);\n      }\n      return n && oA.workerEvent(this.spec.sid, hG(hG({}, n), {}, {\n        requestId: r,\n        actionType: \"response\",\n        payload: JSON.stringify(l.serverResponse),\n        serverCode: l.code,\n        success: 200 === l.code,\n        responseTime: Date.now() - d\n      })), 200 !== l.code && this.handleResponseError(l), l;\n    }\n    tryNextAddress() {\n      this.reconnectMode = \"tryNext\", this.websocket.reconnect(\"tryNext\");\n    }\n    close() {\n      const e = \"4.21.0\" === Iy ? \"0.0.1\" : Iy;\n      this.reqId += 1, \"connected\" === this.websocket.state ? (this.websocket.sendMessage({\n        command: \"request\",\n        appId: this.spec.appId,\n        cname: this.spec.cname,\n        uid: this.spec.uid.toString(),\n        sdkVersion: e,\n        sid: this.spec.sid,\n        seq: this.reqId,\n        ts: Math.floor(Date.now() / 1e3),\n        requestId: this.reqId,\n        clientRequest: {\n          command: \"DestroyWorker\"\n        }\n      }), this.websocket.close(!1, !0)) : this.websocket.close(!1), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);\n    }\n    handleResponseError(e) {\n      switch (e.code) {\n        case Fb.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:\n          return void Qy.warning(\"live stream response already exists stream\");\n        case Fb.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:\n        case Fb.LIVE_STREAM_RESPONSE_BAD_STREAM:\n        case Fb.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:\n          return new bb(tI.LIVE_STREAMING_INVALID_ARGUMENT, \"\", {\n            code: e.code\n          }).throw();\n        case Fb.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:\n          if (\"UnpublishStream\" === e.serverResponse.command || \"UninjectStream\" === e.serverResponse.command) return;\n          throw new bb(tI.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"live stream response wm worker not exist\", {\n            retry: !0\n          });\n        case Fb.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:\n          return new bb(tI.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, \"\", {\n            code: e.code\n          }).throw();\n        case Fb.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:\n          {\n            const t = new bb(tI.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);\n            return this.emit(xb.WARNING, t, e.serverResponse.url);\n          }\n        case Fb.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN:\n          {\n            const t = new bb(tI.LIVE_STREAMING_WARN_FREQUENT_REQUEST);\n            return this.emit(xb.WARNING, t, e.serverResponse.url);\n          }\n        case Fb.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:\n          throw new bb(tI.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"live stream response wm worker not exist\", {\n            retry: !0\n          });\n        case Fb.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:\n          return new bb(tI.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, \"\", {\n            code: e.code\n          }).throw();\n        case Fb.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM:\n          {\n            const t = new bb(tI.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);\n            return this.emit(xb.WARNING, t, e.serverResponse.url);\n          }\n        case Fb.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:\n          return new bb(tI.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"\", {\n            code: e.code\n          }).throw();\n        case Fb.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:\n          throw new bb(tI.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"live stream resource limit\", {\n            retry: !0,\n            changeAddress: !0\n          });\n        case Fb.LIVE_STREAM_RESPONSE_WORKER_LOST:\n        case Fb.LIVE_STREAM_RESPONSE_WORKER_QUIT:\n          if (\"UnpublishStream\" === e.serverResponse.command || \"UninjectStream\" === e.serverResponse.command) return;\n          throw new bb(tI.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"error fail send message\", {\n            retry: !0,\n            changeAddress: !0\n          });\n        case Fb.ERROR_FAIL_SEND_MESSAGE:\n          if (\"UnpublishStream\" === e.serverResponse.command || \"UninjectStream\" === e.serverResponse.command) return;\n          if (\"UpdateTranscoding\" === e.serverResponse.command || \"ControlStream\" === e.serverResponse.command) return new bb(tI.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"error fail send message\", {\n            code: e.code\n          }).throw();\n          throw new bb(tI.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"error fail send message\", {\n            retry: !0,\n            changeAddress: !0\n          });\n        case Fb.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:\n        case Fb.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:\n        case Fb.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:\n        case Fb.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:\n          return new bb(tI.LIVE_STREAMING_CDN_ERROR, \"\", {\n            code: e.code\n          }).throw();\n      }\n    }\n    startPingPong() {\n      this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {\n        \"connected\" === this.websocket.state && this.request(\"ping\", {}).catch(iy);\n      }, 6e3);\n    }\n  }\n  function pG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function _G(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? pG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : pG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class EG extends SI {\n    constructor(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : _y,\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : _y;\n      super(), ng(this, \"onLiveStreamWarning\", void 0), ng(this, \"onLiveStreamError\", void 0), ng(this, \"onInjectStatusChange\", void 0), ng(this, \"spec\", void 0), ng(this, \"retryTimeout\", 1e4), ng(this, \"connection\", void 0), ng(this, \"httpRetryConfig\", void 0), ng(this, \"wsRetryConfig\", void 0), ng(this, \"streamingTasks\", new Map()), ng(this, \"isStartingStreamingTask\", !1), ng(this, \"taskMutex\", new uy(\"live-streaming\")), ng(this, \"cancelToken\", pv.CancelToken.source()), ng(this, \"transcodingConfig\", void 0), ng(this, \"injectConfig\", _G({}, Ub)), ng(this, \"injectLoopTimes\", 0), ng(this, \"uapResponse\", void 0), ng(this, \"lastTaskId\", 1), ng(this, \"statusError\", new Map()), this.spec = e, this.httpRetryConfig = i, this.wsRetryConfig = t;\n    }\n    async setTranscodingConfig(e) {\n      const t = _G(_G({}, Mb), e);\n      66 !== t.videoCodecProfile && 77 !== t.videoCodecProfile && 100 !== t.videoCodecProfile && (Qy.debug(\"[\".concat(this.spec.clientId, \"] set transcoding config, fix video codec profile: \").concat(t.videoCodecProfile, \" -> 100\")), t.videoCodecProfile = 100), t.transcodingUsers || (t.transcodingUsers = t.userConfigs), t.transcodingUsers && (t.transcodingUsers = t.transcodingUsers.map(e => _G(_G(_G({}, Pb), e), {}, {\n        zOrder: e.zOrder ? e.zOrder + 1 : 1\n      }))), function (e) {\n        dI(e.width) || oI(e.width, \"config.width\", 0, 1e4), dI(e.height) || oI(e.height, \"config.height\", 0, 1e4), dI(e.videoBitrate) || oI(e.videoBitrate, \"config.videoBitrate\", 1, 1e6), dI(e.videoFrameRate) || oI(e.videoFrameRate, \"config.videoFrameRate\"), dI(e.lowLatency) || nI(e.lowLatency, \"config.lowLatency\"), dI(e.audioSampleRate) || rI(e.audioSampleRate, \"config.audioSampleRate\", [32e3, 44100, 48e3]), dI(e.audioBitrate) || oI(e.audioBitrate, \"config.audioBitrate\", 1, 128), dI(e.audioChannels) || rI(e.audioChannels, \"config.audioChannels\", [1, 2, 3, 4, 5]), dI(e.videoGop) || oI(e.videoGop, \"config.videoGop\"), dI(e.videoCodecProfile) || rI(e.videoCodecProfile, \"config.videoCodecProfile\", [66, 77, 100]), dI(e.userCount) || oI(e.userCount, \"config.userCount\", 0, 17), dI(e.backgroundColor) || oI(e.backgroundColor, \"config.backgroundColor\", 0, 16777215), dI(e.userConfigExtraInfo) || aI(e.userConfigExtraInfo, \"config.userConfigExtraInfo\", 0, 4096, !1), e.transcodingUsers && !dI(e.transcodingUsers) && (cI(e.transcodingUsers, \"config.transcodingUsers\"), e.transcodingUsers.forEach((e, t) => {\n          Ob(e.uid), dI(e.x) || oI(e.x, \"transcodingUser[\".concat(t, \"].x\"), 0, 1e4), dI(e.y) || oI(e.y, \"transcodingUser[\".concat(t, \"].y\"), 0, 1e4), dI(e.width) || oI(e.width, \"transcodingUser[\".concat(t, \"].width\"), 0, 1e4), dI(e.height) || oI(e.height, \"transcodingUser[\".concat(t, \"].height\"), 0, 1e4), dI(e.zOrder) || oI(e.zOrder - 1, \"transcodingUser[\".concat(t, \"].zOrder\"), 0, 100), dI(e.alpha) || oI(e.alpha, \"transcodingUser[\".concat(t, \"].alpha\"), 0, 1, !1);\n        })), dI(e.watermark) || kb(e.watermark, \"watermark\"), dI(e.backgroundImage) || kb(e.backgroundImage, \"backgroundImage\"), e.images && !dI(e.images) && (cI(e.images, \"config.images\"), e.images.forEach((e, t) => {\n          kb(e, \"images[\".concat(t, \"]\"));\n        }));\n      }(t);\n      const i = [];\n      t.images && i.push(...t.images.map(e => _G(_G(_G({}, Lb), e), {}, {\n        zOrder: 255\n      }))), t.backgroundImage && (i.push(_G(_G(_G({}, Lb), t.backgroundImage), {}, {\n        zOrder: 0\n      })), delete t.backgroundImage), t.watermark && (i.push(_G(_G(_G({}, Lb), t.watermark), {}, {\n        zOrder: 255\n      })), delete t.watermark), t.images = i, t.transcodingUsers && (t.userConfigs = t.transcodingUsers.map(e => _G({}, e)), t.userCount = t.transcodingUsers.length, delete t.transcodingUsers);\n      const n = (t.userConfigs || []).map(e => \"number\" == typeof e.uid ? Gu.resolve(e.uid) : jO(e.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));\n      if ((await Gu.all(n)).forEach((e, i) => {\n        t.userConfigs && t.userConfigs[i] && (t.userConfigs[i].uid = e);\n      }), this.transcodingConfig = t, this.connection) try {\n        var r;\n        const e = await this.connection.request(\"request\", {\n          clientRequest: {\n            command: \"UpdateTranscoding\",\n            transcodingConfig: this.transcodingConfig\n          }\n        }, !1, {\n          command: \"UpdateTranscoding\",\n          workerType: 1,\n          requestByUser: !0,\n          tid: Array.from(ub(r = this.streamingTasks).call(r)).map(e => e.taskId).join(\"#\")\n        });\n        Qy.debug(\"[\".concat(this.spec.clientId, \"] update live transcoding config success, code: \").concat(e.code, \", config:\"), JSON.stringify(this.transcodingConfig));\n      } catch (e) {\n        if (!e.data || !e.data.retry) throw e;\n        e.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach(t => {\n          Qy.warning(\"[\".concat(this.spec.clientId, \"] live streaming receive error\"), e.toString(), \"try to republish\", t.url), this.startLiveStreamingTask(t.url, t.mode, e).then(() => {\n            Qy.debug(\"[\".concat(this.spec.clientId, \"] live streaming republish \").concat(t.url, \" success\"));\n          }).catch(e => {\n            Qy.error(\"[\".concat(this.spec.clientId, \"] live streaming republish failed\"), t.url, e.toString()), this.onLiveStreamError && this.onLiveStreamError(t.url, e);\n          });\n        });\n      }\n    }\n    setInjectStreamConfig(e, t) {\n      this.injectConfig = Object.assign({}, this.injectConfig, e), this.injectLoopTimes = t;\n    }\n    async startLiveStreamingTask(e, t, i) {\n      var n;\n      const r = Array.from(ub(n = this.streamingTasks).call(n)).find(e => e.mode === Nb.INJECT);\n      if (r && t === Nb.INJECT) return new bb(tI.LIVE_STREAMING_TASK_CONFLICT, \"inject stream over limit\").throw();\n      if (!this.transcodingConfig && t === Nb.TRANSCODE) throw new bb(tI.INVALID_OPERATION, \"[LiveStreaming] no transcoding config found, can not start transcoding streaming task\");\n      let o = {\n        command: \"PublishStream\",\n        ts: Date.now(),\n        url: e,\n        uid: this.spec.uid.toString(),\n        autoDestroyTime: 100,\n        acceptImageTimeout: !0\n      };\n      Qy.debug(\"[\".concat(this.spec.clientId, \"] start live streaming \").concat(e, \", mode: \").concat(t));\n      const s = await this.taskMutex.lock();\n      if (!this.connection && i) return void s();\n      if (this.streamingTasks.get(e) && !i) return s(), new bb(tI.LIVE_STREAMING_TASK_CONFLICT).throw();\n      try {\n        this.connection || (this.connection = await this.connect(t));\n      } catch (e) {\n        throw s(), e;\n      }\n      switch (t) {\n        case Nb.TRANSCODE:\n          o.transcodingConfig = _G({}, this.transcodingConfig);\n          break;\n        case Nb.RAW:\n          break;\n        case Nb.INJECT:\n          o = {\n            cname: this.spec.cname,\n            command: \"InjectStream\",\n            sid: this.spec.sid,\n            transcodingConfig: this.injectConfig,\n            ts: Date.now(),\n            url: e,\n            loopTimes: this.injectLoopTimes\n          };\n      }\n      this.uapResponse && this.uapResponse.vid && (o.vid = this.uapResponse.vid), this.isStartingStreamingTask = !0;\n      const a = this.lastTaskId++;\n      try {\n        const n = new Gu((t, n) => {\n            $I(this.retryTimeout).then(() => {\n              if (i) return n(i);\n              const t = this.statusError.get(e);\n              return t ? (this.statusError.delete(e), n(t)) : void 0;\n            });\n          }),\n          r = await Gu.race([this.connection.request(\"request\", {\n            clientRequest: o\n          }, !0, {\n            url: e,\n            command: \"PublishStream\",\n            workerType: t === Nb.TRANSCODE ? 1 : 2,\n            requestByUser: !i,\n            tid: a.toString()\n          }), n]);\n        this.isStartingStreamingTask = !1, Qy.debug(\"[\".concat(this.spec.clientId, \"] live streaming started, code: \").concat(r.code)), this.streamingTasks.set(e, {\n          clientRequest: o,\n          mode: t,\n          url: e,\n          taskId: a\n        }), s();\n      } catch (n) {\n        if (s(), this.isStartingStreamingTask = !1, !n.data || !n.data.retry || i) throw n;\n        return n.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e, t, n)) : await this.startLiveStreamingTask(e, t, n);\n      }\n    }\n    stopLiveStreamingTask(e) {\n      return new Gu((t, i) => {\n        const n = this.streamingTasks.get(e);\n        if (!n || !this.connection) return new bb(tI.UNEXPECTED_ERROR, \"can not find streaming task to stop\").throw();\n        const r = n.mode;\n        n.abortTask = () => {\n          Qy.debug(\"[\".concat(this.spec.clientId, \"] stop live streaming success(worker exception)\")), this.streamingTasks.delete(e), t();\n        }, this.connection.request(\"request\", {\n          clientRequest: {\n            command: r === Nb.INJECT ? \"UninjectStream\" : \"UnpublishStream\",\n            url: n.url\n          }\n        }, !1, {\n          url: e,\n          command: \"UnPublishStream\",\n          workerType: r === Nb.TRANSCODE ? 1 : 2,\n          requestByUser: !0,\n          tid: (this.lastTaskId++).toString()\n        }).then(i => {\n          Qy.debug(\"[\".concat(this.spec.clientId, \"] stop live streaming success, code: \").concat(i.code)), this.streamingTasks.delete(e), 0 === this.streamingTasks.size && r !== Nb.INJECT && (this.connection && this.connection.close(), this.connection = void 0), t(), r === Nb.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(Db.INJECT_STREAM_STATUS_STOP_SUCCESS, this.spec.uid, e);\n        }).catch(i);\n      });\n    }\n    async controlInjectStream(e, t, i, n) {\n      const r = this.streamingTasks.get(e);\n      if (!r || !this.connection || r.mode !== Nb.INJECT) throw new bb(tI.INVALID_OPERATION, \"can not find inject stream task to control\");\n      return (await this.connection.request(\"request\", {\n        clientRequest: {\n          command: \"ControlStream\",\n          url: e,\n          control: t,\n          audioVolume: i,\n          position: n\n        }\n      })).serverResponse;\n    }\n    resetAllTask() {\n      var e;\n      const t = Array.from(ub(e = this.streamingTasks).call(e));\n      this.terminate();\n      for (const e of t) this.startLiveStreamingTask(e.url, e.mode).catch(t => {\n        this.onLiveStreamError && this.onLiveStreamError(e.url, t);\n      });\n    }\n    terminate() {\n      this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = new Map(), this.isStartingStreamingTask = !1, this.statusError = new Map(), this.cancelToken = pv.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;\n    }\n    async connect(e) {\n      if (this.connection) throw new bb(tI.UNEXPECTED_ERROR, \"live streaming connection has already connected\");\n      const t = await kI(this, Vb.REQUEST_WORKER_MANAGER_LIST, e);\n      return this.uapResponse = t, this.connection = new uG(t.workerToken, this.spec, this.wsRetryConfig, e), this.connection.on(xb.WARNING, (e, t) => this.onLiveStreamWarning && this.onLiveStreamWarning(t, e)), this.connection.on(xb.PUBLISH_STREAM_STATUS, e => this.handlePublishStreamServer(e)), this.connection.on(xb.INJECT_STREAM_STATUS, e => this.handleInjectStreamServerStatus(e)), this.connection.on(xb.REQUEST_NEW_ADDRESS, (t, i) => {\n        if (!this.connection) return i(new bb(tI.UNEXPECTED_ERROR, \"can not get new live streaming address list\"));\n        kI(this, Vb.REQUEST_WORKER_MANAGER_LIST, e).then(e => {\n          this.uapResponse = e, t(e.addressList);\n        }).catch(i);\n      }), await this.connection.init(t.addressList), this.connection;\n    }\n    handlePublishStreamServer(e) {\n      const t = e.serverStatus && e.serverStatus.url || \"empty_url\",\n        i = this.streamingTasks.get(t),\n        n = e.reason;\n      switch (e.code) {\n        case Fb.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:\n        case Fb.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:\n        case Fb.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:\n        case Fb.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:\n          {\n            const n = new bb(tI.LIVE_STREAMING_CDN_ERROR, \"\", {\n              code: e.code\n            });\n            if (i) return Qy.error(n.toString()), this.onLiveStreamError && this.onLiveStreamError(t, n);\n            if (!this.isStartingStreamingTask) return;\n            this.statusError.set(t, n);\n          }\n        case Fb.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:\n          {\n            const e = new bb(tI.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, n);\n            return this.onLiveStreamWarning && this.onLiveStreamWarning(t, e);\n          }\n        case Fb.LIVE_STREAM_RESPONSE_WORKER_LOST:\n        case Fb.LIVE_STREAM_RESPONSE_WORKER_QUIT:\n          {\n            var r;\n            if (!this.connection) return;\n            this.connection.tryNextAddress();\n            const t = Array.from(ub(r = this.streamingTasks).call(r));\n            for (const i of t) i.abortTask ? i.abortTask() : (Qy.warning(\"[\".concat(this.spec.clientId, \"] publish stream status code\"), e.code, \"try to republish\", i.url), this.startLiveStreamingTask(i.url, i.mode, new bb(tI.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"\", {\n              code: e.code\n            })).then(() => {\n              Qy.debug(\"[\".concat(this.spec.clientId, \"] republish live stream success\"), i.url);\n            }).catch(e => {\n              Qy.error(e.toString()), this.onLiveStreamError && this.onLiveStreamError(i.url, e);\n            }));\n            return;\n          }\n      }\n    }\n    handleInjectStreamServerStatus(e) {\n      const t = Number(e.uid),\n        i = e.serverStatus && e.serverStatus.url;\n      switch (e.code) {\n        case 200:\n          return void (this.onInjectStatusChange && this.onInjectStatusChange(Db.INJECT_STREAM_STATUS_START_SUCCESS, t, i));\n        case 451:\n          return this.onInjectStatusChange && this.onInjectStatusChange(Db.INJECT_STREAM_STATUS_START_ALREADY_EXISTS, t, i), void this.streamingTasks.delete(i);\n        case 453:\n          return this.onInjectStatusChange && this.onInjectStatusChange(Db.INJECT_STREAM_STATUS_START_UNAUTHORIZED, t, i), void this.streamingTasks.delete(i);\n        case 470:\n          return this.onInjectStatusChange && this.onInjectStatusChange(Db.INJECT_STREAM_STATUS_BROKEN, t, i), void this.streamingTasks.delete(i);\n        case 499:\n          return this.onInjectStatusChange && this.onInjectStatusChange(Db.INJECT_STREAM_STATUS_START_TIMEOUT, t, i), void this.streamingTasks.delete(i);\n        default:\n          return void Qy.debug(\"inject stream server status\", e);\n      }\n    }\n    hasUrl(e) {\n      return this.streamingTasks.has(e);\n    }\n  }\n  class mG {\n    constructor() {\n      ng(this, \"destChannelMediaInfos\", new Map()), ng(this, \"srcChannelMediaInfo\", void 0);\n    }\n    setSrcChannelInfo(e) {\n      Bb(e), this.srcChannelMediaInfo = e;\n    }\n    addDestChannelInfo(e) {\n      Bb(e), this.destChannelMediaInfos.set(e.channelName, e);\n    }\n    removeDestChannelInfo(e) {\n      wb(e), this.destChannelMediaInfos.delete(e);\n    }\n    getSrcChannelMediaInfo() {\n      return this.srcChannelMediaInfo;\n    }\n    getDestChannelMediaInfo() {\n      return this.destChannelMediaInfos;\n    }\n  }\n  function fG(e) {\n    if (!(e instanceof mG)) {\n      return new bb(tI.INVALID_PARAMS, \"Config should be instance of [ChannelMediaRelayConfiguration]\").throw();\n    }\n    const t = e.getSrcChannelMediaInfo(),\n      i = e.getDestChannelMediaInfo();\n    if (!t) {\n      return new bb(tI.INVALID_PARAMS, \"srcChannelMediaInfo should not be empty\").throw();\n    }\n    if (0 === i.size) {\n      return new bb(tI.INVALID_PARAMS, \"destChannelMediaInfo should not be empty\").throw();\n    }\n  }\n  class TG extends SI {\n    constructor(e, t, i) {\n      super(), ng(this, \"ws\", void 0), ng(this, \"requestId\", 1), ng(this, \"heartBeatTimer\", void 0), ng(this, \"joinInfo\", void 0), ng(this, \"clientId\", void 0), ng(this, \"onOpen\", () => {\n        this.emit(\"open\"), this.startHeartBeatCheck();\n      }), ng(this, \"onClose\", e => {\n        this.emit(\"close\"), this.dispose();\n      }), ng(this, \"onMessage\", e => {\n        const t = JSON.parse(e.data);\n        if (!t || \"serverResponse\" !== t.command || !t.requestId) return t && \"serverStatus\" === t.command && t.serverStatus && t.serverStatus.command ? (this.emit(\"status\", t.serverStatus), void this.emit(t.serverStatus.command, t.serverStatus)) : void 0;\n        this.emit(\"req_\".concat(t.requestId), t);\n      }), this.joinInfo = e, this.clientId = t, this.ws = new Fw(\"cross-channel-\".concat(this.clientId), i), this.ws.on(Ab.RECONNECTING, () => {\n        this.ws.reconnectMode = \"retry\", this.emit(\"reconnecting\");\n      }), this.ws.on(Ab.CONNECTED, this.onOpen), this.ws.on(Ab.ON_MESSAGE, this.onMessage), this.ws.on(Ab.CLOSED, this.onClose);\n    }\n    isConnect() {\n      return \"connected\" === this.ws.state;\n    }\n    sendMessage(e) {\n      const t = this.requestId++;\n      return e.requestId = t, e.seq = t, this.ws.sendMessage(e), t;\n    }\n    waitStatus(e) {\n      return new Gu((t, i) => {\n        const n = window.setTimeout(() => {\n          i(new bb(tI.TIMEOUT, \"wait status timeout, status: \".concat(e)));\n        }, 5e3);\n        this.once(e, r => {\n          window.clearTimeout(n), r.state && 0 !== r.state ? i(new bb(tI.CROSS_CHANNEL_WAIT_STATUS_ERROR, \"wait status error, status: \".concat(e))) : t(void 0);\n        }), this.once(\"dispose\", () => {\n          window.clearTimeout(n), i(new bb(tI.WS_ABORT));\n        });\n      });\n    }\n    async request(e) {\n      if (\"closed\" === this.ws.state) throw new bb(tI.WS_DISCONNECT);\n      const t = () => new Gu((e, t) => {\n        this.ws.once(Ab.CLOSED, () => t(new bb(tI.WS_ABORT))), this.ws.once(Ab.CONNECTED, e);\n      });\n      \"connected\" !== this.ws.state && (await t());\n      const i = this.sendMessage(e),\n        n = new Gu((e, t) => {\n          const n = () => {\n            t(new bb(tI.WS_ABORT));\n          };\n          this.ws.once(Ab.RECONNECTING, n), this.ws.once(Ab.CLOSED, n), this.once(\"req_\".concat(i), e), $I(3e3).then(() => {\n            this.removeAllListeners(\"req_\".concat(i)), this.ws.off(Ab.RECONNECTING, n), this.ws.off(Ab.CLOSED, n), t(new bb(tI.TIMEOUT, \"cross channel ws request timeout\"));\n          });\n        }),\n        r = await n;\n      if (!r || 200 !== r.code) throw new bb(tI.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, \"response: \".concat(JSON.stringify(r)));\n      return r;\n    }\n    async connect(e) {\n      this.ws.removeAllListeners(Ab.REQUEST_NEW_URLS), this.ws.on(Ab.REQUEST_NEW_URLS, t => {\n        t(e);\n      }), await this.ws.init(e);\n    }\n    dispose() {\n      this.clearHeartBeatCheck(), this.emit(\"dispose\"), this.removeAllListeners(), this.ws.close();\n    }\n    sendPing(e) {\n      const t = this.requestId++;\n      return e.requestId = t, this.ws.sendMessage(e), t;\n    }\n    startHeartBeatCheck() {\n      this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {\n        this.sendPing({\n          command: \"ping\",\n          appId: this.joinInfo.appId,\n          cname: this.joinInfo.cname,\n          uid: this.joinInfo.uid.toString(),\n          sid: this.joinInfo.sid,\n          ts: +new Date(),\n          requestId: 0\n        });\n      }, 3e3);\n    }\n    clearHeartBeatCheck() {\n      window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;\n    }\n  }\n  class SG extends SI {\n    set state(e) {\n      e !== this._state && (e !== Wb.RELAY_STATE_FAILURE && (this.errorCode = Hb.RELAY_OK), this.emit(\"state\", e, this.errorCode), this._state = e);\n    }\n    get state() {\n      return this._state;\n    }\n    constructor(e, t, i, n, r) {\n      super(), ng(this, \"joinInfo\", void 0), ng(this, \"sid\", void 0), ng(this, \"clientId\", void 0), ng(this, \"cancelToken\", pv.CancelToken.source()), ng(this, \"workerToken\", void 0), ng(this, \"requestId\", 0), ng(this, \"signal\", void 0), ng(this, \"prevChannelMediaConfig\", void 0), ng(this, \"httpRetryConfig\", void 0), ng(this, \"_resolution\", void 0), ng(this, \"_state\", Wb.RELAY_STATE_IDLE), ng(this, \"errorCode\", Hb.RELAY_OK), ng(this, \"onStatus\", e => {\n        Qy.debug(\"[\".concat(this.clientId, \"] ChannelMediaStatus: \").concat(JSON.stringify(e))), e && e.command && (\"onAudioPacketReceived\" === e.command && this.emit(\"event\", Gb.PACKET_RECEIVED_AUDIO_FROM_SRC), \"onVideoPacketReceived\" === e.command && this.emit(\"event\", Gb.PACKET_RECEIVED_VIDEO_FROM_SRC), \"onSrcTokenPrivilegeDidExpire\" === e.command && (this.errorCode = Hb.SRC_TOKEN_EXPIRED, this.state = Wb.RELAY_STATE_FAILURE), \"onDestTokenPrivilegeDidExpire\" === e.command && (this.errorCode = Hb.DEST_TOKEN_EXPIRED, this.state = Wb.RELAY_STATE_FAILURE));\n      }), ng(this, \"onReconnect\", async () => {\n        Qy.debug(\"[\".concat(this.clientId, \"] ChannelMediaSocket disconnect, reconnecting\")), this.emit(\"event\", Gb.NETWORK_DISCONNECTED), this.state = Wb.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch(e => {\n          this.state !== Wb.RELAY_STATE_IDLE && (Qy.error(\"auto restart channel media relay failed\", e.toString()), this.errorCode = Hb.SERVER_CONNECTION_LOST, this.state = Wb.RELAY_STATE_FAILURE);\n        });\n      }), this.joinInfo = e, this.clientId = t, this.sid = ty(), this.signal = new TG(this.joinInfo, this.clientId, i), this.httpRetryConfig = n, this._resolution = r;\n    }\n    async startChannelMediaRelay(e) {\n      if (this.state !== Wb.RELAY_STATE_IDLE) throw new bb(tI.INVALID_OPERATION);\n      this.state = Wb.RELAY_STATE_CONNECTING, await this.connect(), Qy.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: connect success\"));\n      try {\n        await this.sendStartRelayMessage(e);\n      } catch (e) {\n        if (e.data && e.data.serverResponse && \"SetSourceChannel\" === e.data.serverResponse.command) throw new bb(tI.CROSS_CHANNEL_FAILED_JOIN_SRC);\n        if (e.data && e.data.serverResponse && \"SetDestChannelStatus\" === e.serverResponse.command) throw new bb(tI.CROSS_CHANNEL_FAILED_JOIN_DEST);\n        if (e.data && e.data.serverResponse && \"StartPacketTransfer\" === e.serverResponse.command) throw new bb(tI.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);\n        throw e;\n      }\n      this.prevChannelMediaConfig = e;\n    }\n    async updateChannelMediaRelay(e) {\n      if (this.state !== Wb.RELAY_STATE_RUNNING) throw new bb(tI.INVALID_OPERATION);\n      await this.sendUpdateMessage(e), this.prevChannelMediaConfig = e;\n    }\n    async setVideoProfile(e) {\n      if (this._resolution = e, this.state !== Wb.RELAY_STATE_RUNNING) throw new bb(tI.INVALID_OPERATION);\n      const t = this.genMessage(jb.SetVideoProfile);\n      await this.signal.request(t), Qy.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: setVideoProfile success\"));\n    }\n    async stopChannelMediaRelay() {\n      await this.sendStopRelayMessage(), Qy.debug(\"[\".concat(this.clientId, \"] stopChannelMediaRelay: send stop message success\")), this.state = Wb.RELAY_STATE_IDLE, this.dispose();\n    }\n    dispose() {\n      Qy.debug(\"[\".concat(this.clientId, \"] disposeChannelMediaRelay\")), this.cancelToken.cancel(), this.cancelToken = pv.CancelToken.source(), this.state = Wb.RELAY_STATE_IDLE, this.emit(\"dispose\"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;\n    }\n    async connect() {\n      const e = await qO(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);\n      this.workerToken = e.workerToken, await this.signal.connect(e.addressList), this.emit(\"event\", Gb.NETWORK_CONNECTED), this.signal.on(\"status\", this.onStatus), this.signal.on(\"reconnecting\", this.onReconnect);\n    }\n    async sendStartRelayMessage(e) {\n      const t = this.genMessage(jb.StopPacketTransfer);\n      await this.signal.request(t), await this.signal.waitStatus(\"Normal Quit\"), Qy.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: StopPacketTransfer success\"));\n      const i = this.genMessage(jb.SetSdkProfile, e);\n      await this.signal.request(i), Qy.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: SetSdkProfile success\"));\n      const n = this.genMessage(jb.SetSourceChannel, e);\n      await this.signal.request(n), await this.signal.waitStatus(\"SetSourceChannelStatus\"), this.emit(\"event\", Gb.PACKET_JOINED_SRC_CHANNEL), Qy.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: SetSourceChannel success\"));\n      const r = this.genMessage(jb.SetSourceUserId, e);\n      await this.signal.request(r), Qy.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: SetSourceUserId success\"));\n      const o = this.genMessage(jb.SetDestChannel, e);\n      await this.signal.request(o), await this.signal.waitStatus(\"SetDestChannelStatus\"), this.emit(\"event\", Gb.PACKET_JOINED_DEST_CHANNEL), Qy.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: SetDestChannel success\"));\n      const s = this.genMessage(jb.StartPacketTransfer, e);\n      await this.signal.request(s), this.emit(\"event\", Gb.PACKET_SENT_TO_DEST_CHANNEL), this.state = Wb.RELAY_STATE_RUNNING, Qy.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: StartPacketTransfer success\")), this.setVideoProfile(this._resolution);\n    }\n    async sendUpdateMessage(e) {\n      const t = this.genMessage(jb.UpdateDestChannel, e);\n      await this.signal.request(t), this.emit(\"event\", Gb.PACKET_UPDATE_DEST_CHANNEL), Qy.debug(\"[\".concat(this.clientId, \"] sendUpdateMessage: UpdateDestChannel success\"));\n    }\n    async sendStopRelayMessage() {\n      const e = this.genMessage(jb.StopPacketTransfer);\n      await this.signal.request(e), Qy.debug(\"[\".concat(this.clientId, \"] sendStopRelayMessage: StopPacketTransfer success\"));\n    }\n    genMessage(e, t) {\n      const i = [],\n        n = [],\n        r = [];\n      this.requestId += 1;\n      const o = {\n        appId: this.joinInfo.appId,\n        cname: this.joinInfo.cname,\n        uid: this.joinInfo.uid.toString(),\n        sdkVersion: Iy,\n        sid: this.sid,\n        ts: Date.now(),\n        requestId: this.requestId,\n        seq: this.requestId,\n        allocate: !0,\n        clientRequest: {}\n      };\n      \"4.21.0\" === o.sdkVersion && (o.sdkVersion = \"0.0.1\");\n      let s = null,\n        a = null;\n      switch (e) {\n        case jb.SetSdkProfile:\n          return o.clientRequest = {\n            command: \"SetSdkProfile\",\n            type: \"multi_channel\"\n          }, o;\n        case jb.SetSourceChannel:\n          if (a = t && t.getSrcChannelMediaInfo(), !a) throw new bb(tI.UNEXPECTED_ERROR, \"can not find source config\");\n          return o.clientRequest = {\n            command: \"SetSourceChannel\",\n            uid: \"0\",\n            channelName: a.channelName,\n            token: a.token || this.joinInfo.appId\n          }, o;\n        case jb.SetSourceUserId:\n          if (a = t && t.getSrcChannelMediaInfo(), !a) throw new bb(tI.UNEXPECTED_ERROR, \"can not find source config\");\n          return o.clientRequest = {\n            command: \"SetSourceUserId\",\n            uid: a.uid + \"\"\n          }, o;\n        case jb.SetDestChannel:\n          if (s = t && t.getDestChannelMediaInfo(), !s) throw new bb(tI.UNEXPECTED_ERROR, \"can not find dest config\");\n          return s.forEach(e => {\n            i.push(e.channelName), n.push(e.uid + \"\"), r.push(e.token || this.joinInfo.appId);\n          }), o.clientRequest = {\n            command: \"SetDestChannel\",\n            channelName: i,\n            uid: n,\n            token: r\n          }, o;\n        case jb.StartPacketTransfer:\n          return o.clientRequest = {\n            command: \"StartPacketTransfer\"\n          }, o;\n        case jb.Reconnect:\n          return o.clientRequest = {\n            command: \"Reconnect\"\n          }, o;\n        case jb.StopPacketTransfer:\n          return o.clientRequest = {\n            command: \"StopPacketTransfer\"\n          }, o;\n        case jb.UpdateDestChannel:\n          if (s = t && t.getDestChannelMediaInfo(), !s) throw new bb(tI.UNEXPECTED_ERROR, \"can not find dest config\");\n          return s.forEach(e => {\n            i.push(e.channelName), n.push(e.uid + \"\"), r.push(e.token || this.joinInfo.appId);\n          }), o.clientRequest = {\n            command: \"UpdateDestChannel\",\n            channelName: i,\n            uid: n,\n            token: r\n          }, o;\n        case jb.SetVideoProfile:\n          o.clientRequest = {\n            command: \"SetVideoProfile\",\n            width: this._resolution.width,\n            height: this._resolution.height\n          };\n      }\n      return o;\n    }\n  }\n  function gG(e) {\n    var t = {},\n      i = !1;\n    function n(t, n) {\n      return i = !0, {\n        done: !1,\n        value: new nB(n = new dB(function (i) {\n          i(e[t](n));\n        }), 1)\n      };\n    }\n    return t[void 0 !== ZS && $S || \"@@iterator\"] = function () {\n      return this;\n    }, t.next = function (e) {\n      return i ? (i = !1, e) : n(\"next\", e);\n    }, \"function\" == typeof e.throw && (t.throw = function (e) {\n      if (i) throw i = !1, e;\n      return n(\"throw\", e);\n    }), \"function\" == typeof e.return && (t.return = function (e) {\n      return i ? (i = !1, e) : n(\"return\", e);\n    }), t;\n  }\n  var RG = i(lB);\n  function CG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function vG(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? CG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : CG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  var IG;\n  function yG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function AG(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? yG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : yG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let bG = (IG = class e extends iw {\n    get peerConnectionState() {\n      return this.peerConnection.connectionState;\n    }\n    get iceConnectionState() {\n      return this.peerConnection.iceConnectionState;\n    }\n    get currentLocalDescription() {\n      return this.peerConnection.currentLocalDescription;\n    }\n    get currentRemoteDescription() {\n      return this.peerConnection.currentRemoteDescription;\n    }\n    get localCodecs() {\n      return [...new Set(this.localCapabilities && this.localCapabilities.videoCodecs.map(e => e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").filter(e => {\n        var t;\n        return Dn(t = Object.keys(My)).call(t, e);\n      }))];\n    }\n    constructor(t, i) {\n      super(t, i), ng(this, \"store\", void 0), ng(this, \"peerConnection\", void 0), ng(this, \"remoteSDP\", void 0), ng(this, \"initialOffer\", void 0), ng(this, \"statsFilter\", void 0), ng(this, \"useRTX\", !1), ng(this, \"localCapabilities\", void 0), ng(this, \"localCandidateCount\", 0), ng(this, \"allCandidatesReceived\", !1), ng(this, \"establishPromise\", void 0), ng(this, \"mutex\", new uy(\"P2PConnection-mutex\")), this.store = i, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), {\n        optional: [{\n          googDscp: !0\n        }]\n      }), this.statsFilter = zB(this.peerConnection, Dy(\"STATS_UPDATE_INTERVAL\"), void 0, Pv() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();\n    }\n    async establish() {\n      try {\n        const e = await this.peerConnection.createOffer({\n          offerToReceiveAudio: !0,\n          offerToReceiveVideo: !0\n        });\n        if (!e.sdp) throw new Error(\"Cannot get initialOffer.sdp when trying to establish PeerConnection.\");\n        const t = ZB(e.sdp),\n          i = QB(e.sdp, {\n            filterRTX: !this.useRTX,\n            filterVideoFec: Dy(\"FILTER_VIDEO_FEC\"),\n            filterAudioFec: Dy(\"FILTER_AUDIO_FEC\"),\n            filterAudioCodec: [\"opus\"]\n          });\n        return this.localCapabilities = i, this.initialOffer = e, AG(AG({}, t), {}, {\n          rtpCapabilities: {\n            send: {\n              audioCodecs: [],\n              audioExtensions: [],\n              videoCodecs: [],\n              videoExtensions: []\n            },\n            recv: {\n              audioCodecs: [],\n              audioExtensions: [],\n              videoCodecs: [],\n              videoExtensions: []\n            },\n            sendrecv: i\n          },\n          offerSDP: e.sdp\n        });\n      } catch (e) {\n        throw new iI(tI.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString());\n      }\n    }\n    async connect(e, t, i, n, r, o) {\n      try {\n        if (!this.initialOffer) throw new Error(\"Cannot establish P2PConnection without initial offer.\");\n        this.remoteSDP = new class {\n          constructor(e) {\n            ng(this, \"sessionDesc\", void 0), ng(this, \"localCapabilities\", void 0), ng(this, \"rtpCapabilities\", void 0), ng(this, \"candidates\", void 0), ng(this, \"iceParameters\", void 0), ng(this, \"dtlsParameters\", void 0), ng(this, \"setup\", void 0), ng(this, \"currentMidIndex\", void 0), ng(this, \"cname\", void 0), e = GI(e);\n            const _e46 = e,\n              t = _e46.remoteIceParameters,\n              i = _e46.remoteDtlsParameters,\n              n = _e46.candidates,\n              r = _e46.remoteRTPCapabilities,\n              o = _e46.remoteSetup,\n              s = _e46.localCapabilities,\n              a = _e46.sdkCodec,\n              c = _e46.cname,\n              d = wB.parse(\"v=0\\no=- 0 0 IN IP4 127.0.0.1\\ns=AgoraGateway\\nt=0 0\\na=group:BUNDLE audio video\\na=msid-semantic: WMS\\na=ice-lite\\nm=audio 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=sendrecv\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:audio\\nm=video 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=sendrecv\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:video\\n\");\n            this.rtpCapabilities = r, this.candidates = n, this.iceParameters = t, this.dtlsParameters = i, this.setup = o, this.localCapabilities = s, this.cname = c;\n            for (let e = 0; e < d.mediaDescriptions.length; e++) {\n              const s = d.mediaDescriptions[e];\n              if (s.attributes.iceUfrag = t.iceUfrag, s.attributes.icePwd = t.icePwd, s.attributes.fingerprints = i.fingerprints, s.attributes.candidates = n, s.attributes.setup = o, \"video\" === s.media.mediaType) {\n                s.media.fmts = r.videoCodecs.map(e => e.payloadType.toString(10));\n                let e = r.videoCodecs.filter(e => {\n                  var t, i;\n                  return null === (t = e.rtpMap) || void 0 === t ? void 0 : Dn(i = t.encodingName.toLowerCase()).call(i, a);\n                });\n                0 === e.length && (e = r.videoCodecs), s.attributes.payloads = e, s.attributes.extmaps = r.videoExtensions;\n              }\n              \"audio\" === s.media.mediaType && (s.media.fmts = r.audioCodecs.map(e => e.payloadType.toString(10)), s.attributes.payloads = r.audioCodecs, s.attributes.extmaps = r.audioExtensions), d.mediaDescriptions[e] = this.mungMediaDesc(s);\n            }\n            this.sessionDesc = d, this.currentMidIndex = d.mediaDescriptions.length - 1;\n          }\n          toString() {\n            return wB.print(this.sessionDesc);\n          }\n          send(e, t, i) {\n            const _tj2 = tj(t, this.cname),\n              n = _tj2.ssrcs,\n              r = _tj2.ssrcGroups,\n              o = this.sessionDesc.mediaDescriptions.find(t => e === nw.VIDEO ? \"video\" === t.media.mediaType : \"audio\" === t.media.mediaType),\n              s = n[0].attributes.label,\n              a = n[0].attributes.mslabel;\n            return o.attributes.ssrcs = o.attributes.ssrcs.concat(n), o.attributes.ssrcGroups = o.attributes.ssrcGroups.concat(r), {\n              id: s,\n              mslabel: a\n            };\n          }\n          batchSend(e) {\n            return e.map(e => {\n              let t = e.kind,\n                i = e.ssrcMsg;\n              return this.send(t, i, void 0);\n            });\n          }\n          stopSending(e) {\n            this.sessionDesc.mediaDescriptions.forEach(t => {\n              const i = [],\n                n = [],\n                r = [];\n              t.attributes.ssrcs.forEach(t => {\n                Dn(e).call(e, t.attributes.label || \"\") ? r.push(t) : i.push(t);\n              }), t.attributes.ssrcGroups.forEach(e => {\n                var t;\n                Dn(t = r.map(e => e.ssrcId)).call(t, e.ssrcIds[0]) || n.push(e);\n              }), t.attributes.ssrcs = i, t.attributes.ssrcGroups = n;\n            });\n          }\n          mute(e) {\n            const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n            if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.mute.\"));\n            t.attributes.direction = \"inactive\";\n          }\n          unmute(e) {\n            const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n            if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.unmute.\"));\n            t.attributes.direction = \"sendonly\";\n          }\n          receive(e, t, i) {\n            e.forEach((e, t) => {\n              const i = e._mediaStreamTrack,\n                n = this.sessionDesc.mediaDescriptions.findIndex(e => e.attributes.mid === i.kind),\n                r = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n], e);\n              this.sessionDesc.mediaDescriptions[n] = r;\n            });\n          }\n          stopReceiving(e) {}\n          updateCandidates(e) {\n            e === rw.TCP ? this.candidates.forEach(e => {\n              -1 === this.candidates.findIndex(t => \"tcp\" === t.transport && t.connectionAddress === e.connectionAddress && t.port === e.port) && this.candidates.push(vG(vG({}, e), {}, {\n                foundation: \"tcpcandidate\",\n                priority: Number(e.priority) - 1 + \"\",\n                transport: \"tcp\",\n                port: Number(e.port) + 90 + \"\"\n              }));\n            }) : this.candidates = this.candidates.filter(e => \"tcp\" !== e.transport);\n            for (const e of this.sessionDesc.mediaDescriptions) e.attributes.candidates = this.candidates;\n          }\n          restartICE(e) {\n            e = GI(e), this.iceParameters = e, this.sessionDesc.mediaDescriptions.forEach(t => {\n              t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd;\n            });\n          }\n          predictReceivingMids(e) {\n            const t = [];\n            for (let i = 0; i < e; i++) t.push((this.currentMidIndex + i + 1).toString(10));\n            return t;\n          }\n          mungRecvMediaDsec(e, t) {\n            const i = GI(e);\n            return ij(i, t), rj(i, t), i;\n          }\n          updateRecvMedia(e, t) {\n            const i = this.sessionDesc.mediaDescriptions.findIndex(t => t.attributes.mid === e);\n            if (-1 !== i) {\n              const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i], t);\n              this.sessionDesc.mediaDescriptions[i] = e;\n            }\n          }\n          bumpMid(e) {\n            this.currentMidIndex += e;\n          }\n          updateTrackLabel(e, t, i) {\n            const n = this.sessionDesc.mediaDescriptions.find(t => e === nw.VIDEO ? \"video\" === t.attributes.mid : \"audio\" === t.attributes.mid);\n            if (n) {\n              const e = n.attributes.ssrcs.find(e => e.attributes.label === t);\n              var r;\n              e && (e.attributes.label = i, null === (r = e.attributes.msid) || void 0 === r || r.replace(t, i));\n            }\n          }\n          mungMediaDesc(e) {\n            const t = GI(e);\n            return nj(t), function (e) {\n              const t = e.attributes.extmaps.find(e => \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\" === e.extensionName);\n              t && e.attributes.extmaps.splice(e.attributes.extmaps.indexOf(t), 1), e.attributes.payloads.forEach(e => {\n                const t = e.rtcpFeedbacks.findIndex(e => \"transport-cc\" === e.type);\n                -1 !== t && e.rtcpFeedbacks.splice(t, 1);\n              });\n            }(t), t;\n          }\n          getSSRC(e) {\n            for (const t of this.sessionDesc.mediaDescriptions) for (const i of t.attributes.ssrcs) if (i.attributes.label === e) return [i];\n          }\n        }({\n          remoteIceParameters: e,\n          remoteDtlsParameters: t,\n          candidates: i,\n          remoteRTPCapabilities: n.send,\n          remoteSetup: r,\n          localCapabilities: this.localCapabilities,\n          sdkCodec: this.store.codec,\n          cname: o\n        });\n        const s = this.remoteSDP.toString();\n        await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: s\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.connect failed; \".concat(e.toString()));\n      }\n    }\n    async updateRemoteRTPCapabilities(e, t) {\n      throw new iI(tI.NOT_SUPPORTED, \"Planb mode does not support createDataChannels.\");\n    }\n    send(e, t) {\n      var i = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var n, r, o, s, a, c, d, l;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return rB(i.mutex.lock());\n            case 2:\n              n = _context4.sent;\n              _context4.prev = 3;\n              if (i.remoteSDP) {\n                _context4.next = 6;\n                break;\n              }\n              throw new Error(\"Cannot call P2PConnection.send before remote SDP created\");\n            case 6:\n              r = e.map(e => i.peerConnection.addTrack(e._mediaStreamTrack));\n              _context4.next = 9;\n              return rB(i.peerConnection.createOffer());\n            case 9:\n              o = _context4.sent;\n              s = wB.parse(o.sdp);\n              a = e.map(e => {\n                const t = e._mediaStreamTrack,\n                  n = s.mediaDescriptions.find(e => e.attributes.mid === t.kind);\n                if (!n) throw new Error(\"Cannot extract ssrc from mediaDescription.\");\n                return function (e, t, i) {\n                  const n = e.attributes.ssrcs.filter(e => e.attributes.label === t),\n                    r = e.attributes.ssrcGroups;\n                  if (0 === n.length) throw new Error(\"Cannot extract ssrc from plan-b SDP.\");\n                  if (r && n.length > 1) {\n                    const e = r.find(e => -1 !== e.ssrcIds.indexOf(n[0].ssrcId));\n                    return e ? [{\n                      ssrcId: e.ssrcIds[0],\n                      rtx: i ? e.ssrcIds[1] : void 0\n                    }] : [{\n                      ssrcId: n[0].ssrcId\n                    }];\n                  }\n                  return [{\n                    ssrcId: n[0].ssrcId\n                  }];\n                }(n, t.id, i.useRTX);\n              });\n              _context4.prev = 12;\n              _context4.next = 15;\n              return a;\n            case 15:\n              c = _context4.sent;\n              _context4.next = 21;\n              break;\n            case 18:\n              _context4.prev = 18;\n              _context4.t0 = _context4[\"catch\"](12);\n              throw r.forEach(e => {\n                Nv() && e.replaceTrack(null), i.peerConnection.removeTrack(e);\n              }), _context4.t0;\n            case 21:\n              d = i.mungSendOfferSDP(o.sdp, e);\n              i.remoteSDP.receive(e, t, c);\n              l = i.remoteSDP.toString();\n              _context4.next = 26;\n              return rB(i.peerConnection.setLocalDescription({\n                type: \"offer\",\n                sdp: d\n              }));\n            case 26:\n              _context4.next = 28;\n              return rB(i.applySendEncodings(r, e));\n            case 28:\n              _context4.next = 30;\n              return rB(i.peerConnection.setRemoteDescription({\n                type: \"answer\",\n                sdp: l\n              }));\n            case 30:\n              return _context4.abrupt(\"return\", e.map((e, t) => {\n                const i = e._mediaStreamTrack.id;\n                return {\n                  localSSRC: a[t],\n                  id: i\n                };\n              }));\n            case 33:\n              _context4.prev = 33;\n              _context4.t1 = _context4[\"catch\"](3);\n              throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.send failed; \".concat(_context4.t1.toString()));\n            case 36:\n              _context4.prev = 36;\n              n();\n              return _context4.finish(36);\n            case 39:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, null, [[3, 33, 36, 39], [12, 18]]);\n      }))();\n    }\n    async stopSending(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopSending before remote SDP created\");\n        const t = this.peerConnection.getSenders().filter(t => {\n          var i;\n          return -1 !== e.indexOf((null === (i = t.track) || void 0 === i ? void 0 : i.id) || \"\");\n        });\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.\");\n        t.map(e => {\n          Nv() && e.replaceTrack(null), this.peerConnection.removeTrack(e);\n        });\n        const i = await this.peerConnection.createOffer();\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.stopReceiving(e);\n        const n = this.remoteSDP.toString();\n        await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: n\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.stopSending failed; \".concat(e.toString()));\n      }\n    }\n    async receive(e, t, i, n) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.receive \".concat(e, \" before remoteSDP created.\"));\n        const _this$remoteSDP$send3 = this.remoteSDP.send(e, t, n),\n          i = _this$remoteSDP$send3.id,\n          r = _this$remoteSDP$send3.mslabel,\n          o = new Gu((t, n) => {\n            const o = setTimeout(() => {\n                n(new Error(\"Cannot receive track, id: \".concat(i)));\n              }, 1e4),\n              s = n => {\n                const a = Iv();\n                if ((\"Safari\" === a.name && 11 === Number(a.version) || Lv()) && n.track.id !== i && n.streams[0].id === r) {\n                  var c;\n                  const r = n.streams[0].getTracks()[0];\n                  return null === (c = this.remoteSDP) || void 0 === c || c.updateTrackLabel(e, i, n.track.id), this.peerConnection.removeEventListener(\"track\", s), clearTimeout(o), void t(r);\n                }\n                if (n.track.id === i) return this.peerConnection.removeEventListener(\"track\", s), clearTimeout(o), void t(n.track);\n              };\n            this.peerConnection.addEventListener(\"track\", s);\n          }),\n          s = this.remoteSDP.toString();\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: s\n        });\n        const a = await this.peerConnection.createAnswer();\n        await this.peerConnection.setLocalDescription(a);\n        return {\n          track: await o,\n          id: i\n        };\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async stopReceiving(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopReceiving before remote SDP created.\");\n        this.remoteSDP.stopSending(e);\n        const t = this.remoteSDP.toString();\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const i = await this.peerConnection.createAnswer();\n        await this.peerConnection.setLocalDescription(i);\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection stopReceiving failed; \".concat(e.toString()));\n      }\n    }\n    async muteRemote(e) {}\n    async unmuteRemote(e) {}\n    async muteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.muteLocal before remote SDP created.\");\n        const t = this.peerConnection.getSenders().filter(t => {\n          var i;\n          return -1 !== e.indexOf((null === (i = t.track) || void 0 === i ? void 0 : i.id) || \"\");\n        });\n        if (t.length !== e.length) throw new Error(\"sender' length doesn't match mids' length.\");\n        t.map(e => {\n          if (Nv() && e.track) e.track.enabled = !1;else {\n            const t = e.getParameters();\n            t.encodings.forEach(e => e.active = !1), e.setParameters(t);\n          }\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.muteLocal failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.unmuteLocal before remote SDP created.\");\n        const t = this.peerConnection.getSenders().filter(t => {\n          var i;\n          return -1 !== e.indexOf((null === (i = t.track) || void 0 === i ? void 0 : i.id) || \"\");\n        });\n        if (t.length !== e.length) throw new Error(\"Senders' length doesn't match mids' length.\");\n        t.map(async e => {\n          if (Nv() && e.track) e.track.enabled = !0;else {\n            const t = e.getParameters();\n            t.encodings.forEach(e => e.active = !0), await e.setParameters(t);\n          }\n        });\n        const i = await this.peerConnection.createOffer();\n        await this.peerConnection.setLocalDescription(i);\n        const n = this.remoteSDP.toString();\n        await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: n\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.unmuteLocal failed; \".concat(e.toString()));\n      }\n    }\n    restartICE(e) {\n      var t = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var i, n, r, _yield$r$iceParameter, o, s;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return rB(t.mutex.lock(\"From P2PConnection.restartICE\"));\n            case 2:\n              i = _context5.sent;\n              _context5.prev = 3;\n              if (t.remoteSDP) {\n                _context5.next = 6;\n                break;\n              }\n              throw new Error(\"Cannot restartICE before remoteSDP created.\");\n            case 6:\n              if (!_U().supportPCSetConfiguration) {\n                _context5.next = 11;\n                break;\n              }\n              i = t.peerConnection.getConfiguration(), n = e === rw.RELAY ? \"relay\" : \"all\";\n              i.iceTransportPolicy !== n && (Qy.debug(\"[\".concat(t.store.clientId, \"] restartICE change iceTransportPolicy from [\").concat(i.iceTransportPolicy, \"] to [\").concat(n, \"]\")), i.iceTransportPolicy = n, t.peerConnection.setConfiguration(i));\n              _context5.next = 13;\n              break;\n            case 11:\n              if (!(e === rw.RELAY)) {\n                _context5.next = 13;\n                break;\n              }\n              return _context5.abrupt(\"return\");\n            case 13:\n              e !== rw.RELAY && t.remoteSDP.updateCandidates(e);\n              _context5.next = 16;\n              return rB(t.peerConnection.createOffer({\n                iceRestart: !0\n              }));\n            case 16:\n              n = _context5.sent;\n              if (n.sdp) {\n                _context5.next = 19;\n                break;\n              }\n              throw new Error(\"Cannot restartICE because restart offer SDP does not exist.\");\n            case 19:\n              r = ZB(n.sdp);\n              _context5.next = 22;\n              return r.iceParameters;\n            case 22:\n              _yield$r$iceParameter = _context5.sent;\n              o = _yield$r$iceParameter.remoteIceParameters;\n              t.remoteSDP.restartICE(o);\n              s = t.remoteSDP.toString();\n              _context5.next = 28;\n              return rB(t.peerConnection.setLocalDescription(n));\n            case 28:\n              _context5.next = 30;\n              return rB(t.peerConnection.setRemoteDescription({\n                type: \"answer\",\n                sdp: s\n              }));\n            case 30:\n              _context5.next = 35;\n              break;\n            case 32:\n              _context5.prev = 32;\n              _context5.t0 = _context5[\"catch\"](3);\n              Qy.warning(\"[\".concat(t.store.clientId, \"] restart ICE failed, abort operation\"), _context5.t0);\n            case 35:\n              _context5.prev = 35;\n              i();\n              return _context5.finish(35);\n            case 38:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, null, [[3, 32, 35, 38]]);\n      }))();\n    }\n    close() {\n      var e;\n      this.peerConnection.close(), null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, \"closed\"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();\n    }\n    getStats() {\n      return this.statsFilter.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      return this.statsFilter.getVideoIsReady(e);\n    }\n    async updateEncoderConfig(e, t) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.updateEncoderConfig before remote SDP created.\");\n        const e = await this.peerConnection.createOffer(),\n          i = this.mungSendOfferSDP(e.sdp, [t]);\n        this.remoteSDP.updateRecvMedia(t._mediaStreamTrack.kind, t);\n        const n = this.remoteSDP.toString();\n        await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: i\n        }), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: n\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, e.toString());\n      }\n    }\n    async updateSendParameters(e, t) {\n      const i = this.peerConnection.getSenders().filter(t => {\n        var i;\n        return (null === (i = t.track) || void 0 === i ? void 0 : i.id) === e;\n      });\n      1 === i.length && (await this.applySendEncodings(i, [t]));\n    }\n    setStatsRemoteVideoIsReady(e, t) {\n      this.statsFilter.setVideoIsReady2(e, t);\n    }\n    async replaceTrack(e, t) {\n      const i = this.peerConnection.getSenders().find(e => {\n        var i;\n        return (null === (i = e.track) || void 0 === i ? void 0 : i.id) === t;\n      });\n      i && (await i.replaceTrack(e._mediaStreamTrack));\n    }\n    createDataChannels(e, t) {\n      throw new iI(tI.NOT_SUPPORTED, \"Planb mode does not support createDataChannels.\");\n    }\n    stopDataChannels(e) {\n      throw new iI(tI.NOT_SUPPORTED, \"Planb mode does not support stopDataChannels.\");\n    }\n    bindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = () => {\n        var e;\n        null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState);\n      }, this.peerConnection.onconnectionstatechange = () => {\n        var e;\n        null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState);\n      }, this.peerConnection.onicecandidate = e => {\n        e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, Qy.debug(\"[\".concat(this.store.clientId, \"] [pc-\").concat(this.store.p2pId, \"] local candidate count\"), this.localCandidateCount));\n      }, setTimeout(() => {\n        this.allCandidatesReceived || (this.allCandidatesReceived = !0, Qy.debug(\"[\".concat(this.store.clientId, \"] [pc-\").concat(this.store.p2pId, \"] onicecandidate timeout, local candidate count\"), this.localCandidateCount));\n      }, Dy(\"CANDIDATE_TIMEOUT\"));\n    }\n    unbindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;\n    }\n    static resolvePCConfiguration(t) {\n      const i = {\n        iceServers: [],\n        sdpSemantics: \"plan-b\"\n      };\n      return t.iceServers ? i.iceServers = t.iceServers : t.turnServer && \"off\" !== t.turnServer.mode && (bI(t.turnServer.servers) ? i.iceServers = t.turnServer.servers : (i.iceServers && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), Dy(\"USE_TURN_SERVER_OF_GATEWAY\") && i.iceServers && t.turnServer.serversFromGateway && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {\n        e.forceturn && (i.iceTransportPolicy = \"relay\");\n      }))), i;\n    }\n    static turnServerConfigToIceServers(e) {\n      const t = [];\n      return e.forEach(e => {\n        e.security ? e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turns:\".concat(e.turnServerURL, \":\").concat(e.tcpport, \"?transport=tcp\")\n        }) : (e.udpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.udpport, \"?transport=udp\")\n        }), e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.tcpport, \"?transport=tcp\")\n        }));\n      }), t;\n    }\n    async updateRtpSenderEncodings(e, t) {\n      var i;\n      if (!t) {\n        t = this.peerConnection.getSenders().find(t => {\n          var i;\n          return (null === (i = t.track) || void 0 === i ? void 0 : i.id) === e._mediaStreamTrack.id;\n        });\n      }\n      if (!t) return Qy.warn(\"[\".concat(e.getTrackId(), \"] no rtpSender found}\"));\n      if (!_U().supportSetRtpSenderParameters) return Qy.warn(\"Browser not support set rtp-sender parameters\");\n      const n = {},\n        r = {};\n      if (e instanceof vF) switch (e._optimizationMode) {\n        case \"motion\":\n          n.degradationPreference = \"maintain-framerate\";\n          break;\n        case \"detail\":\n          n.degradationPreference = \"maintain-resolution\";\n          break;\n        default:\n          n.degradationPreference = \"balanced\";\n      }\n      if (Dy(\"DSCP_TYPE\") && Jv()) {\n        var o;\n        const e = Dy(\"DSCP_TYPE\");\n        Dn(o = [\"very-low\", \"low\", \"medium\", \"high\"]).call(o, e) && (r.networkPriority = e);\n      }\n      const s = t.getParameters(),\n        a = null === (i = s.encodings) || void 0 === i ? void 0 : i[0];\n      a && Object.assign(a, r), Object.assign(s, n), Qy.debug(\"[\".concat(e.getTrackId(), \"] updateRtpSenderEncodings: \").concat(JSON.stringify(s.encodings))), await t.setParameters(s);\n    }\n    async applySendEncodings(e, t) {\n      try {\n        if (!_U().supportSetRtpSenderParameters) return;\n        if (e.length !== t.length) return;\n        for (let i = 0; i < e.length; i++) {\n          const n = e[i],\n            r = t[i];\n          n && r && (await this.updateRtpSenderEncodings(r, n));\n        }\n      } catch (e) {\n        Qy.debug(\"[\".concat(this.store.clientId, \"] Apply RTPSendEncodings failed.\"));\n      }\n    }\n    mungSendOfferSDP(e, t) {\n      const i = wB.parse(e);\n      return t.forEach((e, t) => {\n        const n = e._mediaStreamTrack,\n          r = i.mediaDescriptions.find(e => e.attributes.mid === n.kind);\n        r && ij(r, e);\n      }), wB.print(i);\n    }\n    bindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = e => {\n        var t;\n        null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoReceived = e => {\n        var t;\n        null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstAudioDecoded = e => {\n        var t;\n        null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoDecoded = (e, t, i) => {\n        var n;\n        null === (n = this.onFirstVideoDecoded) || void 0 === n || n.call(this, e, t, i);\n      }, this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedLocalCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedRemoteCandidateChanged) || void 0 === i || i.call(this, e, t);\n      };\n    }\n    unbindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;\n    }\n    async batchReceive(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.batchReceive before remoteSDP created.\");\n        const t = this.remoteSDP.batchSend(e).map((t, i) => {\n            let n = t.id,\n              r = t.mslabel;\n            const o = e[i].kind;\n            return new Gu((e, t) => {\n              const i = setTimeout(() => {\n                  t(new Error(\"Cannot receive track, id: \".concat(n)));\n                }, 1e4),\n                s = t => {\n                  const a = Iv();\n                  if (\"Safari\" === a.name && 11 === Number(a.version) && t.track.id !== n && t.streams[0].id === r) {\n                    var c;\n                    const r = t.streams[0].getTracks()[0];\n                    return null === (c = this.remoteSDP) || void 0 === c || c.updateTrackLabel(o, n, t.track.id), this.peerConnection.removeEventListener(\"track\", s), clearTimeout(i), void e({\n                      track: r,\n                      id: n\n                    });\n                  }\n                  if (t.track.id === n) return this.peerConnection.removeEventListener(\"track\", s), clearTimeout(i), void e({\n                    track: t.track,\n                    id: n\n                  });\n                };\n              this.peerConnection.addEventListener(\"track\", s);\n            });\n          }),\n          i = this.remoteSDP.toString();\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: i\n        });\n        const n = await this.peerConnection.createAnswer();\n        return await this.peerConnection.setLocalDescription(n), await Gu.all(t);\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async getRemoteSSRC(e) {\n      if (!this.remoteSDP) return;\n      const t = this.remoteSDP.getSSRC(e);\n      return null == t ? void 0 : t[0].ssrcId;\n    }\n    setConfiguration(t) {\n      if (_U().supportPCSetConfiguration) {\n        const i = e.resolvePCConfiguration(t);\n        this.peerConnection.setConfiguration(i);\n      }\n    }\n  }, nb(IG.prototype, \"connect\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"connect\"), IG.prototype), nb(IG.prototype, \"stopSending\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"stopSending\"), IG.prototype), nb(IG.prototype, \"receive\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"receive\"), IG.prototype), nb(IG.prototype, \"stopReceiving\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"stopReceiving\"), IG.prototype), nb(IG.prototype, \"muteRemote\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"muteRemote\"), IG.prototype), nb(IG.prototype, \"unmuteRemote\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"unmuteRemote\"), IG.prototype), nb(IG.prototype, \"muteLocal\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"muteLocal\"), IG.prototype), nb(IG.prototype, \"unmuteLocal\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"unmuteLocal\"), IG.prototype), nb(IG.prototype, \"close\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"close\"), IG.prototype), nb(IG.prototype, \"updateEncoderConfig\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"updateEncoderConfig\"), IG.prototype), nb(IG.prototype, \"updateSendParameters\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"updateSendParameters\"), IG.prototype), nb(IG.prototype, \"replaceTrack\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"replaceTrack\"), IG.prototype), nb(IG.prototype, \"getRemoteSSRC\", [wG], Object.getOwnPropertyDescriptor(IG.prototype, \"getRemoteSSRC\"), IG.prototype), IG);\n  function wG(e, t, i) {\n    const n = e[t];\n    if (\"function\" != typeof n) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"Locking from P2PConnection.\".concat(t));\n      try {\n        for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];\n        return await n.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  function OG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function NG(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? OG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : OG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  const DG = \"9\",\n    PG = 4e4;\n  function LG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function kG(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? LG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : LG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let MG = function (e) {\n    return e.BANDWIDTH = \"bandwidth\", e.CPU = \"cpu\", e.NONE = \"none\", e.OTHER = \"other\", e;\n  }({});\n  var UG = function (e) {\n    return e[e.DOWN = 0] = \"DOWN\", e[e.UP = 1] = \"UP\", e;\n  }(UG || {});\n  const xG = new Map();\n  function VG(e, t, i, n) {\n    let r = e.scale;\n    if (0 === r && n === UG.UP || r >= t.length - 1 && n === UG.DOWN) return e;\n    let o = kG(kG({}, e), {}, {\n      scale: n === UG.DOWN ? ++r : --r\n    });\n    switch (i) {\n      case \"maintain-framerate\":\n        o = kG(kG({}, o), t[r].motion);\n        break;\n      case \"maintain-resolution\":\n        o = kG(kG({}, o), t[r].detail);\n        break;\n      case \"balanced\":\n        o = kG(kG({}, o), t[r].balanced);\n    }\n    return o;\n  }\n  function FG(e, t) {\n    if (t) {\n      const i = {\n        overUse: 0,\n        underUse: 0,\n        adaptationList: BG(t)\n      };\n      xG.set(e, i);\n    } else xG.delete(e);\n  }\n  function BG(e) {\n    const t = kG({}, e),\n      i = t.bitrateMax,\n      n = t.frameRate,\n      r = t.scaleResolutionDownBy,\n      o = t.bitrateMin,\n      s = by.MIN_FRAME_RATE,\n      a = by.MAX_THRESHOLD_FRAMERATE,\n      c = by.MAX_SCALE,\n      d = by.BITRATE_MIN_THRESHOLD,\n      l = by.BITRATE_MAX_THRESHOLD,\n      h = by.BWE_SCALE_UP_THRESHOLD,\n      u = by.BWE_SCALE_DOWN_THRESHOLD,\n      p = by.PERF_SCALE_DOWN_THRESHOLD,\n      _ = by.PERF_SCALE_UP_THRESHOLD,\n      E = by.BALANCE_BITRATE_FACTOR,\n      m = by.BALANCE_FRAMERATE_FACTOR,\n      f = by.BALANCE_RESOLUTION_FACTOR,\n      T = by.MOTION_RESOLUTION_FACTOR,\n      S = by.MOTION_BITRATE_FACTOR,\n      g = by.DETAIL_FRAMERATE_FACTOR,\n      R = by.DETAIL_BITRATE_FACTOR,\n      C = Math.min(t.frameRate, a),\n      v = [{\n        scale: 0,\n        threshold: {\n          bwe_down: Math.round(Math.pow(u, 1) * i),\n          bwe_up: i,\n          fps_down: Math.round(Math.pow(p, 1) * C),\n          fps_up: n\n        },\n        balanced: {\n          scaleResolutionDownBy: 1,\n          frameRate: n,\n          bitrateMax: i,\n          bitrateMin: o\n        },\n        motion: {\n          scaleResolutionDownBy: 1,\n          frameRate: n,\n          bitrateMax: i,\n          bitrateMin: o\n        },\n        detail: {\n          scaleResolutionDownBy: 1,\n          frameRate: n,\n          bitrateMax: i,\n          bitrateMin: o\n        }\n      }];\n    for (let e = 1; e <= c; e++) {\n      const t = {\n          bwe_up: Math.round(Math.pow(h, e) * i),\n          bwe_down: Math.round(Math.pow(u, e + 1) * i),\n          fps_up: Math.round(Math.pow(_, e) * C),\n          fps_down: Math.round(Math.pow(p, e + 1) * C)\n        },\n        a = {\n          scaleResolutionDownBy: r / Math.pow(f, e),\n          frameRate: Math.max(Math.round(Math.pow(m, e) * n), s),\n          bitrateMax: Math.max(Math.round(Math.pow(E, e) * i), l),\n          bitrateMin: Math.max(Math.round(Math.pow(E, e) * o), d)\n        },\n        c = {\n          scaleResolutionDownBy: r / Math.pow(T, e),\n          frameRate: n,\n          bitrateMax: Math.max(Math.round(Math.pow(S, e) * i), l),\n          bitrateMin: Math.max(Math.round(Math.pow(S, e) * o), d)\n        },\n        I = {\n          scaleResolutionDownBy: 1,\n          frameRate: Math.max(Math.round(Math.pow(g, e) * n), s),\n          bitrateMax: Math.max(Math.round(Math.pow(R, e) * i), l),\n          bitrateMin: Math.max(Math.round(Math.pow(R, e) * o), d)\n        };\n      v.push({\n        scale: e,\n        threshold: t,\n        balanced: a,\n        motion: c,\n        detail: I\n      });\n    }\n    return v;\n  }\n  function jG(e, t, i, n, r, o) {\n    const s = xG.get(e) || {\n        overUse: 0,\n        underUse: 0,\n        adaptationList: BG(r)\n      },\n      a = s.adaptationList;\n    xG.set(e, s);\n    const c = by.OVERUSE_TIMES_THRESHOLD,\n      d = by.UNDERUSE_TIMES_THRESHOLD,\n      l = n.scale;\n    let h, u;\n    return \"number\" == typeof t && t > 0 && function (e, t, i, n) {\n      if (t >= i.length) return !1;\n      let r = i[t].threshold.fps_down;\n      return Dy(\"FORCE_AG_HIGH_FRAMERATE\") && \"maintain-framerate\" === n && (r = i[0].threshold.fps_down), e < r;\n    }(t, l, a, o) && (s.overUse++, u = MG.CPU, s.overUse > c) || \"number\" == typeof i && i > 0 && function (e, t, i) {\n      if (t >= i.length) return !1;\n      const n = i[t].threshold.bwe_down;\n      return e < n;\n    }(i, l, a) && (s.overUse++, u = MG.BANDWIDTH, s.overUse > c) ? (s.overUse = 0, s.underUse = 0, h = VG(n, a, o, UG.DOWN), [h, u]) : (\"number\" == typeof t && t > 0 && \"number\" == typeof i && i > 0 && function (e, t, i, n) {\n      if (0 === t) return;\n      let r = i[t].threshold.fps_up;\n      return Dy(\"FORCE_AG_HIGH_FRAMERATE\") && \"maintain-framerate\" === n && (r = i[1].threshold.fps_up), e > r;\n    }(t, l, a, o) && function (e, t, i) {\n      if (0 === t) return;\n      const n = i[t].threshold.bwe_up;\n      return e > n;\n    }(i, l, a) && (s.underUse++, s.underUse > d && (s.overUse = 0, s.underUse = 0, h = VG(n, a, o, UG.UP), 0 === h.scale && (u = MG.NONE))), [h, u]);\n  }\n  function GG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function WG(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? GG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : GG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function HG(e) {\n    var t;\n    return !!Dy(\"ENABLE_AG_ADAPTATION\") && !!(e instanceof IF || Dn(t = e._hints).call(t, LU.CUSTOM_TRACK)) && (!!Dy(\"FORCE_SUPPORT_AG_ADAPTATION\") || !!(function (e) {\n      const t = Iv();\n      if (t.os !== Sv.IOS || !t.osVersion) return !1;\n      const i = t.osVersion.split(\".\");\n      return Number(i[0]) >= e;\n    }(14) && xv(17, 4, !0) || Uv(14) && Vv(17, 4, !0)));\n  }\n  const KG = new Map();\n  function YG(e) {\n    const t = KG.get(e);\n    if (t) {\n      const i = t.timer,\n        n = t.adaptationFunc,\n        r = t.originConfig;\n      window.clearTimeout(i), n(r), KG.delete(e);\n    }\n    FG(e);\n  }\n  var qG;\n  function zG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function JG(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? zG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : zG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let XG = (qG = class e extends iw {\n    get currentLocalDescription() {\n      return this.peerConnection.currentLocalDescription;\n    }\n    get currentRemoteDescription() {\n      return this.peerConnection.currentRemoteDescription;\n    }\n    get peerConnectionState() {\n      return this.peerConnection.connectionState;\n    }\n    get iceConnectionState() {\n      return this.peerConnection.iceConnectionState;\n    }\n    get dtlsTransportState() {\n      var e, t;\n      return null !== (e = null === (t = this.peerConnection.getReceivers()[0]) || void 0 === t || null === (t = t.transport) || void 0 === t ? void 0 : t.state) && void 0 !== e ? e : null;\n    }\n    get localCodecs() {\n      return [...new Set(this.localCapabilities && this.localCapabilities.send.videoCodecs.map(e => e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").filter(e => {\n        var t;\n        return Dn(t = Object.keys(My)).call(t, e);\n      }))];\n    }\n    constructor(t, i) {\n      super(t, i), ng(this, \"store\", void 0), ng(this, \"peerConnection\", void 0), ng(this, \"id\", ey(5, \"connection-\")), ng(this, \"remoteSDP\", void 0), ng(this, \"initialOffer\", void 0), ng(this, \"transportEventReceiver\", void 0), ng(this, \"statsFilter\", void 0), ng(this, \"useXR\", Dy(\"USE_XR\")), ng(this, \"localCapabilities\", void 0), ng(this, \"remoteCodecs\", void 0), ng(this, \"localCandidateCount\", 0), ng(this, \"allCandidatesReceived\", !1), ng(this, \"dataStreamChannelMap\", new Map()), ng(this, \"establishPromise\", void 0), ng(this, \"recoveredDataChannelIds\", []), ng(this, \"currentDataChannelId\", 1), ng(this, \"mutex\", new uy(\"P2PConnection-mutex\")), ng(this, \"qualityLimitationReason\", MG.NONE), this.store = i, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), {\n        optional: [{\n          googDscp: !0\n        }]\n      }), this.statsFilter = zB(this.peerConnection, Dy(\"STATS_UPDATE_INTERVAL\"), void 0, Pv() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();\n    }\n    async updateRemoteRTPCapabilities(e, t) {\n      if (this.remoteCodecs = t, !this.remoteSDP) return void Qy.debug(\"[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: \".concat(this.localCodecs, \", codecs: \").concat(t));\n      if (this.remoteSDP.updateRemoteCodec(e, t, this.store.codec)) {\n        const e = await this.peerConnection.createOffer(),\n          t = this.logSDPExchange(e.sdp || \"\", \"offer\", \"local\", \"muteLocal\");\n        await this.peerConnection.setLocalDescription(e);\n        const i = this.remoteSDP.toString();\n        null == t || t(i), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: i\n        });\n      } else Qy.debug(\"[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.\");\n    }\n    async establish() {\n      try {\n        this.peerConnection.addTransceiver(\"video\", {\n          direction: \"recvonly\"\n        }), this.peerConnection.addTransceiver(\"audio\", {\n          direction: \"recvonly\"\n        });\n        const e = await this.peerConnection.createOffer();\n        if (!e.sdp) throw new Error(\"Cannot get initialOffer.sdp when trying to establish PeerConnection.\");\n        const t = ZB(e.sdp),\n          i = await cj({\n            filterRTX: !Dy(\"USE_PUB_RTX\") && !Dy(\"USE_SUB_RTX\"),\n            filterVideoFec: Dy(\"FILTER_VIDEO_FEC\"),\n            filterAudioFec: Dy(\"FILTER_AUDIO_FEC\"),\n            filterVideoCodec: Dy(\"FILTER_VIDEO_CODEC\")\n          }, {\n            useXR: this.useXR\n          });\n        return this.localCapabilities = hj(i), this.initialOffer = e, JG(JG({}, t), {}, {\n          rtpCapabilities: i,\n          offerSDP: e.sdp\n        });\n      } catch (e) {\n        throw new iI(tI.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString());\n      }\n    }\n    async connect(e, t, i, n, r, o) {\n      try {\n        if (!this.initialOffer) throw new Error(\"Cannot establish P2PConnection without initial offer.\");\n        this.remoteSDP = new class {\n          get localCapabilities() {\n            return GI(this._localCapabilities);\n          }\n          get rtpCapabilities() {\n            return GI(this._rtpCapabilities);\n          }\n          get candidates() {\n            return GI(this._candidates);\n          }\n          get iceParameters() {\n            return GI(this._iceParameters);\n          }\n          get dtlsParameters() {\n            return GI(this._dtlsParameters);\n          }\n          constructor(e) {\n            ng(this, \"sessionDesc\", void 0), ng(this, \"_localCapabilities\", void 0), ng(this, \"_rtpCapabilities\", void 0), ng(this, \"_candidates\", void 0), ng(this, \"_iceParameters\", void 0), ng(this, \"_dtlsParameters\", void 0), ng(this, \"setup\", void 0), ng(this, \"currentMidIndex\", void 0), ng(this, \"cname\", void 0), ng(this, \"firefoxSsrcMidMap\", new Map()), e = GI(e);\n            const _e47 = e,\n              t = _e47.remoteIceParameters,\n              i = _e47.remoteDtlsParameters,\n              n = _e47.candidates,\n              r = _e47.remoteRTPCapabilities,\n              o = _e47.remoteSetup,\n              s = _e47.localCapabilities,\n              a = _e47.cname,\n              c = wB.parse(\"v=0\\no=- 0 0 IN IP4 127.0.0.1\\ns=AgoraGateway\\nt=0 0\\na=group:BUNDLE 0 1\\na=msid-semantic: WMS\\na=ice-lite\\nm=video 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=sendonly\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:0\\nm=audio 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=sendonly\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:1\\n\");\n            this._rtpCapabilities = r, this._candidates = n, this._iceParameters = t, this._dtlsParameters = i, this._localCapabilities = s, this.setup = o, this.cname = a;\n            const d = this.rtpCapabilities.send;\n            for (const e of c.mediaDescriptions) {\n              if (e.attributes.iceUfrag = t.iceUfrag, e.attributes.icePwd = t.icePwd, e.attributes.fingerprints = i.fingerprints, e.attributes.candidates = n, e.attributes.setup = o, \"video\" === e.media.mediaType && (e.media.fmts = d.videoCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = d.videoCodecs, e.attributes.extmaps = d.videoExtensions, Dy(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n                const _tj3 = tj([{\n                    ssrcId: PG,\n                    rtx: Dy(\"USE_SUB_RTX\") ? 40001 : void 0\n                  }], this.cname),\n                  t = _tj3.ssrcs,\n                  i = _tj3.ssrcGroups;\n                e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n              }\n              if (\"audio\" === e.media.mediaType && (e.media.fmts = d.audioCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = d.audioCodecs, e.attributes.extmaps = d.audioExtensions, uj(e), Dy(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n                const _tj4 = tj([{\n                    ssrcId: 2e4\n                  }], this.cname),\n                  t = _tj4.ssrcs,\n                  i = _tj4.ssrcGroups;\n                e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n              }\n            }\n            this.sessionDesc = c, this.currentMidIndex = c.mediaDescriptions.length - 1;\n          }\n          preloadRemoteMedia() {\n            const e = Dy(\"PRELOAD_MEDIA_COUNT\");\n            this.rtpCapabilities;\n            const t = this.candidates,\n              i = this.dtlsParameters,\n              n = this.iceParameters,\n              r = this.rtpCapabilities.send;\n            for (let o = 1; o < e; o++) {\n              const e = 2 * o + 2e4,\n                s = 2 * o + PG,\n                _tj5 = tj([{\n                  ssrcId: e\n                }], this.cname),\n                a = _tj5.ssrcs,\n                c = _tj5.ssrcGroups,\n                _tj6 = tj([{\n                  ssrcId: s,\n                  rtx: Dy(\"USE_SUB_RTX\") ? s + 1 : void 0\n                }], this.cname),\n                d = _tj6.ssrcs,\n                l = _tj6.ssrcGroups;\n              this.sessionDesc.mediaDescriptions.push({\n                media: {\n                  mediaType: \"video\",\n                  port: DG,\n                  protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n                  fmts: r.videoCodecs.map(e => e.payloadType.toString(10))\n                },\n                connections: [{\n                  nettype: \"IN\",\n                  addrtype: \"IP4\",\n                  address: \"127.0.0.1\"\n                }],\n                bandwidths: [],\n                attributes: {\n                  iceUfrag: n.iceUfrag,\n                  icePwd: n.icePwd,\n                  unrecognized: [],\n                  candidates: t,\n                  extmaps: r.videoExtensions,\n                  fingerprints: i.fingerprints,\n                  imageattr: [],\n                  msids: [],\n                  remoteCandidatesList: [],\n                  rids: [],\n                  ssrcs: d,\n                  ssrcGroups: l,\n                  rtcpFeedbackWildcards: [],\n                  payloads: r.videoCodecs,\n                  rtcp: {\n                    port: \"9\",\n                    netType: \"IN\",\n                    addressType: \"IP4\",\n                    address: \"0.0.0.0\"\n                  },\n                  setup: this.setup,\n                  direction: \"sendonly\",\n                  rtcpMux: !0,\n                  rtcpRsize: !0,\n                  mid: \"\".concat(2 * o)\n                }\n              }), this.sessionDesc.mediaDescriptions.push({\n                media: {\n                  mediaType: \"audio\",\n                  port: DG,\n                  protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n                  fmts: r.audioCodecs.map(e => e.payloadType.toString(10))\n                },\n                connections: [{\n                  nettype: \"IN\",\n                  addrtype: \"IP4\",\n                  address: \"127.0.0.1\"\n                }],\n                bandwidths: [],\n                attributes: {\n                  iceUfrag: n.iceUfrag,\n                  icePwd: n.icePwd,\n                  unrecognized: [],\n                  candidates: t,\n                  extmaps: r.audioExtensions,\n                  fingerprints: i.fingerprints,\n                  imageattr: [],\n                  msids: [],\n                  remoteCandidatesList: [],\n                  rids: [],\n                  ssrcs: a,\n                  ssrcGroups: c,\n                  rtcpFeedbackWildcards: [],\n                  payloads: r.audioCodecs,\n                  rtcp: {\n                    port: \"9\",\n                    netType: \"IN\",\n                    addressType: \"IP4\",\n                    address: \"0.0.0.0\"\n                  },\n                  setup: this.setup,\n                  direction: \"sendonly\",\n                  rtcpMux: !0,\n                  rtcpRsize: !0,\n                  mid: \"\".concat(2 * o + 1)\n                }\n              }), this.currentMidIndex += 2;\n            }\n            this.updateBundleMids();\n          }\n          toString() {\n            return wB.print(this.sessionDesc);\n          }\n          send(e, t, i, n) {\n            const _tj7 = tj(t, this.cname, Dy(\"SYNC_GROUP\") ? i : void 0),\n              r = _tj7.ssrcs,\n              o = _tj7.ssrcGroups,\n              s = this.findPreloadMediaDesc(r);\n            if (s) {\n              if (Pv() && this.firefoxSsrcMidMap.set(r[0].ssrcId, s.attributes.mid), n && (n.twcc || n.remb)) {\n                const e = this.sessionDesc.mediaDescriptions.indexOf(s);\n                return this.sessionDesc.mediaDescriptions[e] = this.mungSendMediaDesc(s, n), {\n                  mid: s.attributes.mid,\n                  needExchangeSDP: !0\n                };\n              }\n              return {\n                mid: s.attributes.mid,\n                needExchangeSDP: !1\n              };\n            }\n            {\n              const t = this.findAvailableMediaIndex(e, r);\n              let i;\n              return -1 === t || 1 === t && (Nv() || Bv()) || 0 === t && Dy(\"USE_SUB_RTX\") || jv() ? (i = this.createOrRecycleSendMedia(e, r, o, \"sendonly\", n), this.updateBundleMids()) : (i = GI(this.sessionDesc.mediaDescriptions[t]), i.attributes.direction = \"sendonly\", i.attributes.ssrcs = r, i.attributes.ssrcGroups = o, this.sessionDesc.mediaDescriptions[t] = this.mungSendMediaDesc(i, n)), Pv() && this.firefoxSsrcMidMap.set(r[0].ssrcId, i.attributes.mid), {\n                mid: i.attributes.mid,\n                needExchangeSDP: !0\n              };\n            }\n          }\n          sendDataChannel() {\n            const _this$createOrRecycle = this.createOrRecycleDataChannel(),\n              e = _this$createOrRecycle.mediaDesc,\n              t = _this$createOrRecycle.needExchangeSDP;\n            return this.updateBundleMids(), {\n              mid: e.attributes.mid,\n              needExchangeSDP: t\n            };\n          }\n          batchSend(e) {\n            const t = e.map(e => {\n                let t = e.kind,\n                  i = e.ssrcMsg,\n                  n = e.mslabel;\n                return this.send(t, i, n);\n              }),\n              i = [];\n            let n = !1;\n            return t.forEach(e => {\n              let t = e.mid,\n                r = e.needExchangeSDP;\n              r && (n = !0), i.push(t);\n            }), {\n              mids: i,\n              needExchangeSDP: n\n            };\n          }\n          stopSending(e) {\n            const t = this.sessionDesc.mediaDescriptions.filter(t => t.attributes.mid && -1 !== e.indexOf(t.attributes.mid));\n            if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.\");\n            t.forEach(e => {\n              \"0\" === e.attributes.mid || Pv() || jv() ? e.attributes.ssrcs = [] : (e.attributes.ssrcs = [], e.attributes.direction = \"inactive\", e.media.port = \"0\");\n            }), this.updateBundleMids();\n          }\n          mute(e) {\n            const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n            if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.mute.\"));\n            t.attributes.direction = \"inactive\";\n          }\n          unmute(e) {\n            const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n            if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.unmute.\"));\n            t.attributes.direction = \"sendonly\";\n          }\n          muteRemote(e) {\n            const t = this.sessionDesc.mediaDescriptions.filter(t => Dn(e).call(e, t.attributes.mid || \"\"));\n            if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.\");\n            t.forEach(e => {\n              e.attributes.direction = \"inactive\";\n            });\n          }\n          unmuteRemote(e) {\n            const t = this.sessionDesc.mediaDescriptions.filter(t => Dn(e).call(e, t.attributes.mid || \"\"));\n            if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.\");\n            t.forEach(e => {\n              e.attributes.direction = \"recvonly\";\n            });\n          }\n          receive(e, t, i, n) {\n            e.forEach((e, r) => {\n              this.createOrRecycleRecvMedia(e, [], \"recvonly\", t, i, n[r]);\n            }), this.updateBundleMids();\n          }\n          stopReceiving(e) {\n            const t = this.sessionDesc.mediaDescriptions.filter(t => -1 !== e.indexOf(t.attributes.mid));\n            if (t.length !== e.length) throw new Error(\"MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.\");\n            t.forEach(e => {\n              e.media.port = \"0\", e.attributes.direction = \"inactive\";\n            }), this.updateBundleMids();\n          }\n          updateCandidates(e) {\n            const t = this._candidates.filter(e => \"udp\" === e.transport);\n            if (e === rw.TCP) {\n              if (0 === t.length) return;\n              if (Dy(\"TCP_CANDIDATE_ONLY\")) {\n                const e = this._candidates.filter(e => \"tcp\" === e.transport);\n                t.forEach(t => {\n                  -1 === e.findIndex(e => e.connectionAddress === t.connectionAddress) && e.push(NG(NG({}, t), {}, {\n                    foundation: \"tcpcandidate\",\n                    priority: Number(t.priority) - 1 + \"\",\n                    transport: \"tcp\",\n                    port: Number(t.port) + 90 + \"\"\n                  }));\n                }), this._candidates = e;\n              } else {\n                const e = [];\n                t.forEach(t => {\n                  e.push(NG(NG({}, t), {}, {\n                    foundation: \"tcpcandidate\",\n                    priority: Number(t.priority) - 1 + \"\",\n                    transport: \"tcp\",\n                    port: Number(t.port) + 90 + \"\"\n                  }));\n                }), this._candidates = [...t, ...e];\n              }\n            } else if (e === rw.RELAY) {\n              if (0 !== t.length) return;\n              {\n                const e = this._candidates.filter(e => \"tcp\" === e.transport);\n                e.forEach(e => {\n                  t.push(NG(NG({}, e), {}, {\n                    foundation: \"udpcandidate\",\n                    priority: Number(e.priority) + 1 + \"\",\n                    transport: \"udp\",\n                    port: Number(e.port) - 90 + \"\"\n                  }));\n                }), this._candidates = [...t, ...e];\n              }\n            } else 0 === t.length ? (this._candidates.filter(e => \"tcp\" === e.transport).forEach(e => {\n              t.push(NG(NG({}, e), {}, {\n                foundation: \"udpcandidate\",\n                priority: Number(e.priority) + 1 + \"\",\n                transport: \"udp\",\n                port: Number(e.port) - 90 + \"\"\n              }));\n            }), this._candidates = t) : this._candidates = this._candidates.filter(e => \"tcp\" !== e.transport);\n            for (const e of this.sessionDesc.mediaDescriptions) e.attributes.candidates = this.candidates;\n          }\n          restartICE(e) {\n            e = GI(e), this._iceParameters = e, this.sessionDesc.mediaDescriptions.forEach(t => {\n              t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd;\n            });\n          }\n          predictReceivingMids(e) {\n            const t = [];\n            for (let i = 0; i < e; i++) t.push((this.currentMidIndex + i + 1).toString(10));\n            return t;\n          }\n          findAvailableMediaIndex(e, t) {\n            return this.sessionDesc.mediaDescriptions.findIndex(i => {\n              const n = i.media.mediaType === e && \"0\" !== i.media.port && (\"sendonly\" === i.attributes.direction || \"sendrecv\" === i.attributes.direction) && 0 === i.attributes.ssrcs.length;\n              if (Pv()) {\n                if (n) {\n                  const e = this.firefoxSsrcMidMap.get(t[0].ssrcId);\n                  return !(e || \"0\" !== i.attributes.mid && \"1\" !== i.attributes.mid) || !(!e || e !== i.attributes.mid);\n                }\n                return !1;\n              }\n              return n;\n            });\n          }\n          createOrRecycleDataChannel() {\n            for (const e of this.sessionDesc.mediaDescriptions) if (\"application\" === e.media.mediaType) return {\n              mediaDesc: e,\n              needExchangeSDP: !1\n            };\n            this.currentMidIndex += 1;\n            const e = \"\".concat(this.currentMidIndex),\n              t = {\n                media: {\n                  mediaType: \"application\",\n                  port: DG,\n                  protos: [\"UDP\", \"DTLS\", \"SCTP\"],\n                  fmts: [\"webrtc-datachannel\"]\n                },\n                connections: [{\n                  nettype: \"IN\",\n                  addrtype: \"IP4\",\n                  address: \"127.0.0.1\"\n                }],\n                bandwidths: [],\n                attributes: {\n                  iceUfrag: this.iceParameters.iceUfrag,\n                  icePwd: this.iceParameters.icePwd,\n                  unrecognized: [],\n                  candidates: this.candidates,\n                  extmaps: [],\n                  fingerprints: this.dtlsParameters.fingerprints,\n                  imageattr: [],\n                  msids: [],\n                  remoteCandidatesList: [],\n                  rids: [],\n                  ssrcs: [],\n                  ssrcGroups: [],\n                  rtcpFeedbackWildcards: [],\n                  payloads: [],\n                  rtcp: {\n                    port: \"9\",\n                    netType: \"IN\",\n                    addressType: \"IP4\",\n                    address: \"0.0.0.0\"\n                  },\n                  setup: this.setup,\n                  mid: \"\".concat(e),\n                  sctpPort: \"5000\"\n                }\n              };\n            return this.sessionDesc.mediaDescriptions.push(t), {\n              mediaDesc: t,\n              needExchangeSDP: !0\n            };\n          }\n          createOrRecycleRecvMedia(e, t, i, n, r, o) {\n            const s = e._mediaStreamTrack.kind,\n              a = this.rtpCapabilities.recv,\n              c = _j(s, a, this.localCapabilities.send, s === nw.VIDEO ? n : r),\n              d = s === nw.VIDEO ? a.videoExtensions : a.audioExtensions;\n            this.currentMidIndex += 1;\n            const l = \"\".concat(this.currentMidIndex);\n            let h = {\n              media: {\n                mediaType: s,\n                port: DG,\n                protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n                fmts: c.map(e => e.payloadType.toString(10))\n              },\n              connections: [{\n                nettype: \"IN\",\n                addrtype: \"IP4\",\n                address: \"127.0.0.1\"\n              }],\n              bandwidths: [],\n              attributes: {\n                iceUfrag: this.iceParameters.iceUfrag,\n                icePwd: this.iceParameters.icePwd,\n                unrecognized: [],\n                candidates: this.candidates,\n                extmaps: d,\n                fingerprints: this.dtlsParameters.fingerprints,\n                imageattr: [],\n                msids: [],\n                remoteCandidatesList: [],\n                rids: [],\n                ssrcs: t,\n                ssrcGroups: [],\n                rtcpFeedbackWildcards: [],\n                payloads: c,\n                rtcp: {\n                  port: \"9\",\n                  netType: \"IN\",\n                  addressType: \"IP4\",\n                  address: \"0.0.0.0\"\n                },\n                setup: this.setup,\n                direction: i,\n                rtcpMux: !0,\n                rtcpRsize: !0,\n                mid: \"\".concat(l)\n              }\n            };\n            h = this.mungRecvMediaDsec(h, e, o);\n            const u = this.findFirstClosedMedia(s);\n            if (u) {\n              const e = this.sessionDesc.mediaDescriptions.indexOf(u);\n              this.sessionDesc.mediaDescriptions[e] = h;\n            } else this.sessionDesc.mediaDescriptions.push(h);\n            return h;\n          }\n          updateRemoteCodec(e, t, i) {\n            const n = [...new Set(this._rtpCapabilities.recv.videoCodecs.map(e => e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").filter(e => {\n                var t;\n                return Dn(t = Object.keys(My)).call(t, e);\n              }))],\n              r = new Set(t);\n            if (n.every(e => r.has(e))) return Qy.debug(\"codecs has not changed, no need to updateRemoteCodec, codecs: \".concat(t)), !1;\n            const o = this._rtpCapabilities.recv.videoCodecs.filter(e => t.some(t => {\n              var i;\n              return Dn(i = e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").call(i, t);\n            }));\n            if (0 === o.length) return Qy.debug(\"updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: \".concat(n, \" codecs: \").concat(t)), !1;\n            const s = [...new Set(o.map(e => e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\"))];\n            let a;\n            if (Qy.debug(\"updateRemoteCodec, from \".concat(n, \" to \").concat(s)), 0 === e.length) a = this.sessionDesc.mediaDescriptions.filter(e => \"video\" === e.media.mediaType && \"recvonly\" === e.attributes.direction);else if (a = this.sessionDesc.mediaDescriptions.filter(t => t.attributes.mid && Dn(e).call(e, t.attributes.mid) && \"recvonly\" === t.attributes.direction), a.length !== e.length) return Qy.debug(\"updateRemoteCodec failed, because cannot find mids, mids: \".concat(e, \", codecs: \").concat(t)), !1;\n            if (Dy(\"USE_PUB_RTX\") || Dy(\"USE_SUB_RTX\")) {\n              const e = Ej(o, this.rtpCapabilities.recv.videoCodecs);\n              o.push(...e);\n            }\n            this._rtpCapabilities.recv.videoCodecs = o;\n            const c = this.localCapabilities.send,\n              d = this.rtpCapabilities.recv,\n              l = _j(nw.VIDEO, d, c, i);\n            return a.forEach(e => {\n              const t = l.map(e => e.payloadType.toString(10));\n              Qy.debug(\"updateRemoteCodec mid: \".concat(e.attributes.mid, \", from \").concat(e.attributes.payloads, \" to \").concat(l)), e.attributes.payloads = l, e.media.fmts = t;\n            }), !0;\n          }\n          createOrRecycleSendMedia(e, t, i, n, r) {\n            const o = this.rtpCapabilities.send,\n              s = e === nw.VIDEO ? o.videoCodecs : o.audioCodecs,\n              a = e === nw.VIDEO ? o.videoExtensions : o.audioExtensions;\n            this.currentMidIndex += 1;\n            const c = \"\".concat(this.currentMidIndex);\n            let d = {\n              media: {\n                mediaType: e,\n                port: DG,\n                protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n                fmts: s.map(e => e.payloadType.toString(10))\n              },\n              connections: [{\n                nettype: \"IN\",\n                addrtype: \"IP4\",\n                address: \"127.0.0.1\"\n              }],\n              bandwidths: [],\n              attributes: {\n                iceUfrag: this.iceParameters.iceUfrag,\n                icePwd: this.iceParameters.icePwd,\n                unrecognized: [],\n                candidates: this.candidates,\n                extmaps: a,\n                fingerprints: this.dtlsParameters.fingerprints,\n                imageattr: [],\n                msids: [],\n                remoteCandidatesList: [],\n                rids: [],\n                ssrcs: t,\n                ssrcGroups: i,\n                rtcpFeedbackWildcards: [],\n                payloads: s,\n                rtcp: {\n                  port: \"9\",\n                  netType: \"IN\",\n                  addressType: \"IP4\",\n                  address: \"0.0.0.0\"\n                },\n                setup: this.setup,\n                direction: n,\n                rtcpMux: !0,\n                rtcpRsize: !0,\n                mid: \"\".concat(c)\n              }\n            };\n            d = this.mungSendMediaDesc(d, r);\n            const l = this.findFirstClosedMedia(e);\n            if (l) {\n              const e = this.sessionDesc.mediaDescriptions.indexOf(l);\n              this.sessionDesc.mediaDescriptions[e] = d;\n            } else this.sessionDesc.mediaDescriptions.push(d);\n            return d;\n          }\n          updateBundleMids() {\n            this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter(e => \"0\" !== e.media.port).map(e => e.attributes.mid);\n          }\n          mungRecvMediaDsec(e, t, i) {\n            const n = GI(e);\n            return nj(n), ij(n, t), rj(n, t), oj(n), sj(n, i, this.localCapabilities.send), n;\n          }\n          mungSendMediaDesc(e, t) {\n            const i = GI(e);\n            return sj(i, t, this.localCapabilities.recv), uj(i), i;\n          }\n          updateRecvMedia(e, t) {\n            const i = this.sessionDesc.mediaDescriptions.findIndex(t => t.attributes.mid === e);\n            if (-1 !== i) {\n              const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i], t);\n              this.sessionDesc.mediaDescriptions[i] = e;\n            }\n          }\n          bumpMid(e) {\n            this.currentMidIndex += e;\n          }\n          findFirstClosedMedia(e) {\n            return this.sessionDesc.mediaDescriptions.find(t => Pv() ? \"0\" === t.media.port && t.media.mediaType === e : \"0\" === t.media.port);\n          }\n          findPreloadMediaDesc(e) {\n            return this.sessionDesc.mediaDescriptions.find(t => {\n              var i;\n              return (null === (i = t.attributes) || void 0 === i || null === (i = i.ssrcs[0]) || void 0 === i ? void 0 : i.ssrcId) === e[0].ssrcId;\n            });\n          }\n          getSSRC(e) {\n            var t;\n            return null === (t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e)) || void 0 === t ? void 0 : t.attributes.ssrcs;\n          }\n        }({\n          remoteIceParameters: e,\n          remoteDtlsParameters: t,\n          candidates: i,\n          remoteRTPCapabilities: n,\n          remoteSetup: r,\n          localCapabilities: this.localCapabilities,\n          cname: o\n        }), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);\n        const s = this.remoteSDP.toString(),\n          a = wB.parse(this.initialOffer.sdp),\n          c = a.mediaDescriptions.find(e => \"audio\" === e.media.mediaType);\n        c && uj(c), this.useXR && pj(a);\n        const d = wB.print(a),\n          l = this.logSDPExchange(d || \"\", \"offer\", \"local\", \"connect\");\n        this.store.descriptionStart(), await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: d\n        }), null == l || l(s), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: s\n        });\n        const h = this.peerConnection.getTransceivers()[0];\n        if (null != h && h.receiver && this.tryBindTransportEvents(h.receiver), Dy(\"PRELOAD_MEDIA_COUNT\") > 0) {\n          this.remoteSDP.preloadRemoteMedia();\n          const e = this.remoteSDP.toString();\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: e\n          });\n          const t = await this.peerConnection.createAnswer();\n          await this.peerConnection.setLocalDescription(t);\n        }\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.connect failed; \".concat(e.toString()));\n      }\n    }\n    send(e, t, i) {\n      var n = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var r, o, s, a, c, d, l, h, u, p;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return rB(n.mutex.lock(\"From P2PConnection.send\"));\n            case 2:\n              r = _context6.sent;\n              _context6.prev = 3;\n              if (n.remoteSDP) {\n                _context6.next = 6;\n                break;\n              }\n              throw new Error(\"Cannot call P2PConnection.send before remote SDP created\");\n            case 6:\n              o = [];\n              e.forEach(e => {\n                const t = n.peerConnection.addTransceiver(e._mediaStreamTrack, {\n                  direction: \"sendonly\"\n                });\n                o.push(t), e._updateRtpTransceiver(t);\n              });\n              _context6.t0 = Pv() && !0 === Dy(\"SIMULCAST\");\n              if (!_context6.t0) {\n                _context6.next = 12;\n                break;\n              }\n              _context6.next = 12;\n              return rB(n.applySimulcastForFirefox(o, e));\n            case 12:\n              _context6.next = 14;\n              return rB(n.peerConnection.createOffer());\n            case 14:\n              s = _context6.sent;\n              a = n.remoteSDP.predictReceivingMids(e.length);\n              c = n.mungSendOfferSDP(s.sdp, e, a);\n              d = wB.parse(c);\n              l = a.map(e => {\n                const t = d.mediaDescriptions.find(t => t.attributes.mid === e);\n                if (!t) throw new Error(\"Cannot extract ssrc from mediaDescription.\");\n                return $B(t, Dy(\"USE_PUB_RTX\"));\n              });\n              _context6.prev = 19;\n              _context6.next = 22;\n              return l;\n            case 22:\n              h = _context6.sent;\n              _context6.next = 36;\n              break;\n            case 25:\n              _context6.prev = 25;\n              _context6.t1 = _context6[\"catch\"](19);\n              h = [], n.remoteSDP.receive(e, t, i, h);\n              o = n.remoteSDP.toString();\n              _context6.next = 31;\n              return rB(n.peerConnection.setLocalDescription({\n                type: \"offer\",\n                sdp: c\n              }));\n            case 31:\n              _context6.next = 33;\n              return rB(n.peerConnection.setRemoteDescription({\n                type: \"answer\",\n                sdp: o\n              }));\n            case 33:\n              _context6.next = 35;\n              return rB(n.stopSending(a, !0));\n            case 35:\n              throw _context6.t1;\n            case 36:\n              n.remoteSDP.receive(e, t, i, h);\n              u = n.remoteSDP.toString(), p = n.logSDPExchange(c, \"offer\", \"local\", \"send\");\n              _context6.next = 40;\n              return rB(n.peerConnection.setLocalDescription({\n                type: \"offer\",\n                sdp: c\n              }));\n            case 40:\n              _context6.next = 42;\n              return rB(n.applySimulcastEncodings(o, e));\n            case 42:\n              _context6.next = 44;\n              return rB(n.applySendEncodings(o, e));\n            case 44:\n              null == p || p(u);\n              _context6.next = 47;\n              return rB(n.peerConnection.setRemoteDescription({\n                type: \"answer\",\n                sdp: u\n              }));\n            case 47:\n              return _context6.abrupt(\"return\", o.map((e, t) => {\n                const i = a[t];\n                return {\n                  localSSRC: l[t],\n                  id: i,\n                  transceiver: e\n                };\n              }));\n            case 50:\n              _context6.prev = 50;\n              _context6.t2 = _context6[\"catch\"](3);\n              throw _context6.t2 instanceof iI ? _context6.t2 : new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.send failed; \".concat(_context6.t2.toString()));\n            case 53:\n              _context6.prev = 53;\n              r();\n              return _context6.finish(53);\n            case 56:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, null, [[3, 50, 53, 56], [19, 25]]);\n      }))();\n    }\n    async createDataChannels(e, t) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.createDataChannels before remote SDP created\");\n        let i = this.dataStreamChannelMap.get(e);\n        if (i && \"open\" === i.readyState) Qy.debug(\"[P2PConnection] Channels are already available and can be reused directly.\");else {\n          const t = this.currentDataChannelId < 1023 ? this.currentDataChannelId++ : this.recoveredDataChannelIds.shift();\n          if (\"number\" != typeof t) throw new Error(\"create DataChannel error, because cannot get dc id\");\n          i = this.peerConnection.createDataChannel(\"datastream-channel\", {\n            id: t,\n            negotiated: !0,\n            ordered: !1,\n            maxRetransmits: Dy(\"DATASTREAM_MAX_RETRANSMITS\")\n          }), i.binaryType = \"arraybuffer\", this.dataStreamChannelMap.set(e, i);\n        }\n        t.forEach(e => {\n          e._updateOriginDataChannel(i);\n        });\n        const _this$remoteSDP$sendD = this.remoteSDP.sendDataChannel(),\n          n = _this$remoteSDP$sendD.needExchangeSDP;\n        if (n) {\n          const e = this.remoteSDP.toString();\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: e\n          });\n          const t = await this.peerConnection.createAnswer();\n          await this.peerConnection.setLocalDescription(t), Qy.debug(\"[P2PConnection] createDataChannels by exchanging SDP.\");\n        } else Qy.debug(\"[P2PConnection] createDataChannels no need to exchange SDP.\");\n        return;\n      } catch (e) {\n        throw e instanceof iI ? e : new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.createDataChannels failed; \".concat(e.toString()));\n      }\n    }\n    async stopDataChannels(e) {\n      try {\n        const t = this.dataStreamChannelMap.get(e);\n        return t && (t.id && this.recoveredDataChannelIds.push(t.id), t.close()), void this.dataStreamChannelMap.delete(e);\n      } catch (e) {\n        throw e instanceof iI ? e : new iI(tI.DATACHANNEL_FAILED, \"P2PConnection.stopDataChannels failed; \".concat(e.toString()));\n      }\n    }\n    async stopSending(e, t) {\n      const i = t ? void 0 : await this.mutex.lock(\"From P2PConnection.stopSending\");\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopSending before remote SDP created\");\n        const t = this.peerConnection.getTransceivers().filter(t => -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.\");\n        t.map(e => {\n          var t;\n          YG(this.id + e.mid), e.direction = \"inactive\", null === (t = e.stop) || void 0 === t || t.call(e);\n        });\n        const n = await this.peerConnection.createOffer(),\n          r = this.logSDPExchange(n.sdp || \"\", \"offer\", \"local\", \"stopSending\");\n        await this.peerConnection.setLocalDescription(n), this.remoteSDP.stopReceiving(e);\n        const o = this.remoteSDP.toString();\n        null == r || r(o), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: o\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.stopSending failed; \".concat(e.toString()));\n      } finally {\n        i && i();\n      }\n    }\n    async receive(e, t, i, n) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.receive \".concat(e, \" before remoteSDP created.\"));\n        const _this$remoteSDP$send4 = this.remoteSDP.send(e, t, i, n),\n          r = _this$remoteSDP$send4.mid,\n          o = _this$remoteSDP$send4.needExchangeSDP;\n        if (o) {\n          const t = this.remoteSDP.toString(),\n            i = this.logSDPExchange(t, \"offer\", \"remote\", \"receive\");\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: t\n          });\n          const n = await this.peerConnection.createAnswer(),\n            o = this.mungReceiveAnswerSDP(n.sdp, r, e);\n          null == i || i(o || \"\"), await this.peerConnection.setLocalDescription({\n            type: \"answer\",\n            sdp: o\n          }), Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PConnection] receive \").concat(e, \" by exchanging SDP.\"));\n        } else Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PConnection] receive \").concat(e, \" no need to exchange SDP.\"));\n        const s = this.peerConnection.getTransceivers().find(e => e.mid === r);\n        if (!s) throw new Error(\"Cannot get transceiver after setLocalDescription.\");\n        return {\n          track: s.receiver.track,\n          id: r,\n          transceiver: s\n        };\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async batchReceive(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.batchReceive before remoteSDP created.\");\n        const _this$remoteSDP$batch = this.remoteSDP.batchSend(e),\n          t = _this$remoteSDP$batch.mids,\n          i = _this$remoteSDP$batch.needExchangeSDP;\n        if (i) {\n          const e = this.remoteSDP.toString(),\n            t = this.logSDPExchange(e, \"offer\", \"remote\", \"receive\");\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: e\n          });\n          const i = await this.peerConnection.createAnswer();\n          null == t || t(i.sdp || \"\"), await this.peerConnection.setLocalDescription(i), Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PConnection] batchReceive by exchanging SDP.\"));\n        } else Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PConnection] batchReceive no need to exchange SDP.\"));\n        return t.map(e => {\n          const t = this.peerConnection.getTransceivers().find(t => t.mid === e);\n          if (!t) throw new Error(\"Cannot get transceiver after setLocalDescription.\");\n          return {\n            track: t.receiver.track,\n            id: e,\n            transceiver: t\n          };\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async stopReceiving(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopReceiving before remote SDP created.\");\n        this.remoteSDP.stopSending(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"stopReceiving\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const n = await this.peerConnection.createAnswer();\n        null == i || i(n.sdp || \"\"), await this.peerConnection.setLocalDescription(n);\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection stopReceiving failed; \".concat(e.toString()));\n      }\n    }\n    async muteRemote(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.muteRemote mid=\".concat(e, \" before remote SDP created.\"));\n        this.remoteSDP.mute(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"muteRemote\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const n = await this.peerConnection.createAnswer();\n        null == i || i(n.sdp || \"\"), await this.peerConnection.setLocalDescription(n);\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.muteRemote failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteRemote(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.unmuteRemote mid=\".concat(e, \" before remote SDP created.\"));\n        this.remoteSDP.unmute(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"unmuteRemote\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const n = await this.peerConnection.createAnswer();\n        null == i || i(n.sdp || \"\"), await this.peerConnection.setLocalDescription(n);\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.unmuteRemote failed; \".concat(e.toString()));\n      }\n    }\n    async muteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.muteLocal before remote SDP created.\");\n        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length.\");\n        t.map(e => {\n          e.direction = \"inactive\";\n        });\n        const i = await this.peerConnection.createOffer(),\n          n = this.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"muteLocal\");\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.muteRemote(e);\n        const r = this.remoteSDP.toString();\n        null == n || n(r), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.muteLocal failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.unmuteLocal before remote SDP created.\");\n        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length.\");\n        t.map(async (e, t) => {\n          e.direction = \"sendonly\";\n        });\n        const i = await this.peerConnection.createOffer(),\n          n = this.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"unmuteLocal\");\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.unmuteRemote(e);\n        const r = this.remoteSDP.toString();\n        null == n || n(r), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, \"P2PConnection.unmuteLocal failed; \".concat(e.toString()));\n      }\n    }\n    restartICE(e) {\n      var t = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var i, n, r, _yield$r$iceParameter2, o, s, a;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return rB(t.mutex.lock(\"From P2PConnection.restartICE\"));\n            case 2:\n              i = _context7.sent;\n              _context7.prev = 3;\n              if (t.remoteSDP) {\n                _context7.next = 6;\n                break;\n              }\n              throw new Error(\"Cannot restartICE before remoteSDP created.\");\n            case 6:\n              if (!_U().supportPCSetConfiguration) {\n                _context7.next = 11;\n                break;\n              }\n              i = t.peerConnection.getConfiguration(), n = e === rw.RELAY ? \"relay\" : \"all\";\n              i.iceTransportPolicy !== n && (Qy.debug(\"[\".concat(t.store.clientId, \"] restartICE change iceTransportPolicy from [\").concat(i.iceTransportPolicy, \"] to [\").concat(n, \"]\")), i.iceTransportPolicy = n, t.peerConnection.setConfiguration(i));\n              _context7.next = 13;\n              break;\n            case 11:\n              if (!(e === rw.RELAY)) {\n                _context7.next = 13;\n                break;\n              }\n              return _context7.abrupt(\"return\");\n            case 13:\n              t.remoteSDP.updateCandidates(e);\n              _context7.next = 16;\n              return rB(t.peerConnection.createOffer({\n                iceRestart: !0\n              }));\n            case 16:\n              n = _context7.sent;\n              if (n.sdp) {\n                _context7.next = 19;\n                break;\n              }\n              throw new Error(\"Cannot restartICE because restart offer SDP does not exist.\");\n            case 19:\n              r = ZB(n.sdp);\n              _context7.next = 22;\n              return r.iceParameters;\n            case 22:\n              _yield$r$iceParameter2 = _context7.sent;\n              o = _yield$r$iceParameter2.remoteIceParameters;\n              t.remoteSDP.restartICE(o);\n              s = t.remoteSDP.toString(), a = t.logSDPExchange(n.sdp || \"\", \"offer\", \"local\", \"restartICE\");\n              t.store.descriptionStart();\n              _context7.next = 29;\n              return rB(t.peerConnection.setLocalDescription(n));\n            case 29:\n              null == a || a(s);\n              _context7.next = 32;\n              return rB(t.peerConnection.setRemoteDescription({\n                type: \"answer\",\n                sdp: s\n              }));\n            case 32:\n              _context7.next = 37;\n              break;\n            case 34:\n              _context7.prev = 34;\n              _context7.t0 = _context7[\"catch\"](3);\n              Qy.warning(\"[\".concat(t.store.clientId, \"] restart ICE failed, abort operation\"), _context7.t0);\n            case 37:\n              _context7.prev = 37;\n              i();\n              return _context7.finish(37);\n            case 40:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, null, [[3, 34, 37, 40]]);\n      }))();\n    }\n    close() {\n      var e;\n      this.peerConnection.getTransceivers().forEach(e => {\n        YG(this.id + e.mid);\n      }), this.peerConnection.close(), null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, \"closed\"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear(), this.recoveredDataChannelIds = [], this.currentDataChannelId = 1;\n    }\n    getStats() {\n      return JG(JG({}, this.statsFilter.getStats()), {}, {\n        qualityLimitationReason: this.qualityLimitationReason\n      });\n    }\n    getRemoteVideoIsReady(e) {\n      return this.statsFilter.getVideoIsReady(e);\n    }\n    async updateEncoderConfig(e, t) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.updateEncoderConfig before remote SDP created.\");\n        const i = await this.peerConnection.createOffer(),\n          n = this.mungSendOfferSDP(i.sdp, [t], [e]);\n        this.remoteSDP.updateRecvMedia(e, t);\n        const r = this.remoteSDP.toString(),\n          o = this.logSDPExchange(n, \"offer\", \"local\", \"updateEncoderConfig\");\n        await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: n\n        }), null == o || o(r), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new iI(tI.EXCHANGE_SDP_FAILED, e.toString());\n      }\n    }\n    async updateSendParameters(e, t) {\n      const i = this.peerConnection.getTransceivers().filter(t => t.mid === e);\n      1 === i.length && (this.isVP8Simulcast(t) ? Pv() || (await this.applySimulcastEncodings(i, [t])) : await this.applySendEncodings(i, [t]));\n    }\n    setStatsRemoteVideoIsReady(e, t) {\n      this.statsFilter.setVideoIsReady2(e, t);\n    }\n    async replaceTrack(e, t) {\n      const i = this.peerConnection.getTransceivers().find(e => e.mid === t);\n      i && (await i.sender.replaceTrack(e._mediaStreamTrack));\n    }\n    async getSelectedCandidatePair() {\n      const e = this.peerConnection.getReceivers();\n      if (e.length > 0 && e[0].transport && e[0].transport.iceTransport && e[0].transport.iceTransport.getSelectedCandidatePair && e[0].transport.iceTransport.getSelectedCandidatePair()) {\n        const t = e[0].transport.iceTransport,\n          _t$getSelectedCandida3 = t.getSelectedCandidatePair(),\n          i = _t$getSelectedCandida3.local,\n          n = _t$getSelectedCandida3.remote;\n        return {\n          local: JG(JG({}, PB), {}, {\n            candidateType: i.type,\n            protocol: i.protocol,\n            address: i.address,\n            port: i.port\n          }),\n          remote: JG(JG({}, PB), {}, {\n            candidateType: n.type,\n            protocol: n.protocol,\n            address: n.address,\n            port: n.port\n          })\n        };\n      }\n      return this.statsFilter.getSelectedCandidatePair();\n    }\n    bindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = () => {\n        var e;\n        null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState);\n      }, this.peerConnection.onconnectionstatechange = () => {\n        var e;\n        null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState);\n      }, this.peerConnection.onicecandidate = e => {\n        e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, Qy.debug(\"[\".concat(this.store.clientId, \"] [pc-\").concat(this.store.p2pId, \"] local candidate count\"), this.localCandidateCount));\n      }, setTimeout(() => {\n        this.allCandidatesReceived || (this.allCandidatesReceived = !0, Qy.debug(\"[\".concat(this.store.clientId, \"] [pc-\").concat(this.store.p2pId, \"] onicecandidate timeout, local candidate count\"), this.localCandidateCount));\n      }, Dy(\"CANDIDATE_TIMEOUT\"));\n    }\n    unbindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;\n    }\n    static resolvePCConfiguration(t) {\n      const i = {\n        iceServers: []\n      };\n      return t.iceServers ? i.iceServers = t.iceServers : t.turnServer && \"off\" !== t.turnServer.mode && (bI(t.turnServer.servers) ? i.iceServers = t.turnServer.servers : (i.iceServers && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), Dy(\"USE_TURN_SERVER_OF_GATEWAY\") && i.iceServers && t.turnServer.serversFromGateway && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), Dy(\"FORCE_TURN_TCP\") ? i.iceTransportPolicy = \"relay\" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {\n        e.forceturn && (i.iceTransportPolicy = \"relay\");\n      }))), Dy(\"ENABLE_ENCODED_TRANSFORM\") && _U().supportWebRTCEncodedTransform && (i.encodedInsertableStreams = !0), i;\n    }\n    static turnServerConfigToIceServers(e) {\n      const t = [];\n      return e.forEach(e => {\n        e.security ? e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turns:\".concat(Hw(e.turnServerURL), \":\").concat(e.tcpport, \"?transport=tcp\")\n        }) : (e.udpport && !Dy(\"FORCE_TURN_TCP\") && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.udpport, \"?transport=udp\")\n        }), e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.tcpport, \"?transport=tcp\")\n        }));\n      }), t;\n    }\n    tryBindTransportEvents(e) {\n      const t = e.transport;\n      if (t) {\n        this.transportEventReceiver = e, t.onstatechange = () => {\n          var e;\n          null != t && t.state && (null === (e = this.onDTLSTransportStateChange) || void 0 === e || e.call(this, t.state));\n        }, t.onerror = e => {\n          var t;\n          null === (t = this.onDTLSTransportError) || void 0 === t || t.call(this, \"error\" in e ? e.error : e);\n        };\n        const i = t.iceTransport;\n        i && (i.onstatechange = () => {\n          const e = null == t ? void 0 : t.iceTransport.state;\n          var i;\n          e && (null === (i = this.onICETransportStateChange) || void 0 === i || i.call(this, e));\n        }, i.getSelectedCandidatePair && (i.onselectedcandidatepairchange = () => {\n          if (i.getSelectedCandidatePair()) {\n            const _i$getSelectedCandida = i.getSelectedCandidatePair(),\n              e = _i$getSelectedCandida.local,\n              t = _i$getSelectedCandida.remote;\n            Qy.info(\"[\".concat(this.store.clientId, \"] [pc-\").concat(this.store.p2pId, \"] selectedcandidatepairchange: local \").concat(JSON.stringify({\n              candidateType: e.type,\n              protocol: e.protocol\n            }), \", remote \").concat(JSON.stringify({\n              candidateType: t.type,\n              protocol: t.protocol,\n              address: t.address,\n              port: t.port\n            }), \" )\"));\n          }\n        }));\n      }\n    }\n    tryUnbindTransportEvents() {\n      this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));\n    }\n    async updateRtpSenderEncodings(e, t) {\n      var i, n;\n      if (!t) {\n        const i = this.peerConnection.getSenders();\n        t = i.find(t => t.track === e._mediaStreamTrack);\n      }\n      if (!t) return Qy.warn(\"[\".concat(e.getTrackId(), \"] no rtpSender found}\"));\n      if (this.isVP8Simulcast(e)) return Qy.warn(\"[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings\");\n      if (!_U().supportSetRtpSenderParameters) return Qy.warn(\"[updateRtpSenderEncodings] Browser not support set rtp-sender parameters\");\n      const r = {},\n        o = {};\n      switch (e._optimizationMode) {\n        case \"motion\":\n          r.degradationPreference = \"maintain-framerate\";\n          break;\n        case \"detail\":\n          r.degradationPreference = \"maintain-resolution\";\n          break;\n        case \"balanced\":\n          r.degradationPreference = \"balanced\";\n      }\n      const s = function (e, t) {\n          return e.getTransceivers().find(e => e.sender.track === t || e.receiver.track === t);\n        }(this.peerConnection, e._mediaStreamTrack),\n        a = Wx(e);\n      if (HG(e) && s && t && a && this.getLocalVideoStats && Dn(i = [\"vp8\", \"vp9\"]).call(i, this.store.codec)) {\n        var c;\n        const i = r.degradationPreference || (Dn(c = e._hints).call(c, LU.CUSTOM_TRACK) ? Dy(\"CUSTOM_ADAPTATION_DEFAULT_MODE\") : \"maintain-framerate\");\n        !function (e, t, i, n, r, o) {\n          if (YG(e), \"balanced\" !== n && \"maintain-framerate\" !== n && \"maintain-resolution\" !== n) return;\n          let s = -1;\n          FG(e, t);\n          const a = window.setInterval(() => {\n              const a = KG.get(e);\n              if (!Dy(\"ENABLE_AG_ADAPTATION\") || !a) return void YG(e);\n              const c = o();\n              if (c.sendPackets > 0 && c.OutgoingAvailableBandwidth > 0) {\n                if (-1 === s) return void (s = Date.now());\n                if (Date.now() - s < 1e3) return;\n                const o = c.sendFrameRate,\n                  d = c.OutgoingAvailableBandwidth,\n                  _jG = jG(e, o, d, a.adaptationConfig, t, n),\n                  _jG2 = _slicedToArray(_jG, 2),\n                  l = _jG2[0],\n                  h = _jG2[1];\n                h && (i.qualityLimitationReason = h), l && a.adaptationConfig.scale !== l.scale && (Qy.debug(\"[\".concat(e, \"] applyAdaptation: \").concat(i.qualityLimitationReason, \"\\n           sendFps \").concat(o, \", bwe \").concat(d, \", switch from \").concat(a.adaptationConfig.scale, \" to \").concat(l.scale, \" \")), a.adaptationConfig = WG(WG({}, a.adaptationConfig), l), r(l));\n              }\n            }, Dy(\"CHECK_LOCAL_STATS_INTERVAL\")),\n            c = WG({}, t);\n          KG.set(e, {\n            timer: a,\n            adaptationConfig: c,\n            originConfig: t,\n            adaptationFunc: r\n          }), Qy.debug(\"[\".concat(e, \"] start adaptation, originConfig: \").concat(JSON.stringify(t), \", degradationPreference: \").concat(n));\n        }(this.id + s.mid, a, this, i, e => {\n          t && this.updateAdaptation(t, e);\n        }, this.getLocalVideoStats.bind(this));\n      }\n      if (e._encoderConfig) {\n        var d;\n        const _e$_encoderConfig2 = e._encoderConfig,\n          t = _e$_encoderConfig2.bitrateMax,\n          i = _e$_encoderConfig2.frameRate,\n          n = _e$_encoderConfig2.scaleResolutionDownBy;\n        t && (o.maxBitrate = 1e3 * t), (Dn(d = e._hints).call(d, LU.LOW_STREAM) || e.isUseScaleResolutionDownBy) && (i && (o.maxFramerate = Yw(i)), n && n >= 1 && (o.scaleResolutionDownBy = n));\n      }\n      const _Dy2 = Dy(\"ENCODER_CONFIG_LIMIT\"),\n        l = _Dy2.maxFramerate;\n      if (l && \"number\" == typeof l && (o.maxFramerate = o.maxFramerate ? Math.min(o.maxFramerate, l) : l), Dy(\"DSCP_TYPE\") && Jv()) {\n        var h;\n        const e = Dy(\"DSCP_TYPE\");\n        Dn(h = [\"very-low\", \"low\", \"medium\", \"high\"]).call(h, e) && (o.networkPriority = e);\n      }\n      const u = t.getParameters(),\n        p = null === (n = u.encodings) || void 0 === n ? void 0 : n[0];\n      Pv() && !p && (r.encodings = [o]), p && Object.assign(p, o), Object.assign(u, r), Qy.debug(\"[\".concat(e.getTrackId(), \"] updateRtpSenderEncodings: \").concat(JSON.stringify(u.encodings))), await t.setParameters(u);\n    }\n    async updateAdaptation(e, t) {\n      var i, n;\n      if (!e) return Qy.debug(\"[updateAdaptation] no rtpSender found\");\n      if (!_U().supportSetRtpSenderParameters) return Qy.debug(\"[updateAdaptation] Browser not support set rtp-sender parameters\");\n      const r = {},\n        o = t.bitrateMax,\n        s = t.frameRate,\n        a = t.scaleResolutionDownBy;\n      o && (r.maxBitrate = 1e3 * o), s && (r.maxFramerate = Yw(s)), a && a >= 1 && Dn(i = [\"vp8\", \"vp9\"]).call(i, this.store.codec) && (r.scaleResolutionDownBy = a);\n      const c = e.getParameters(),\n        d = null === (n = c.encodings) || void 0 === n ? void 0 : n[0];\n      d && Object.assign(d, r), Object.assign(c, {});\n      try {\n        await e.setParameters(c), Qy.debug(\"[updateAdaptation] updateRtpSenderEncodings: \".concat(JSON.stringify(c.encodings)));\n      } catch (t) {\n        !(\"transport\" in e) || e.transport && \"connected\" === e.transport.state ? \"connected\" !== this.peerConnectionState ? Qy.debug(\"[updateAdaptation] peerConnection not connected}\") : Qy.debug(\"[updateAdaptation] updateRtpSenderEncodings failed\", t) : Qy.debug(\"[updateAdaptation] rtpSender transport not connected}\");\n      }\n    }\n    async applySendEncodings(e, t) {\n      try {\n        if (!_U().supportSetRtpSenderParameters) return;\n        if (e.length !== t.length) return;\n        for (let i = 0; i < e.length; i++) {\n          const n = e[i],\n            r = t[i];\n          r instanceof vF && !this.isVP8Simulcast(r) && (await this.updateRtpSenderEncodings(r, n.sender));\n        }\n      } catch (e) {\n        Qy.debug(\"[\".concat(this.store.clientId, \"] Apply RTPSendEncodings failed.\"));\n      }\n    }\n    mungSendOfferSDP(e, t, i) {\n      const n = wB.parse(e);\n      return t.forEach((e, t) => {\n        const r = i[t],\n          o = n.mediaDescriptions.find(e => e.attributes.mid === r);\n        o && (ij(o, e), aj(o, e, this.store.codec));\n      }), wB.print(n);\n    }\n    mungReceiveAnswerSDP(e, t, i) {\n      const n = wB.parse(e),\n        r = n.mediaDescriptions.find(e => e.attributes.mid === t);\n      return r && (i === nw.AUDIO && \"audio\" === r.media.mediaType && uj(r), this.useXR && pj(n)), wB.print(n);\n    }\n    bindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = e => {\n        var t;\n        null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoReceived = e => {\n        var t;\n        null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstAudioDecoded = e => {\n        var t;\n        null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoDecoded = (e, t, i) => {\n        var n;\n        null === (n = this.onFirstVideoDecoded) || void 0 === n || n.call(this, e, t, i);\n      }, this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedLocalCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedRemoteCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onFirstVideoDecodedTimeout = e => {\n        var t;\n        null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t || t.call(this, e);\n      };\n    }\n    unbindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;\n    }\n    async applySimulcastForFirefox(e, t) {\n      if (e.length === t.length) for (let a = 0; a < e.length; a++) {\n        var i, n, r, o, s;\n        const c = e[a],\n          d = t[a];\n        if (d instanceof vF && !Dn(i = d._hints).call(i, LU.LOW_STREAM) && null !== (n = d._encoderConfig) && void 0 !== n && n.bitrateMax && (null === (r = d._encoderConfig) || void 0 === r ? void 0 : r.bitrateMax) > 200 && null !== (o = d._scalabilityMode) && void 0 !== o && o.numSpatialLayers && (null === (s = d._scalabilityMode) || void 0 === s ? void 0 : s.numSpatialLayers) > 1 && \"vp8\" === this.store.codec) {\n          const e = {},\n            t = {\n              high: 1e3 * (d._encoderConfig.bitrateMax - 50),\n              medium: 5e4\n            };\n          e.encodings = [{\n            rid: \"m\",\n            active: !0,\n            maxBitrate: t.medium,\n            scaleResolutionDownBy: 4\n          }, {\n            rid: \"h\",\n            active: !0,\n            maxBitrate: t.high\n          }];\n          const i = c.sender.getParameters();\n          await c.sender.setParameters(Object.assign(i, e));\n        }\n      }\n    }\n    async applySimulcastEncodings(e, t) {\n      if (!Pv() && e.length === t.length) for (let i = 0; i < e.length; i++) {\n        const n = t[i];\n        if (n instanceof vF && this.isVP8Simulcast(n)) {\n          const t = e[i],\n            r = {},\n            o = {\n              high: 1e3 * (n._encoderConfig.bitrateMax - 50),\n              medium: 5e4\n            };\n          r.encodings = [{\n            active: !0,\n            adaptivePtime: !1,\n            networkPriority: \"high\",\n            priority: \"high\",\n            maxBitrate: o.high\n          }, {\n            active: !0,\n            adaptivePtime: !1,\n            networkPriority: \"low\",\n            priority: \"low\",\n            maxBitrate: o.medium,\n            scaleResolutionDownBy: 4\n          }];\n          const s = t.sender.getParameters();\n          await t.sender.setParameters(Object.assign(s, r));\n        }\n      }\n    }\n    isVP8Simulcast(e) {\n      var t, i, n, r, o;\n      return !!(e instanceof vF && Dy(\"SIMULCAST\") && \"vp8\" === this.store.codec && !Dn(t = e._hints).call(t, LU.LOW_STREAM) && null !== (i = e._encoderConfig) && void 0 !== i && i.bitrateMax && (null === (n = e._encoderConfig) || void 0 === n ? void 0 : n.bitrateMax) > 200 && null !== (r = e._scalabilityMode) && void 0 !== r && r.numSpatialLayers && (null === (o = e._scalabilityMode) || void 0 === o ? void 0 : o.numSpatialLayers) > 1);\n    }\n    logSDPExchange(e, t, i, n) {\n      if (Dy(\"SDP_LOGGING\")) return Qy.upload(\"[\".concat(this.store.clientId, \"] exchanging \").concat(i, \" \").concat(t, \" SDP during P2PConnection.\").concat(n, \"\\n\"), e), \"offer\" === t ? e => {\n        this.logSDPExchange(e, \"answer\", \"local\" === i ? \"remote\" : \"local\", n);\n      } : void 0;\n    }\n    async getRemoteSSRC(e) {\n      if (!this.remoteSDP) return;\n      const t = this.remoteSDP.getSSRC(e);\n      return null == t ? void 0 : t[0].ssrcId;\n    }\n    setConfiguration(t) {\n      if (_U().supportPCSetConfiguration) {\n        const i = e.resolvePCConfiguration(t);\n        this.peerConnection.setConfiguration(i);\n      }\n    }\n  }, nb(qG.prototype, \"updateRemoteRTPCapabilities\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"updateRemoteRTPCapabilities\"), qG.prototype), nb(qG.prototype, \"connect\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"connect\"), qG.prototype), nb(qG.prototype, \"createDataChannels\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"createDataChannels\"), qG.prototype), nb(qG.prototype, \"receive\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"receive\"), qG.prototype), nb(qG.prototype, \"batchReceive\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"batchReceive\"), qG.prototype), nb(qG.prototype, \"stopReceiving\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"stopReceiving\"), qG.prototype), nb(qG.prototype, \"muteRemote\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"muteRemote\"), qG.prototype), nb(qG.prototype, \"unmuteRemote\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"unmuteRemote\"), qG.prototype), nb(qG.prototype, \"muteLocal\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"muteLocal\"), qG.prototype), nb(qG.prototype, \"unmuteLocal\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"unmuteLocal\"), qG.prototype), nb(qG.prototype, \"close\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"close\"), qG.prototype), nb(qG.prototype, \"updateEncoderConfig\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"updateEncoderConfig\"), qG.prototype), nb(qG.prototype, \"updateSendParameters\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"updateSendParameters\"), qG.prototype), nb(qG.prototype, \"replaceTrack\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"replaceTrack\"), qG.prototype), nb(qG.prototype, \"updateAdaptation\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"updateAdaptation\"), qG.prototype), nb(qG.prototype, \"getRemoteSSRC\", [QG], Object.getOwnPropertyDescriptor(qG.prototype, \"getRemoteSSRC\"), qG.prototype), qG);\n  function QG(e, t, i) {\n    const n = e[t];\n    if (\"function\" != typeof n) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"From P2PConnection.\".concat(t));\n      try {\n        for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];\n        return await n.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  function ZG(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function $G(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? ZG(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : ZG(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  const eW = \"v=0\\no=- 0 0 IN IP4 127.0.0.1\\ns=AgoraGateway\\nt=0 0\\na=group:BUNDLE 0\\na=msid-semantic: WMS\\na=ice-lite\\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\\nc=IN IP4 127.0.0.1\\na=mid:0\\n\",\n    tW = \"9\",\n    iW = 2e4,\n    nW = 4e4;\n  class rW {\n    get localCapabilities() {\n      return GI(this._localCapabilities);\n    }\n    get rtpCapabilities() {\n      return GI(this._rtpCapabilities);\n    }\n    get candidates() {\n      return GI(this._candidates);\n    }\n    get iceParameters() {\n      return GI(this._iceParameters);\n    }\n    get dtlsParameters() {\n      return GI(this._dtlsParameters);\n    }\n    constructor(e) {\n      ng(this, \"sessionDesc\", void 0), ng(this, \"_localCapabilities\", void 0), ng(this, \"_rtpCapabilities\", void 0), ng(this, \"_candidates\", void 0), ng(this, \"_iceParameters\", void 0), ng(this, \"_dtlsParameters\", void 0), ng(this, \"setup\", void 0), ng(this, \"currentMidIndex\", void 0), ng(this, \"cname\", void 0), ng(this, \"firefoxSsrcMidMap\", new Map()), e = GI(e);\n      const _e48 = e,\n        t = _e48.remoteIceParameters,\n        i = _e48.remoteDtlsParameters,\n        n = _e48.candidates,\n        r = _e48.remoteRTPCapabilities,\n        o = _e48.remoteSetup,\n        s = _e48.localCapabilities,\n        a = _e48.cname,\n        c = wB.parse(eW);\n      this._rtpCapabilities = r, this._candidates = n, this._iceParameters = t, this._dtlsParameters = i, this._localCapabilities = s, this.setup = o, this.cname = a;\n      const d = this.rtpCapabilities.send;\n      for (const e of c.mediaDescriptions) {\n        if (e.attributes.iceUfrag = t.iceUfrag, e.attributes.icePwd = t.icePwd, e.attributes.fingerprints = i.fingerprints, e.attributes.candidates = n, e.attributes.setup = o, \"application\" === e.media.mediaType && (e.attributes.sctpPort = \"5000\"), \"video\" === e.media.mediaType && (e.media.fmts = d.videoCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = d.videoCodecs, e.attributes.extmaps = d.videoExtensions, Dy(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n          const _tj8 = tj([{\n              ssrcId: nW,\n              rtx: Dy(\"USE_SUB_RTX\") ? 40001 : void 0\n            }], this.cname),\n            t = _tj8.ssrcs,\n            i = _tj8.ssrcGroups;\n          e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n        }\n        if (\"audio\" === e.media.mediaType && (e.media.fmts = d.audioCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = d.audioCodecs, e.attributes.extmaps = d.audioExtensions, uj(e), Dy(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n          const _tj9 = tj([{\n              ssrcId: iW\n            }], this.cname),\n            t = _tj9.ssrcs,\n            i = _tj9.ssrcGroups;\n          e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n        }\n      }\n      this.sessionDesc = c, this.currentMidIndex = c.mediaDescriptions.length - 1;\n    }\n    updateRemoteRTPCapabilities(e) {\n      const t = wB.parse(eW);\n      this._rtpCapabilities = e;\n      const i = this.rtpCapabilities.send;\n      for (const e of t.mediaDescriptions) {\n        if (e.attributes.iceUfrag = this._iceParameters.iceUfrag, e.attributes.icePwd = this._iceParameters.icePwd, e.attributes.fingerprints = this._dtlsParameters.fingerprints, e.attributes.candidates = this._candidates, e.attributes.setup = this.setup, \"application\" === e.media.mediaType && (e.attributes.sctpPort = \"5000\"), \"video\" === e.media.mediaType && (e.media.fmts = i.videoCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = i.videoCodecs, e.attributes.extmaps = i.videoExtensions, Dy(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n          const _tj10 = tj([{\n              ssrcId: nW,\n              rtx: Dy(\"USE_SUB_RTX\") ? 40001 : void 0\n            }], this.cname),\n            t = _tj10.ssrcs,\n            i = _tj10.ssrcGroups;\n          e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n        }\n        if (\"audio\" === e.media.mediaType && (e.media.fmts = i.audioCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = i.audioCodecs, e.attributes.extmaps = i.audioExtensions, Dy(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n          const _tj11 = tj([{\n              ssrcId: iW\n            }], this.cname),\n            t = _tj11.ssrcs,\n            i = _tj11.ssrcGroups;\n          e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n        }\n      }\n      this.sessionDesc = t, this.currentMidIndex = t.mediaDescriptions.length - 1;\n    }\n    preloadRemoteMedia(e) {\n      this.rtpCapabilities;\n      const t = this.candidates,\n        i = this.dtlsParameters,\n        n = this.iceParameters,\n        r = this.rtpCapabilities.send;\n      for (let o = 1; o < e; o++) {\n        const e = 2 * o + iW,\n          s = 2 * o + nW,\n          _tj12 = tj([{\n            ssrcId: e\n          }], this.cname),\n          a = _tj12.ssrcs,\n          c = _tj12.ssrcGroups,\n          _tj13 = tj([{\n            ssrcId: s,\n            rtx: Dy(\"USE_SUB_RTX\") ? s + 1 : void 0\n          }], this.cname),\n          d = _tj13.ssrcs,\n          l = _tj13.ssrcGroups;\n        this.sessionDesc.mediaDescriptions.push({\n          media: {\n            mediaType: \"video\",\n            port: tW,\n            protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n            fmts: r.videoCodecs.map(e => e.payloadType.toString(10))\n          },\n          connections: [{\n            nettype: \"IN\",\n            addrtype: \"IP4\",\n            address: \"127.0.0.1\"\n          }],\n          bandwidths: [],\n          attributes: {\n            iceUfrag: n.iceUfrag,\n            icePwd: n.icePwd,\n            unrecognized: [],\n            candidates: t,\n            extmaps: r.videoExtensions,\n            fingerprints: i.fingerprints,\n            imageattr: [],\n            msids: [],\n            remoteCandidatesList: [],\n            rids: [],\n            ssrcs: d,\n            ssrcGroups: l,\n            rtcpFeedbackWildcards: [],\n            payloads: r.videoCodecs,\n            rtcp: {\n              port: \"9\",\n              netType: \"IN\",\n              addressType: \"IP4\",\n              address: \"0.0.0.0\"\n            },\n            setup: this.setup,\n            direction: \"sendonly\",\n            rtcpMux: !0,\n            rtcpRsize: !0,\n            mid: \"\".concat(2 * o - 1)\n          }\n        }), this.sessionDesc.mediaDescriptions.push({\n          media: {\n            mediaType: \"audio\",\n            port: tW,\n            protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n            fmts: r.audioCodecs.map(e => e.payloadType.toString(10))\n          },\n          connections: [{\n            nettype: \"IN\",\n            addrtype: \"IP4\",\n            address: \"127.0.0.1\"\n          }],\n          bandwidths: [],\n          attributes: {\n            iceUfrag: n.iceUfrag,\n            icePwd: n.icePwd,\n            unrecognized: [],\n            candidates: t,\n            extmaps: r.audioExtensions,\n            fingerprints: i.fingerprints,\n            imageattr: [],\n            msids: [],\n            remoteCandidatesList: [],\n            rids: [],\n            ssrcs: a,\n            ssrcGroups: c,\n            rtcpFeedbackWildcards: [],\n            payloads: r.audioCodecs,\n            rtcp: {\n              port: \"9\",\n              netType: \"IN\",\n              addressType: \"IP4\",\n              address: \"0.0.0.0\"\n            },\n            setup: this.setup,\n            direction: \"sendonly\",\n            rtcpMux: !0,\n            rtcpRsize: !0,\n            mid: \"\".concat(2 * o)\n          }\n        }), this.currentMidIndex += 2;\n      }\n      this.updateBundleMids();\n    }\n    toString() {\n      return wB.print(this.sessionDesc);\n    }\n    send(e, t, i, n) {\n      const _tj14 = tj(t, this.cname, Dy(\"SYNC_GROUP\") ? i : void 0),\n        r = _tj14.ssrcs,\n        o = _tj14.ssrcGroups,\n        s = this.findPreloadMediaDesc(r);\n      if (s) {\n        if (Pv() && this.firefoxSsrcMidMap.set(r[0].ssrcId, s.attributes.mid), n && (n.twcc || n.remb)) {\n          const e = this.sessionDesc.mediaDescriptions.indexOf(s);\n          return this.sessionDesc.mediaDescriptions[e] = this.mungSendMediaDesc(s, n), {\n            mid: s.attributes.mid,\n            needExchangeSDP: !0\n          };\n        }\n        return {\n          mid: s.attributes.mid,\n          needExchangeSDP: !1\n        };\n      }\n      {\n        const t = this.findAvailableMediaIndex(e, r);\n        let i;\n        return -1 === t || Nv() || Lv() || Bv() || 0 === t && Dy(\"USE_SUB_RTX\") ? (i = this.createOrRecycleSendMedia(e, r, o, \"sendonly\", n), this.updateBundleMids()) : (i = GI(this.sessionDesc.mediaDescriptions[t]), i.attributes.direction = \"sendonly\", i.attributes.ssrcs = r, i.attributes.ssrcGroups = o, this.sessionDesc.mediaDescriptions[t] = this.mungSendMediaDesc(i, n)), Pv() && this.firefoxSsrcMidMap.set(r[0].ssrcId, i.attributes.mid), {\n          mid: i.attributes.mid,\n          needExchangeSDP: !0\n        };\n      }\n    }\n    batchSend(e) {\n      const t = e.map(e => {\n          let t = e.kind,\n            i = e.ssrcMsg,\n            n = e.mslabel;\n          return this.send(t, i, n);\n        }),\n        i = [];\n      let n = !1;\n      return t.forEach(e => {\n        let t = e.mid,\n          r = e.needExchangeSDP;\n        r && (n = !0), i.push(t);\n      }), {\n        mids: i,\n        needExchangeSDP: n\n      };\n    }\n    stopSending(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => t.attributes.mid && -1 !== e.indexOf(t.attributes.mid));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.\");\n      t.forEach(e => {\n        \"0\" === e.attributes.mid || Pv() || Nv() || Lv() ? e.attributes.ssrcs = [] : (e.attributes.ssrcs = [], e.attributes.direction = \"inactive\", e.media.port = \"0\");\n      }), this.updateBundleMids();\n    }\n    mute(e) {\n      const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n      if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.mute.\"));\n      t.attributes.direction = \"inactive\";\n    }\n    unmute(e) {\n      const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n      if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.unmute.\"));\n      t.attributes.direction = \"sendonly\";\n    }\n    muteRemote(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => Dn(e).call(e, t.attributes.mid || \"\"));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.\");\n      t.forEach(e => {\n        e.attributes.direction = \"inactive\";\n      });\n    }\n    unmuteRemote(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => Dn(e).call(e, t.attributes.mid || \"\"));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.\");\n      t.forEach(e => {\n        e.attributes.direction = \"recvonly\";\n      });\n    }\n    receive(e, t, i, n) {\n      e.forEach((e, r) => {\n        this.createOrRecycleRecvMedia(e, [], \"recvonly\", t, i, n[r]);\n      }), this.updateBundleMids();\n    }\n    stopReceiving(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => -1 !== e.indexOf(t.attributes.mid));\n      if (t.length !== e.length) throw new Error(\"MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.\");\n      t.forEach(e => {\n        e.media.port = \"0\", e.attributes.direction = \"inactive\";\n      }), this.updateBundleMids();\n    }\n    updateCandidates(e) {\n      e === rw.TCP ? this._candidates.forEach(e => {\n        -1 === this._candidates.findIndex(t => \"tcp\" === t.transport && t.connectionAddress === e.connectionAddress && t.port === e.port) && this._candidates.push($G($G({}, e), {}, {\n          foundation: \"tcpcandidate\",\n          priority: Number(e.priority) - 1 + \"\",\n          transport: \"tcp\",\n          port: Number(e.port) + 90 + \"\"\n        }));\n      }) : this._candidates = this._candidates.filter(e => \"tcp\" !== e.transport);\n      for (const e of this.sessionDesc.mediaDescriptions) e.attributes.candidates = this.candidates;\n    }\n    restartICE(e) {\n      e = GI(e), this._iceParameters = e, this.sessionDesc.mediaDescriptions.forEach(t => {\n        t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd;\n      });\n    }\n    predictReceivingMids(e) {\n      const t = [];\n      for (let i = 0; i < e; i++) t.push((this.currentMidIndex + i + 1).toString(10));\n      return t;\n    }\n    findAvailableMediaIndex(e, t) {\n      return this.sessionDesc.mediaDescriptions.findIndex(i => {\n        const n = i.media.mediaType === e && \"0\" !== i.media.port && (\"sendonly\" === i.attributes.direction || \"sendrecv\" === i.attributes.direction) && 0 === i.attributes.ssrcs.length;\n        if (Pv()) {\n          if (n) {\n            const e = this.firefoxSsrcMidMap.get(t[0].ssrcId);\n            return !(e || \"0\" !== i.attributes.mid && \"1\" !== i.attributes.mid) || !(!e || e !== i.attributes.mid);\n          }\n          return !1;\n        }\n        return n;\n      });\n    }\n    createOrRecycleRecvMedia(e, t, i, n, r, o) {\n      const s = e._mediaStreamTrack.kind,\n        a = this.rtpCapabilities.recv,\n        c = _j(s, a, this.localCapabilities.send, s === nw.VIDEO ? n : r),\n        d = s === nw.VIDEO ? a.videoExtensions : a.audioExtensions;\n      this.currentMidIndex += 1;\n      const l = \"\".concat(this.currentMidIndex);\n      let h = {\n        media: {\n          mediaType: s,\n          port: tW,\n          protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n          fmts: c.map(e => e.payloadType.toString(10))\n        },\n        connections: [{\n          nettype: \"IN\",\n          addrtype: \"IP4\",\n          address: \"127.0.0.1\"\n        }],\n        bandwidths: [],\n        attributes: {\n          iceUfrag: this.iceParameters.iceUfrag,\n          icePwd: this.iceParameters.icePwd,\n          unrecognized: [],\n          candidates: this.candidates,\n          extmaps: d,\n          fingerprints: this.dtlsParameters.fingerprints,\n          imageattr: [],\n          msids: [],\n          remoteCandidatesList: [],\n          rids: [],\n          ssrcs: t,\n          ssrcGroups: [],\n          rtcpFeedbackWildcards: [],\n          payloads: c,\n          rtcp: {\n            port: \"9\",\n            netType: \"IN\",\n            addressType: \"IP4\",\n            address: \"0.0.0.0\"\n          },\n          setup: this.setup,\n          direction: i,\n          rtcpMux: !0,\n          rtcpRsize: !0,\n          mid: \"\".concat(l)\n        }\n      };\n      h = this.mungRecvMediaDsec(h, e, o);\n      const u = this.findFirstClosedMedia(s);\n      if (u) {\n        const e = this.sessionDesc.mediaDescriptions.indexOf(u);\n        this.sessionDesc.mediaDescriptions[e] = h;\n      } else this.sessionDesc.mediaDescriptions.push(h);\n      return h;\n    }\n    updateRemoteCodec(e, t, i) {\n      const n = [...new Set(this._rtpCapabilities.recv.videoCodecs.map(e => e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").filter(e => {\n          var t;\n          return Dn(t = Object.keys(My)).call(t, e);\n        }))],\n        r = new Set(t);\n      if (n.every(e => r.has(e))) return Qy.debug(\"codecs has not changed, no need to updateRemoteCodec, codecs: \".concat(t)), !1;\n      const o = this._rtpCapabilities.recv.videoCodecs.filter(e => t.some(t => {\n        var i;\n        return Dn(i = e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").call(i, t);\n      }));\n      if (0 === o.length) return Qy.debug(\"updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: \".concat(n, \" codecs: \").concat(t)), !1;\n      const s = [...new Set(o.map(e => e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\"))];\n      let a;\n      if (Qy.debug(\"updateRemoteCodec, from \".concat(n, \" to \").concat(s)), 0 === e.length) a = this.sessionDesc.mediaDescriptions.filter(e => \"video\" === e.media.mediaType && \"recvonly\" === e.attributes.direction);else if (a = this.sessionDesc.mediaDescriptions.filter(t => t.attributes.mid && Dn(e).call(e, t.attributes.mid) && \"recvonly\" === t.attributes.direction), a.length !== e.length) return Qy.debug(\"updateRemoteCodec failed, because cannot find mids, mids: \".concat(e, \", codecs: \").concat(t)), !1;\n      this._rtpCapabilities.recv.videoCodecs = o;\n      const c = this.localCapabilities.send,\n        d = this.rtpCapabilities.recv,\n        l = _j(nw.VIDEO, d, c, i);\n      return a.forEach(e => {\n        const t = l.map(e => e.payloadType.toString(10));\n        Qy.debug(\"updateRemoteCodec mid: \".concat(e.attributes.mid, \", from \").concat(e.attributes.payloads, \" to \").concat(l)), e.attributes.payloads = l, e.media.fmts = t;\n      }), !0;\n    }\n    createOrRecycleSendMedia(e, t, i, n, r) {\n      const o = this.rtpCapabilities.send,\n        s = e === nw.VIDEO ? o.videoCodecs : o.audioCodecs,\n        a = e === nw.VIDEO ? o.videoExtensions : o.audioExtensions;\n      this.currentMidIndex += 1;\n      const c = \"\".concat(this.currentMidIndex);\n      let d = {\n        media: {\n          mediaType: e,\n          port: tW,\n          protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n          fmts: s.map(e => e.payloadType.toString(10))\n        },\n        connections: [{\n          nettype: \"IN\",\n          addrtype: \"IP4\",\n          address: \"127.0.0.1\"\n        }],\n        bandwidths: [],\n        attributes: {\n          iceUfrag: this.iceParameters.iceUfrag,\n          icePwd: this.iceParameters.icePwd,\n          unrecognized: [],\n          candidates: this.candidates,\n          extmaps: a,\n          fingerprints: this.dtlsParameters.fingerprints,\n          imageattr: [],\n          msids: [],\n          remoteCandidatesList: [],\n          rids: [],\n          ssrcs: t,\n          ssrcGroups: i,\n          rtcpFeedbackWildcards: [],\n          payloads: s,\n          rtcp: {\n            port: \"9\",\n            netType: \"IN\",\n            addressType: \"IP4\",\n            address: \"0.0.0.0\"\n          },\n          setup: this.setup,\n          direction: n,\n          rtcpMux: !0,\n          rtcpRsize: !0,\n          mid: \"\".concat(c)\n        }\n      };\n      d = this.mungSendMediaDesc(d, r);\n      const l = this.findFirstClosedMedia(e);\n      if (l) {\n        const e = this.sessionDesc.mediaDescriptions.indexOf(l);\n        this.sessionDesc.mediaDescriptions[e] = d;\n      } else this.sessionDesc.mediaDescriptions.push(d);\n      return d;\n    }\n    updateBundleMids() {\n      this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter(e => \"0\" !== e.media.port).map(e => e.attributes.mid);\n    }\n    mungRecvMediaDsec(e, t, i) {\n      const n = GI(e);\n      return nj(n), ij(n, t), rj(n, t), oj(n), sj(n, i, this.localCapabilities.send), n;\n    }\n    mungSendMediaDesc(e, t) {\n      const i = GI(e);\n      return sj(i, t, this.localCapabilities.recv), uj(i), i;\n    }\n    updateRecvMedia(e, t) {\n      const i = this.sessionDesc.mediaDescriptions.findIndex(t => t.attributes.mid === e);\n      if (-1 !== i) {\n        const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i], t);\n        this.sessionDesc.mediaDescriptions[i] = e;\n      }\n    }\n    bumpMid(e) {\n      this.currentMidIndex += e;\n    }\n    findFirstClosedMedia(e) {\n      return this.sessionDesc.mediaDescriptions.find(t => Pv() ? \"0\" === t.media.port && t.media.mediaType === e : \"0\" === t.media.port);\n    }\n    findPreloadMediaDesc(e) {\n      return this.sessionDesc.mediaDescriptions.find(t => {\n        var i;\n        return (null === (i = t.attributes) || void 0 === i || null === (i = i.ssrcs[0]) || void 0 === i ? void 0 : i.ssrcId) === e[0].ssrcId;\n      });\n    }\n    getSSRC(e) {\n      var t;\n      return null === (t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e)) || void 0 === t ? void 0 : t.attributes.ssrcs;\n    }\n  }\n  var oW;\n  function sW(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function aW(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? sW(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : sW(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let cW = (oW = class e extends iw {\n    get currentLocalDescription() {\n      return this.peerConnection.currentLocalDescription;\n    }\n    get currentRemoteDescription() {\n      return this.peerConnection.currentRemoteDescription;\n    }\n    get peerConnectionState() {\n      return this.peerConnection.connectionState;\n    }\n    get iceConnectionState() {\n      return this.peerConnection.iceConnectionState;\n    }\n    get localCodecs() {\n      let e;\n      return this.localCapabilities && (e = hj(this.localCapabilities)), [...new Set(e && e.send.videoCodecs.map(e => e.rtpMap && e.rtpMap.encodingName.toLowerCase() || \"\").filter(e => {\n        var t;\n        return Dn(t = Object.keys(My)).call(t, e);\n      }))];\n    }\n    constructor(e, t, i) {\n      super(e, t), ng(this, \"store\", void 0), ng(this, \"peerConnection\", void 0), ng(this, \"remoteSDP\", void 0), ng(this, \"initialOffer\", void 0), ng(this, \"transportEventReceiver\", void 0), ng(this, \"statsFilter\", void 0), ng(this, \"useXR\", Dy(\"USE_XR\")), ng(this, \"localCapabilities\", void 0), ng(this, \"localCandidateCount\", 0), ng(this, \"allCandidatesReceived\", !1), ng(this, \"remoteCodecs\", void 0), ng(this, \"dataStreamChannelMap\", new Map()), ng(this, \"establishPromise\", void 0), ng(this, \"mutex\", new uy(\"NVExtentionsConnection-mutex\")), ng(this, \"rtcMedia\", void 0), this.store = t, this.peerConnection = i, this.statsFilter = zB(this.peerConnection, Dy(\"STATS_UPDATE_INTERVAL\"), void 0, Pv() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();\n    }\n    async establish(e) {\n      try {\n        const e = await this.peerConnection.createOffer();\n        if (!e.sdp) throw new Error(\"Cannot get initialOffer.sdp when trying to establish PeerConnection.\");\n        const t = ZB(e.sdp),\n          i = await cj({\n            filterRTX: !Dy(\"USE_PUB_RTX\") && !Dy(\"USE_SUB_RTX\"),\n            filterVideoFec: Dy(\"FILTER_VIDEO_FEC\"),\n            filterAudioFec: Dy(\"FILTER_AUDIO_FEC\"),\n            filterVideoCodec: Dy(\"FILTER_VIDEO_CODEC\")\n          }, {\n            useXR: this.useXR\n          });\n        return this.localCapabilities = i, this.initialOffer = e, aW(aW({}, t), {}, {\n          rtpCapabilities: i,\n          offerSDP: e.sdp\n        });\n      } catch (e) {\n        throw new bb(tI.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString());\n      }\n    }\n    async connect(e, t, i, n, r, o) {\n      try {\n        if (!this.initialOffer) throw new Error(\"Cannot establish NVConnection without initial offer.\");\n        this.remoteSDP = new rW({\n          remoteIceParameters: e,\n          remoteDtlsParameters: t,\n          candidates: i,\n          remoteRTPCapabilities: n,\n          remoteSetup: r,\n          localCapabilities: hj(this.localCapabilities),\n          cname: o\n        });\n        const s = this.remoteSDP.toString(),\n          a = wB.parse(this.initialOffer.sdp),\n          c = a.mediaDescriptions.find(e => \"audio\" === e.media.mediaType);\n        c && uj(c), this.useXR && pj(a);\n        const d = wB.print(a),\n          l = this.logSDPExchange(d || \"\", \"offer\", \"local\", \"connect\");\n        await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: d\n        }), null == l || l(s), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: s\n        });\n      } catch (e) {\n        throw new bb(tI.EXCHANGE_SDP_FAILED, \"NV.connect failed; \".concat(e.toString()));\n      }\n    }\n    async updateRemoteRTPCapabilities(e, t) {\n      if (this.remoteCodecs = t, !this.remoteSDP) return void Qy.debug(\"[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: \".concat(this.localCodecs, \", codecs: \").concat(t));\n      if (this.remoteSDP.updateRemoteCodec(e, t, this.store.codec)) {\n        const e = await this.peerConnection.createOffer(),\n          t = this.logSDPExchange(e.sdp || \"\", \"offer\", \"local\", \"muteLocal\");\n        await this.peerConnection.setLocalDescription(e);\n        const i = this.remoteSDP.toString();\n        null == t || t(i), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: i\n        });\n      } else Qy.debug(\"[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.\");\n    }\n    async updateRemoteConnect(e) {\n      var t, i, n, r;\n      (null === (t = this.remoteSDP) || void 0 === t || t.updateRemoteRTPCapabilities(e), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0) && (null === (r = this.remoteSDP) || void 0 === r || r.updateRemoteCodec([], this.remoteCodecs, this.store.codec));\n      null === (i = this.remoteSDP) || void 0 === i || i.preloadRemoteMedia(2);\n      const o = null === (n = this.remoteSDP) || void 0 === n ? void 0 : n.toString();\n      await this.peerConnection.setRemoteDescription({\n        type: \"offer\",\n        sdp: o\n      });\n      const s = await this.peerConnection.createAnswer();\n      await this.peerConnection.setLocalDescription(s), Qy.debug(\"[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.\");\n    }\n    send(e, t, i) {\n      var n = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var r, o, s, a, c, d, l, h, u, p;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return rB(n.mutex.lock(\"From NVExtentionsConnection.send\"));\n            case 2:\n              r = _context8.sent;\n              _context8.prev = 3;\n              if (n.remoteSDP) {\n                _context8.next = 6;\n                break;\n              }\n              throw new Error(\"Cannot call NVExtentionsConnection.send before remote SDP created\");\n            case 6:\n              o = [];\n              e.forEach(e => {\n                const t = n.peerConnection.addTransceiver(e._mediaStreamTrack, {\n                  direction: \"sendonly\"\n                });\n                o.push(t);\n              });\n              _context8.t0 = Pv() && !0 === Dy(\"SIMULCAST\");\n              if (!_context8.t0) {\n                _context8.next = 12;\n                break;\n              }\n              _context8.next = 12;\n              return rB(n.applySimulcastForFirefox(o, e));\n            case 12:\n              _context8.next = 14;\n              return rB(n.peerConnection.createOffer());\n            case 14:\n              s = _context8.sent;\n              a = n.remoteSDP.predictReceivingMids(e.length);\n              c = n.mungSendOfferSDP(s.sdp, e, a);\n              d = wB.parse(c);\n              l = a.map(e => {\n                const t = d.mediaDescriptions.find(t => t.attributes.mid === e);\n                if (!t) throw new Error(\"Cannot extract ssrc from mediaDescription.\");\n                return $B(t, Dy(\"USE_PUB_RTX\"));\n              });\n              _context8.prev = 19;\n              _context8.next = 22;\n              return l;\n            case 22:\n              h = _context8.sent;\n              _context8.next = 36;\n              break;\n            case 25:\n              _context8.prev = 25;\n              _context8.t1 = _context8[\"catch\"](19);\n              h = [], n.remoteSDP.receive(e, t, i, h);\n              o = n.remoteSDP.toString();\n              _context8.next = 31;\n              return rB(n.peerConnection.setLocalDescription({\n                type: \"offer\",\n                sdp: c\n              }));\n            case 31:\n              _context8.next = 33;\n              return rB(n.peerConnection.setRemoteDescription({\n                type: \"answer\",\n                sdp: o\n              }));\n            case 33:\n              _context8.next = 35;\n              return rB(n.stopSending(a, !0));\n            case 35:\n              throw _context8.t1;\n            case 36:\n              n.remoteSDP.receive(e, t, i, h);\n              u = n.remoteSDP.toString(), p = n.logSDPExchange(c, \"offer\", \"local\", \"send\");\n              _context8.next = 40;\n              return rB(n.peerConnection.setLocalDescription({\n                type: \"offer\",\n                sdp: c\n              }));\n            case 40:\n              _context8.next = 42;\n              return rB(n.applySimulcastEncodings(o, e));\n            case 42:\n              _context8.next = 44;\n              return rB(n.applySendEncodings(o, e));\n            case 44:\n              null == p || p(u);\n              _context8.next = 47;\n              return rB(n.peerConnection.setRemoteDescription({\n                type: \"answer\",\n                sdp: u\n              }));\n            case 47:\n              return _context8.abrupt(\"return\", o.map((e, t) => {\n                const i = a[t];\n                return {\n                  localSSRC: l[t],\n                  id: i,\n                  transceiver: e\n                };\n              }));\n            case 50:\n              _context8.prev = 50;\n              _context8.t2 = _context8[\"catch\"](3);\n              throw _context8.t2 instanceof bb ? _context8.t2 : new bb(tI.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.send failed; \".concat(_context8.t2.toString()));\n            case 53:\n              _context8.prev = 53;\n              r();\n              return _context8.finish(53);\n            case 56:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, null, [[3, 50, 53, 56], [19, 25]]);\n      }))();\n    }\n    async stopSending(e, t) {\n      const i = t ? void 0 : await this.mutex.lock(\"From NVExtentionsConnection.stopSending\");\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.stopSending before remote SDP created\");\n        const t = this.peerConnection.getTransceivers().filter(t => -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending.\");\n        t.map(e => {\n          var t;\n          e.direction = \"inactive\", null === (t = e.stop) || void 0 === t || t.call(e);\n        });\n        const n = await this.peerConnection.createOffer(),\n          r = this.logSDPExchange(n.sdp || \"\", \"offer\", \"local\", \"stopSending\");\n        await this.peerConnection.setLocalDescription(n), this.remoteSDP.stopReceiving(e);\n        const o = this.remoteSDP.toString();\n        null == r || r(o), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: o\n        });\n      } catch (e) {\n        throw new bb(tI.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.stopSending failed; \".concat(e.toString()));\n      } finally {\n        i && i();\n      }\n    }\n    async createDataChannels(e, t) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.createDataChannels before remote SDP created\");\n        let i = this.dataStreamChannelMap.get(e);\n        return i && \"open\" === i.readyState ? Qy.debug(\"[P2PConnection] Channels are already available and can be reused directly.\") : (i = this.peerConnection.createDataChannel(\"datastream-channel\", {\n          ordered: !1,\n          maxRetransmits: Dy(\"DATASTREAM_MAX_RETRANSMITS\")\n        }), i.binaryType = \"arraybuffer\", this.dataStreamChannelMap.set(e, i)), void t.forEach(e => {\n          e._updateOriginDataChannel(i);\n        });\n      } catch (e) {\n        throw e instanceof bb ? e : new bb(tI.DATACHANNEL_FAILED, \"NVExtentionsConnection.createDataChannels failed; \".concat(e.toString()));\n      }\n    }\n    async stopDataChannels(e) {\n      try {\n        const t = this.dataStreamChannelMap.get(e);\n        return null == t || t.close(), void this.dataStreamChannelMap.delete(e);\n      } catch (e) {\n        throw e instanceof bb ? e : new bb(tI.DATACHANNEL_FAILED, \"NVExtentionsConnection.stopDataChannels failed; \".concat(e.toString()));\n      }\n    }\n    async receive(e, t, i, n) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.receive \".concat(e, \" before remoteSDP created.\"));\n        const _this$remoteSDP$send5 = this.remoteSDP.send(e, t, i, n),\n          r = _this$remoteSDP$send5.mid,\n          o = _this$remoteSDP$send5.needExchangeSDP;\n        if (o) {\n          const t = this.remoteSDP.toString(),\n            i = this.logSDPExchange(t, \"offer\", \"remote\", \"receive\");\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: t\n          });\n          const n = await this.peerConnection.createAnswer(),\n            o = this.mungReceiveAnswerSDP(n.sdp, r, e);\n          null == i || i(o || \"\"), await this.peerConnection.setLocalDescription({\n            type: \"answer\",\n            sdp: o\n          }), Qy.debug(\"[NVExtentionsConnection] receive \".concat(e, \" by exchanging SDP.\"));\n        } else Qy.debug(\"[NVExtentionsConnection] receive \".concat(e, \" no need to exchange SDP.\"));\n        const s = this.peerConnection.getTransceivers().find(e => e.mid === r);\n        if (!s) throw new Error(\"Cannot get transceiver after setLocalDescription.\");\n        return {\n          track: s.receiver.track,\n          id: r\n        };\n      } catch (e) {\n        throw new bb(tI.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async batchReceive(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.batchReceive before remoteSDP created.\");\n        const _this$remoteSDP$batch2 = this.remoteSDP.batchSend(e),\n          t = _this$remoteSDP$batch2.mids,\n          i = _this$remoteSDP$batch2.needExchangeSDP;\n        if (i) {\n          const e = this.remoteSDP.toString(),\n            t = this.logSDPExchange(e, \"offer\", \"remote\", \"receive\");\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: e\n          });\n          const i = await this.peerConnection.createAnswer();\n          null == t || t(i.sdp || \"\"), await this.peerConnection.setLocalDescription(i), Qy.debug(\"[NVExtentionsConnection] batchReceive by exchanging SDP.\");\n        } else Qy.debug(\"[NVExtentionsConnection] batchReceive no need to exchange SDP.\");\n        return t.map(e => {\n          const t = this.peerConnection.getTransceivers().find(t => t.mid === e);\n          if (!t) throw new Error(\"Cannot get transceiver after setLocalDescription.\");\n          return {\n            track: t.receiver.track,\n            id: e\n          };\n        });\n      } catch (e) {\n        throw new bb(tI.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async stopReceiving(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.stopReceiving before remote SDP created.\");\n        this.remoteSDP.stopSending(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"stopReceiving\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const n = await this.peerConnection.createAnswer();\n        null == i || i(n.sdp || \"\"), await this.peerConnection.setLocalDescription(n);\n      } catch (e) {\n        throw new bb(tI.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection stopReceiving failed; \".concat(e.toString()));\n      }\n    }\n    async muteRemote(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.muteRemote mid=\".concat(e, \" before remote SDP created.\"));\n        this.remoteSDP.mute(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"muteRemote\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const n = await this.peerConnection.createAnswer();\n        null == i || i(n.sdp || \"\"), await this.peerConnection.setLocalDescription(n);\n      } catch (e) {\n        throw new bb(tI.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.muteRemote failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteRemote(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.unmuteRemote mid=\".concat(e, \" before remote SDP created.\"));\n        this.remoteSDP.unmute(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"unmuteRemote\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const n = await this.peerConnection.createAnswer();\n        null == i || i(n.sdp || \"\"), await this.peerConnection.setLocalDescription(n);\n      } catch (e) {\n        throw new bb(tI.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.unmuteRemote failed; \".concat(e.toString()));\n      }\n    }\n    async muteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.muteLocal before remote SDP created.\");\n        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length.\");\n        t.map(e => {\n          e.direction = \"inactive\";\n        });\n        const i = await this.peerConnection.createOffer(),\n          n = this.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"muteLocal\");\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.muteRemote(e);\n        const r = this.remoteSDP.toString();\n        null == n || n(r), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new bb(tI.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.muteLocal failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created.\");\n        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length.\");\n        t.map(async (e, t) => {\n          e.direction = \"sendonly\";\n        });\n        const i = await this.peerConnection.createOffer(),\n          n = this.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"unmuteLocal\");\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.unmuteRemote(e);\n        const r = this.remoteSDP.toString();\n        null == n || n(r), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new bb(tI.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.unmuteLocal failed; \".concat(e.toString()));\n      }\n    }\n    restartICE(e) {\n      var t = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var i, n, r, _yield$r$iceParameter3, o, s, a;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return rB(t.mutex.lock(\"From NVExtentionsConnection.restartICE\"));\n            case 2:\n              i = _context9.sent;\n              _context9.prev = 3;\n              if (t.remoteSDP) {\n                _context9.next = 6;\n                break;\n              }\n              throw new Error(\"Cannot restartICE before remoteSDP created.\");\n            case 6:\n              if (!_U().supportPCSetConfiguration) {\n                _context9.next = 11;\n                break;\n              }\n              i = t.peerConnection.getConfiguration(), n = e === rw.RELAY ? \"relay\" : \"all\";\n              i.iceTransportPolicy !== n && (Qy.debug(\"restartICE change iceTransportPolicy from [\".concat(i.iceTransportPolicy, \"] to [\").concat(n, \"]\")), i.iceTransportPolicy = n, t.peerConnection.setConfiguration(i));\n              _context9.next = 13;\n              break;\n            case 11:\n              if (!(e === rw.RELAY)) {\n                _context9.next = 13;\n                break;\n              }\n              return _context9.abrupt(\"return\");\n            case 13:\n              e !== rw.RELAY && t.remoteSDP.updateCandidates(e);\n              _context9.next = 16;\n              return rB(t.peerConnection.createOffer({\n                iceRestart: !0\n              }));\n            case 16:\n              n = _context9.sent;\n              if (n.sdp) {\n                _context9.next = 19;\n                break;\n              }\n              throw new Error(\"Cannot restartICE because restart offer SDP does not exist.\");\n            case 19:\n              r = ZB(n.sdp);\n              _context9.next = 22;\n              return r.iceParameters;\n            case 22:\n              _yield$r$iceParameter3 = _context9.sent;\n              o = _yield$r$iceParameter3.remoteIceParameters;\n              t.remoteSDP.restartICE(o);\n              s = t.remoteSDP.toString(), a = t.logSDPExchange(n.sdp || \"\", \"offer\", \"local\", \"restartICE\");\n              _context9.next = 28;\n              return rB(t.peerConnection.setLocalDescription(n));\n            case 28:\n              null == a || a(s);\n              _context9.next = 31;\n              return rB(t.peerConnection.setRemoteDescription({\n                type: \"answer\",\n                sdp: s\n              }));\n            case 31:\n              _context9.next = 36;\n              break;\n            case 33:\n              _context9.prev = 33;\n              _context9.t0 = _context9[\"catch\"](3);\n              Qy.warning(\"restart ICE failed, abort operation\", _context9.t0);\n            case 36:\n              _context9.prev = 36;\n              i();\n              return _context9.finish(36);\n            case 39:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, null, [[3, 33, 36, 39]]);\n      }))();\n    }\n    close() {\n      var e;\n      null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, \"closed\"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear();\n    }\n    getStats() {\n      return this.statsFilter.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      return this.statsFilter.getVideoIsReady(e);\n    }\n    async updateEncoderConfig(e, t) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created.\");\n        const i = await this.peerConnection.createOffer(),\n          n = this.mungSendOfferSDP(i.sdp, [t], [e]);\n        this.remoteSDP.updateRecvMedia(e, t);\n        const r = this.remoteSDP.toString(),\n          o = this.logSDPExchange(n, \"offer\", \"local\", \"updateEncoderConfig\");\n        await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: n\n        }), null == o || o(r), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new bb(tI.EXCHANGE_SDP_FAILED, e.toString());\n      }\n    }\n    async updateSendParameters(e, t) {\n      const i = this.peerConnection.getTransceivers().filter(t => t.mid === e);\n      1 === i.length && (this.isVP8Simulcast(t) ? Pv() || (await this.applySimulcastEncodings(i, [t])) : await this.applySendEncodings(i, [t]));\n    }\n    setStatsRemoteVideoIsReady(e, t) {\n      this.statsFilter.setVideoIsReady2(e, t);\n    }\n    async replaceTrack(e, t) {\n      const i = this.peerConnection.getTransceivers().find(e => e.mid === t);\n      i && (await i.sender.replaceTrack(e._mediaStreamTrack));\n    }\n    getP2PConnectionParams() {\n      var e;\n      if (null === (e = this.peerConnection.currentLocalDescription) || void 0 === e || !e.sdp || !this.localCapabilities) throw new Error();\n      return aW(aW({}, ZB(this.peerConnection.currentLocalDescription.sdp)), {}, {\n        rtpCapabilities: this.localCapabilities\n      });\n    }\n    bindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = () => {\n        var e;\n        null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState);\n      }, this.peerConnection.onconnectionstatechange = () => {\n        var e;\n        null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState);\n      }, this.peerConnection.onicecandidate = e => {\n        e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, Qy.debug(\"[pc-\".concat(this.store.p2pId, \"] local candidate count\"), this.localCandidateCount));\n      }, setTimeout(() => {\n        this.allCandidatesReceived || (this.allCandidatesReceived = !0, Qy.debug(\"[pc-\".concat(this.store.p2pId, \"] onicecandidate timeout, local candidate count\"), this.localCandidateCount));\n      }, Dy(\"CANDIDATE_TIMEOUT\"));\n    }\n    unbindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;\n    }\n    static resolvePCConfiguration(t) {\n      const i = {\n        iceServers: []\n      };\n      return t.iceServers ? i.iceServers = t.iceServers : t.turnServer && \"off\" !== t.turnServer.mode && (bI(t.turnServer.servers) ? i.iceServers = t.turnServer.servers : (i.iceServers && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), Dy(\"USE_TURN_SERVER_OF_GATEWAY\") && i.iceServers && t.turnServer.serversFromGateway && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), Dy(\"FORCE_TURN_TCP\") ? i.iceTransportPolicy = \"relay\" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {\n        e.forceturn && (i.iceTransportPolicy = \"relay\");\n      }))), i;\n    }\n    static turnServerConfigToIceServers(e) {\n      const t = [];\n      return e.forEach(e => {\n        e.security ? e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turns:\".concat(Hw(e.turnServerURL), \":\").concat(e.tcpport, \"?transport=tcp\")\n        }) : (e.udpport && !Dy(\"FORCE_TURN_TCP\") && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.udpport, \"?transport=udp\")\n        }), e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.tcpport, \"?transport=tcp\")\n        }));\n      }), t;\n    }\n    async applySendEncodings(e, t) {\n      try {\n        if (!_U().supportSetRtpSenderParameters) return;\n        if (e.length !== t.length) return;\n        for (let l = 0; l < e.length; l++) {\n          const h = e[l],\n            u = t[l];\n          if (u && u instanceof vF) {\n            var i, n, r;\n            if (this.isVP8Simulcast(u)) continue;\n            const e = {},\n              t = {};\n            switch (u._optimizationMode) {\n              case \"motion\":\n                e.degradationPreference = \"maintain-framerate\";\n                break;\n              case \"detail\":\n                e.degradationPreference = \"maintain-resolution\";\n                break;\n              default:\n                e.degradationPreference = \"balanced\";\n            }\n            var o, s, a, c;\n            if (null !== (i = u._encoderConfig) && void 0 !== i && i.bitrateMax) t.maxBitrate = 1e3 * (null === (o = u._encoderConfig) || void 0 === o ? void 0 : o.bitrateMax);\n            if (Dn(n = u._hints).call(n, LU.LOW_STREAM)) null !== (s = u._encoderConfig) && void 0 !== s && s.frameRate && (t.maxFramerate = Yw(u._encoderConfig.frameRate)), null !== (a = u._encoderConfig) && void 0 !== a && a.scaleResolutionDownBy && (null === (c = u._encoderConfig) || void 0 === c ? void 0 : c.scaleResolutionDownBy) > 1 && (t.scaleResolutionDownBy = u._encoderConfig.scaleResolutionDownBy);\n            if (Dy(\"DSCP_TYPE\") && Jv()) {\n              var d;\n              const e = Dy(\"DSCP_TYPE\");\n              Dn(d = [\"very-low\", \"low\", \"medium\", \"high\"]).call(d, e) && (t.networkPriority = e);\n            }\n            const l = h.sender.getParameters(),\n              p = null === (r = l.encodings) || void 0 === r ? void 0 : r[0];\n            Pv() && !p && (e.encodings = [t]), p && Object.assign(p, t), Object.assign(l, e), await h.sender.setParameters(l);\n          }\n        }\n      } catch (e) {\n        Qy.debug(\"Apply RTPSendEncodings failed.\");\n      }\n    }\n    mungSendOfferSDP(e, t, i) {\n      const n = wB.parse(e);\n      return t.forEach((e, t) => {\n        const r = i[t],\n          o = n.mediaDescriptions.find(e => e.attributes.mid === r);\n        o && (ij(o, e), aj(o, e, this.store.codec));\n      }), wB.print(n);\n    }\n    mungReceiveAnswerSDP(e, t, i) {\n      const n = wB.parse(e),\n        r = n.mediaDescriptions.find(e => e.attributes.mid === t);\n      return r && i === nw.AUDIO && \"audio\" === r.media.mediaType && uj(r), this.useXR && pj(n), wB.print(n);\n    }\n    bindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = e => {\n        var t;\n        null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoReceived = e => {\n        var t;\n        null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstAudioDecoded = e => {\n        var t;\n        null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoDecoded = (e, t, i) => {\n        var n;\n        null === (n = this.onFirstVideoDecoded) || void 0 === n || n.call(this, e, t, i);\n      }, this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedLocalCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedRemoteCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onFirstVideoDecodedTimeout = e => {\n        var t;\n        null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t || t.call(this, e);\n      };\n    }\n    unbindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;\n    }\n    async applySimulcastForFirefox(e, t) {\n      if (e.length === t.length) for (let a = 0; a < e.length; a++) {\n        var i, n, r, o, s;\n        const c = e[a],\n          d = t[a];\n        if (d instanceof vF && !Dn(i = d._hints).call(i, LU.LOW_STREAM) && null !== (n = d._encoderConfig) && void 0 !== n && n.bitrateMax && (null === (r = d._encoderConfig) || void 0 === r ? void 0 : r.bitrateMax) > 200 && null !== (o = d._scalabilityMode) && void 0 !== o && o.numSpatialLayers && (null === (s = d._scalabilityMode) || void 0 === s ? void 0 : s.numSpatialLayers) > 1 && \"vp8\" === this.store.codec) {\n          const e = {},\n            t = {\n              high: 1e3 * (d._encoderConfig.bitrateMax - 50),\n              medium: 5e4\n            };\n          e.encodings = [{\n            rid: \"m\",\n            active: !0,\n            maxBitrate: t.medium,\n            scaleResolutionDownBy: 4\n          }, {\n            rid: \"h\",\n            active: !0,\n            maxBitrate: t.high\n          }];\n          const i = c.sender.getParameters();\n          await c.sender.setParameters(Object.assign(i, e));\n        }\n      }\n    }\n    async applySimulcastEncodings(e, t) {\n      if (!Pv() && e.length === t.length) for (let i = 0; i < e.length; i++) {\n        const n = t[i];\n        if (n instanceof vF && this.isVP8Simulcast(n)) {\n          const t = e[i],\n            r = {},\n            o = {\n              high: 1e3 * (n._encoderConfig.bitrateMax - 50),\n              medium: 5e4\n            };\n          r.encodings = [{\n            active: !0,\n            adaptivePtime: !1,\n            networkPriority: \"high\",\n            priority: \"high\",\n            maxBitrate: o.high\n          }, {\n            active: !0,\n            adaptivePtime: !1,\n            networkPriority: \"low\",\n            priority: \"low\",\n            maxBitrate: o.medium,\n            scaleResolutionDownBy: 4\n          }];\n          const s = t.sender.getParameters();\n          await t.sender.setParameters(Object.assign(s, r));\n        }\n      }\n    }\n    isVP8Simulcast(e) {\n      var t, i, n, r, o;\n      return !!(e instanceof vF && Dy(\"SIMULCAST\") && \"vp8\" === this.store.codec && !Dn(t = e._hints).call(t, LU.LOW_STREAM) && null !== (i = e._encoderConfig) && void 0 !== i && i.bitrateMax && (null === (n = e._encoderConfig) || void 0 === n ? void 0 : n.bitrateMax) > 200 && null !== (r = e._scalabilityMode) && void 0 !== r && r.numSpatialLayers && (null === (o = e._scalabilityMode) || void 0 === o ? void 0 : o.numSpatialLayers) > 1);\n    }\n    logSDPExchange(e, t, i, n) {\n      if (Dy(\"SDP_LOGGING\")) return Qy.upload(\"exchanging \".concat(i, \" \").concat(t, \" SDP during NVExtentionsConnection.\").concat(n, \"\\n\"), e), \"offer\" === t ? e => {\n        this.logSDPExchange(e, \"answer\", \"local\" === i ? \"remote\" : \"local\", n);\n      } : void 0;\n    }\n    async getRemoteSSRC(e) {\n      if (!this.remoteSDP) return;\n      const t = this.remoteSDP.getSSRC(e);\n      return null == t ? void 0 : t[0].ssrcId;\n    }\n    setConfiguration(t) {\n      if (_U().supportPCSetConfiguration) {\n        const i = e.resolvePCConfiguration(t);\n        this.peerConnection.setConfiguration(i);\n      }\n    }\n  }, nb(oW.prototype, \"connect\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"connect\"), oW.prototype), nb(oW.prototype, \"updateRemoteRTPCapabilities\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"updateRemoteRTPCapabilities\"), oW.prototype), nb(oW.prototype, \"updateRemoteConnect\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"updateRemoteConnect\"), oW.prototype), nb(oW.prototype, \"createDataChannels\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"createDataChannels\"), oW.prototype), nb(oW.prototype, \"receive\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"receive\"), oW.prototype), nb(oW.prototype, \"batchReceive\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"batchReceive\"), oW.prototype), nb(oW.prototype, \"stopReceiving\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"stopReceiving\"), oW.prototype), nb(oW.prototype, \"muteRemote\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"muteRemote\"), oW.prototype), nb(oW.prototype, \"unmuteRemote\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"unmuteRemote\"), oW.prototype), nb(oW.prototype, \"muteLocal\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"muteLocal\"), oW.prototype), nb(oW.prototype, \"unmuteLocal\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"unmuteLocal\"), oW.prototype), nb(oW.prototype, \"close\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"close\"), oW.prototype), nb(oW.prototype, \"updateEncoderConfig\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"updateEncoderConfig\"), oW.prototype), nb(oW.prototype, \"updateSendParameters\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"updateSendParameters\"), oW.prototype), nb(oW.prototype, \"replaceTrack\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"replaceTrack\"), oW.prototype), nb(oW.prototype, \"getRemoteSSRC\", [dW], Object.getOwnPropertyDescriptor(oW.prototype, \"getRemoteSSRC\"), oW.prototype), oW);\n  function dW(e, t, i) {\n    const n = e[t];\n    if (\"function\" != typeof n) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"From NVExtentionsConnection.\".concat(t));\n      try {\n        for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];\n        return await n.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  var lW;\n  function hW(e) {\n    var t,\n      i,\n      n,\n      r = 2;\n    for (\"undefined\" != typeof Symbol && (i = RG, n = Symbol.iterator); r--;) {\n      if (i && null != (t = e[i])) return t.call(e);\n      if (n && null != (t = e[n])) return new uW(t.call(e));\n      i = \"@@asyncIterator\", n = \"@@iterator\";\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  }\n  function uW(e) {\n    function t(e) {\n      if (Object(e) !== e) return Gu.reject(new TypeError(e + \" is not an object.\"));\n      var t = e.done;\n      return Gu.resolve(e.value).then(function (e) {\n        return {\n          value: e,\n          done: t\n        };\n      });\n    }\n    return uW = function (e) {\n      this.s = e, this.n = e.next;\n    }, uW.prototype = {\n      s: null,\n      n: null,\n      next: function () {\n        return t(this.n.apply(this.s, arguments));\n      },\n      return: function (e) {\n        var i = this.s.return;\n        return void 0 === i ? Gu.resolve({\n          value: e,\n          done: !0\n        }) : t(i.apply(this.s, arguments));\n      },\n      throw: function (e) {\n        var i = this.s.return;\n        return void 0 === i ? Gu.reject(e) : t(i.apply(this.s, arguments));\n      }\n    }, new uW(e);\n  }\n  let pW = (lW = class e extends iw {\n    get currentLocalDescription() {\n      return this.peerConnection.currentLocalDescription;\n    }\n    get currentRemoteDescription() {\n      return this.peerConnection.currentRemoteDescription;\n    }\n    get peerConnectionState() {\n      return this.peerConnection.connectionState;\n    }\n    get iceConnectionState() {\n      return this.peerConnection.iceConnectionState;\n    }\n    get localCodecs() {\n      return this._p2pConnection.localCodecs;\n    }\n    constructor(t, i) {\n      super(t, i), ng(this, \"store\", void 0), ng(this, \"peerConnection\", void 0), ng(this, \"cname\", void 0), ng(this, \"mutex\", new uy(\"DataChannelConnection-mutex\")), ng(this, \"dataChannel\", void 0), ng(this, \"_p2pConnection\", void 0), ng(this, \"establishPromise\", void 0), ng(this, \"_nvMedia\", void 0), this.store = i, this.store.dcId = this.store.dcId + 1, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), {\n        optional: [{\n          googDscp: !0\n        }]\n      }), this.dataChannel = this.peerConnection.createDataChannel(\"agora-signal\", {\n        ordered: !1,\n        maxPacketLifeTime: 50\n      }), this.dataChannel.binaryType = \"arraybuffer\", this._p2pConnection = new cW(t, i, this.peerConnection), this.bindPCEvents(), this.establishPromise = this._p2pConnection.establishPromise;\n    }\n    async establish() {\n      var e;\n      const t = null === (e = this._nvMedia) || void 0 === e ? void 0 : e.getLocalRtpCapabilities();\n      return await this._p2pConnection.establish(t);\n    }\n    getP2PConnectionParams() {\n      return this._p2pConnection.getP2PConnectionParams();\n    }\n    async connect(e, t, i, n, r, o) {\n      return this.cname = o, await this._p2pConnection.connect(e, t, i, n, r, o), await new Gu((e, t) => {\n        const n = setTimeout(() => {\n          this.closeSignal(), t(new bb(tI.DATACHANNEL_CONNECTION_TIMEOUT, \"Datachannel connection timed out, candidates: \".concat(JSON.stringify(i))));\n        }, 2e3);\n        this.dataChannel.onopen = () => {\n          if (\"open\" === this.dataChannel.readyState) return clearTimeout(n), void e();\n        }, this.dataChannel.onerror = e => {\n          this.closeSignal(), t(e);\n        };\n      }), {\n        transmitter: this.dataChannel,\n        close: this.closeSignal.bind(this)\n      };\n    }\n    async updateRemoteRTPCapabilities(e, t) {\n      return this._p2pConnection.updateRemoteRTPCapabilities(e, t);\n    }\n    send(e, t, i) {\n      var n = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var r;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return rB(n.mutex.lock(\"From DataChannelConnection.send\"));\n            case 2:\n              r = _context10.sent;\n              _context10.prev = 3;\n              return _context10.delegateYield(gG(hW(n._p2pConnection.send(e, t, i))), \"t0\", 5);\n            case 5:\n              return _context10.abrupt(\"return\", _context10.t0);\n            case 6:\n              _context10.prev = 6;\n              r();\n              return _context10.finish(6);\n            case 9:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, null, [[3,, 6, 9]]);\n      }))();\n    }\n    async stopSending(e, t) {\n      return this._p2pConnection.stopSending(e, t);\n    }\n    async createDataChannels(e, t) {\n      return this._p2pConnection.createDataChannels(e, t);\n    }\n    async stopDataChannels(e) {\n      return this._p2pConnection.stopDataChannels(e);\n    }\n    async receive(e, t, i, n) {\n      return this._nvMedia ? (Qy.debug(\"[DataChannelConnection] receive \".concat(e, \" by DataChannel.\")), await this._nvMedia.reveiveByRTCMedia(e, t, this.cname)) : (Qy.debug(\"[DataChannelConnection] receive \".concat(e, \" by WebRTC.\")), await this._p2pConnection.receive(e, t, i, n));\n    }\n    async batchReceive(e) {\n      return [...(await this._p2pConnection.batchReceive(e))];\n    }\n    async stopReceiving(e) {\n      return await this._p2pConnection.stopReceiving(e);\n    }\n    async muteRemote(e) {\n      return await this._p2pConnection.muteRemote(e);\n    }\n    async unmuteRemote(e) {\n      return await this._p2pConnection.unmuteRemote(e);\n    }\n    async muteLocal(e) {\n      return await this._p2pConnection.muteLocal(e);\n    }\n    async unmuteLocal(e) {\n      return await this._p2pConnection.unmuteLocal(e);\n    }\n    restartICE(e) {\n      var t = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              return _context11.delegateYield(gG(hW(t._p2pConnection.restartICE(e))), \"t0\", 1);\n            case 1:\n              return _context11.abrupt(\"return\", _context11.t0);\n            case 2:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11);\n      }))();\n    }\n    close() {\n      var e;\n      null === (e = this._nvMedia) || void 0 === e || e.close(), this._p2pConnection.close(), this.unbindConnectionEvents(this._p2pConnection);\n    }\n    getStats() {\n      return this._p2pConnection.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      return this._p2pConnection.getRemoteVideoIsReady(e);\n    }\n    updateRemoteConnect(e) {\n      var t;\n      null === (t = this._nvMedia) || void 0 === t || t.setRemoteRtpCapabilities(e), this._p2pConnection.updateRemoteConnect(e);\n    }\n    async updateEncoderConfig(e, t) {\n      return await this._p2pConnection.updateEncoderConfig(e, t);\n    }\n    async updateSendParameters(e, t) {\n      return await this._p2pConnection.updateSendParameters(e, t);\n    }\n    setStatsRemoteVideoIsReady(e, t) {\n      this._p2pConnection.setStatsRemoteVideoIsReady(e, t);\n    }\n    async replaceTrack(e, t) {\n      return await this._p2pConnection.replaceTrack(e, t);\n    }\n    async getRemoteSSRC(e) {\n      return this._p2pConnection.getRemoteSSRC(e);\n    }\n    logSDPExchange(e, t, i, n) {\n      if (Dy(\"SDP_LOGGING\")) return Qy.upload(\"exchanging \".concat(i, \" \").concat(t, \" SDP during DataChannelConnection.\").concat(n, \"\\n\"), e), \"offer\" === t ? e => {\n        this.logSDPExchange(e, \"answer\", \"local\" === i ? \"remote\" : \"local\", n);\n      } : void 0;\n    }\n    static resolvePCConfiguration(t) {\n      const i = {\n        iceServers: []\n      };\n      return t.iceServers ? i.iceServers = t.iceServers : t.turnServer && \"off\" !== t.turnServer.mode && (bI(t.turnServer.servers) ? i.iceServers = t.turnServer.servers : (i.iceServers && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), Dy(\"USE_TURN_SERVER_OF_GATEWAY\") && i.iceServers && t.turnServer.serversFromGateway && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), Dy(\"FORCE_TURN_TCP\") ? i.iceTransportPolicy = \"relay\" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {\n        e.forceturn && (i.iceTransportPolicy = \"relay\");\n      }))), i;\n    }\n    static turnServerConfigToIceServers(e) {\n      const t = [];\n      return e.forEach(e => {\n        e.security ? e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turns:\".concat(Hw(e.turnServerURL), \":\").concat(e.tcpport, \"?transport=tcp\")\n        }) : (e.udpport && !Dy(\"FORCE_TURN_TCP\") && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.udpport, \"?transport=udp\")\n        }), e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.tcpport, \"?transport=tcp\")\n        }));\n      }), t;\n    }\n    bindPCEvents() {\n      this._p2pConnection.onICEConnectionStateChange = e => {\n        var t;\n        return null === (t = this.onICEConnectionStateChange) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onConnectionStateChange = e => {\n        var t;\n        return null === (t = this.onConnectionStateChange) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onDTLSTransportStateChange = e => {\n        var t;\n        return null === (t = this.onDTLSTransportStateChange) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onDTLSTransportError = e => {\n        var t;\n        return null === (t = this.onDTLSTransportError) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onICETransportStateChange = e => {\n        var t;\n        return null === (t = this.onICETransportStateChange) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onFirstAudioReceived = e => {\n        var t;\n        return null === (t = this.onFirstAudioReceived) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onFirstVideoReceived = e => {\n        var t;\n        return null === (t = this.onFirstVideoReceived) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onFirstAudioDecoded = e => {\n        var t;\n        return null === (t = this.onFirstAudioDecoded) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onFirstVideoDecoded = (e, t, i) => {\n        var n;\n        return null === (n = this.onFirstVideoDecoded) || void 0 === n ? void 0 : n.call(this, e, t, i);\n      }, this._p2pConnection.onFirstVideoDecodedTimeout = e => {\n        var t;\n        return null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onSelectedLocalCandidateChanged = (e, t) => {\n        var i;\n        return null === (i = this.onSelectedLocalCandidateChanged) || void 0 === i ? void 0 : i.call(this, e, t);\n      }, this._p2pConnection.onSelectedRemoteCandidateChanged = (e, t) => {\n        var i;\n        return null === (i = this.onSelectedRemoteCandidateChanged) || void 0 === i ? void 0 : i.call(this, e, t);\n      };\n    }\n    closeSignal() {\n      this.dataChannel.close(), this.peerConnection.close();\n    }\n    unbindConnectionEvents(e) {\n      e.onConnectionStateChange = void 0, e.onICEConnectionStateChange = void 0, e.onICETransportStateChange = void 0, e.onDTLSTransportStateChange = void 0, e.onDTLSTransportError = void 0, e.onFirstAudioDecoded = void 0, e.onFirstAudioReceived = void 0, e.onFirstVideoDecoded = void 0, e.onFirstVideoReceived = void 0, e.onSelectedLocalCandidateChanged = void 0, e.onSelectedRemoteCandidateChanged = void 0, e.onFirstVideoDecodedTimeout = void 0;\n    }\n    setConfiguration(e) {\n      this._p2pConnection.setConfiguration(e);\n    }\n  }, nb(lW.prototype, \"connect\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"connect\"), lW.prototype), nb(lW.prototype, \"updateRemoteRTPCapabilities\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"updateRemoteRTPCapabilities\"), lW.prototype), nb(lW.prototype, \"createDataChannels\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"createDataChannels\"), lW.prototype), nb(lW.prototype, \"receive\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"receive\"), lW.prototype), nb(lW.prototype, \"stopReceiving\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"stopReceiving\"), lW.prototype), nb(lW.prototype, \"muteRemote\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"muteRemote\"), lW.prototype), nb(lW.prototype, \"unmuteRemote\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"unmuteRemote\"), lW.prototype), nb(lW.prototype, \"muteLocal\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"muteLocal\"), lW.prototype), nb(lW.prototype, \"unmuteLocal\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"unmuteLocal\"), lW.prototype), nb(lW.prototype, \"close\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"close\"), lW.prototype), nb(lW.prototype, \"updateEncoderConfig\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"updateEncoderConfig\"), lW.prototype), nb(lW.prototype, \"updateSendParameters\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"updateSendParameters\"), lW.prototype), nb(lW.prototype, \"replaceTrack\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"replaceTrack\"), lW.prototype), nb(lW.prototype, \"getRemoteSSRC\", [_W], Object.getOwnPropertyDescriptor(lW.prototype, \"getRemoteSSRC\"), lW.prototype), lW);\n  function _W(e, t, i) {\n    const n = e[t];\n    if (\"function\" != typeof n) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"From DataChannelConnection.\".concat(t));\n      try {\n        for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];\n        return await n.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  var EW;\n  function mW(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function fW(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? mW(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : mW(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function TW(e) {\n    var t,\n      i,\n      n,\n      r = 2;\n    for (\"undefined\" != typeof Symbol && (i = RG, n = Symbol.iterator); r--;) {\n      if (i && null != (t = e[i])) return t.call(e);\n      if (n && null != (t = e[n])) return new SW(t.call(e));\n      i = \"@@asyncIterator\", n = \"@@iterator\";\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  }\n  function SW(e) {\n    function t(e) {\n      if (Object(e) !== e) return Gu.reject(new TypeError(e + \" is not an object.\"));\n      var t = e.done;\n      return Gu.resolve(e.value).then(function (e) {\n        return {\n          value: e,\n          done: t\n        };\n      });\n    }\n    return SW = function (e) {\n      this.s = e, this.n = e.next;\n    }, SW.prototype = {\n      s: null,\n      n: null,\n      next: function () {\n        return t(this.n.apply(this.s, arguments));\n      },\n      return: function (e) {\n        var i = this.s.return;\n        return void 0 === i ? Gu.resolve({\n          value: e,\n          done: !0\n        }) : t(i.apply(this.s, arguments));\n      },\n      throw: function (e) {\n        var i = this.s.return;\n        return void 0 === i ? Gu.reject(e) : t(i.apply(this.s, arguments));\n      }\n    }, new SW(e);\n  }\n  let gW = (EW = class extends SI {\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      const t = this._state;\n      this._state = e, this.emit(cw.StateChange, t, this._state);\n    }\n    constructor(e, t) {\n      super(), ng(this, \"store\", void 0), ng(this, \"statsUploader\", void 0), ng(this, \"connection\", void 0), ng(this, \"localTrackMap\", new Map()), ng(this, \"remoteUserMap\", new Map()), ng(this, \"localDataChannels\", []), ng(this, \"remoteDataChannelMap\", new Map()), ng(this, \"pendingLocalTracks\", []), ng(this, \"pendingRemoteTracks\", []), ng(this, \"pendingLocalDataChannels\", []), ng(this, \"pendingRemoteDataChannels\", []), ng(this, \"statsCollector\", void 0), ng(this, \"isPlanB\", !1), ng(this, \"shouldForwardP2PCreation\", void 0), ng(this, \"iceFailedCount\", 0), ng(this, \"dtlsFailedCount\", 0), ng(this, \"mutex\", new uy(\"P2PChannel-mutex\")), ng(this, \"_state\", aw.Disconnected), ng(this, \"_pcStatsUploadType\", Dy(\"NEW_ICE_RESTART\") ? ow.FIRST_CONNECTION : ow.OLD_FIRST_CONNECTION), ng(this, \"_isInRestartIce\", !1), ng(this, \"_isStartRestartIce\", !1), ng(this, \"_restartStates\", [\"disconnected\", \"failed\"]), ng(this, \"_restartTimer\", void 0), ng(this, \"_isFirstConnected\", !0), ng(this, \"handleMuteLocalTrack\", async (e, t, i) => {\n        const n = await this.mutex.lock(\"Locking from P2PChannel.handleMuteLocalTrack\");\n        try {\n          if (!this.connection || this.state !== aw.Connected) return void i(new iI(tI.INVALID_OPERATION, \"Cannot call P2PChannel.handleMuteLocalTrack before connection established.\"));\n          const r = this.filterTobeMutedTracks(e);\n          if (0 === r.length) return void t();\n          const o = r.find(e => \"videoLowTrack\" === e[0]);\n          if (o) {\n            o[1].track._originMediaStreamTrack.stop();\n          }\n          await this.connection.muteLocal(r.map(e => {\n            let _e49 = _slicedToArray(e, 2),\n              t = _e49[1].id;\n            return t;\n          }));\n          const s = this.createMuteMessage(r);\n          await MI(this, cw.RequestMuteLocal, s), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          n();\n        }\n      }), ng(this, \"handleUnmuteLocalTrack\", async (e, t, i) => {\n        const n = await this.mutex.lock(\"Locking from P2PChannel.handleUnmuteLocalTrack\");\n        try {\n          if (!this.connection || this.state !== aw.Connected) return void i(new iI(tI.INVALID_OPERATION, \"Cannot call P2PChannel.handleUnmuteLocalTrack before connection established.\"));\n          const r = this.filterTobeUnmutedTracks(e);\n          if (0 === r.length) return void t();\n          const o = r.find(e => \"videoLowTrack\" === e[0]);\n          if (o) {\n            const t = o[1];\n            if (t.track._originMediaStreamTrack.stop(), !Dy(\"DISABLE_DUAL_STREAM_USE_ENCODING\") && _U().supportDualStreamEncoding) {\n              const i = e._mediaStreamTrack.clone();\n              t.track._mediaStreamTrack = i, t.track._originMediaStreamTrack = i;\n            } else {\n              const i = vj(e, xI(this, cw.RequestLowStreamParameter));\n              t.track._mediaStreamTrack = i, t.track._originMediaStreamTrack = i;\n            }\n            await new Gu((e, i) => {\n              this.handleReplaceTrack(t.track, e, i, !0);\n            });\n          }\n          await this.connection.unmuteLocal(r.map(e => {\n            let _e50 = _slicedToArray(e, 2),\n              t = _e50[1].id;\n            return t;\n          }));\n          const s = this.createUnmuteMessage(r);\n          await MI(this, cw.RequestUnmuteLocal, s), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          n();\n        }\n      }), ng(this, \"handleUpdateVideoEncoder\", async (e, t, i) => {\n        const n = await this.mutex.lock(\"Locking from P2PChannel.handleSetVideoEncoder\");\n        try {\n          const i = this.localTrackMap.get(sw.LocalVideoTrack);\n          if (!this.connection || !i || i.track !== e || this.state !== aw.Connected) return void t();\n          const r = i.id,\n            o = i.track;\n          await this.connection.updateSendParameters(r, o), await this.connection.updateEncoderConfig(r, o), this.emit(cw.UpdateVideoEncoder, o), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          n();\n        }\n      }), ng(this, \"handleUpdateVideoSendParameters\", async (e, t, i) => {\n        const n = await this.mutex.lock(\"Locking from P2PChannel.handleUpdateVideoSendParameters\");\n        try {\n          const i = this.localTrackMap.get(sw.LocalVideoTrack);\n          if (!this.connection || !i || i.track !== e || this.state !== aw.Connected) return void t();\n          const r = i.id,\n            o = i.track;\n          await this.connection.updateSendParameters(r, o), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          n();\n        }\n      }), ng(this, \"handleReplaceMixingTrack\", async (e, t, i, n) => {\n        if (!this.connection || this.state !== aw.Connected) return void t();\n        const r = Hj([e]);\n        let o;\n        Qy.debug(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection will replace audioTrack [\").concat(r.getTrackId(), \"]\")), \"boolean\" == typeof n && n || (o = await this.mutex.lock(\"From P2PChannel.handleReplaceMixingTrack\"));\n        try {\n          await this.replaceTrack(e, r), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          var s;\n          null === (s = o) || void 0 === s || s();\n        }\n      }), ng(this, \"handleReplaceTrack\", async (e, t, i, n) => {\n        let r;\n        Qy.debug(\"[\".concat(this.store.clientId, \"] P2PChannel handleReplaceTrack for [track-id-\").concat(e.getTrackId(), \"]\")), \"boolean\" == typeof n && n || (r = await this.mutex.lock(\"From P2PChannel.handleReplaceTrack\"));\n        try {\n          var o;\n          const i = Array.from(this.localTrackMap.entries()).find(t => {\n            let _t13 = _slicedToArray(t, 2),\n              i = _t13[1].track;\n            return e === i;\n          });\n          if (!this.connection || !i || this.state !== aw.Connected) return void t();\n          if (await (null === (o = this.connection) || void 0 === o ? void 0 : o.replaceTrack(e, i[1].id)), this.isPlanB) {\n            const t = i[1];\n            t.id = e._mediaStreamTrack.id, this.localTrackMap.set(i[0], t);\n          }\n          if (i[0] === sw.LocalVideoTrack && !Dy(\"DISABLE_DUAL_STREAM_USE_ENCODING\") && _U().supportDualStreamEncoding) {\n            const t = this.localTrackMap.get(sw.LocalVideoLowTrack);\n            if (t) {\n              const i = e._mediaStreamTrack.clone();\n              t.track._originMediaStreamTrack.stop(), t.track._mediaStreamTrack = i, t.track._originMediaStreamTrack = i, await new Gu((e, i) => {\n                this.handleReplaceTrack(t.track, e, i, !0);\n              });\n            }\n          }\n          t();\n        } catch (e) {\n          i(e);\n        } finally {\n          var s;\n          null === (s = r) || void 0 === s || s();\n        }\n      }), ng(this, \"handleGetRTCStats\", e => {\n        e(this.statsCollector.getRTCStats());\n      }), ng(this, \"handleGetLocalVideoStats\", e => {\n        e(this.statsCollector.getLocalVideoTrackStats());\n      }), ng(this, \"handleGetLocalAudioStats\", e => {\n        e(this.statsCollector.getLocalAudioTrackStats());\n      }), ng(this, \"handleGetRemoteVideoStats\", e => this.statsCollector.getRemoteVideoTrackStats(e.uid)[e.uid]), ng(this, \"handleGetRemoteAudioStats\", e => this.statsCollector.getRemoteAudioTrackStats(e.uid)[e.uid]), this.store = e, this.statsCollector = t, this.statsCollector.addP2PChannel(this), this.statsUploader = new Fj(this.store), this.bindStatsUploaderEvents(), this.isPlanB = !_U().supportUnifiedPlan || Dy(\"CHROME_FORCE_PLAN_B\") && Jv(), this.shouldForwardP2PCreation = Dy(\"FORWARD_P2P_CREATION\") && _U().supportPCSetConfiguration && zv(), this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new pW({}, this.store) : this.isPlanB ? new bG({}, this.store) : new XG({}, this.store), this.bindConnectionEvents(this.connection));\n    }\n    async startP2PConnection(e, t) {\n      var i;\n      this.state = aw.New;\n      const n = this.shouldForwardP2PCreation && \"closed\" === (null === (i = this.connection) || void 0 === i ? void 0 : i.peerConnectionState);\n      if (this.shouldForwardP2PCreation && !n || (n && this.connection && (Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel.startP2PConnection ForwardP2P closed.\")), this.connection.close(), this.unbindConnectionEvents(this.connection)), this.connection = this.store.useDataChannel ? new pW(e, this.store) : this.isPlanB ? new bG(e, this.store) : new XG(e, this.store), this.bindConnectionEvents(this.connection)), !this.connection) throw new iI(tI.UNEXPECTED_ERROR, \"Cannot P2PChannel.startConnection before P2PConnection initialization .\");\n      return this._pcStatsUploadType = Dy(\"NEW_ICE_RESTART\") ? ow.FIRST_CONNECTION : ow.OLD_FIRST_CONNECTION, this._isFirstConnected = !0, this._isInRestartIce = !1, this._isStartRestartIce = !1, this.connection.setConfiguration(e), this.connection.establishPromise;\n    }\n    async connect(e, t, i, n, r, o) {\n      if (!this.connection) throw new iI(tI.UNEXPECTED_ERROR, \"Cannot P2PChannel.connect before P2PChannel.startP2PConnection .\");\n      this.connection instanceof pW ? this.connection.updateRemoteConnect(n) : (this.store.peerConnectionStart(), await this.connection.connect(e, t, i, n, r, o), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = aw.Connected);\n    }\n    updateRemoteRTPCapabilities(e) {\n      const t = Array.from(this.localTrackMap.entries()).filter(e => {\n          var t;\n          let _e51 = _slicedToArray(e, 1),\n            i = _e51[0];\n          return Dn(t = [sw.LocalVideoLowTrack, sw.LocalVideoTrack]).call(t, i);\n        }),\n        i = t.map(e => {\n          let _e52 = _slicedToArray(e, 2),\n            t = _e52[1].id;\n          return t;\n        }),\n        n = t.map(e => {\n          let _e53 = _slicedToArray(e, 1),\n            t = _e53[0];\n          return t;\n        });\n      if (this.connection instanceof XG) {\n        if (oA.updateRemoteRTPCapabilities(this.store.sessionId, {\n          trackTypes: JSON.stringify(n),\n          localCodecs: JSON.stringify(this.connection.localCodecs),\n          remoteCodecs: JSON.stringify(e)\n        }), !Dn(e).call(e, this.store.codec)) {\n          const t = [\"vp9\", \"vp8\", \"h264\"].find(t => Dn(e).call(e, t));\n          t && (this.store.codec = t, Qy.debug(\"[\".concat(this.store.clientId, \"] [\").concat(this.store.p2pId, \" updateRemoteRTPCapabilities] default codec is not available, hence the fallback to \").concat(t, \".\")));\n        }\n        this.connection.updateRemoteRTPCapabilities(i, e);\n      }\n    }\n    async preConnect(e, t, i, n, r, o) {\n      if (!this.connection) throw new iI(tI.UNEXPECTED_ERROR, \"Cannot P2PChannel.connect before P2PChannel.startP2PConnection .\");\n      this.store.peerConnectionStart();\n      const s = await this.connection.connect(e, t, i, n, r, o);\n      return this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = aw.Connected, s;\n    }\n    getEstablishParams() {\n      if (this.connection instanceof pW) return this.connection.getP2PConnectionParams();\n      throw new Error(\"Only DataChannelConnection needs to obtain establishParams\");\n    }\n    async publishDataChannel(e) {\n      if (!this.connection || this.state !== aw.Connected) {\n        if (this.state === aw.Disconnected) throw new iI(tI.UNEXPECTED_ERROR, \"PeerConnection already disconnected.\");\n        return void e.forEach(e => {\n          var t;\n          Dn(t = this.pendingLocalDataChannels).call(t, e) || this.pendingLocalDataChannels.push(e);\n        });\n      }\n      const t = this.filterTobePublishedDataChannels(e);\n      0 !== t.length && (t.forEach(e => {\n        const t = Date.now();\n        this.store.publish(e.id.toString(), \"datachannel\", t);\n      }), await this.connection.createDataChannels(this.store.uid, t), t.forEach(e => {\n        this.localDataChannels.push(e);\n        const t = Date.now();\n        this.store.publish(e.id + \"\", \"datachannel\", void 0, t);\n      }));\n    }\n    publish(e, t, i) {\n      var n = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var r, t, o;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.next = 2;\n              return rB(n.mutex.lock(\"From P2PChannel.publish\"));\n            case 2:\n              r = _context12.sent;\n              _context12.prev = 3;\n              if (!(!n.connection || n.state !== aw.Connected)) {\n                _context12.next = 10;\n                break;\n              }\n              if (!(n.state === aw.Disconnected)) {\n                _context12.next = 7;\n                break;\n              }\n              throw new iI(tI.UNEXPECTED_ERROR, \"PeerConnection already disconnected.\");\n            case 7:\n              n.throwIfTrackTypeNotMatch(e);\n              t = e.filter(e => -1 === n.pendingLocalTracks.indexOf(e));\n              return _context12.abrupt(\"return\", void (n.pendingLocalTracks = n.pendingLocalTracks.concat(t)));\n            case 10:\n              n.store.pubId = n.store.pubId + 1, iB.markPublishStart(n.store.clientId, n.store.pubId);\n              o = n.filterTobePublishedTracks(e, t, i);\n              if (!(0 === o.length)) {\n                _context12.next = 16;\n                break;\n              }\n              _context12.next = 15;\n              return rB(n.tryToUnmuteAudio(e));\n            case 15:\n              return _context12.abrupt(\"return\", void _context12.sent);\n            case 16:\n              return _context12.delegateYield(gG(TW(n.doPublish(n.connection, o))), \"t0\", 17);\n            case 17:\n              _context12.prev = 17;\n              r();\n              return _context12.finish(17);\n            case 20:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, null, [[3,, 17, 20]]);\n      }))();\n    }\n    doPublish(e, t) {\n      var i = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var n, r, o, s, a, c, d, l;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              t.forEach(e => {\n                let t = e.track,\n                  n = e.type;\n                const r = Date.now();\n                i.store.publish(t.getTrackId(), n === sw.LocalAudioTrack ? \"audio\" : \"video\", r);\n              }), i.bindLocalTrackEvents(t);\n              n = t.map(e => {\n                let t = e.track;\n                return t;\n              });\n              _context13.next = 4;\n              return rB(e.send(t.map(e => {\n                let t = e.track;\n                return t;\n              }), i.store.codec, i.store.audioCodec));\n            case 4:\n              r = _context13.sent;\n              _context13.next = 7;\n              return rB(r.next());\n            case 7:\n              o = _context13.sent.value;\n              s = i.createGatewayPublishMessage(t, o);\n              _context13.prev = 9;\n              _context13.next = 12;\n              return s;\n            case 12:\n              a = _context13.sent;\n              _context13.next = 18;\n              break;\n            case 15:\n              _context13.prev = 15;\n              _context13.t0 = _context13[\"catch\"](9);\n              throw r.throw(_context13.t0), (null == _context13.t0 ? void 0 : _context13.t0.code) === tI.WS_ABORT && t.forEach(e => {\n                let t = e.track;\n                -1 === i.pendingLocalTracks.indexOf(t) && i.pendingLocalTracks.push(t);\n              }), i.unbindLocalTrackEvents(t), _context13.t0;\n            case 18:\n              c = i.mapPubResToRemoteConfig(s, a);\n              _context13.next = 21;\n              return rB(r.next(c));\n            case 21:\n              d = _context13.sent.value;\n              l = Dy(\"ENABLE_VIDEO_SEI\");\n              n.forEach(async e => {\n                const t = e.getRTCRtpTransceiver();\n                t && l && (e.trackMediaType === nw.VIDEO ? await QF(t.sender, e) : e.trackMediaType === nw.AUDIO && (await async function (e) {\n                  if (!_U().supportWebRTCEncodedTransform) return void Qy.warning(\"browser not support audio encoded transform\");\n                  if (zF.has(e)) return;\n                  if (!e.track) return;\n                  const t = {\n                    track: e.track\n                  };\n                  if (Ov()) {\n                    if (!e.createEncodedStreams) return void Qy.warning(\"browser not support createEncodedStreams() API\");\n                    let n = null;\n                    try {\n                      n = e.createEncodedStreams();\n                    } catch (e) {\n                      return void Qy.error(\"create audio-encoded-streams error\", e && e.message);\n                    }\n                    const r = new TransformStream({\n                      transform(n, r) {\n                        t.controller || (t.controller = r), e.track && e.track.id !== t.track.id && (Qy.debug(\"audio track changed: \".concat(t.track.id, \" => \").concat(e.track.id)), t.track.removeEventListener(\"ended\", i), t.track = e.track, t.track.addEventListener(\"ended\", i)), r.enqueue(n);\n                      }\n                    });\n                    n.readable.pipeThrough(r).pipeTo(n.writable);\n                  } else if (Nv()) {\n                    if (\"undefined\" == typeof RTCRtpScriptTransform) return void Qy.warning(\"browser not support RTCRtpScriptTransform\");\n                    const n = qF(),\n                      r = new MessageChannel();\n                    await new Gu(e => n.onmessage = t => {\n                      \"registered\" === t.data && e(void 0);\n                    });\n                    const o = new RTCRtpScriptTransform(n, {\n                      name: \"tx\",\n                      port: r.port2\n                    }, [r.port2]);\n                    e.transform = o, await new Gu(e => n.onmessage = t => {\n                      \"started\" === t.data && e(void 0);\n                    }), r.port1.onmessage = n => {\n                      var r;\n                      n.data.transformed && e.track && (null === (r = e.track) || void 0 === r ? void 0 : r.id) !== t.track.id && (Qy.debug(\"audio track changed: \".concat(t.track.id, \" => \").concat(e.track.id)), t.track.removeEventListener(\"ended\", i), t.track = e.track, t.track.addEventListener(\"ended\", i));\n                    }, t.worker = n;\n                  }\n                  function i() {\n                    if (e.track) {\n                      if (this.id !== e.track.id) return;\n                      e.track.removeEventListener(\"ended\", i);\n                    }\n                    const t = zF.get(e);\n                    if (t) {\n                      zF.delete(e);\n                      try {\n                        var n, r;\n                        null === (n = t.controller) || void 0 === n || n.terminate(), null === (r = t.worker) || void 0 === r || r.terminate();\n                      } catch (e) {\n                        Qy.warning(e && e.message);\n                      }\n                    }\n                  }\n                  zF.set(e, t), e.track.addEventListener(\"ended\", i);\n                }(t.sender)));\n              }), t.forEach(e => {\n                let t = e.type;\n                i.statsCollector.addLocalStats(t);\n              }), i.assignLocalTracks(t, d), i.statsUploader.startUploadOutboundStats(), t.forEach(e => {\n                let t = e.track,\n                  n = e.type;\n                const r = Date.now();\n                i.store.publish(t.getTrackId(), n === sw.LocalAudioTrack ? \"audio\" : \"video\", void 0, r);\n              });\n            case 24:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, null, [[9, 15]]);\n      }))();\n    }\n    async updateVideoStreamParameter(e, t) {\n      const i = this.localTrackMap.get(t);\n      if (!i) return;\n      if (!(i.track instanceof vF)) return Qy.warn(\"[updateVideoStreamParameter]: track is not an instance of LocalVideoTrack\");\n      if (!(this.connection instanceof XG || this.connection instanceof bG)) return Qy.warn(\"[updateVideoStreamParameter]: connection is not P2PConnection or P2PConnectionPlanB\");\n      const n = i.track,\n        r = function (e, t) {\n          const i = {};\n          return e.height && e.width && (i.scaleResolutionDownBy = Qw(e, t)), i.maxFramerate = e.framerate ? Yw(e.framerate) : void 0, i.maxBitrate = e.bitrate ? 1e3 * e.bitrate : void 0, i;\n        }(e, n);\n      if (n._encoderConfig || (n._encoderConfig = {}), t !== sw.LocalVideoLowTrack || !Dy(\"DISABLE_DUAL_STREAM_USE_ENCODING\") && _U().supportDualStreamEncoding) null != r.scaleResolutionDownBy && (n._encoderConfig.scaleResolutionDownBy = r.scaleResolutionDownBy);else {\n        const t = n._originMediaStreamTrack;\n        if (!t.canvas) return Qy.warn(\"[\".concat(n.getTrackId(), \"] no canvas on track\"));\n        !function (e, t) {\n          const i = e.canvas;\n          t.width && (i.width = Yw(t.width)), t.height && (i.height = Yw(t.height)), t.framerate && (i.stopCapture && i.stopCapture(), i.stopCapture = ux(() => {\n            !i.startCapture && i.stopCapture && i.stopCapture(), i.startCapture && i.startCapture();\n          }, Yw(t.framerate)));\n        }(t, e);\n      }\n      null != r.maxBitrate && (n._encoderConfig.bitrateMax = r.maxBitrate / 1e3), null != r.maxFramerate && (n._encoderConfig.frameRate && \"object\" == typeof n._encoderConfig.frameRate ? n._encoderConfig.frameRate.max = r.maxFramerate : n._encoderConfig.frameRate = {\n        max: r.maxFramerate\n      }), Qy.debug(\"[\".concat(n.getTrackId(), \"] LowStreamEncoderConfig: , \").concat(JSON.stringify(n._encoderConfig))), await this.connection.updateRtpSenderEncodings(n);\n    }\n    publishLowStream(e) {\n      var t = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var i, r, o, n, e;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              if (!(!t.connection || t.state !== aw.Connected)) {\n                _context14.next = 2;\n                break;\n              }\n              return _context14.abrupt(\"return\");\n            case 2:\n              _context14.next = 4;\n              return rB(t.mutex.lock(\"Locking from P2PChannel.publishLowStream\"));\n            case 4:\n              i = _context14.sent;\n              _context14.prev = 5;\n              r = t.localTrackMap.get(sw.LocalVideoTrack);\n              if (r) {\n                _context14.next = 9;\n                break;\n              }\n              throw new iI(tI.UNEXPECTED_ERROR, \"Could not find high stream\");\n            case 9:\n              if (!t.localTrackMap.has(sw.LocalVideoLowTrack)) {\n                _context14.next = 11;\n                break;\n              }\n              throw new iI(tI.UNEXPECTED_ERROR, \"[\".concat(t.store.clientId, \"] Can't publish low stream when stream already publish\"));\n            case 11:\n              o = [{\n                track: t.getLowVideoTrack(r.track, e),\n                type: sw.LocalVideoLowTrack\n              }];\n              return _context14.delegateYield(gG(TW(t.doPublish(t.connection, o))), \"t0\", 13);\n            case 13:\n              if (!(r.track.muted || !r.track.enabled)) {\n                _context14.next = 19;\n                break;\n              }\n              e = null === (n = t.localTrackMap.get(sw.LocalVideoLowTrack)) || void 0 === n ? void 0 : n.id;\n              _context14.t1 = void 0 !== e;\n              if (!_context14.t1) {\n                _context14.next = 19;\n                break;\n              }\n              _context14.next = 19;\n              return rB(t.connection.muteLocal([e]));\n            case 19:\n              _context14.prev = 19;\n              i();\n              return _context14.finish(19);\n            case 22:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, null, [[5,, 19, 22]]);\n      }))();\n    }\n    async republish() {\n      this.pendingLocalTracks.length > 0 && (Qy.debug(\"[\".concat(this.store.clientId, \"] Emit P2PChannelEvents.RequestRePublish to republish tracks.\")), await kI(this, cw.RequestRePublish, this.pendingLocalTracks), this.emit(cw.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []), this.pendingLocalDataChannels.length > 0 && (Qy.debug(\"Emit P2PChannelEvents.RequestRePublishDataChannel to republish datachannels.\"), await kI(this, cw.RequestRePublishDataChannel, this.pendingLocalDataChannels), this.pendingLocalDataChannels = []);\n    }\n    async reSubscribe(e) {\n      for (let e = this.pendingRemoteTracks.length - 1; e >= 0; e--) {\n        const _this$pendingRemoteTr = this.pendingRemoteTracks[e],\n          t = _this$pendingRemoteTr.user,\n          i = _this$pendingRemoteTr.kind;\n        (i !== nw.AUDIO || t._audio_added_ && t._audioSSRC) && (i !== nw.VIDEO || t._video_added_ && t._videoSSRC) || this.pendingRemoteTracks.splice(e, 1);\n      }\n      if (e) await kI(this, cw.RequestReSubscribe, this.pendingRemoteTracks);else for (const _ref28 of this.pendingRemoteTracks) {\n        const e = _ref28.user;\n        const t = _ref28.kind;\n        await this.subscribe(e, t, t === nw.VIDEO ? e._videoSSRC : e._audioSSRC);\n      }\n      this.pendingRemoteTracks.forEach(e => {\n        let t = e.user;\n        this.emit(cw.MediaReconnectEnd, t.uid);\n      }), this.pendingRemoteTracks = [];\n    }\n    async unpublish(e) {\n      if (!this.connection || this.state !== aw.Connected) return void e.forEach(e => {\n        const t = this.pendingLocalTracks.indexOf(e);\n        -1 !== t && this.pendingLocalTracks.splice(t, 1);\n      });\n      const t = this.filterTobeUnpublishedTracks(e);\n      if (0 === t.length) return;\n      const i = t.find(e => \"videoLowTrack\" === e[0]);\n      if (i) {\n        i[1].track.close();\n      }\n      return this.doUnpublish(this.connection, t);\n    }\n    async unpublishDataChannel(e) {\n      if (!this.connection || this.state !== aw.Connected) return void e.forEach(e => {\n        const t = this.pendingLocalDataChannels.indexOf(e);\n        -1 !== t && this.pendingLocalDataChannels.splice(t, 1);\n      });\n      const t = this.filterTobeUnpublishedDataChannels(e);\n      return 0 !== t.length ? (t.forEach(e => {\n        const t = this.localDataChannels.indexOf(e);\n        -1 !== t && this.localDataChannels.splice(t, 1);\n      }), 0 === this.localDataChannels.length && (await this.connection.stopDataChannels(this.store.uid)), t.map(e => e.id)) : void 0;\n    }\n    async unpublishLowStream() {\n      if (!this.connection || this.state !== aw.Connected) return;\n      const e = this.localTrackMap.get(sw.LocalVideoLowTrack);\n      if (!e) return;\n      e.track.close();\n      const t = [[sw.LocalVideoLowTrack, e]];\n      return this.doUnpublish(this.connection, t);\n    }\n    async doUnpublish(e, t) {\n      const i = this.createGatewayUnpublishMessage(t);\n      return await e.stopSending(t.map(e => {\n        let _e54 = _slicedToArray(e, 2),\n          t = _e54[1].id;\n        return t;\n      })), this.withdrawLocalTracks(t), this.unbindLocalTrackEvents(t.map(e => {\n        let _e55 = _slicedToArray(e, 2),\n          t = _e55[0],\n          i = _e55[1].track;\n        return {\n          type: t,\n          track: i\n        };\n      })), t.forEach(e => {\n        let _e56 = _slicedToArray(e, 1),\n          t = _e56[0];\n        this.statsCollector.removeLocalStats(t);\n      }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadOutboundStats(), i;\n    }\n    async subscribeDataChannel(e, t) {\n      if (!this.connection || this.state !== aw.Connected) throw new iI(tI.INVALID_OPERATION, \"Cannot subscribe remote user when peerConnection disconnected.\");\n      const i = t.filter(t => {\n        var i;\n        return !(null !== (i = this.remoteDataChannelMap.get(e)) && void 0 !== i && i.get(t.id));\n      });\n      if (0 !== i.length) return await this.connection.createDataChannels(e.uid, i), i.forEach(t => {\n        var i;\n        this.remoteDataChannelMap.has(e) ? null === (i = this.remoteDataChannelMap.get(e)) || void 0 === i || i.set(t.id, t) : this.remoteDataChannelMap.set(e, new Map([[t.id, t]]));\n        const n = this.pendingRemoteDataChannels.findIndex(i => {\n          let n = i.user,\n            r = i.id;\n          return n.uid === e.uid && r === t.id;\n        });\n        -1 !== n && this.pendingRemoteDataChannels.splice(n, 1);\n      }), i.map(e => e.id);\n    }\n    async subscribe(e, t, i, n, r) {\n      var o;\n      if (!this.connection || this.state !== aw.Connected) throw new iI(tI.INVALID_OPERATION, \"Cannot subscribe remote user when peerConnection disconnected.\");\n      if (null !== (o = this.remoteUserMap.get(e)) && void 0 !== o && o.has(t)) return;\n      let s, a, c;\n      if (r) {\n        const i = r.find(e => {\n          let i = e.stream_type;\n          return i === t;\n        });\n        if (!i) throw new iI(tI.UNEXPECTED_ERROR, \"Cannot subscribe to remote \".concat(t, \" for user: \").concat(e.uid, \" because subscribe answer from gateway does not contain stream_type: \").concat(t, \".\"));\n        const n = await this.connection.receive(t, i.ssrcs, String(e._uintid), i.attributes);\n        this.connection instanceof XG && (c = n.transceiver), s = n.track, a = n.id;\n      } else {\n        const r = await this.connection.receive(t, [{\n          ssrcId: i,\n          rtx: n\n        }], String(e._uintid), void 0);\n        this.connection instanceof XG && (c = r.transceiver), s = r.track, a = r.id;\n      }\n      t === nw.AUDIO ? (e._audioTrack ? e._audioTrack._updateOriginMediaStreamTrack(s) : (e._audioTrack = new BF(s, e.uid, e._uintid, this.store), Qy.info(\"[\".concat(this.store.clientId, \"] [\").concat(this.store.p2pId, \"] create remote audio track: \").concat(e._audioTrack.getTrackId()))), c && e._audioTrack._updateRtpTransceiver(c), this.bindRemoteTrackEvents(e, e._audioTrack)) : (e._videoTrack ? e._videoTrack._updateOriginMediaStreamTrack(s) : (e._videoTrack = new FF(s, e.uid, e._uintid, this.store), Qy.info(\"[\".concat(this.store.clientId, \"] [\").concat(this.store.p2pId, \"] create remote video track: \").concat(e._videoTrack.getTrackId()))), c && e._videoTrack._updateRtpTransceiver(c), this.bindRemoteTrackEvents(e, e._videoTrack)), Dy(\"ENABLE_VIDEO_SEI\") && c && (t == nw.VIDEO ? await $F(c.receiver, {\n        onSei: t => {\n          var i;\n          null === (i = e._videoTrack) || void 0 === i || i._onSei(t);\n        }\n      }) : t == nw.AUDIO && (await async function (e) {\n        if (!_U().supportWebRTCEncodedTransform) return void Qy.warning(\"browser not support audio encoded transform\");\n        if (JF.has(e)) return;\n        const t = {\n          track: e.track\n        };\n        if (Ov()) {\n          if (!e.createEncodedStreams) return void Qy.warning(\"browser not support createEncodedStreams() API\");\n          let n = null;\n          try {\n            n = e.createEncodedStreams();\n          } catch (e) {\n            return void Qy.error(\"create audio-encoded-streams error\", e && e.message);\n          }\n          const r = new TransformStream({\n            transform(n, r) {\n              t.controller || (t.controller = r), e.track && e.track.id !== t.track.id && (Qy.debug(\"audio track changed: \".concat(t.track.id, \" => \").concat(e.track.id)), t.track.removeEventListener(\"ended\", i), t.track = e.track, t.track.addEventListener(\"ended\", i)), r.enqueue(n);\n            }\n          });\n          n.readable.pipeThrough(r).pipeTo(n.writable);\n        } else if (Nv()) {\n          if (\"undefined\" == typeof RTCRtpScriptTransform) return void Qy.warning(\"browser not support RTCRtpScriptTransform\");\n          const n = qF(),\n            r = new MessageChannel();\n          await new Gu(e => n.onmessage = t => {\n            \"registered\" === t.data && e(void 0);\n          });\n          const o = new RTCRtpScriptTransform(n, {\n            name: \"rx\",\n            port: r.port2\n          }, [r.port2]);\n          e.transform = o, await new Gu(e => n.onmessage = t => {\n            \"started\" === t.data && e(void 0);\n          }), r.port1.onmessage = n => {\n            var r;\n            n.data.transformed && e.track && (null === (r = e.track) || void 0 === r ? void 0 : r.id) !== t.track.id && (Qy.debug(\"audio track changed: \".concat(t.track.id, \" => \").concat(e.track.id)), t.track.removeEventListener(\"ended\", i), t.track = e.track, t.track.addEventListener(\"ended\", i));\n          }, t.worker = n;\n        }\n        function i() {\n          e.track.removeEventListener(\"ended\", i), function (e) {\n            const t = JF.get(e);\n            if (t) {\n              JF.delete(e);\n              try {\n                var i, n;\n                null === (i = t.controller) || void 0 === i || i.terminate(), null === (n = t.worker) || void 0 === n || n.terminate();\n              } catch (e) {\n                Qy.warning(e && e.message);\n              }\n            }\n          }(e);\n        }\n        JF.set(e, t), e.track.addEventListener(\"ended\", i);\n      }(c.receiver)));\n      const d = this.remoteUserMap.get(e);\n      d ? d.set(t, a) : this.remoteUserMap.set(e, new Map([[t, a]])), this.statsCollector.addRemoteStats(e.uid), this.statsUploader.startUploadInboundStats();\n      const l = this.pendingRemoteTracks.findIndex(i => {\n        let n = i.user,\n          r = i.kind;\n        return n.uid === e.uid && t === r;\n      });\n      -1 !== l && (this.pendingRemoteTracks.splice(l, 1), this.emit(cw.MediaReconnectEnd, e.uid));\n    }\n    async massSubscribe(e) {\n      return this.massSubscribeNoLock(e);\n    }\n    async massSubscribeNoLock(e) {\n      if (!this.connection || this.state !== aw.Connected) throw new iI(tI.INVALID_OPERATION, \"Cannot subscribeAll remote users when peerConnection disconnected.\");\n      e = e.filter(e => {\n        var t;\n        let i = e.user,\n          n = e.mediaType;\n        return !(null !== (t = this.remoteUserMap.get(i)) && void 0 !== t && t.has(n));\n      });\n      const t = await this.connection.batchReceive(e.map(e => {\n        let t = e.user,\n          i = e.mediaType,\n          n = e.ssrcId,\n          r = e.rtxSsrcId;\n        return {\n          kind: i,\n          ssrcMsg: [{\n            ssrcId: n,\n            rtx: r\n          }],\n          mslabel: String(t._uintid)\n        };\n      }));\n      e.forEach((e, i) => {\n        let n = e.user,\n          r = e.mediaType;\n        const _t$i = t[i],\n          o = _t$i.track,\n          s = _t$i.id,\n          a = _t$i.transceiver;\n        r === nw.AUDIO ? (n._audioTrack ? n._audioTrack._updateOriginMediaStreamTrack(o) : (n._audioTrack = new BF(o, n.uid, n._uintid, this.store), Qy.info(\"[\".concat(this.store.clientId, \"] [\").concat(this.store.p2pId, \"] create remote audio track: \").concat(n._audioTrack.getTrackId()))), a && n._audioTrack._updateRtpTransceiver(a), this.bindRemoteTrackEvents(n, n._audioTrack)) : (n._videoTrack ? n._videoTrack._updateOriginMediaStreamTrack(o) : (n._videoTrack = new FF(o, n.uid, n._uintid, this.store), Qy.info(\"[\".concat(this.store.clientId, \"] [\").concat(this.store.p2pId, \"] create remote video track: \").concat(n._videoTrack.getTrackId()))), a && n._videoTrack._updateRtpTransceiver(a), this.bindRemoteTrackEvents(n, n._videoTrack));\n        const c = this.remoteUserMap.get(n);\n        c ? c.set(r, s) : this.remoteUserMap.set(n, new Map([[r, s]])), this.statsCollector.addRemoteStats(n.uid), this.statsUploader.startUploadInboundStats();\n        const d = this.pendingRemoteTracks.findIndex(e => {\n          let t = e.user,\n            i = e.kind;\n          return t.uid === n.uid && r === i;\n        });\n        -1 !== d && (this.pendingRemoteTracks.splice(d, 1), this.emit(cw.MediaReconnectEnd, n.uid));\n      });\n    }\n    async unsubscribe(e, t, i) {\n      const n = this.pendingRemoteTracks.filter(i => {\n        let n = i.user,\n          r = i.kind;\n        return void 0 !== t ? n.uid === e.uid && t === r : n.uid === e.uid;\n      });\n      if (n.forEach(e => {\n        const t = this.pendingRemoteTracks.indexOf(e);\n        this.pendingRemoteTracks.splice(t, 1);\n      }), this.connection && this.state === aw.Connected || i || n.forEach(t => {\n        let i = t.kind;\n        var n;\n        if (i === nw.AUDIO) null === (n = e._audioTrack) || void 0 === n || n._destroy(), e._audioTrack = void 0;else if (i === nw.VIDEO) {\n          var r;\n          null === (r = e._videoTrack) || void 0 === r || r._destroy(), e._videoTrack = void 0;\n        }\n      }), !this.connection || this.state !== aw.Connected) return;\n      const r = this.filterTobeUnSubscribedTracks(e, t);\n      if (0 === r.length) return;\n      await this.connection.stopReceiving(r.map(e => {\n        let _e57 = _slicedToArray(e, 2),\n          t = _e57[1].id;\n        return t;\n      }));\n      const o = this.createUnsubscribeMessage(r);\n      return this.withdrawRemoteTracks(r), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), r.forEach(e => {\n        let _e58 = _slicedToArray(e, 2),\n          t = _e58[0],\n          n = _e58[1].kind;\n        var r, o;\n        n === nw.VIDEO && t._videoSSRC && (null === (r = this.connection) || void 0 === r || r.setStatsRemoteVideoIsReady(t._videoSSRC, !1));\n        if (n === nw.VIDEO) this.unbindRemoteTrackEvents(t._videoTrack), i || (null === (o = t._videoTrack) || void 0 === o || o._destroy(), t._videoTrack = void 0);else if (n === nw.AUDIO) {\n          var s;\n          if (this.unbindRemoteTrackEvents(t._audioTrack), !i) null === (s = t._audioTrack) || void 0 === s || s._destroy(), t._audioTrack = void 0;\n        }\n      }), o;\n    }\n    async unsubscribeDataChannel(e, t) {\n      if (t.forEach(e => {\n        const t = this.pendingRemoteDataChannels.findIndex(t => t.id === e.id);\n        -1 !== t && this.pendingRemoteDataChannels.splice(t, 1);\n      }), !this.connection) return;\n      const i = this.filterTobeUnSubscribedDataChannels(e, t);\n      if (0 === i.length) return;\n      t.forEach(e => {\n        e._close();\n      });\n      const n = this.remoteDataChannelMap.get(e);\n      return i.forEach(e => {\n        n && n.delete(e.id);\n      }), n && 0 === n.size && (this.remoteDataChannelMap.delete(e), await this.connection.stopDataChannels(e.uid)), i.map(e => e.id);\n    }\n    async massUnsubscribe(e) {\n      return this.massUnsubscribeNoLock(e);\n    }\n    async massUnsubscribeNoLock(e) {\n      let t = [];\n      for (const _ref29 of e) {\n        const i = _ref29.user;\n        const n = _ref29.mediaType;\n        {\n          const e = this.pendingRemoteTracks.filter(e => {\n            let t = e.user,\n              r = e.kind;\n            return void 0 !== n ? t.uid === i.uid && n === r : t.uid === i.uid;\n          });\n          e.forEach(e => {\n            const t = this.pendingRemoteTracks.indexOf(e);\n            this.pendingRemoteTracks.splice(t, 1);\n          }), t = t.concat(e);\n        }\n      }\n      if (!this.connection || this.state !== aw.Connected) return void t.forEach(e => {\n        let t = e.user,\n          i = e.kind;\n        var n;\n        if (i === nw.AUDIO) null === (n = t._audioTrack) || void 0 === n || n._destroy(), t._audioTrack = void 0;else if (i === nw.VIDEO) {\n          var r;\n          null === (r = t._videoTrack) || void 0 === r || r._destroy(), t._videoTrack = void 0;\n        }\n      });\n      const i = Jn(e).call(e, (e, t) => {\n        let i = t.user,\n          n = t.mediaType;\n        const r = this.filterTobeUnSubscribedTracks(i, n);\n        return e.concat(r);\n      }, []);\n      if (0 === i.length) return;\n      await this.connection.stopReceiving(i.map(e => {\n        let _e59 = _slicedToArray(e, 2),\n          t = _e59[1].id;\n        return t;\n      }));\n      const n = this.createUnsubscribeAllMessage(i);\n      return this.withdrawRemoteTracks(i), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), i.forEach(e => {\n        let _e60 = _slicedToArray(e, 2),\n          t = _e60[0],\n          i = _e60[1].kind;\n        var n, r;\n        i === nw.VIDEO && t._videoSSRC && (null === (n = this.connection) || void 0 === n || n.setStatsRemoteVideoIsReady(t._videoSSRC, !1));\n        if (i === nw.VIDEO) this.unbindRemoteTrackEvents(t._videoTrack), null === (r = t._videoTrack) || void 0 === r || r._destroy(), t._videoTrack = void 0;else if (i === nw.AUDIO) {\n          var o;\n          this.unbindRemoteTrackEvents(t._audioTrack), null === (o = t._audioTrack) || void 0 === o || o._destroy(), t._audioTrack = void 0;\n        }\n      }), n;\n    }\n    async muteRemote(e, t) {\n      if (!this.connection) return;\n      const i = this.remoteUserMap.get(e);\n      if (!i) return void Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel.muteRemote has no remote user \").concat(e.uid, \".\"));\n      if (!i.get(t)) return void Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel.muteRemote has no remote user \").concat(e.uid, \" media type \").concat(t, \".\"));\n      const n = t === nw.VIDEO ? e._videoSSRC : e._audioSSRC;\n      void 0 !== n && this.connection.setStatsRemoteVideoIsReady(n, !1);\n    }\n    async unmuteRemote(e, t) {\n      return this.unmuteRemoteNoLock(e, t);\n    }\n    async unmuteRemoteNoLock(e, t) {\n      if (!this.connection) return;\n      const i = this.remoteUserMap.get(e);\n      if (!i) return void Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel.unmuteRemote has no remote user \").concat(e.uid, \".\"));\n      i.get(t) || Qy.warning(\"[\".concat(this.store.clientId, \"] P2PChannel.unmuteRemote has no remote user \").concat(e.uid, \" media type \").concat(t, \".\"));\n    }\n    getAllTracks(e) {\n      const t = this.localTrackMap.get(sw.LocalAudioTrack);\n      if ((null == t ? void 0 : t.track) instanceof UV) {\n        const i = t.track;\n        return Array.from(this.localTrackMap.entries()).filter(e => {\n          let _e61 = _slicedToArray(e, 1),\n            t = _e61[0];\n          return t !== sw.LocalAudioTrack;\n        }).filter(t => {\n          let _t14 = _slicedToArray(t, 1),\n            i = _t14[0];\n          return !(e && i === sw.LocalVideoLowTrack);\n        }).map(e => {\n          let _e62 = _slicedToArray(e, 2),\n            t = _e62[1].track;\n          return t;\n        }).concat(i.trackList);\n      }\n      return Array.from(this.localTrackMap.entries()).filter(t => {\n        let _t15 = _slicedToArray(t, 1),\n          i = _t15[0];\n        return !(e && i === sw.LocalVideoLowTrack);\n      }).map(e => {\n        let _e63 = _slicedToArray(e, 2),\n          t = _e63[1].track;\n        return t;\n      });\n    }\n    getAllDataChannels() {\n      return this.localDataChannels;\n    }\n    reportPublishEvent(e, t, i, n, r) {\n      if (e) {\n        const i = this.localTrackMap.get(sw.LocalAudioTrack),\n          o = n ? this.localTrackMap.get(sw.LocalVideoLowTrack) : this.localTrackMap.get(sw.LocalVideoTrack);\n        oA.publish(this.store.sessionId, {\n          eventElapse: iB.measureFromPublishStart(this.store.clientId, this.store.pubId),\n          succ: e,\n          ec: t,\n          audioName: null == i ? void 0 : i.track.getTrackLabel(),\n          videoName: null == o ? void 0 : o.track.getTrackLabel(),\n          screenshare: -1 !== (null == o ? void 0 : o.track._hints.indexOf(LU.SCREEN_TRACK)),\n          audio: !!i,\n          video: !!o,\n          p2pid: this.store.p2pId,\n          publishRequestid: this.store.pubId,\n          extend: r\n        });\n      } else {\n        var o;\n        i || (i = []);\n        const s = i.find(e => e instanceof LV),\n          a = n ? null === (o = this.localTrackMap.get(sw.LocalVideoTrack)) || void 0 === o ? void 0 : o.track : i.find(e => e instanceof vF);\n        oA.publish(this.store.sessionId, {\n          eventElapse: iB.measureFromPublishStart(this.store.clientId, this.store.pubId),\n          succ: e,\n          ec: t,\n          audioName: null == s ? void 0 : s.getTrackLabel(),\n          videoName: null == a ? void 0 : a.getTrackLabel(),\n          screenshare: -1 !== (null == a ? void 0 : a._hints.indexOf(LU.SCREEN_TRACK)),\n          audio: !!s,\n          video: !!a,\n          p2pid: this.store.p2pId,\n          publishRequestid: this.store.pubId,\n          extend: r\n        });\n      }\n    }\n    reportSubscribeEvent(e, t, i, n) {\n      const r = n === nw.VIDEO ? i._videoSSRC : i._audioSSRC;\n      r && oA.subscribe(this.store.sessionId, {\n        succ: e,\n        ec: t,\n        video: n === nw.VIDEO,\n        audio: n === nw.AUDIO,\n        peerid: i.uid,\n        subscribeRequestid: n === nw.VIDEO ? i._videoSSRC : i._audioSSRC,\n        p2pid: this.store.p2pId,\n        eventElapse: iB.measureFromSubscribeStart(this.store.clientId, r)\n      });\n    }\n    reset() {\n      Qy.debug(\"[\".concat(this.store.clientId, \"] P2PChannel.reset\")), this.mutex = new uy(\"P2PChannel-mutex\"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new pW({}, this.store) : this.isPlanB ? new bG({}, this.store) : new XG({}, this.store), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();\n      const e = this.localTrackMap.get(sw.LocalAudioTrack);\n      if ((null == e ? void 0 : e.track) instanceof UV) {\n        if (e.track.trackList.length > 0) {\n          const t = e.track;\n          e.track.trackList.forEach(e => {\n            t.removeAudioTrack(e);\n          });\n        }\n        e.track.close();\n      }\n      this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.localDataChannels = [], this.remoteDataChannelMap.clear(), this.pendingLocalDataChannels = [], this.pendingRemoteDataChannels = [], this.state = aw.Disconnected;\n    }\n    getStats() {\n      var e;\n      return null === (e = this.connection) || void 0 === e ? void 0 : e.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      var t;\n      return (null === (t = this.connection) || void 0 === t ? void 0 : t.getRemoteVideoIsReady(e)) || !1;\n    }\n    getLocalAudioVolume() {\n      const e = this.localTrackMap.get(sw.LocalAudioTrack);\n      if (e) return e.track.getVolumeLevel();\n    }\n    getLocalVideoSize() {\n      const e = this.localTrackMap.get(sw.LocalVideoTrack);\n      if (e) return {\n        width: e.track.videoWidth || 0,\n        height: e.track.videoHeight || 0\n      };\n    }\n    getEncoderConfig(e) {\n      const t = this.localTrackMap.get(e);\n      return t && t.track instanceof vF || t && t.track instanceof LV ? t.track._encoderConfig : void 0;\n    }\n    getLocalMedia(e) {\n      return this.localTrackMap.get(e);\n    }\n    hasLocalMedia() {\n      return this.localTrackMap.size > 0;\n    }\n    hasRemoteMedia(e, t) {\n      if (!e) return this.remoteUserMap.size > 0;\n      const i = this.remoteUserMap.get(e);\n      return !!i && (!t || i.has(t));\n    }\n    async hasRemoteMediaWithLock(e, t) {\n      if (!e) return this.remoteUserMap.size > 0;\n      const i = this.remoteUserMap.get(e);\n      return !!i && (!t || i.has(t));\n    }\n    getRemoteMedia(e) {\n      var t;\n      const i = Array.from(d_(t = this.remoteUserMap).call(t)).find(t => t.uid === e);\n      return i ? {\n        audioTrack: i.audioTrack,\n        audioSSRC: i._audioSSRC,\n        videoTrack: i.videoTrack,\n        videoSSRC: i._videoSSRC\n      } : {};\n    }\n    getAudioLevels() {\n      let e = Array.from(this.remoteUserMap.entries()).map(e => {\n        let _e64 = _slicedToArray(e, 1),\n          t = _e64[0];\n        return {\n          uid: t.uid,\n          level: t.audioTrack ? 100 * t.audioTrack._source.getAccurateVolumeLevel() : 0\n        };\n      });\n      const t = this.localTrackMap.get(sw.LocalAudioTrack);\n      return t && e.push({\n        level: 100 * t.track._source.getAccurateVolumeLevel(),\n        uid: this.store.uid\n      }), e = oE(e).call(e, (e, t) => e.level - t.level), e;\n    }\n    async disconnectForReconnect() {\n      this.connection && (Qy.debug(\"[\".concat(this.store.clientId, \"] P2PChannel.disconnectForReconnect closing P2PConnection\")), this.state = aw.Reconnecting, Dy(\"KEEP_LAST_FRAME\") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach(e => {\n        let _e65 = _slicedToArray(e, 1),\n          t = _e65[0];\n        var i;\n        t._videoTrack && t._videoTrack._player && (null === (i = t._videoTrack._player.getVideoElement()) || void 0 === i || i.pause(), t._videoTrack._player.isKeepLastFrame = !0, t._videoTrack._originMediaStreamTrack.stop());\n      }), this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new pW({}, this.store) : this.isPlanB ? new bG({}, this.store) : new XG({}, this.store), this.bindConnectionEvents(this.connection)), 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach(e => {\n        var t;\n        let _e66 = _slicedToArray(e, 2),\n          i = _e66[0],\n          n = _e66[1].track;\n        switch (i) {\n          case sw.LocalVideoTrack:\n            Dn(t = n._hints).call(t, LU.LOW_STREAM) ? n.close() : this.pendingLocalTracks.push(n);\n            break;\n          case sw.LocalAudioTrack:\n            n instanceof UV ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n.trackList) : this.pendingLocalTracks.push(n);\n          case sw.LocalVideoLowTrack:\n        }\n      }), this.emit(cw.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach(e => {\n        let _e67 = _slicedToArray(e, 2),\n          t = _e67[0],\n          i = _e67[1];\n        Array.from(d_(i).call(i)).forEach(e => {\n          this.setPendingRemoteMedia(t, e);\n        }), this.emit(cw.MediaReconnectStart, t.uid);\n      }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), 0 !== this.localDataChannels.length && (this.localDataChannels.forEach(e => {\n        this.pendingLocalDataChannels.push(e);\n      }), this.localDataChannels.length = 0), 0 !== this.remoteDataChannelMap.size && (Array.from(this.remoteDataChannelMap.entries()).forEach(e => {\n        let _e68 = _slicedToArray(e, 2),\n          t = _e68[0],\n          i = _e68[1];\n        Array.from(d_(i).call(i)).forEach(e => {\n          this.setPendingRemoteDataChannel(t, e);\n        });\n      }), this.remoteDataChannelMap.clear()), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), Qy.debug(\"[\".concat(this.store.clientId, \"] P2PChannel disconnected, waiting to reconnect.\")));\n    }\n    hasPendingRemoteDataChannel(e, t) {\n      for (const i of this.pendingRemoteDataChannels) {\n        const n = i.user,\n          r = i.id;\n        if ((e instanceof Bj ? e.uid : e) === n.uid && r === t) return !0;\n      }\n      return !1;\n    }\n    setPendingRemoteDataChannel(e, t) {\n      this.hasPendingRemoteDataChannel(e, t) || this.pendingRemoteDataChannels.push({\n        user: e,\n        id: t\n      });\n    }\n    hasPendingRemoteMedia(e, t) {\n      for (const i of this.pendingRemoteTracks) {\n        const n = i.user,\n          r = i.kind;\n        if ((e instanceof Bj ? e.uid : e) === n.uid && t === r) return !0;\n      }\n      return !1;\n    }\n    setPendingRemoteMedia(e, t) {\n      this.hasPendingRemoteMedia(e, t) || this.pendingRemoteTracks.push({\n        user: e,\n        kind: t\n      });\n    }\n    restartICE(e) {\n      var t = this;\n      return pB( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var i, n, r, o, s;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              if (!(!t.connection || t.state !== aw.Connected || t.connection instanceof pW)) {\n                _context15.next = 2;\n                break;\n              }\n              return _context15.abrupt(\"return\");\n            case 2:\n              _context15.next = 4;\n              return rB(t.mutex.lock(\"From P2PChannel.restartICE\"));\n            case 4:\n              i = _context15.sent;\n              _context15.prev = 5;\n              _context15.next = 8;\n              return rB(t.connection.restartICE(e));\n            case 8:\n              n = _context15.sent;\n              _context15.next = 11;\n              return rB(n.next());\n            case 11:\n              r = _context15.sent;\n              if (!r.done) {\n                _context15.next = 14;\n                break;\n              }\n              return _context15.abrupt(\"return\");\n            case 14:\n              o = r.value;\n              _context15.next = 17;\n              return o;\n            case 17:\n              s = _context15.sent;\n              _context15.t0 = (t.reportPCDisconnectedOrFailed(e), e);\n              _context15.next = _context15.t0 === rw.TCP ? 21 : _context15.t0 === rw.RELAY ? 23 : 25;\n              break;\n            case 21:\n              t._pcStatsUploadType = ow.TCP_RESTART;\n              return _context15.abrupt(\"break\", 26);\n            case 23:\n              t._pcStatsUploadType = ow.RELAY_RESTART;\n              return _context15.abrupt(\"break\", 26);\n            case 25:\n              t._pcStatsUploadType = ow.OLD_RESTART;\n            case 26:\n              t._isInRestartIce = !0, n.next(s);\n              _context15.next = 32;\n              break;\n            case 29:\n              _context15.prev = 29;\n              _context15.t1 = _context15[\"catch\"](5);\n              null === (r = n) || void 0 === r || r.throw(_context15.t1);\n            case 32:\n              _context15.prev = 32;\n              i();\n              return _context15.finish(32);\n            case 35:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, null, [[5, 29, 32, 35]]);\n      }))();\n    }\n    getUplinkNetworkQuality() {\n      if (!this.connection) return 0;\n      const e = this.connection.getStats(),\n        t = this.localTrackMap.get(sw.LocalVideoTrack),\n        i = this.localTrackMap.get(sw.LocalAudioTrack),\n        n = e.videoSend.find(e => e.ssrc === (null == t ? void 0 : t.ssrcs[0].ssrcId)),\n        r = e.audioSend.find(e => e.ssrc === (null == i ? void 0 : i.ssrcs[0].ssrcId));\n      if (!n || !r) return 1;\n      const o = UI(this, cw.NeedSignalRTT),\n        s = n ? n.rttMs : void 0,\n        a = r ? r.rttMs : void 0,\n        c = s && a ? (s + a) / 2 : s || a,\n        d = (c && o ? (c + o) / 2 : c || o) || 0,\n        l = 100 * e.sendPacketLossRate * .7 / 50 + .3 * d / 1500,\n        h = l < .17 ? 1 : l < .36 ? 2 : l < .59 ? 3 : l < .1 ? 4 : 5,\n        u = null == t ? void 0 : t.track;\n      if (u && u._encoderConfig && -1 === u._hints.indexOf(LU.SCREEN_TRACK)) {\n        const t = u._encoderConfig.bitrateMax,\n          i = e.bitrate.actualEncoded;\n        if (t && i) {\n          const e = (1e3 * t - i) / (1e3 * t);\n          return cA[e < .15 ? 0 : e < .3 ? 1 : e < .45 ? 2 : e < .6 ? 3 : 4][h];\n        }\n      }\n      return h;\n    }\n    getDownlinkNetworkQuality() {\n      if (!this.connection) return 0;\n      const e = this.connection.getStats();\n      let t = 0;\n      return Array.from(this.remoteUserMap.entries()).forEach(i => {\n        let _i5 = _slicedToArray(i, 1),\n          n = _i5[0];\n        const r = n._audioSSRC,\n          o = n._videoSSRC,\n          s = e.audioRecv.find(e => e.ssrc === r),\n          a = e.videoRecv.find(e => e.ssrc === o);\n        if (!s && !a) return void (t += 1);\n        const c = UI(this, cw.NeedSignalRTT),\n          d = e.rtt,\n          l = (d && c ? (d + c) / 2 : d || c) || 0,\n          h = s ? s.jitterMs : void 0,\n          u = e.recvPacketLossRate;\n        let p = .7 * u * 100 / 50 + .3 * l / 1500;\n        h && (p = .6 * u * 100 / 50 + .2 * l / 1500 + .2 * h / 400);\n        t += p < .1 ? 1 : p < .17 ? 2 : p < .36 ? 3 : p < .59 ? 4 : 5;\n      }), this.remoteUserMap.size > 0 ? Math.round(t / this.remoteUserMap.size) : t;\n    }\n    async muteLocalTrack(e) {\n      return new Gu((t, i) => {\n        this.handleMuteLocalTrack(e, t, i);\n      });\n    }\n    async replaceTrack(e, t) {\n      var i;\n      if (Qy.debug(\"[\".concat(this.store.clientId, \"] P2PChannel replaceTrack from [\").concat(e.getTrackId(), \"] to [\").concat(t.getTrackId(), \"]\")), !this.connection || this.state !== aw.Connected) return;\n      const n = Array.from(this.localTrackMap.entries()).find(t => {\n        let _t16 = _slicedToArray(t, 2),\n          i = _t16[1].track;\n        return e === i;\n      });\n      if (!n) return;\n      const r = n[0];\n      if (e !== t && (this.unbindLocalTrackEvents([{\n        track: e,\n        type: r\n      }]), this.bindLocalTrackEvents([{\n        track: t,\n        type: r\n      }]), n[1].track = t), await (null === (i = this.connection) || void 0 === i ? void 0 : i.replaceTrack(t, n[1].id)), this.isPlanB) {\n        const e = n[1];\n        e.id = t._mediaStreamTrack.id, this.localTrackMap.set(r, e);\n      }\n      if (r === sw.LocalVideoTrack && !Dy(\"DISABLE_DUAL_STREAM_USE_ENCODING\") && _U().supportDualStreamEncoding) {\n        const t = this.localTrackMap.get(sw.LocalVideoLowTrack);\n        if (t) {\n          const i = e._mediaStreamTrack.clone();\n          t.track._originMediaStreamTrack.stop(), t.track._mediaStreamTrack = i, t.track._originMediaStreamTrack = i, await new Gu((e, i) => {\n            this.handleReplaceTrack(t.track, e, i, !0);\n          });\n        }\n      }\n    }\n    filterTobePublishedTracks(e, t, i) {\n      const n = [],\n        r = this.getAllTracks();\n      e = BI(e = e.filter(e => -1 === r.indexOf(e)));\n      let o,\n        s = !1;\n      const a = this.localTrackMap.get(sw.LocalAudioTrack);\n      for (const r of e) {\n        if (r instanceof vF && (this.localTrackMap.has(sw.LocalVideoTrack) || s ? new iI(tI.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n.push({\n          track: r,\n          type: sw.LocalVideoTrack\n        }), s = !0), t)) {\n          const e = this.getLowVideoTrack(r, i);\n          n.push({\n            track: e,\n            type: sw.LocalVideoLowTrack\n          });\n        }\n        if (r instanceof LV) if (a) {\n          const e = a.track;\n          if (e instanceof UV) Wj([r]), e.addAudioTrack(r), this.bindLocalAudioTrackEvents(r, !0);else {\n            const t = Hj([e, r]);\n            Qy.debug(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection will replace audioTrack [\").concat(t.getTrackId(), \"]\")), this.replaceTrack(e, t);\n          }\n        } else if (o instanceof UV) Wj([r]), o.addAudioTrack(r);else if (o || !r._useAudioElement && _U().webAudioMediaStreamDest && !r._bypassWebAudio) {\n          o = Hj(o ? [r, o] : [r]);\n        } else o = r;\n      }\n      return o && (Qy.debug(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection will send audioTrack [\").concat(o.getTrackId(), \"]\")), n.push({\n        track: o,\n        type: sw.LocalAudioTrack\n      })), n;\n    }\n    filterTobeUnpublishedTracks(e) {\n      const t = [],\n        i = this.getAllTracks();\n      e = BI(e = e.filter(e => -1 !== i.indexOf(e)));\n      for (const i of e) {\n        if (i instanceof LV) {\n          const e = this.localTrackMap.get(sw.LocalAudioTrack);\n          if (!e) continue;\n          e.track instanceof UV ? (e.track.removeAudioTrack(i), this.unbindLocalAudioTrackEvents(i), 0 === e.track.trackList.length && (t.push([sw.LocalAudioTrack, e]), e.track.close())) : t.push([sw.LocalAudioTrack, e]);\n        }\n        if (i instanceof vF) {\n          const e = this.localTrackMap.get(sw.LocalVideoTrack);\n          if (!e) continue;\n          t.push([sw.LocalVideoTrack, e]);\n          const i = this.localTrackMap.get(sw.LocalVideoLowTrack);\n          i && t.push([sw.LocalVideoLowTrack, i]);\n        }\n      }\n      return t;\n    }\n    filterTobePublishedDataChannels(e) {\n      return e = (e = BI(e)).filter(e => -1 === this.localDataChannels.findIndex(t => t.id === e.id));\n    }\n    filterTobeUnpublishedDataChannels(e) {\n      return e = (e = (e = BI(e)).filter(e => -1 !== this.localDataChannels.indexOf(e))).filter(e => e._originDataChannel);\n    }\n    bindLocalTrackEvents(e) {\n      e.forEach(e => {\n        let t = e.track,\n          i = e.type;\n        switch (i) {\n          case sw.LocalVideoTrack:\n            t.addListener(PU.GET_STATS, this.handleGetLocalVideoStats), t.addListener(PU.GET_RTC_STATS, this.handleGetRTCStats), t.addListener(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t.addListener(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t.addListener(PU.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t.addListener(PU.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t.addListener(PU.NEED_REPLACE_TRACK, this.handleReplaceTrack), t.addListener(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t.addListener(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n            break;\n          case sw.LocalAudioTrack:\n            this.bindLocalAudioTrackEvents(t);\n          case sw.LocalVideoLowTrack:\n        }\n      });\n    }\n    bindLocalAudioTrackEvents(e, t) {\n      e instanceof UV ? e.trackList.forEach(e => {\n        e.addListener(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.addListener(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.addListener(PU.GET_STATS, this.handleGetLocalAudioStats), e.addListener(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.addListener(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n      }) : (e.addListener(PU.GET_STATS, this.handleGetLocalAudioStats), e.addListener(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.addListener(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.addListener(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.addListener(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t || (e.addListener(PU.NEED_REPLACE_TRACK, this.handleReplaceTrack), e.addListener(PU.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack)));\n    }\n    unbindLocalTrackEvents(e) {\n      e || (e = Array.from(this.localTrackMap.entries()).map(e => {\n        let _e69 = _slicedToArray(e, 2),\n          t = _e69[0],\n          i = _e69[1].track;\n        return {\n          track: i,\n          type: t\n        };\n      })), e.forEach(e => {\n        let t = e.track,\n          i = e.type;\n        switch (i) {\n          case sw.LocalVideoTrack:\n            t.off(PU.GET_STATS, this.handleGetLocalVideoStats), t.off(PU.GET_RTC_STATS, this.handleGetRTCStats), t.off(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t.off(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t.off(PU.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t.off(PU.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t.off(PU.NEED_REPLACE_TRACK, this.handleReplaceTrack), t.off(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t.off(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n            break;\n          case sw.LocalAudioTrack:\n            this.unbindLocalAudioTrackEvents(t);\n          case sw.LocalVideoLowTrack:\n        }\n      });\n    }\n    unbindLocalAudioTrackEvents(e) {\n      e instanceof UV ? e.trackList.forEach(e => {\n        e.off(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(PU.GET_STATS, this.handleGetLocalAudioStats), e.off(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n      }) : (e.off(PU.GET_STATS, this.handleGetLocalAudioStats), e.off(PU.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(PU.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(PU.NEED_REPLACE_TRACK, this.handleReplaceTrack), e.off(PU.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack), e.off(PU.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(PU.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));\n    }\n    bindRemoteTrackEvents(e, t) {\n      t instanceof FF && t.addListener(PU.GET_STATS, t => {\n        t(this.handleGetRemoteVideoStats(e));\n      }), t instanceof BF && t.addListener(PU.GET_STATS, t => {\n        t(this.handleGetRemoteAudioStats(e));\n      });\n    }\n    unbindRemoteTrackEvents(e) {\n      e && e.removeAllListeners(PU.GET_STATS);\n    }\n    unbindAllRemoteTrackEvents() {\n      Array.from(this.remoteUserMap.entries()).forEach(e => {\n        let _e70 = _slicedToArray(e, 2),\n          t = _e70[0],\n          i = _e70[1];\n        i.has(nw.AUDIO) && this.unbindRemoteTrackEvents(t._audioTrack), i.has(nw.VIDEO) && this.unbindRemoteTrackEvents(t._videoTrack);\n      });\n    }\n    createGatewayPublishMessage(e, t) {\n      return e.map((e, i) => {\n        var n;\n        let r,\n          o,\n          s = e.track,\n          a = e.type;\n        switch (a) {\n          case sw.LocalAudioTrack:\n            r = Kb.Audio, o = {\n              dtx: s instanceof kV && s._config.DTX,\n              hq: !1,\n              lq: !1,\n              stereo: !1,\n              speech: !1\n            };\n            break;\n          case sw.LocalVideoTrack:\n            r = Dn(n = s._hints).call(n, LU.SCREEN_TRACK) ? Kb.Screen : Kb.High, o = fW(fW({}, qw(s)), {}, {\n              codec: this.store.codec\n            });\n            break;\n          case sw.LocalVideoLowTrack:\n            r = Kb.Low, o = fW(fW({}, qw(s)), {}, {\n              codec: this.store.codec\n            });\n        }\n        return {\n          stream_type: r,\n          attributes: o,\n          ssrcs: t[i]\n        };\n      });\n    }\n    createGatewayUnpublishMessage(e) {\n      return e.map(e => {\n        var t;\n        let i,\n          _e71 = _slicedToArray(e, 2),\n          n = _e71[0],\n          _e71$ = _e71[1],\n          r = _e71$.track,\n          o = _e71$.ssrcs,\n          s = _e71$.id;\n        switch (n) {\n          case sw.LocalVideoTrack:\n            i = Dn(t = r._hints).call(t, LU.SCREEN_TRACK) ? Kb.Screen : Kb.High;\n            break;\n          case sw.LocalAudioTrack:\n            i = Kb.Audio;\n            break;\n          case sw.LocalVideoLowTrack:\n            i = Kb.Low;\n        }\n        return {\n          stream_type: i,\n          ssrcs: o,\n          mid: s\n        };\n      });\n    }\n    assignLocalTracks(e, t) {\n      e.forEach((e, i) => {\n        let n = e.track,\n          r = e.type;\n        this.localTrackMap.set(r, {\n          track: n,\n          id: t[i].id,\n          ssrcs: t[i].localSSRC\n        });\n      });\n    }\n    withdrawLocalTracks(e) {\n      e.forEach(e => {\n        let _e72 = _slicedToArray(e, 1),\n          t = _e72[0];\n        this.localTrackMap.delete(t);\n      });\n    }\n    bindConnectionEvents(e) {\n      e.onConnectionStateChange = async t => {\n        if (Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.onConnectionStateChange(\").concat(t, \")\")), this.emit(cw.PeerConnectionStateChange, t), \"connected\" !== t || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), \"connected\" === t && (this._restartTimer && (clearTimeout(this._restartTimer), this._restartTimer = void 0), (this._isFirstConnected || this._isInRestartIce) && this.reportPCStats(Date.now(), !0, this._pcStatsUploadType), this._isInRestartIce = !1, this._isFirstConnected = !1, this._isStartRestartIce = !1), Dy(\"NEW_ICE_RESTART\")) {\n          var i;\n          if (Dn(i = this._restartStates).call(i, t)) {\n            if (this._isStartRestartIce) return;\n            this._isStartRestartIce = !0;\n            const t = t => {\n                if (\"disconnected\" === e.iceConnectionState || \"checking\" === e.iceConnectionState || \"failed\" === e.iceConnectionState) {\n                  Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PChannel] start use restartICE, type is \").concat(t));\n                  \"CONNECTED\" === UI(this, cw.QueryClientConnectionState) && this.emit(cw.RequestRestartICE, t);\n                }\n              },\n              i = () => {\n                \"disconnected\" !== e.iceConnectionState && \"checking\" !== e.iceConnectionState && \"failed\" !== e.iceConnectionState || (this.reportPCStats(Date.now(), !1, this._pcStatsUploadType), Qy.debug(\"[\".concat(this.store.clientId, \"] P2PConnection disconnected timeout, force reconnect\")), setTimeout(() => this.emit(cw.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());\n              },\n              n = Dy(\"ICE_RESTART_INTERVAL\");\n            return void (this._restartTimer = window.setTimeout(() => {\n              if (Dy(\"JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE\") && _U().supportPCSetConfiguration) t(rw.RELAY), this._restartTimer = window.setTimeout(i, n);else if (Pv()) t(rw.UDP), this._restartTimer = window.setTimeout(i, 4e3);else {\n                if (t(rw.TCP), _U().supportPCSetConfiguration) return void (this._restartTimer = window.setTimeout(() => {\n                  t(rw.RELAY), this._restartTimer = window.setTimeout(i, n);\n                }, n));\n                this._restartTimer = window.setTimeout(i, n);\n              }\n            }, 800));\n          }\n        } else {\n          if (\"disconnected\" === t && \"disconnected\" === e.iceConnectionState) return setTimeout(() => {\n            if (\"disconnected\" === e.iceConnectionState && Dy(\"ICE_RESTART\")) {\n              \"CONNECTED\" === UI(this, cw.QueryClientConnectionState) && this.emit(cw.RequestRestartICE);\n            }\n          }, 800), void setTimeout(() => {\n            \"disconnected\" === e.peerConnectionState && (Qy.debug(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection disconnected timeout 4000ms, force reconnect\")), this.reportPCStats(Date.now(), !1, this._pcStatsUploadType), this._isInRestartIce = !1, setTimeout(() => this.emit(cw.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());\n          }, 4e3);\n          \"failed\" === t && (Qy.debug(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection state failed, force reconnect\")), this.reportPCDisconnectedOrFailed(), setTimeout(() => this.emit(cw.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());\n        }\n      }, e.onICEConnectionStateChange = e => {\n        \"connected\" !== e || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.onICEConnectionStateChange(\").concat(e, \")\")), oA.reportApiInvoke(this.store.sessionId, {\n          name: \"ICEConnectionStateChange\",\n          options: e,\n          tag: vI.TRACER\n        }).onSuccess(), this.emit(cw.IceConnectionStateChange, e);\n      }, e.onICETransportStateChange = e => {\n        Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.onICETransportStateChange(\").concat(e, \")\"));\n      }, e.onDTLSTransportStateChange = e => {\n        Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.onDTLSTransportStateChange(\").concat(e, \")\"));\n      }, e.onDTLSTransportError = e => {\n        Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.onDTLSTransportError(\").concat(e, \")\"));\n      }, e.onFirstAudioDecoded = e => {\n        var t;\n        const i = Array.from(d_(t = this.remoteUserMap).call(t)).find(t => t._audioSSRC === e);\n        var n;\n        i && (this.store.subscribe(i.uid, \"audio\", void 0, void 0, void 0, Date.now()), null === (n = i.audioTrack) || void 0 === n || n.emit(FU.FIRST_FRAME_DECODED), oA.firstRemoteFrame(this.store.sessionId, tA.FIRST_AUDIO_DECODE, iA.FIRST_AUDIO_DECODE, {\n          peer: i._uintid,\n          subscribeElapse: iB.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId\n        }));\n      }, e.onFirstAudioReceived = e => {\n        var t;\n        const i = Array.from(d_(t = this.remoteUserMap).call(t)).find(t => t._audioSSRC === e);\n        i && oA.firstRemoteFrame(this.store.sessionId, tA.FIRST_AUDIO_RECEIVED, iA.FIRST_AUDIO_RECEIVED, {\n          peer: i._uintid,\n          subscribeElapse: iB.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId\n        });\n      }, e.onFirstVideoDecoded = (e, t, i) => {\n        this.reportVideoFirstFrameDecoded(e, t, i);\n      }, e.onFirstVideoReceived = e => {\n        var t;\n        const i = Array.from(d_(t = this.remoteUserMap).call(t)).find(t => t._videoSSRC === e);\n        i && oA.firstRemoteFrame(this.store.sessionId, tA.FIRST_VIDEO_RECEIVED, iA.FIRST_VIDEO_RECEIVED, {\n          peer: i._uintid,\n          subscribeElapse: iB.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId\n        });\n      }, e.onSelectedLocalCandidateChanged = (e, t) => {\n        const i = \"relay\" === e.candidateType,\n          n = \"relay\" === t.candidateType;\n        \"unknown\" !== t.candidateType && i === n || this.emit(cw.ConnectionTypeChange, i), Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.SelectedLocalCandidateChanged(\").concat(JSON.stringify(Zw(t)), \" -> \").concat(JSON.stringify(Zw(e)), \")\"));\n      }, e.onSelectedRemoteCandidateChanged = (e, t) => {\n        Qy.info(\"[\".concat(this.store.clientId, \"] [p2pId: \").concat(this.store.p2pId, \"]: P2PConnection.SelectedRemoteCandidateChanged(\").concat(JSON.stringify(Zw(t)), \" -> \").concat(JSON.stringify(Zw(e)), \")\"));\n      }, e.onFirstVideoDecodedTimeout = e => {\n        this.reportVideoFirstFrameDecoded(e, void 0, void 0, !0);\n      }, e.getLocalVideoStats = () => {\n        const e = this.statsCollector.getLocalVideoTrackStats(),\n          t = this.statsCollector.getRTCStats();\n        return fW(fW({}, e), t);\n      };\n    }\n    unbindConnectionEvents(e) {\n      e.onConnectionStateChange = void 0, e.onICEConnectionStateChange = void 0, e.onICETransportStateChange = void 0, e.onDTLSTransportStateChange = void 0, e.onDTLSTransportError = void 0, e.onFirstAudioDecoded = void 0, e.onFirstAudioReceived = void 0, e.onFirstVideoDecoded = void 0, e.onFirstVideoReceived = void 0, e.onSelectedLocalCandidateChanged = void 0, e.onSelectedRemoteCandidateChanged = void 0, e.onFirstVideoDecodedTimeout = void 0, e.getLocalVideoStats = void 0;\n    }\n    filterTobeMutedTracks(e) {\n      const t = [];\n      if (-1 === this.getAllTracks().indexOf(e)) return t;\n      const i = this.localTrackMap.get(sw.LocalAudioTrack);\n      if (e instanceof LV && (null == i ? void 0 : i.track) instanceof UV) return i.track.isActive || t.push([sw.LocalAudioTrack, i]), t;\n      const n = Array.from(this.localTrackMap.entries()).find(t => {\n        let _t17 = _slicedToArray(t, 2),\n          i = _t17[1].track;\n        return e === i;\n      });\n      if (n && (t.push(n), n[0] === sw.LocalVideoTrack)) {\n        const e = this.localTrackMap.get(sw.LocalVideoLowTrack);\n        e && t.push([sw.LocalVideoLowTrack, e]);\n      }\n      return t;\n    }\n    filterTobeUnmutedTracks(e) {\n      const t = [],\n        i = this.localTrackMap.get(sw.LocalAudioTrack);\n      if (e instanceof LV && (null == i ? void 0 : i.track) instanceof UV) return i.track.isActive && t.push([sw.LocalAudioTrack, i]), t;\n      const n = Array.from(this.localTrackMap.entries()).find(t => {\n        let _t18 = _slicedToArray(t, 2),\n          i = _t18[1].track;\n        return e === i;\n      });\n      if (n) if (n[0] === sw.LocalVideoTrack) {\n        t.push(n);\n        const e = this.localTrackMap.get(sw.LocalVideoLowTrack);\n        e && t.push([sw.LocalVideoLowTrack, e]);\n      } else t.push(n);\n      return t;\n    }\n    createMuteMessage(e) {\n      return e.map(e => {\n        var t;\n        let i,\n          _e73 = _slicedToArray(e, 2),\n          n = _e73[0],\n          _e73$ = _e73[1],\n          r = _e73$.track,\n          o = _e73$.ssrcs,\n          s = _e73$.id;\n        switch (n) {\n          case sw.LocalAudioTrack:\n            i = Kb.Audio;\n            break;\n          case sw.LocalVideoTrack:\n            i = Dn(t = r._hints).call(t, LU.SCREEN_TRACK) ? Kb.Screen : Kb.High;\n            break;\n          case sw.LocalVideoLowTrack:\n            i = Kb.Low;\n        }\n        return {\n          stream_type: i,\n          ssrcs: o,\n          mid: s\n        };\n      });\n    }\n    createUnmuteMessage(e) {\n      return e.map(e => {\n        var t;\n        let i,\n          _e74 = _slicedToArray(e, 2),\n          n = _e74[0],\n          _e74$ = _e74[1],\n          r = _e74$.track,\n          o = _e74$.ssrcs,\n          s = _e74$.id;\n        switch (n) {\n          case sw.LocalAudioTrack:\n            i = Kb.Audio;\n            break;\n          case sw.LocalVideoTrack:\n            i = Dn(t = r._hints).call(t, LU.SCREEN_TRACK) ? Kb.Screen : Kb.High;\n            break;\n          case sw.LocalVideoLowTrack:\n            i = Kb.Low;\n        }\n        return {\n          stream_type: i,\n          ssrcs: o,\n          mid: s\n        };\n      });\n    }\n    filterTobeUnSubscribedTracks(e, t) {\n      const i = [],\n        n = this.remoteUserMap.get(e);\n      if (!n) return i;\n      if (t) {\n        const r = n.get(t);\n        if (!r) return i;\n        i.push([e, {\n          kind: t,\n          id: r\n        }]);\n      } else Array.from(n.entries()).forEach(t => {\n        let _t19 = _slicedToArray(t, 2),\n          n = _t19[0],\n          r = _t19[1];\n        i.push([e, {\n          kind: n,\n          id: r\n        }]);\n      });\n      return i;\n    }\n    filterTobeUnSubscribedDataChannels(e, t) {\n      const i = [];\n      return t.forEach(t => {\n        var n;\n        null !== (n = this.remoteDataChannelMap.get(e)) && void 0 !== n && n.has(t.id) && i.push(t);\n      }), i;\n    }\n    createUnsubscribeMessage(e) {\n      const t = [];\n      return e.forEach(e => {\n        let _e75 = _slicedToArray(e, 2),\n          i = _e75[0],\n          _e75$ = _e75[1],\n          n = _e75$.kind,\n          r = _e75$.id;\n        switch (n) {\n          case nw.VIDEO:\n            return void (i._videoSSRC && t.push({\n              stream_type: nw.VIDEO,\n              ssrcId: i._videoSSRC\n            }));\n          case nw.AUDIO:\n            return void (i._audioSSRC && t.push({\n              stream_type: nw.AUDIO,\n              ssrcId: i._audioSSRC\n            }));\n        }\n      }), t;\n    }\n    createUnsubscribeAllMessage(e) {\n      const t = new Map();\n      return e.forEach(e => {\n        let _e76 = _slicedToArray(e, 2),\n          i = _e76[0],\n          n = _e76[1].kind;\n        if (t.has(i)) {\n          let e = t.get(i);\n          n === nw.VIDEO ? e |= zb.Video : e |= zb.Audio, t.set(i, e);\n        } else n === nw.VIDEO ? t.set(i, zb.Video) : t.set(i, zb.Audio);\n      }), {\n        users: Array.from(t.entries()).map(e => {\n          let _e77 = _slicedToArray(e, 2),\n            t = _e77[0],\n            i = _e77[1];\n          return {\n            stream_id: t.uid,\n            stream_type: i\n          };\n        })\n      };\n    }\n    withdrawRemoteTracks(e) {\n      e.forEach(e => {\n        let _e78 = _slicedToArray(e, 2),\n          t = _e78[0],\n          i = _e78[1].kind;\n        const n = this.remoteUserMap.get(t);\n        n && (n.delete(i), 0 === Array.from(n.entries()).length && this.remoteUserMap.delete(t));\n      });\n    }\n    async updateBitrateLimit(e) {\n      const t = this.localTrackMap.get(sw.LocalVideoTrack),\n        i = this.localTrackMap.get(sw.LocalVideoLowTrack);\n      t && (await t.track.setBitrateLimit(e.uplink)), i && e.low_stream_uplink && (await i.track.setBitrateLimit({\n        max_bitrate: e.low_stream_uplink.bitrate,\n        min_bitrate: e.low_stream_uplink.bitrate || 0\n      }));\n    }\n    isP2PDisconnected() {\n      if (this.connection) {\n        return \"connected\" !== this.connection.peerConnectionState;\n      }\n      return !0;\n    }\n    mapPubResToRemoteConfig(e, t) {\n      return e.map((e, i) => {\n        var n;\n        let r = e.stream_type;\n        return null === (n = t.find(e => {\n          let t = e.stream_type;\n          return r === t;\n        })) || void 0 === n ? void 0 : n.attributes;\n      });\n    }\n    async tryToUnmuteAudio(e) {\n      for (let i = 0; i < e.length; i++) if (e[i] instanceof LV) {\n        var t;\n        const n = this.filterTobeUnmutedTracks(e[i]);\n        if (0 === n.length) continue;\n        await (null === (t = this.connection) || void 0 === t ? void 0 : t.unmuteLocal(n.map(e => {\n          let _e79 = _slicedToArray(e, 2),\n            t = _e79[1].id;\n          return t;\n        })));\n        const r = this.createUnmuteMessage(n);\n        return void (await MI(this, cw.RequestUnmuteLocal, r));\n      }\n    }\n    bindStatsUploaderEvents() {\n      this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = e => {\n        var t;\n        return !(null === (t = this.connection) || void 0 === t || !t.getRemoteVideoIsReady(e));\n      }, this.statsUploader.requestUpload = (e, t) => this.emit(cw.RequestUpload, e, t), this.statsUploader.requestUploadStats = e => this.emit(cw.RequestUploadStats, e), this.statsUploader.requestAllTracks = () => this.getAllTracks();\n    }\n    unbindStatsUploaderEvents() {\n      this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;\n    }\n    async requestReconnect() {\n      this.dtlsFailedCount += 1, await $I(Ey(this.dtlsFailedCount, _y)), this.emit(cw.RequestReconnect);\n    }\n    async reconnectP2P() {\n      const e = Array.from(this.localTrackMap.entries()),\n        t = this.createGatewayUnpublishMessage(e);\n      Array.from(this.remoteUserMap.entries()), t.length > 0 && (await kI(this, cw.RequestUnpublishForReconnectPC, t)), this.disconnectForReconnect(), this.emit(cw.RequestReconnectPC);\n    }\n    canPublishLowStream() {\n      return this.localTrackMap.has(sw.LocalVideoTrack) || this.pendingLocalTracks.some(e => e instanceof vF);\n    }\n    throwIfTrackTypeNotMatch(e) {\n      if (e.filter(e => e instanceof vF).length > 1) throw new iI(tI.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);\n      if (e.filter(e => e instanceof LV).length > 1 && (e.some(e => e instanceof LV && e._bypassWebAudio) || !_U().webAudioMediaStreamDest)) throw new iI(tI.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode\");\n      for (const t of e) {\n        if (t instanceof vF && this.pendingLocalTracks.some(e => e instanceof vF)) throw new iI(tI.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);\n        if (t instanceof LV && this.pendingLocalTracks.some(e => e instanceof LV) && (!_U().webAudioMediaStreamDest || t._bypassWebAudio || this.pendingLocalTracks.some(e => e instanceof LV && e._bypassWebAudio))) throw new iI(tI.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode\");\n      }\n    }\n    getLowVideoTrack(e, t) {\n      const i = !Dy(\"DISABLE_DUAL_STREAM_USE_ENCODING\") && _U().supportDualStreamEncoding,\n        n = fW(fW({}, {\n          width: 160,\n          height: 120,\n          framerate: 15,\n          bitrate: 50\n        }), t);\n      let r;\n      r = i ? e._mediaStreamTrack.clone() : vj(e, n);\n      const o = ey(8, \"track-low-\"),\n        s = new vF(r, fW(fW({}, i && {\n          scaleResolutionDownBy: Qw(n, e)\n        }), {}, {\n          frameRate: n.framerate,\n          bitrateMax: n.bitrate,\n          bitrateMin: n.bitrate\n        }), void 0, void 0, o);\n      return s.on(xU.TRANSCEIVER_UPDATED, t => {\n        e._updateRtpTransceiver(t, kU.LOW_STREAM);\n      }), s._hints.push(LU.LOW_STREAM), e.on(\"sei-to-send\", e => {\n        s.emit(\"sei-to-send\", e);\n      }), e.addListener(PU.NEED_CLOSE, () => {\n        s.close();\n      }), s;\n    }\n    async globalLock() {\n      return this.mutex.lock(\"From P2PChannel.globalLock\");\n    }\n    async reportPCStats(e, t, i) {\n      let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;\n      if (this.connection && this.connection instanceof XG) {\n        var r, o, s, a;\n        const c = this.store.keyMetrics.descriptionStart || 0,\n          _this$connection = this.connection,\n          d = _this$connection.iceConnectionState,\n          l = _this$connection.dtlsTransportState,\n          h = _this$connection.peerConnectionState,\n          _await$this$connectio = await this.connection.getSelectedCandidatePair(),\n          u = _await$this$connectio.local,\n          p = _await$this$connectio.remote;\n        oA.pcStats(this.store.sessionId, {\n          startTime: c,\n          eventElapse: e - c || 0,\n          iceconnectionsate: d,\n          dtlsstate: l,\n          connectionstate: h,\n          intSucc: t ? 1 : 2,\n          error: n,\n          selectedLocalCandidateProtocol: null !== (r = null == u ? void 0 : u.protocol) && void 0 !== r ? r : \"\",\n          selectedLocalCandidateType: null !== (o = u.candidateType) && void 0 !== o ? o : \"\",\n          selectedLocalCandidateAddress: \"\".concat(u.address, \":\").concat(u.port),\n          selectedRemoteCandidateProtocol: null !== (s = p.protocol) && void 0 !== s ? s : \"\",\n          selectedRemoteCandidateType: null !== (a = p.candidateType) && void 0 !== a ? a : \"\",\n          selectedRemoteCandidateAddress: \"\".concat(p.address, \":\").concat(p.port),\n          restartCnt: i\n        });\n      }\n    }\n    reportVideoFirstFrameDecoded(e, t, i, n) {\n      var r;\n      const o = Array.from(d_(r = this.remoteUserMap).call(r)).find(t => t._videoSSRC === e);\n      if (o) {\n        n || this.store.subscribe(o.uid, \"video\", void 0, void 0, void 0, void 0, Date.now());\n        const r = this.store.keyMetrics,\n          s = r.subscribe.find(e => e.userId === o.uid && \"video\" === e.type);\n        oA.firstRemoteVideoDecode(this.store.sessionId, tA.FIRST_VIDEO_DECODE, iA.FIRST_VIDEO_DECODE, {\n          peer: o._uintid,\n          videowidth: t,\n          videoheight: i,\n          subscribeElapse: iB.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId,\n          apEnd: r.requestAPEnd || 0,\n          apStart: r.requestAPStart || 0,\n          joinGwEnd: r.joinGatewayEnd || 0,\n          joinGwStart: r.joinGatewayStart || 0,\n          pcEnd: r.peerConnectionEnd || 0,\n          pcStart: r.peerConnectionStart || 0,\n          subscriberEnd: (null == s ? void 0 : s.subscribeEnd) || 0,\n          subscriberStart: (null == s ? void 0 : s.subscribeStart) || 0,\n          videoAddNotify: (null == s ? void 0 : s.streamAdded) || 0,\n          state: n ? 1 : 0\n        });\n      }\n    }\n    async remoteMediaSsrcChanged(e, t, i) {\n      if (!this.connection) return !1;\n      const n = this.remoteUserMap.get(e);\n      if (!n) return !1;\n      const r = n.get(t);\n      if (!r) return !1;\n      const o = await this.connection.getRemoteSSRC(r);\n      return void 0 !== o && o !== i;\n    }\n    resetConnection(e) {\n      Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PChannel] reset connection to \").concat(e)), this.state === aw.Connected ? (Qy.debug(\"[\".concat(this.store.clientId, \"] [P2PChannel] fallback to websocket but P2PChannel state still connected, disconnect first\")), this.disconnectForReconnect()) : (this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = e === Jb.datachannel ? new pW({}, this.store) : this.isPlanB ? new bG({}, this.store) : new XG({}, this.store), this.bindConnectionEvents(this.connection)));\n    }\n    unbindRtpTransceiver() {\n      0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach(e => {\n        let _e80 = _slicedToArray(e, 2),\n          t = _e80[0],\n          i = _e80[1].track;\n        t === sw.LocalVideoLowTrack ? i._updateRtpTransceiver(void 0, kU.LOW_STREAM) : i._updateRtpTransceiver(void 0);\n      });\n    }\n    reportPCDisconnectedOrFailed(e) {\n      this.connection && this.connection instanceof XG && (\"disconnected\" !== this.connection.iceConnectionState && \"checking\" !== this.connection.iceConnectionState && \"failed\" !== this.connection.iceConnectionState || (this._isFirstConnected ? (this.reportPCStats(Date.now(), !1, this._pcStatsUploadType), this._isFirstConnected = !1) : this._pcStatsUploadType === ow.TCP_RESTART && e === rw.RELAY ? this.reportPCStats(Date.now(), !1, this._pcStatsUploadType) : this.reportPCStats(Date.now(), !1, ow.DISCONNECTED_OR_FAILED)));\n    }\n  }, nb(EW.prototype, \"startP2PConnection\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"startP2PConnection\"), EW.prototype), nb(EW.prototype, \"connect\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"connect\"), EW.prototype), nb(EW.prototype, \"updateRemoteRTPCapabilities\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"updateRemoteRTPCapabilities\"), EW.prototype), nb(EW.prototype, \"preConnect\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"preConnect\"), EW.prototype), nb(EW.prototype, \"publishDataChannel\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"publishDataChannel\"), EW.prototype), nb(EW.prototype, \"unpublish\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"unpublish\"), EW.prototype), nb(EW.prototype, \"unpublishDataChannel\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"unpublishDataChannel\"), EW.prototype), nb(EW.prototype, \"unpublishLowStream\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"unpublishLowStream\"), EW.prototype), nb(EW.prototype, \"subscribeDataChannel\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"subscribeDataChannel\"), EW.prototype), nb(EW.prototype, \"subscribe\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"subscribe\"), EW.prototype), nb(EW.prototype, \"massSubscribe\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"massSubscribe\"), EW.prototype), nb(EW.prototype, \"unsubscribe\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"unsubscribe\"), EW.prototype), nb(EW.prototype, \"unsubscribeDataChannel\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"unsubscribeDataChannel\"), EW.prototype), nb(EW.prototype, \"massUnsubscribe\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"massUnsubscribe\"), EW.prototype), nb(EW.prototype, \"muteRemote\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"muteRemote\"), EW.prototype), nb(EW.prototype, \"unmuteRemote\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"unmuteRemote\"), EW.prototype), nb(EW.prototype, \"hasRemoteMediaWithLock\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"hasRemoteMediaWithLock\"), EW.prototype), nb(EW.prototype, \"disconnectForReconnect\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"disconnectForReconnect\"), EW.prototype), nb(EW.prototype, \"updateBitrateLimit\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"updateBitrateLimit\"), EW.prototype), nb(EW.prototype, \"remoteMediaSsrcChanged\", [RW], Object.getOwnPropertyDescriptor(EW.prototype, \"remoteMediaSsrcChanged\"), EW.prototype), EW);\n  function RW(e, t, i) {\n    const n = e[t];\n    if (\"function\" != typeof n) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"From P2PChannel.\".concat(t));\n      try {\n        for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];\n        return await n.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  function CW(e) {\n    let t = LW();\n    return function (e, t) {\n      let i = e.appId;\n      void 0 !== i && (qW(t, 10), BW(t, i));\n      let n = e.cid;\n      void 0 !== n && (qW(t, 16), qW(t, n));\n      let r = e.cname;\n      void 0 !== r && (qW(t, 26), BW(t, r));\n      let o = e.deviceId;\n      void 0 !== o && (qW(t, 34), BW(t, o));\n      let s = e.elapse;\n      void 0 !== s && (qW(t, 40), zW(t, s));\n      let a = e.fileSize;\n      void 0 !== a && (qW(t, 48), zW(t, DW(a)));\n      let c = e.height;\n      void 0 !== c && (qW(t, 56), zW(t, DW(c)));\n      let d = e.jpg;\n      void 0 !== d && (qW(t, 66), qW(t, d.length), function (e, t) {\n        let i = xW(e, t.length);\n        e.bytes.set(t, i);\n      }(t, d));\n      let l = e.networkType;\n      void 0 !== l && (qW(t, 72), zW(t, DW(l)));\n      let h = e.osType;\n      void 0 !== h && (qW(t, 80), zW(t, DW(h)));\n      let u = e.requestId;\n      void 0 !== u && (qW(t, 90), BW(t, u));\n      let p = e.sdkVersion;\n      void 0 !== p && (qW(t, 98), BW(t, p));\n      let _ = e.sequence;\n      void 0 !== _ && (qW(t, 104), zW(t, DW(_)));\n      let E = e.sid;\n      void 0 !== E && (qW(t, 114), BW(t, E));\n      let m = e.timestamp;\n      void 0 !== m && (qW(t, 120), zW(t, m));\n      let f = e.uid;\n      void 0 !== f && (qW(t, 128), qW(t, f));\n      let T = e.vid;\n      void 0 !== T && (qW(t, 136), qW(t, T));\n      let S = e.width;\n      void 0 !== S && (qW(t, 144), zW(t, DW(S)));\n      let g = e.service;\n      void 0 !== g && (qW(t, 152), qW(t, g));\n      let R = e.callbackData;\n      void 0 !== R && (qW(t, 162), BW(t, R));\n      let C = e.jpgEncryption;\n      void 0 !== C && (qW(t, 168), qW(t, C));\n      let v = e.requestType;\n      void 0 !== v && (qW(t, 176), qW(t, v));\n      let I = e.scorePorn;\n      void 0 !== I && (qW(t, 185), KW(t, I));\n      let y = e.scoreSexy;\n      void 0 !== y && (qW(t, 193), KW(t, y));\n      let A = e.scoreNeutral;\n      void 0 !== A && (qW(t, 201), KW(t, A));\n      let b = e.scene;\n      void 0 !== b && (qW(t, 208), qW(t, b));\n      let w = e.ossFilePrefix;\n      void 0 !== w && (qW(t, 218), BW(t, w));\n      let O = e.serviceVendor;\n      if (void 0 !== O) for (let e of O) {\n        qW(t, 226);\n        let i = LW();\n        yW(e, i), qW(t, i.limit), jW(t, i), kW(i);\n      }\n    }(e, t), function (e) {\n      let t = e.bytes,\n        i = e.limit;\n      return t.length === i ? t : t.subarray(0, i);\n    }(t);\n  }\n  function vW(e) {\n    return function (e) {\n      let t = {};\n      e: for (; !UW(e);) {\n        let i = YW(e);\n        switch (i >>> 3) {\n          case 0:\n            break e;\n          case 1:\n            t.code = YW(e);\n            break;\n          case 2:\n            t.msg = FW(e, YW(e));\n            break;\n          case 3:\n            {\n              let i = AW(e);\n              t.data = IW(e), e.limit = i;\n              break;\n            }\n          default:\n            bW(e, 7 & i);\n        }\n      }\n      return t;\n    }({\n      bytes: t = e,\n      offset: 0,\n      limit: t.length\n    });\n    var t;\n  }\n  function IW(e) {\n    let t = {};\n    e: for (; !UW(e);) {\n      let i = YW(e);\n      switch (i >>> 3) {\n        case 0:\n          break e;\n        case 1:\n          t.requestId = FW(e, YW(e));\n          break;\n        case 2:\n          t.requestType = YW(e) >>> 0;\n          break;\n        case 3:\n          t.scorePorn = HW(e);\n          break;\n        case 4:\n          t.scoreSexy = HW(e);\n          break;\n        case 5:\n          t.scoreNeutral = HW(e);\n          break;\n        case 6:\n          t.requestScene = YW(e) >>> 0;\n          break;\n        case 7:\n          t.scene = YW(e) >>> 0;\n          break;\n        default:\n          bW(e, 7 & i);\n      }\n    }\n    return t;\n  }\n  function yW(e, t) {\n    let i = e.service;\n    void 0 !== i && (qW(t, 8), qW(t, i));\n    let n = e.vendor;\n    void 0 !== n && (qW(t, 16), qW(t, n));\n    let r = e.token;\n    void 0 !== r && (qW(t, 26), BW(t, r));\n    let o = e.callbackUrl;\n    void 0 !== o && (qW(t, 34), BW(t, o));\n  }\n  function AW(e) {\n    let t = YW(e),\n      i = e.limit;\n    return e.limit = e.offset + t, i;\n  }\n  function bW(e, t) {\n    switch (t) {\n      case 0:\n        for (; 128 & GW(e););\n        break;\n      case 2:\n        MW(e, YW(e));\n        break;\n      case 5:\n        MW(e, 4);\n        break;\n      case 1:\n        MW(e, 8);\n        break;\n      default:\n        throw new Error(\"Unimplemented type: \" + t);\n    }\n  }\n  let wW = new Float32Array(1);\n  new Uint8Array(wW.buffer);\n  let OW = new Float64Array(1),\n    NW = new Uint8Array(OW.buffer);\n  function DW(e) {\n    return {\n      low: e |= 0,\n      high: e >> 31,\n      unsigned: e >= 0\n    };\n  }\n  let PW = [];\n  function LW() {\n    const e = PW.pop();\n    return e ? (e.offset = e.limit = 0, e) : {\n      bytes: new Uint8Array(64),\n      offset: 0,\n      limit: 0\n    };\n  }\n  function kW(e) {\n    PW.push(e);\n  }\n  function MW(e, t) {\n    if (e.offset + t > e.limit) throw new Error(\"Skip past limit\");\n    e.offset += t;\n  }\n  function UW(e) {\n    return e.offset >= e.limit;\n  }\n  function xW(e, t) {\n    let i = e.bytes,\n      n = e.offset,\n      r = e.limit,\n      o = n + t;\n    if (o > i.length) {\n      let t = new Uint8Array(2 * o);\n      t.set(i), e.bytes = t;\n    }\n    return e.offset = o, o > r && (e.limit = o), n;\n  }\n  function VW(e, t) {\n    let i = e.offset;\n    if (i + t > e.limit) throw new Error(\"Read past limit\");\n    return e.offset += t, i;\n  }\n  function FW(e, t) {\n    let i = VW(e, t),\n      n = String.fromCharCode,\n      r = e.bytes,\n      o = \"ï¿½\",\n      s = \"\";\n    for (let e = 0; e < t; e++) {\n      let a,\n        c,\n        d,\n        l,\n        h = r[e + i];\n      0 == (128 & h) ? s += n(h) : 192 == (224 & h) ? e + 1 >= t ? s += o : (a = r[e + i + 1], 128 != (192 & a) ? s += o : (l = (31 & h) << 6 | 63 & a, l < 128 ? s += o : (s += n(l), e++))) : 224 == (240 & h) ? e + 2 >= t ? s += o : (a = r[e + i + 1], c = r[e + i + 2], 32896 != (49344 & (a | c << 8)) ? s += o : (l = (15 & h) << 12 | (63 & a) << 6 | 63 & c, l < 2048 || l >= 55296 && l <= 57343 ? s += o : (s += n(l), e += 2))) : 240 == (248 & h) ? e + 3 >= t ? s += o : (a = r[e + i + 1], c = r[e + i + 2], d = r[e + i + 3], 8421504 != (12632256 & (a | c << 8 | d << 16)) ? s += o : (l = (7 & h) << 18 | (63 & a) << 12 | (63 & c) << 6 | 63 & d, l < 65536 || l > 1114111 ? s += o : (l -= 65536, s += n(55296 + (l >> 10), 56320 + (1023 & l)), e += 3))) : s += o;\n    }\n    return s;\n  }\n  function BW(e, t) {\n    let i = t.length,\n      n = 0;\n    for (let e = 0; e < i; e++) {\n      let r = t.charCodeAt(e);\n      r >= 55296 && r <= 56319 && e + 1 < i && (r = (r << 10) + t.charCodeAt(++e) - 56613888), n += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;\n    }\n    qW(e, n);\n    let r = xW(e, n),\n      o = e.bytes;\n    for (let e = 0; e < i; e++) {\n      let n = t.charCodeAt(e);\n      n >= 55296 && n <= 56319 && e + 1 < i && (n = (n << 10) + t.charCodeAt(++e) - 56613888), n < 128 ? o[r++] = n : (n < 2048 ? o[r++] = n >> 6 & 31 | 192 : (n < 65536 ? o[r++] = n >> 12 & 15 | 224 : (o[r++] = n >> 18 & 7 | 240, o[r++] = n >> 12 & 63 | 128), o[r++] = n >> 6 & 63 | 128), o[r++] = 63 & n | 128);\n    }\n  }\n  function jW(e, t) {\n    let i = xW(e, t.limit),\n      n = e.bytes,\n      r = t.bytes;\n    for (let e = 0, o = t.limit; e < o; e++) n[e + i] = r[e];\n  }\n  function GW(e) {\n    return e.bytes[VW(e, 1)];\n  }\n  function WW(e, t) {\n    let i = xW(e, 1);\n    e.bytes[i] = t;\n  }\n  function HW(e) {\n    let t = VW(e, 8),\n      i = e.bytes;\n    return NW[0] = i[t++], NW[1] = i[t++], NW[2] = i[t++], NW[3] = i[t++], NW[4] = i[t++], NW[5] = i[t++], NW[6] = i[t++], NW[7] = i[t++], OW[0];\n  }\n  function KW(e, t) {\n    let i = xW(e, 8),\n      n = e.bytes;\n    OW[0] = t, n[i++] = NW[0], n[i++] = NW[1], n[i++] = NW[2], n[i++] = NW[3], n[i++] = NW[4], n[i++] = NW[5], n[i++] = NW[6], n[i++] = NW[7];\n  }\n  function YW(e) {\n    let t,\n      i = 0,\n      n = 0;\n    do {\n      t = GW(e), i < 32 && (n |= (127 & t) << i), i += 7;\n    } while (128 & t);\n    return n;\n  }\n  function qW(e, t) {\n    for (t >>>= 0; t >= 128;) WW(e, 127 & t | 128), t >>>= 7;\n    WW(e, t);\n  }\n  function zW(e, t) {\n    let i = t.low >>> 0,\n      n = (t.low >>> 28 | t.high << 4) >>> 0,\n      r = t.high >>> 24,\n      o = 0 === r ? 0 === n ? i < 16384 ? i < 128 ? 1 : 2 : i < 1 << 21 ? 3 : 4 : n < 16384 ? n < 128 ? 5 : 6 : n < 1 << 21 ? 7 : 8 : r < 128 ? 9 : 10,\n      s = xW(e, o),\n      a = e.bytes;\n    switch (o) {\n      case 10:\n        a[s + 9] = r >>> 7 & 1;\n      case 9:\n        a[s + 8] = 9 !== o ? 128 | r : 127 & r;\n      case 8:\n        a[s + 7] = 8 !== o ? n >>> 21 | 128 : n >>> 21 & 127;\n      case 7:\n        a[s + 6] = 7 !== o ? n >>> 14 | 128 : n >>> 14 & 127;\n      case 6:\n        a[s + 5] = 6 !== o ? n >>> 7 | 128 : n >>> 7 & 127;\n      case 5:\n        a[s + 4] = 5 !== o ? 128 | n : 127 & n;\n      case 4:\n        a[s + 3] = 4 !== o ? i >>> 21 | 128 : i >>> 21 & 127;\n      case 3:\n        a[s + 2] = 3 !== o ? i >>> 14 | 128 : i >>> 14 & 127;\n      case 2:\n        a[s + 1] = 2 !== o ? i >>> 7 | 128 : i >>> 7 & 127;\n      case 1:\n        a[s] = 1 !== o ? 128 | i : 127 & i;\n    }\n  }\n  function JW(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  const XW = new Map([[\"moderation\", 1], [\"supervise\", 2]]);\n  class QW extends SI {\n    get connectionState() {\n      return this._connectionState;\n    }\n    set connectionState(e) {\n      if (this._connectionState === e) return;\n      const t = this._connectionState;\n      this._connectionState = e, this.emit(hw.CONNECTION_STATE_CHANGE, t, e);\n    }\n    get inspectType() {\n      return this._inspectType;\n    }\n    set inspectType(e) {\n      var t;\n      this._inspectMode = Jn(t = e.map(e => XW.get(e) || 0)).call(t, (e, t) => e + t), this._inspectType = e;\n    }\n    get quality() {\n      return this._quality;\n    }\n    set quality(e) {\n      this._quality = e > 1 ? 1 : e < .1 ? .1 : e, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {\n        this.quality = this._quality / this.qualityRatio;\n      }, 6e4));\n    }\n    constructor(e) {\n      super(), ng(this, \"name\", \"AgoraRTCVideoContentInspect\"), ng(this, \"_connectionState\", dw.CONNECTING), ng(this, \"_innerConnectionState\", void 0), ng(this, \"sequence\", 0), ng(this, \"inspectStartTime\", void 0), ng(this, \"workerManagerConnection\", void 0), ng(this, \"workerConnection\", void 0), ng(this, \"workerMessageLengthLimit\", void 0), ng(this, \"inspectIntervalMinimum\", void 0), ng(this, \"qualityRatio\", void 0), ng(this, \"_connectInfo\", void 0), ng(this, \"_cancelTokenSource\", pv.CancelToken.source()), ng(this, \"_retryConfig\", void 0), ng(this, \"wmSequence\", 0), ng(this, \"inspectInterval\", void 0), ng(this, \"inspectTimer\", null), ng(this, \"ossFilePrefix\", void 0), ng(this, \"extraInfo\", void 0), ng(this, \"_inspectType\", void 0), ng(this, \"_inspectMode\", void 0), ng(this, \"_quality\", 1), ng(this, \"qualityTimer\", null), ng(this, \"_inspectId\", void 0), ng(this, \"_needWorkUrlOnly\", !1), ng(this, \"inspectImage\", () => {\n        if (this.connectionState !== dw.CONNECTED) throw new bb(tI.OPERATION_ABORTED, \"content inspect service connection status is \".concat(this.connectionState));\n        this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {\n          this.connectionState === dw.CONNECTED ? this.requestToInspectImage() : Qy.debug(\"[\".concat(this._inspectId, \"] Inspect State is not connected , \"), this.connectionState);\n        }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();\n      }), this._inspectId = ey(5, \"inspect-\"), this.workerMessageLengthLimit = Dy(\"VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT\"), this.inspectIntervalMinimum = Dy(\"VIDEO_INSPECT_INTERVAL_MINIMUM\"), this.qualityRatio = Dy(\"VIDEO_INSPECT_QUALITY_RATIO\"), this.inspectInterval = e.interval, this.ossFilePrefix = e.ossFilePrefix, this.extraInfo = e.extraInfo, this.inspectType = e.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new Fw(\"worker-manager-\" + this._inspectId, _y), this.on(hw.STATE_CHANGE, (e, t) => {\n        this._innerConnectionState = e, Qy.debug(\"[\".concat(this._inspectId, \"] Inspect operation :\").concat(lw[e], \" \").concat(t || \"\"));\n      }), this.handleWorkerManagerEvents(), this.workerConnection = new Fw(\"worker-\" + this._inspectId, _y), this.handleWorkerEvents();\n    }\n    async init(e, t) {\n      this.emit(hw.STATE_CHANGE, lw.CONNECT_AP), this._connectInfo = e;\n      const i = this._cancelTokenSource.token;\n      return this._retryConfig = t, new Gu((n, r) => {\n        this.on(hw.CONNECTION_STATE_CHANGE, (e, t) => {\n          t === dw.CONNECTED && n();\n        }), this.requestAP(e, i, t).then(e => {\n          this.connectWorkerManager(e);\n        }).catch(e => {\n          r(e);\n        });\n      });\n    }\n    async requestAP(e, t, i) {\n      const n = Dy(\"WEBCS_DOMAIN\").map(e => \"https://\".concat(e, \"/api/v1\")),\n        r = await function (e, t, i, n) {\n          let r = t.appId,\n            o = t.areaCode,\n            s = t.cname,\n            a = t.sid,\n            c = t.token,\n            d = t.uid;\n          MO++;\n          const l = \"image_moderation_api\",\n            h = {\n              service_name: l,\n              json_body: JSON.stringify({\n                appId: r,\n                areaCode: o,\n                cname: s,\n                command: \"allocateEdge\",\n                requestId: MO,\n                seq: MO,\n                sid: a,\n                token: c,\n                ts: Date.now(),\n                uid: d + \"\"\n              })\n            };\n          let u,\n            p,\n            _ = e[0];\n          return my(async () => {\n            u = Date.now();\n            const e = await pO(_, {\n              data: h,\n              cancelToken: i,\n              headers: {\n                \"X-Packet-Service-Type\": \"0\",\n                \"X-Packet-URI\": \"61\"\n              },\n              params: {\n                action: \"wrtc_gateway\"\n              }\n            });\n            if (p = Date.now() - u, 0 !== e.code) {\n              const t = new bb(tI.UNEXPECTED_RESPONSE, \"image inspect ap error, code\" + e.code, {\n                retry: !0,\n                responseTime: p\n              });\n              throw Qy.error(t.toString()), t;\n            }\n            const t = JSON.parse(e.json_body);\n            if (200 !== t.code) {\n              const e = new bb(tI.UNEXPECTED_RESPONSE, \"image inspect ap error, code: \".concat(t.code, \", reason: \").concat(t.reason), {\n                code: t.code,\n                responseTime: p\n              });\n              throw Qy.error(e.toString()), e;\n            }\n            if (!t.servers || !Array.isArray(t.servers) || 0 === t.servers.length) {\n              const e = new bb(tI.UNEXPECTED_RESPONSE, \"image inspect ap empty server\", {\n                code: t.code,\n                responseTime: p\n              });\n              throw Qy.error(e.toString()), e;\n            }\n            const n = Dy(\"VIDEO_INSPECT_WORKER_MANAGER_HOST\"),\n              r = Dy(\"VIDEO_INSPECT_WORKER_MANAGER_PORT\");\n            return {\n              addressList: t.servers.map(e => {\n                let t = e.address,\n                  i = e.wss;\n                if (t && i) return \"wss://\".concat(t.replace(/\\./g, \"-\"), \".\").concat(n, \":\").concat(r || i);\n              }).filter(e => !!e),\n              workerToken: t.workerToken,\n              vid: t.vid,\n              responseTime: p\n            };\n          }, (t, i) => (oA.apworkerEvent(a, {\n            success: !0,\n            sc: 200,\n            serviceName: l,\n            responseDetail: JSON.stringify(t.addressList),\n            firstSuccess: 0 === i,\n            responseTime: p,\n            serverIp: e[i % e.length]\n          }), !1), (t, i) => (oA.apworkerEvent(a, {\n            success: !1,\n            sc: t.data && t.data.code || 200,\n            serviceName: l,\n            responseTime: p,\n            serverIp: e[i % e.length]\n          }), !!(t.code !== tI.OPERATION_ABORTED && t.code !== tI.UNEXPECTED_RESPONSE || t.data && t.data.retry) && (_ = e[(i + 1) % e.length], !0)), n);\n        }(n, e, t, i);\n      this.emit(hw.STATE_CHANGE, lw.AP_CONNECTED);\n      const o = r.addressList;\n      return this.wmSequence++, o;\n    }\n    async connectWorkerManager(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      this._needWorkUrlOnly = t, this.emit(hw.STATE_CHANGE, lw.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e, 1e4);\n    }\n    async connectWorker(e) {\n      await this.workerConnection.init([e]);\n    }\n    handleWorkerManagerEvents() {\n      this.workerManagerConnection.on(Ab.CONNECTED, async () => {\n        this.emit(hw.STATE_CHANGE, lw.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({\n          appId: this._connectInfo.appId,\n          cname: this._connectInfo.cname,\n          uid: this._connectInfo.uid + \"\",\n          sdkVersion: \"4.21.0\",\n          sid: this._connectInfo.sid,\n          seq: this.wmSequence,\n          ts: Number(Date.now()),\n          requestId: Math.floor(1e12 * Math.random()),\n          allocate: !0,\n          clientRequest: {\n            command: \"join\"\n          }\n        }, !0);\n      }), this.workerManagerConnection.on(Ab.CLOSED, () => {\n        this._innerConnectionState < lw.GET_WORKER_MANAGER_RESPONSE && Qy.debug(\"[\".concat(this._inspectId, \"] Inspect worker manager is closed before connecting worker\"));\n      }), this.workerManagerConnection.on(Ab.FAILED, () => {\n        this._innerConnectionState < lw.GET_WORKER_MANAGER_RESPONSE && Qy.debug(\"[\".concat(this._inspectId, \"] Connecting inspect worker manager is failed before connecting worker\"));\n      }), this.workerManagerConnection.on(Ab.RECONNECTING, () => {\n        this._innerConnectionState < lw.GET_WORKER_MANAGER_RESPONSE && Qy.debug(\"[\".concat(this._inspectId, \"] Inspect worker manager is reconnecting before connecting worker\"));\n      }), this.workerManagerConnection.on(Ab.ON_MESSAGE, async e => {\n        this.emit(hw.STATE_CHANGE, lw.GET_WORKER_MANAGER_RESPONSE);\n        const t = this.workerManagerConnection.url;\n        this.workerManagerConnection.close();\n        const i = JSON.parse(e.data);\n        if (200 !== i.code) throw Qy.error(\"[\".concat(this._inspectId, \"] Unexpected code \").concat(i.code, \" from worker manager\")), new bb(tI.UNEXPECTED_RESPONSE, \"response code of worker is unexpected\", i);\n        if (!(i.serverResponse && i.serverResponse.portWss && t)) throw Qy.error(\"[\".concat(this._inspectId, \"] Unexpected content from worker manager : \").concat(JSON.stringify(i))), new bb(tI.UNEXPECTED_RESPONSE, \"response content of worker is unexpected\", i);\n        {\n          const e = Dy(\"VIDEO_INSPECT_WORKER_PORT\") || i.serverResponse.portWss,\n            n = t.replace(/:\\d+\\/?$/, \":\".concat(e));\n          this.emit(hw.STATE_CHANGE, lw.CONNECT_WORKER, n), this._needWorkUrlOnly ? this.emit(hw.REQUEST_NEW_WORKER_URL, n) : await this.connectWorker(n);\n        }\n      }), this.workerManagerConnection.on(Ab.WILL_RECONNECT, (e, t, i) => {\n        i(e);\n      }), this.workerManagerConnection.on(Ab.REQUEST_NEW_URLS, (e, t) => {\n        this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e).catch(t);\n      });\n    }\n    handleWorkerEvents() {\n      this.workerConnection.on(Ab.CONNECTED, async () => {\n        this.emit(hw.STATE_CHANGE, lw.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = dw.CONNECTED;\n      }), this.workerConnection.on(Ab.ON_MESSAGE, async e => {\n        if (e.data instanceof ArrayBuffer) {\n          const i = vW(new Uint8Array(e.data));\n          if (Dy(\"SHOW_VIDEO_INSPECT_WORKER_MESSAGE\") && Qy.debug(\"[\".concat(this._inspectId, \"] Response message for worker of inspect content \"), JSON.stringify(i)), 200 === i.code) {\n            if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && \"supervise\" === this.inspectType[0]) return void this.emit(hw.INSPECT_RESULT, void 0, void 0);\n            if (i.data && i.data.scorePorn && i.data.scoreSexy && i.data.scoreNeutral) {\n              var t;\n              const e = {\n                  porn: i.data.scorePorn,\n                  sexy: i.data.scoreSexy,\n                  neutral: i.data.scoreNeutral\n                },\n                n = Jn(t = Object.keys(e)).call(t, (t, i) => e[t] > e[i] ? t : i, \"porn\"),\n                r = Object.keys(e).find(e => e === n);\n              this.emit(hw.INSPECT_RESULT, r);\n            } else this.emit(hw.INSPECT_RESULT, void 0, new bb(tI.UNEXPECTED_RESPONSE, i.code + \"\", \"There is an unexpected data on message\"));\n          } else this.emit(hw.INSPECT_RESULT, void 0, new bb(tI.UNEXPECTED_RESPONSE, i.code + \"\", i.msg));\n        } else Qy.error(\"[\".concat(this._inspectId, \"] Unexpected message type from worker\")), this.emit(hw.INSPECT_RESULT, void 0, new bb(tI.UNEXPECTED_RESPONSE, \"invalid worker message type\"));\n      }), this.workerConnection.on(Ab.CLOSED, () => {\n        this.connectionState = dw.CLOSED;\n      }), this.workerConnection.on(Ab.FAILED, () => {\n        this.connectionState = dw.CLOSED;\n      }), this.workerConnection.on(Ab.RECONNECTING, () => {\n        this.connectionState = this.connectionState === dw.CONNECTED ? dw.RECONNECTING : dw.CONNECTING;\n      }), this.workerConnection.on(Ab.WILL_RECONNECT, (e, t, i) => {\n        \"recover\" === e && i(e), i(\"tryNext\");\n      }), this.workerConnection.on(Ab.REQUEST_NEW_URLS, (e, t) => {\n        this.workerManagerConnection.close(), this.once(hw.REQUEST_NEW_WORKER_URL, t => {\n          e([t]);\n        }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e => {\n          this.connectWorkerManager(e, !0);\n        }).catch(e => {\n          t(e);\n        });\n      });\n    }\n    static intToLong(e) {\n      return {\n        low: e |= 0,\n        high: e >> 31,\n        unsigned: e >= 0\n      };\n    }\n    async requestToInspectImage() {\n      this.sequence++;\n      const e = UI(this, hw.CLIENT_LOCAL_VIDEO_TRACK),\n        t = {\n          appId: this._connectInfo.appId,\n          cname: this._connectInfo.cname,\n          cid: this._connectInfo.cid,\n          sid: this._connectInfo.sid,\n          uid: this._connectInfo.uid,\n          vid: this._connectInfo.vid\n        };\n      if (e) {\n        if (!e.isPlaying) return void this.emit(hw.INSPECT_RESULT, void 0, new bb(tI.INVALID_OPERATION, \"Only the track being played can be inspected\"));\n        const i = await this.generateRequestData(e, t);\n        this.workerConnection.sendMessage(i, !0, !0);\n      } else this.emit(hw.INSPECT_RESULT, void 0, new bb(tI.INVALID_OPERATION, \"Only the track being published can be inspected\"));\n    }\n    async generateRequestData(e, t) {\n      let i = t.appId,\n        n = t.cname,\n        r = t.cid,\n        o = t.vid,\n        s = t.sid,\n        a = t.uid;\n      const c = Date.now(),\n        d = await e.getCurrentFrameImage(\"image/jpeg\", this.quality),\n        l = await Hx(d, i, n),\n        h = this.sequence + \"-\" + r + \"-\" + a + \"-\" + c + \"-\" + ey(12, \"\"),\n        u = {\n          appId: i,\n          cid: r,\n          cname: n,\n          deviceId: \"\",\n          elapse: QW.intToLong(Number(c - this.inspectStartTime)),\n          fileSize: l.byteLength,\n          jpgEncryption: 2,\n          height: d.height,\n          width: d.width,\n          jpg: l,\n          networkType: 6,\n          osType: 7,\n          requestId: h,\n          sdkVersion: \"4.21.0\",\n          sequence: this.sequence,\n          sid: s,\n          timestamp: QW.intToLong(c),\n          uid: a,\n          vid: o,\n          service: this._inspectMode,\n          callbackData: this.extraInfo,\n          ossFilePrefix: this.ossFilePrefix\n        };\n      void 0 === this.extraInfo && delete u.callbackData, void 0 === this.ossFilePrefix && delete u.ossFilePrefix;\n      const p = CW(u);\n      if (p.byteLength < this.workerMessageLengthLimit) {\n        if (Dy(\"SHOW_VIDEO_INSPECT_WORKER_MESSAGE\")) {\n          const e = function (e) {\n            for (var t = 1; t < arguments.length; t++) {\n              var i = null != arguments[t] ? arguments[t] : {};\n              t % 2 ? JW(Object(i), !0).forEach(function (t) {\n                ng(e, t, i[t]);\n              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : JW(Object(i)).forEach(function (t) {\n                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n              });\n            }\n            return e;\n          }({}, u);\n          delete e.jpg, Qy.debug(\"[\".concat(this._inspectId, \"] Request message for worker of inspect content \"), JSON.stringify(e));\n        }\n        return p;\n      }\n      {\n        const t = this.quality * this.qualityRatio;\n        return this.quality = t, await this.generateRequestData(e, {\n          appId: i,\n          cname: n,\n          cid: r,\n          vid: o,\n          sid: s,\n          uid: a\n        });\n      }\n    }\n    close() {\n      this._cancelTokenSource.cancel(), this._cancelTokenSource = pv.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = dw.CLOSED, this.emit(hw.STATE_CHANGE, lw.CLOSED);\n    }\n  }\n  function ZW(e) {\n    let t = function () {\n      const e = iH.pop();\n      return e ? (e.offset = e.limit = 0, e) : {\n        bytes: new Uint8Array(64),\n        offset: 0,\n        limit: 0\n      };\n    }();\n    return function (e, t) {\n      let i = e.appId;\n      void 0 !== i && (pH(t, 10), dH(t, i));\n      let n = e.cid;\n      void 0 !== n && (pH(t, 16), pH(t, n));\n      let r = e.cname;\n      void 0 !== r && (pH(t, 26), dH(t, r));\n      let o = e.deviceId;\n      void 0 !== o && (pH(t, 34), dH(t, o));\n      let s = e.elapse;\n      void 0 !== s && (pH(t, 40), EH(t, s));\n      let a = e.fileSize;\n      void 0 !== a && (pH(t, 48), EH(t, tH(a)));\n      let c = e.height;\n      void 0 !== c && (pH(t, 56), EH(t, tH(c)));\n      let d = e.jpg;\n      void 0 !== d && (pH(t, 66), pH(t, d.length), aH(t, d));\n      let l = e.networkType;\n      void 0 !== l && (pH(t, 72), EH(t, tH(l)));\n      let h = e.osType;\n      void 0 !== h && (pH(t, 80), EH(t, tH(h)));\n      let u = e.requestId;\n      void 0 !== u && (pH(t, 90), dH(t, u));\n      let p = e.sdkVersion;\n      void 0 !== p && (pH(t, 98), dH(t, p));\n      let _ = e.sequence;\n      void 0 !== _ && (pH(t, 104), EH(t, tH(_)));\n      let E = e.sid;\n      void 0 !== E && (pH(t, 114), dH(t, E));\n      let m = e.timestamp;\n      void 0 !== m && (pH(t, 120), EH(t, m));\n      let f = e.uid;\n      void 0 !== f && (pH(t, 128), pH(t, f));\n      let T = e.vid;\n      void 0 !== T && (pH(t, 136), pH(t, T));\n      let S = e.width;\n      void 0 !== S && (pH(t, 144), EH(t, tH(S)));\n      let g = e.service;\n      void 0 !== g && (pH(t, 152), pH(t, g));\n      let R = e.callbackData;\n      void 0 !== R && (pH(t, 162), pH(t, R.length), aH(t, R));\n      let C = e.ticket;\n      void 0 !== C && (pH(t, 170), dH(t, C));\n      let v = e.vendorConfigs;\n      void 0 !== v && (pH(t, 178), dH(t, v));\n    }(e, t), function (e) {\n      let t = e.bytes,\n        i = e.limit;\n      return t.length === i ? t : t.subarray(0, i);\n    }(t);\n  }\n  function $W(e) {\n    return function (e) {\n      let t = {};\n      e: for (; !rH(e);) {\n        let i = uH(e);\n        switch (i >>> 3) {\n          case 0:\n            break e;\n          case 1:\n            t.code = uH(e);\n            break;\n          case 2:\n            t.msg = cH(e, uH(e));\n            break;\n          case 3:\n            t.requestId = cH(e, uH(e));\n            break;\n          case 4:\n            t.timestamp = _H(e, !1);\n            break;\n          default:\n            eH(e, 7 & i);\n        }\n      }\n      return t;\n    }({\n      bytes: t = e,\n      offset: 0,\n      limit: t.length\n    });\n    var t;\n  }\n  function eH(e, t) {\n    switch (t) {\n      case 0:\n        for (; 128 & lH(e););\n        break;\n      case 2:\n        nH(e, uH(e));\n        break;\n      case 5:\n        nH(e, 4);\n        break;\n      case 1:\n        nH(e, 8);\n        break;\n      default:\n        throw new Error(\"Unimplemented type: \" + t);\n    }\n  }\n  function tH(e) {\n    return {\n      low: e |= 0,\n      high: e >> 31,\n      unsigned: e >= 0\n    };\n  }\n  let iH = [];\n  function nH(e, t) {\n    if (e.offset + t > e.limit) throw new Error(\"Skip past limit\");\n    e.offset += t;\n  }\n  function rH(e) {\n    return e.offset >= e.limit;\n  }\n  function oH(e, t) {\n    let i = e.bytes,\n      n = e.offset,\n      r = e.limit,\n      o = n + t;\n    if (o > i.length) {\n      let t = new Uint8Array(2 * o);\n      t.set(i), e.bytes = t;\n    }\n    return e.offset = o, o > r && (e.limit = o), n;\n  }\n  function sH(e, t) {\n    let i = e.offset;\n    if (i + t > e.limit) throw new Error(\"Read past limit\");\n    return e.offset += t, i;\n  }\n  function aH(e, t) {\n    let i = oH(e, t.length);\n    e.bytes.set(t, i);\n  }\n  function cH(e, t) {\n    let i = sH(e, t),\n      n = String.fromCharCode,\n      r = e.bytes,\n      o = \"ï¿½\",\n      s = \"\";\n    for (let e = 0; e < t; e++) {\n      let a,\n        c,\n        d,\n        l,\n        h = r[e + i];\n      0 == (128 & h) ? s += n(h) : 192 == (224 & h) ? e + 1 >= t ? s += o : (a = r[e + i + 1], 128 != (192 & a) ? s += o : (l = (31 & h) << 6 | 63 & a, l < 128 ? s += o : (s += n(l), e++))) : 224 == (240 & h) ? e + 2 >= t ? s += o : (a = r[e + i + 1], c = r[e + i + 2], 32896 != (49344 & (a | c << 8)) ? s += o : (l = (15 & h) << 12 | (63 & a) << 6 | 63 & c, l < 2048 || l >= 55296 && l <= 57343 ? s += o : (s += n(l), e += 2))) : 240 == (248 & h) ? e + 3 >= t ? s += o : (a = r[e + i + 1], c = r[e + i + 2], d = r[e + i + 3], 8421504 != (12632256 & (a | c << 8 | d << 16)) ? s += o : (l = (7 & h) << 18 | (63 & a) << 12 | (63 & c) << 6 | 63 & d, l < 65536 || l > 1114111 ? s += o : (l -= 65536, s += n(55296 + (l >> 10), 56320 + (1023 & l)), e += 3))) : s += o;\n    }\n    return s;\n  }\n  function dH(e, t) {\n    let i = t.length,\n      n = 0;\n    for (let e = 0; e < i; e++) {\n      let r = t.charCodeAt(e);\n      r >= 55296 && r <= 56319 && e + 1 < i && (r = (r << 10) + t.charCodeAt(++e) - 56613888), n += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;\n    }\n    pH(e, n);\n    let r = oH(e, n),\n      o = e.bytes;\n    for (let e = 0; e < i; e++) {\n      let n = t.charCodeAt(e);\n      n >= 55296 && n <= 56319 && e + 1 < i && (n = (n << 10) + t.charCodeAt(++e) - 56613888), n < 128 ? o[r++] = n : (n < 2048 ? o[r++] = n >> 6 & 31 | 192 : (n < 65536 ? o[r++] = n >> 12 & 15 | 224 : (o[r++] = n >> 18 & 7 | 240, o[r++] = n >> 12 & 63 | 128), o[r++] = n >> 6 & 63 | 128), o[r++] = 63 & n | 128);\n    }\n  }\n  function lH(e) {\n    return e.bytes[sH(e, 1)];\n  }\n  function hH(e, t) {\n    let i = oH(e, 1);\n    e.bytes[i] = t;\n  }\n  function uH(e) {\n    let t,\n      i = 0,\n      n = 0;\n    do {\n      t = lH(e), i < 32 && (n |= (127 & t) << i), i += 7;\n    } while (128 & t);\n    return n;\n  }\n  function pH(e, t) {\n    for (t >>>= 0; t >= 128;) hH(e, 127 & t | 128), t >>>= 7;\n    hH(e, t);\n  }\n  function _H(e, t) {\n    let i,\n      n = 0,\n      r = 0,\n      o = 0;\n    return i = lH(e), n = 127 & i, 128 & i && (i = lH(e), n |= (127 & i) << 7, 128 & i && (i = lH(e), n |= (127 & i) << 14, 128 & i && (i = lH(e), n |= (127 & i) << 21, 128 & i && (i = lH(e), r = 127 & i, 128 & i && (i = lH(e), r |= (127 & i) << 7, 128 & i && (i = lH(e), r |= (127 & i) << 14, 128 & i && (i = lH(e), r |= (127 & i) << 21, 128 & i && (i = lH(e), o = 127 & i, 128 & i && (i = lH(e), o |= (127 & i) << 7))))))))), {\n      low: n | r << 28,\n      high: r >>> 4 | o << 24,\n      unsigned: t\n    };\n  }\n  function EH(e, t) {\n    let i = t.low >>> 0,\n      n = (t.low >>> 28 | t.high << 4) >>> 0,\n      r = t.high >>> 24,\n      o = 0 === r ? 0 === n ? i < 16384 ? i < 128 ? 1 : 2 : i < 1 << 21 ? 3 : 4 : n < 16384 ? n < 128 ? 5 : 6 : n < 1 << 21 ? 7 : 8 : r < 128 ? 9 : 10,\n      s = oH(e, o),\n      a = e.bytes;\n    switch (o) {\n      case 10:\n        a[s + 9] = r >>> 7 & 1;\n      case 9:\n        a[s + 8] = 9 !== o ? 128 | r : 127 & r;\n      case 8:\n        a[s + 7] = 8 !== o ? n >>> 21 | 128 : n >>> 21 & 127;\n      case 7:\n        a[s + 6] = 7 !== o ? n >>> 14 | 128 : n >>> 14 & 127;\n      case 6:\n        a[s + 5] = 6 !== o ? n >>> 7 | 128 : n >>> 7 & 127;\n      case 5:\n        a[s + 4] = 5 !== o ? 128 | n : 127 & n;\n      case 4:\n        a[s + 3] = 4 !== o ? i >>> 21 | 128 : i >>> 21 & 127;\n      case 3:\n        a[s + 2] = 3 !== o ? i >>> 14 | 128 : i >>> 14 & 127;\n      case 2:\n        a[s + 1] = 2 !== o ? i >>> 7 | 128 : i >>> 7 & 127;\n      case 1:\n        a[s] = 1 !== o ? 128 | i : 127 & i;\n    }\n  }\n  const mH = {},\n    fH = {},\n    TH = 4294967296,\n    SH = TH * TH,\n    gH = SH / 2,\n    RH = AH(0, !0),\n    CH = AH(0),\n    vH = bH(0, -2147483648, !1),\n    IH = bH(-1, 2147483647, !1),\n    yH = bH(-1, -1, !0);\n  function AH(e, t) {\n    let i, n, r;\n    return t ? (r = 0 <= (e >>>= 0) && e < 256) && (n = fH[e], n) ? n : (i = bH(e, 0, !0), r && (fH[e] = i), i) : (r = -128 <= (e |= 0) && e < 128) && (n = mH[e], n) ? n : (i = bH(e, e < 0 ? -1 : 0, !1), r && (mH[e] = i), i);\n  }\n  function bH(e, t, i) {\n    return {\n      low: 0 | e,\n      high: 0 | t,\n      unsigned: !!i\n    };\n  }\n  function wH(e, t) {\n    if (isNaN(e)) return t ? RH : CH;\n    if (t) {\n      if (e < 0) return RH;\n      if (e >= SH) return yH;\n    } else {\n      if (e <= -gH) return vH;\n      if (e + 1 >= gH) return IH;\n    }\n    return e < 0 ? t ? RH : CH : bH(e % TH | 0, e / TH | 0, t);\n  }\n  function OH(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  class NH extends SI {\n    get connectionState() {\n      return this._connectionState;\n    }\n    set connectionState(e) {\n      if (this._connectionState === e) return;\n      const t = this._connectionState;\n      this._connectionState = e, this.emit(mw.CONNECTION_STATE_CHANGE, e, t);\n    }\n    get quality() {\n      return this._quality;\n    }\n    set quality(e) {\n      this._quality = e > 1 ? 1 : e < .1 ? .1 : e, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout(() => {\n        this.quality = this._quality / this._qualityRatio;\n      }, 6e4));\n    }\n    constructor(e) {\n      var t;\n      super(), ng(this, \"name\", \"AgoraRTCImageModeration\"), ng(this, \"_connectionState\", Ew.CONNECTING), ng(this, \"_sequence\", 0), ng(this, \"_moderationStartTime\", void 0), ng(this, \"_workerConnection\", void 0), ng(this, \"_workerMessageLengthLimit\", void 0), ng(this, \"_qualityRatio\", void 0), ng(this, \"_connectInfo\", void 0), ng(this, \"_cancelTokenSource\", pv.CancelToken.source()), ng(this, \"_retryConfig\", void 0), ng(this, \"_moderationInterval\", void 0), ng(this, \"_moderationTimer\", null), ng(this, \"_moderationMode\", 1), ng(this, \"_quality\", 1), ng(this, \"_qualityTimer\", null), ng(this, \"_ticket\", void 0), ng(this, \"_moderationIntervalMinimum\", void 0), ng(this, \"_uploadFailedNum\", 0), ng(this, \"_uploadNum\", 0), ng(this, \"_uploadTimer\", null), ng(this, \"_extraInfo\", void 0), ng(this, \"_vendor\", \"\"), ng(this, \"_encoder\", new TextEncoder()), ng(this, \"_moderationId\", void 0), ng(this, \"inspectImage\", () => {\n        if (this.connectionState !== Ew.CONNECTED) throw new bb(tI.OPERATION_ABORTED, \"image moderation service connection status is \".concat(this.connectionState));\n        this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval(() => {\n          this.connectionState === Ew.CONNECTED ? this.requestToInspectImage() : Qy.debug(\"[\".concat(this._moderationId, \"] Moderation State is not connected , \"), this.connectionState);\n        }, this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage();\n      }), this._moderationId = ey(5, \"image-moderation-\"), this._workerMessageLengthLimit = Dy(\"IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT\"), this._moderationIntervalMinimum = Dy(\"IMAGE_MODERATION_INTERVAL_MINIMUM\"), this._moderationInterval = null !== (t = e.interval) && void 0 !== t ? t : 1e3, e.extraInfo && (this._extraInfo = this._encoder.encode(e.extraInfo)), e.vendor && (this._vendor = e.vendor), this._qualityRatio = Dy(\"IMAGE_MODERATION_QUALITY_RATIO\"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new Fw(\"worker-\" + this._moderationId, _y), this.on(mw.STATE_CHANGE, (e, t) => {\n        Qy.debug(\"[\".concat(this._moderationId, \"] Moderation operation :\").concat(fw[e], \" \").concat(t || \"\"));\n      }), this.handleWorkerEvents();\n    }\n    async init(e, t) {\n      this.emit(mw.STATE_CHANGE, fw.CONNECT_AP), this._connectInfo = e;\n      const i = this._cancelTokenSource.token;\n      return this._retryConfig = t, new Gu((n, r) => {\n        this.on(mw.CONNECTION_STATE_CHANGE, (e, t) => {\n          e === Ew.CONNECTED && n();\n        }), this.requestAP(e, i, t).then(e => {\n          this.connectWorker(e);\n        }).catch(e => {\n          r(e);\n        });\n      });\n    }\n    updateConfig(e) {\n      var t;\n      this._moderationInterval = null !== (t = e.interval) && void 0 !== t ? t : 1e3, e.extraInfo && (this._extraInfo = this._encoder.encode(e.extraInfo)), e.vendor && (this._vendor = e.vendor), Qy.debug(\"[\".concat(this._moderationId, \"] updateConfig: \").concat(JSON.stringify(e))), this.connectionState === Ew.CONNECTED && this.inspectImage();\n    }\n    async requestAP(e, t, i) {\n      const n = Dy(\"WEBCS_DOMAIN\").map(e => \"https://\".concat(e, \"/api/v1\")),\n        r = await function (e, t, i, n) {\n          let r = t.appId,\n            o = t.areaCode,\n            s = t.cname,\n            a = t.sid,\n            c = t.token,\n            d = t.uid;\n          MO++;\n          const l = \"moderation_plugin\",\n            h = {\n              service_name: l,\n              json_body: JSON.stringify({\n                appId: r,\n                areaCode: o,\n                cname: s,\n                command: \"allocateEdge\",\n                requestId: MO,\n                seq: MO,\n                sid: a,\n                appToken: c,\n                ts: Date.now(),\n                uid: d + \"\"\n              })\n            };\n          let u,\n            p,\n            _ = e[0];\n          return my(async () => {\n            u = Date.now();\n            const e = await pO(_, {\n              data: h,\n              cancelToken: i,\n              headers: {\n                \"X-Packet-Service-Type\": \"0\",\n                \"X-Packet-URI\": \"61\"\n              },\n              params: {\n                action: \"wrtc_gateway\"\n              }\n            });\n            if (p = Date.now() - u, 0 !== e.code) {\n              const t = new bb(tI.UNEXPECTED_RESPONSE, \"moderation plugin ap error, code\" + e.code, {\n                retry: !0,\n                responseTime: p\n              });\n              throw Qy.error(t.toString()), t;\n            }\n            const t = JSON.parse(e.json_body);\n            if (200 !== t.code) {\n              const e = new bb(tI.UNEXPECTED_RESPONSE, \"moderation plugin ap error, code: \".concat(t.code, \", reason: \").concat(t.reason), {\n                code: t.code,\n                responseTime: p\n              });\n              throw Qy.error(e.toString()), e;\n            }\n            if (!t.servers || !Array.isArray(t.servers) || 0 === t.servers.length) {\n              const e = new bb(tI.UNEXPECTED_RESPONSE, \"moderation plugin ap empty server\", {\n                code: t.code,\n                responseTime: p\n              });\n              throw Qy.error(e.toString()), e;\n            }\n            if (!t.servers.some(e => !!e.wss)) {\n              const e = new bb(tI.UNEXPECTED_RESPONSE, \"moderation plugin ap empty port\", {\n                code: t.code,\n                responseTime: p\n              });\n              throw Qy.error(e.toString()), e;\n            }\n            const n = Dy(\"IMAGE_MODERATION_WORKER_HOST\");\n            return {\n              addressList: t.servers.map(e => {\n                let t = e.address,\n                  i = e.wss;\n                if (t && i) return \"wss://\".concat(t.replace(/\\./g, \"-\"), \".\").concat(n, \":\").concat(i, \"/moderation\");\n              }).filter(e => !!e),\n              workerToken: t.workerToken,\n              vid: t.vid,\n              ticket: t.appTicket,\n              responseTime: p\n            };\n          }, (t, i) => (oA.apworkerEvent(a, {\n            success: !0,\n            sc: 200,\n            serviceName: l,\n            responseDetail: JSON.stringify(t.addressList),\n            firstSuccess: 0 === i,\n            responseTime: p,\n            serverIp: e[i % e.length]\n          }), !1), (t, i) => (oA.apworkerEvent(a, {\n            success: !1,\n            sc: t.data && t.data.code || 200,\n            serviceName: l,\n            responseTime: p,\n            serverIp: e[i % e.length]\n          }), !!(t.code !== tI.OPERATION_ABORTED && t.code !== tI.UNEXPECTED_RESPONSE || t.data && t.data.retry) && (_ = e[(i + 1) % e.length], !0)), n);\n        }(n, e, t, i);\n      this.emit(mw.STATE_CHANGE, fw.AP_CONNECTED);\n      const o = r.addressList,\n        s = r.ticket;\n      return this._ticket = s, o;\n    }\n    async connectWorker(e) {\n      this.emit(mw.STATE_CHANGE, fw.CONNECT_WORKER), await this._workerConnection.init(e, 1e4);\n    }\n    handleWorkerEvents() {\n      this._workerConnection.on(Ab.CONNECTED, async () => {\n        this.emit(mw.STATE_CHANGE, fw.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = Ew.CONNECTED;\n      }), this._workerConnection.on(Ab.CLOSED, () => {\n        this.connectionState = Ew.CLOSED;\n      }), this._workerConnection.on(Ab.FAILED, () => {\n        this.connectionState = Ew.CLOSED;\n      }), this._workerConnection.on(Ab.RECONNECTING, () => {\n        this.connectionState = this.connectionState === Ew.CONNECTED ? Ew.RECONNECTING : Ew.CONNECTING;\n      }), this._workerConnection.on(Ab.ON_MESSAGE, async e => {\n        if (e.data instanceof ArrayBuffer) {\n          const t = $W(new Uint8Array(e.data));\n          Dy(\"SHOW_IMAGE_MODERATION_WORKER_MESSAGE\") && Qy.debug(\"[\".concat(this._moderationId, \"] Response message for worker of image moderation \"), JSON.stringify(t)), this._uploadNum++, void 0 === t.code || 0 === t.code || (this._uploadFailedNum++, Qy.error(\"[\".concat(this._moderationId, \"] Error response from worke, code is \").concat(t.code, \", msg is \").concat(t.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout(() => {\n            oA.reportApiInvoke(this._connectInfo.sid || null, {\n              name: CI.IMAGE_MODERATION_UPLOAD,\n              options: [this._uploadFailedNum, this._uploadNum, t.code],\n              tag: vI.TRACER\n            }).onError(new bb(tI.IMAGE_MODERATION_UPLOAD_FAILED, t.msg)), this._uploadTimer = null;\n          }, Dy(\"IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL\"))));\n        } else Qy.error(\"[\".concat(this._moderationId, \"] Unexpected message type from worker\"));\n      }), this._workerConnection.on(Ab.WILL_RECONNECT, (e, t, i) => {\n        \"recover\" === e && i(e), i(\"tryNext\");\n      }), this._workerConnection.on(Ab.REQUEST_NEW_URLS, (e, t) => {\n        this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e).catch(t);\n      });\n    }\n    static intToLong(e) {\n      return {\n        low: e |= 0,\n        high: e >> 31,\n        unsigned: e >= 0\n      };\n    }\n    async requestToInspectImage() {\n      const e = UI(this, mw.CLIENT_LOCAL_VIDEO_TRACK),\n        t = {\n          appId: this._connectInfo.appId,\n          cname: this._connectInfo.cname,\n          cid: this._connectInfo.cid,\n          sid: this._connectInfo.sid,\n          uid: this._connectInfo.uid,\n          vid: this._connectInfo.vid\n        };\n      if (e) {\n        if (!e.isPlaying) return void (Dy(\"SHOW_IMAGE_MODERATION_WORKER_MESSAGE\") && Qy.debug(\"Only the track being played can be inspected\"));\n        this._sequence++;\n        const i = await this.generateRequestData(e, t);\n        this._workerConnection.sendMessage(i, !0, !0);\n      } else Dy(\"SHOW_IMAGE_MODERATION_WORKER_MESSAGE\") && Qy.debug(\"Only the track being published can be inspected\");\n    }\n    async generateRequestData(e, t) {\n      let i = t.appId,\n        n = t.cname,\n        r = t.cid,\n        o = t.vid,\n        s = t.sid,\n        a = t.uid;\n      const c = Date.now(),\n        d = await e.getCurrentFrameImage(\"image/jpeg\", this.quality),\n        l = await Hx(d, i, n),\n        h = this._sequence + \"-\" + r + \"-\" + a + \"-\" + c + \"-\" + ey(12, \"\"),\n        u = {\n          appId: i,\n          cid: r,\n          cname: n,\n          deviceId: \"\",\n          elapse: NH.intToLong(Number(c - this._moderationStartTime)),\n          fileSize: d.buffer.byteLength,\n          height: d.height,\n          width: d.width,\n          jpg: l,\n          networkType: 6,\n          osType: 7,\n          requestId: h,\n          sdkVersion: \"4.21.0\",\n          sequence: this._sequence,\n          sid: s,\n          timestamp: wH(c),\n          uid: a,\n          vid: o,\n          service: this._moderationMode,\n          ticket: this._ticket,\n          callbackData: this._extraInfo,\n          vendorConfigs: this._vendor\n        };\n      void 0 === this._extraInfo && delete u.callbackData;\n      const p = ZW(u);\n      if (p.byteLength < this._workerMessageLengthLimit) {\n        if (Dy(\"SHOW_IMAGE_MODERATION_WORKER_MESSAGE\")) {\n          const e = function (e) {\n            for (var t = 1; t < arguments.length; t++) {\n              var i = null != arguments[t] ? arguments[t] : {};\n              t % 2 ? OH(Object(i), !0).forEach(function (t) {\n                ng(e, t, i[t]);\n              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : OH(Object(i)).forEach(function (t) {\n                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n              });\n            }\n            return e;\n          }({}, u);\n          delete e.jpg, Qy.debug(\"[\".concat(this._moderationId, \"] Request message for worker of image moderation service: \"), JSON.stringify(e));\n        }\n        return p;\n      }\n      {\n        const t = this.quality * this._qualityRatio;\n        return this.quality = t, await this.generateRequestData(e, {\n          appId: i,\n          cname: n,\n          cid: r,\n          vid: o,\n          sid: s,\n          uid: a\n        });\n      }\n    }\n    close() {\n      this._cancelTokenSource.cancel(), this._cancelTokenSource = pv.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = Ew.CLOSED, this.emit(mw.STATE_CHANGE, fw.CLOSED);\n    }\n  }\n  function DH(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function PH(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? DH(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : DH(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  const LH = Date.now(),\n    kH = 20,\n    MH = new Map(),\n    UH = new Map();\n  async function xH(e) {\n    const t = MH.get(e),\n      i = Array.isArray(t) && t[t.length - 1],\n      n = UH.get(e);\n    if (!i) return void (n.isSyncing = !1);\n    const r = {\n      uid: i.uid,\n      payload: i.payload\n    };\n    0 === n.firstRecvTs && (n.firstRecvTs = i.recvTs, n.firstSendTs = i.sendTs);\n    const o = i.sendTs - n.firstSendTs,\n      s = o - (Date.now() - n.firstRecvTs);\n    s > 0 && (n.firstRecvTs = Date.now() - o);\n    let a = i.mediaDelay + s;\n    a <= 0 ? (t.pop(), VH(i.context, r), a = 0) : a = Math.min(a, kH), setTimeout(() => t.length && xH(e), a);\n  }\n  function VH(e, t) {\n    e.safeEmit(NI.STREAM_MESSAGE, t.uid, t.payload), e.onStreamMessage && e.onStreamMessage(t);\n  }\n  function FH(e) {\n    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n      i = arguments.length > 2 ? arguments[2] : void 0;\n    if (!e.syncWithAudio) return VH(i, {\n      uid: e.uid,\n      payload: e.payload\n    });\n    const n = \"\".concat(i.id, \"-\").concat(e.uid),\n      r = MH.get(n) || [],\n      o = r.findIndex(t => e.sendTs >= t.sendTs),\n      s = PH(PH({}, e), {}, {\n        context: i,\n        mediaDelay: t,\n        recvTs: Date.now()\n      });\n    -1 === o ? r.push(s) : r.splice(o, 0, s), MH.set(n, r);\n    let a = !1;\n    var c;\n    UH.has(n) ? a = !(null === (c = UH.get(n)) || void 0 === c || !c.isSyncing) : UH.set(n, {\n      isSyncing: a,\n      firstRecvTs: 0,\n      firstSendTs: 0\n    });\n    a || xH(n);\n  }\n  const BH = Iv().name;\n  function jH(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function GH(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? jH(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : jH(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  const WH = \"websdk_ng_cache_parameter\",\n    HH = Dy(\"MAX_PRELOAD_ASYNC_LENGTH\"),\n    KH = 1e4,\n    YH = new Map(),\n    qH = [];\n  let zH = null,\n    JH = 0,\n    XH = 0;\n  const QH = new Map(),\n    ZH = function (e, t) {\n      const i = [];\n      let n = 0;\n      const r = async () => {\n        const e = i.shift();\n        e && (await e()), i.length > 0 && n < t ? r() : n--;\n      };\n      return async function () {\n        for (var o = arguments.length, s = new Array(o), a = 0; a < o; a++) s[a] = arguments[a];\n        return new Gu(async (o, a) => {\n          i.push(async () => {\n            try {\n              const t = await e(...s);\n              o(t);\n            } catch (e) {\n              a(e);\n            }\n          }), n < t && (n++, r());\n        });\n      };\n    }(eK, HH),\n    $H = pv.CancelToken.source();\n  async function eK(e, t, i, n, r) {\n    try {\n      var _await$Gu$all, _await$Gu$all2;\n      if (!Dy(\"ENABLE_PRELOAD\")) return;\n      if (!_U().supportWebCrypto) return void KI(() => {\n        Qy.warn(\"Your browser does not support preloading, this feature  be run in a secure environment\");\n      }, \"preload_webcrypto_not_supported\");\n      if (!i && null !== i) throw new iI(tI.INVALID_PARAMS, \"Invalid token: \".concat(i, \". If you don not use token, set it to null\"));\n      i && aI(i, \"token\", 1, 2047), aI(e, \"appid\", 1, 2047), wb(t), n && Ob(n);\n      const o = ty();\n      Qy.debug(\"preload channel \".concat(t, \", uid is \").concat(n));\n      const s = {\n        appId: e,\n        cname: t,\n        token: i || e,\n        uid: \"string\" != typeof n ? n : null,\n        sid: o,\n        proxyServer: r\n      };\n      let a, c;\n      \"string\" == typeof n ? (s.stringUid = n, (_await$Gu$all = await Gu.all([GO(n, {\n        sid: o,\n        appId: e\n      }, $H.token), HO(GH(GH({}, s), {}, {\n        token: i || e,\n        uid: 0\n      }), $H.token)]), _await$Gu$all2 = _slicedToArray(_await$Gu$all, 2), c = _await$Gu$all2[0], a = _await$Gu$all2[1]), s.uid = c.uid, a.gatewayInfo.uid = s.uid, a.gatewayInfo.res.uid = s.uid) : a = await HO(s, $H.token);\n      const d = {\n        sid: o,\n        appId: e,\n        cname: t,\n        token: i || e,\n        uid: s.stringUid || n,\n        intUid: s.uid || a.gatewayInfo.uid,\n        stringUid: s.stringUid,\n        ts: Date.now(),\n        sua: c,\n        ap: a\n      };\n      await async function (e) {\n        let t;\n        try {\n          e.uid && iK({\n            appId: e.appId,\n            cname: e.cname,\n            token: e.token,\n            uid: e.uid,\n            stringUid: e.stringUid\n          });\n          const i = cK(e),\n            n = await async function (e, t) {\n              try {\n                const i = await window.crypto.subtle.importKey(\"raw\", zI(t), \"AES-GCM\", !1, [\"encrypt\"]),\n                  n = await window.crypto.subtle.encrypt({\n                    name: \"AES-GCM\",\n                    iv: new Uint8Array(1)\n                  }, i, YI(window.btoa(JSON.stringify(e))));\n                return qI(new Uint8Array(n));\n              } catch (e) {\n                return;\n              }\n            }(e, e.token || e.appId);\n          if (!n) return;\n          t = sK(WH);\n          const r = t ? JSON.parse(t) : [];\n          r.push({\n            [i]: n\n          }), r.length > Dy(\"AP_CACHE_NUM\") && r.shift(), aK(WH, JSON.stringify(r));\n        } catch (e) {\n          Qy.warn(\"Error caching server parameters:\", e.message), aK(WH, \"\");\n        }\n      }(d), JH++;\n    } catch (e) {\n      throw XH++, function (e) {\n        zH || (zH = window.setTimeout(() => {\n          let t = \"\";\n          QH.forEach((e, i) => {\n            t += \"\".concat(i, \": \").concat(e, \" ;\");\n          }), oA.reportApiInvoke(null, {\n            name: CI.PRELOAD,\n            options: {\n              success: JH,\n              failed: XH,\n              err: t\n            }\n          }).onError(e), JH = 0, XH = 0, QH.clear(), zH = null;\n        }, KH));\n        const t = QH.get(e.code) || 0;\n        QH.set(e.code, t + 1);\n      }(e), e;\n    }\n  }\n  async function tK(e) {\n    try {\n      const t = iK(e);\n      if (!t || \"disabled\" !== e.cloudProxyServer) return;\n      const i = await async function (e, t) {\n        try {\n          const i = await window.crypto.subtle.importKey(\"raw\", zI(t), \"AES-GCM\", !1, [\"decrypt\"]),\n            n = await window.crypto.subtle.decrypt({\n              name: \"AES-GCM\",\n              iv: new Uint8Array(1)\n            }, i, YI(e));\n          return JSON.parse(window.atob(qI(new Uint8Array(n))));\n        } catch (e) {\n          return;\n        }\n      }(t, e.token || e.appId);\n      if (!i) return;\n      if (!function (e, t) {\n        const i = e.cname === t.cname && e.appId === t.appId && e.token === t.token;\n        if (!i) return !1;\n        return t.stringUid ? e.stringUid === t.stringUid : \"number\" == typeof t.uid ? e.uid === t.uid : e.uid == t.uid;\n      }(i, e)) return;\n      if (i && Date.now() - i.ts < Dy(\"AP_CACHE_LIFETIME\")) return i;\n    } catch (e) {\n      Qy.warn(\"Error get preloadInfo\", e.message);\n    }\n  }\n  function iK(e) {\n    let t;\n    try {\n      if (t = sK(WH), !t) return;\n      const i = JSON.parse(t),\n        n = cK(e),\n        r = function (e, t) {\n          for (let i = e.length - 1; i >= 0; i--) if (t(e[i])) return i;\n          return -1;\n        }(i, e => n in e);\n      if (-1 === r) return;\n      const o = i.splice(r, 1)[0];\n      return aK(WH, JSON.stringify(i)), o[n];\n    } catch (e) {\n      Qy.warn(\"Error delete preload info: \".concat(t), e.message), aK(WH, \"\");\n    }\n  }\n  function nK(e) {\n    if (e) {\n      let t = YH.get(e);\n      t && (window.clearTimeout(t), t = null, YH.delete(e)), Dn(qH).call(qH, e) || \"disabled\" !== e.cloudProxyServer || qH.push(e);\n    }\n    if (YH.size < Dy(\"AP_CACHE_NUM\") && qH.length > 0) {\n      const e = qH.shift();\n      YH.set(e, window.setTimeout(async () => {\n        const t = e.appId,\n          i = e.cname,\n          n = e.token,\n          r = e.uid,\n          o = e.proxyServer;\n        try {\n          await ZH(t, i, n, r, o), YH.has(e) && nK(e);\n        } catch (t) {\n          Qy.warn(\"update preload failed\", t.message), rK(e);\n        }\n      }, Dy(\"AP_UPDATE_INTERVAL\")));\n    }\n  }\n  function rK(e) {\n    const t = qH.indexOf(e);\n    -1 !== t && qH.splice(t, 1);\n    let i = YH.get(e);\n    i && (window.clearTimeout(i), i = null, YH.delete(e), nK());\n  }\n  function oK(e, t) {\n    const i = e.sua,\n      n = e.ap;\n    t && i && oA.reqUserAccount(e.sid, {\n      lts: i.requestTime,\n      elapse: i.elapse,\n      success: !0,\n      serverAddr: i.url,\n      stringUid: t,\n      uid: e.intUid,\n      errorCode: null,\n      extend: i.req\n    }), oA.reportResourceTiming(e.ap.url, e.sid), oA.joinWebProxyAP(e.sid, {\n      lts: n.requestTime,\n      elapse: n.elapse,\n      sucess: 1,\n      apServerAddr: n.url,\n      turnServerAddrList: n.proxyInfo.addresses.map(e => e.ip).join(\",\"),\n      eventType: \"disabled\",\n      unilbsServerIds: [jw.CHOOSE_SERVER, jw.CLOUD_PROXY_FALLBACK].toString()\n    }), oA.joinChooseServer(e.sid, {\n      lts: n.requestTime,\n      elapse: n.elapse,\n      succ: !0,\n      csAddr: n.url,\n      opid: n.opid,\n      serverList: n.gatewayInfo.gatewayAddrs.map(e => e.address),\n      ec: null,\n      cid: n.gatewayInfo.cid.toString(),\n      uid: n.gatewayInfo.uid.toString(),\n      csIp: n.gatewayInfo.csIp,\n      unilbsServerIds: [jw.CHOOSE_SERVER].toString(),\n      isHttp3: n.isHttp3\n    });\n  }\n  function sK(e) {\n    return window.atob(window.localStorage.getItem(e) || \"\");\n  }\n  function aK(e, t) {\n    window.localStorage.setItem(e, window.btoa(t));\n  }\n  function cK(e) {\n    let t = \"\".concat(e.appId, \"_\").concat(e.cname);\n    return \"string\" == typeof e.uid && (t += \"_s_\".concat(e.uid)), \"number\" == typeof e.uid && (t += \"_\".concat(e.uid)), e.token && (t += \"_\".concat(e.token)), dy(t);\n  }\n  var dK, lK, hK, uK, pK, _K, EK, mK, fK, TK, SK, gK, RK, CK, vK, IK, yK, AK, bK, wK, OK, NK, DK, PK, LK, kK, MK, UK, xK, VK, FK, BK, jK, GK, WK, HK, KK, YK, qK, zK, JK, XK, QK;\n  function ZK(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function $K(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? ZK(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : ZK(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  uy.setLogger(Qy);\n  let eY = (dK = rA(), lK = rA({\n    argsMap: (e, t) => {\n      if (!Array.isArray(t)) {\n        if (!(t instanceof ox)) return [t];\n        t = [t];\n      }\n      return t.map(e => e ? Object(e).toString() : \"null\");\n    }\n  }), hK = rA({\n    argsMap: (e, t) => (t || (t = []), t instanceof YF ? [t.getChannelId()] : (Array.isArray(t) || (t = [t]), t.map(e => e.getTrackId())))\n  }), uK = rA({\n    argsMap: (e, t, i, n) => [\"object\" == typeof t ? t.uid : t, i, n]\n  }), pK = rA({\n    argsMap: (e, t, i) => [t, i]\n  }), _K = rA({\n    argsMap: (e, t) => t.map(e => {\n      let t = e.user,\n        i = e.mediaType;\n      return [null == t ? void 0 : t.uid, i];\n    })\n  }), EK = rA({\n    argsMap: (e, t, i, n) => [\"object\" == typeof t ? t.uid : t, i, n]\n  }), mK = rA({\n    argsMap: (e, t) => t.map(e => {\n      let t = e.user,\n        i = e.mediaType;\n      return {\n        uid: null == t ? void 0 : t.uid,\n        mediaType: i\n      };\n    })\n  }), fK = rA(), TK = rA(), SK = rA(), gK = rA(), RK = rA(), CK = rA(), vK = rA(), IK = rA(), yK = rA(), AK = rA(), bK = rA(), wK = rA(), OK = rA(), NK = rA(), DK = rA({\n    argsMap: (e, t) => [t]\n  }), PK = rA(), LK = rA(), kK = rA(), MK = rA(), UK = rA(), xK = rA(), VK = rA(), FK = rA(), BK = rA(), jK = rA(), GK = rA({\n    argsMap: (e, t) => (Array.isArray(t) || (t = [t]), [JSON.stringify(t)])\n  }), WK = rA(), HK = rA(), KK = rA(), YK = rA(), qK = rA(), zK = rA(), JK = rA({\n    reportResult: !0\n  }), XK = rA(), QK = class extends SI {\n    get connectionState() {\n      return this._gateway.state;\n    }\n    get remoteUsers() {\n      return this._users;\n    }\n    get localTracks() {\n      return this._p2pChannel.getAllTracks(!0);\n    }\n    get uid() {\n      return this._uid;\n    }\n    get channelName() {\n      return this._channelName;\n    }\n    get localDataChannels() {\n      return this._p2pChannel.getAllDataChannels();\n    }\n    get mode() {\n      return this._config.mode;\n    }\n    get role() {\n      var e;\n      return (null === (e = this._config) || void 0 === e ? void 0 : e.role) || \"audience\";\n    }\n    get codec() {\n      return this._config.codec;\n    }\n    get audioCodec() {\n      return this._config.audioCodec || \"opus\";\n    }\n    get isStringUID() {\n      return !!this._joinInfo && !!this._joinInfo.stringUid;\n    }\n    get __className__() {\n      return \"Client\";\n    }\n    constructor(e) {\n      let t;\n      if (super(), ng(this, \"store\", void 0), ng(this, \"_uid\", void 0), ng(this, \"_channelName\", void 0), ng(this, \"_uintUid\", void 0), ng(this, \"_users\", []), ng(this, \"_config\", void 0), ng(this, \"_clientId\", void 0), ng(this, \"_appId\", void 0), ng(this, \"_sessionId\", null), ng(this, \"_key\", void 0), ng(this, \"_rtmConfig\", {}), ng(this, \"_joinInfo\", void 0), ng(this, \"_gateway\", void 0), ng(this, \"_statsCollector\", void 0), ng(this, \"_configDistribute\", void 0), ng(this, \"_leaveMutex\", new uy(\"client-leave\")), ng(this, \"_publishMutex\", new uy(\"client-publish\")), ng(this, \"_renewTokenMutex\", new uy(\"client-renewtoken\")), ng(this, \"_subscribeMutex\", new uy(\"client-subscribe\")), ng(this, \"_encryptionMode\", \"none\"), ng(this, \"_encryptionSecret\", null), ng(this, \"_encryptionSalt\", null), ng(this, \"_encryptDataStream\", !1), ng(this, \"_encryptDataStreamKey\", null), ng(this, \"_encryptDataStreamIv\", null), ng(this, \"_proxyServer\", void 0), ng(this, \"_turnServer\", {\n        servers: [],\n        mode: \"auto\"\n      }), ng(this, \"_cloudProxyServerMode\", \"disabled\"), ng(this, \"_isDualStreamEnabled\", !1), ng(this, \"_defaultStreamFallbackType\", void 0), ng(this, \"_lowStreamParameter\", void 0), ng(this, \"_streamFallbackTypeCacheMap\", new Map()), ng(this, \"_remoteStreamTypeCacheMap\", new Map()), ng(this, \"_axiosCancelSource\", pv.CancelToken.source()), ng(this, \"_audioVolumeIndicationInterval\", void 0), ng(this, \"_networkQualityInterval\", void 0), ng(this, \"_userOfflineTimeout\", void 0), ng(this, \"_streamRemovedTimeout\", void 0), ng(this, \"_injectStreamingClient\", void 0), ng(this, \"_liveTranscodeStreamingClient\", void 0), ng(this, \"_liveRawStreamingClient\", void 0), ng(this, \"_channelMediaRelayClient\", void 0), ng(this, \"_networkQualitySensitivity\", \"normal\"), ng(this, \"_p2pChannel\", void 0), ng(this, \"_useLocalAccessPoint\", !1), ng(this, \"_setLocalAPVersion\", void 0), ng(this, \"_joinAndNotLeaveYet\", !1), ng(this, \"_numberOfJoinCount\", 0), ng(this, \"_remoteDefaultVideoStreamType\", void 0), ng(this, \"_inspect\", void 0), ng(this, \"_moderation\", void 0), ng(this, \"_license\", void 0), ng(this, \"_pendingPublishedUsers\", []), ng(this, \"ntpAlignErrorCount\", 0), ng(this, \"remoteInboundOffset\", 0), ng(this, \"_handleLocalTrackEnable\", (e, t, i) => {\n        this.publish(e, !1).then(t).catch(i);\n      }), ng(this, \"_handleLocalTrackDisable\", (e, t, i) => {\n        this.unpublish(e).then(t).catch(i);\n      }), ng(this, \"_handleUserOnline\", e => {\n        if (Dy(\"BLOCK_LOCAL_CLIENT\") && lA(e.uid, this.channelName)) return void Qy.debug(\"[\".concat(e.uid, \"] will be ignored in local\"));\n        this.isStringUID && \"string\" != typeof e.uid && Qy.error(\"[\".concat(this._clientId, \"] StringUID is Mixed with UintUID\"));\n        const t = this._users.find(t => t.uid === e.uid);\n        if (t) t._trust_in_room_ = !0, t._is_pre_created && (t._is_pre_created = !1, this.safeEmit(NI.USER_JOINED, t));else {\n          const t = new Bj(e.uid, e.uint_id || e.uid);\n          this._users.push(t), Qy.debug(\"[\".concat(this._clientId, \"] user online\"), e.uid), this.safeEmit(NI.USER_JOINED, t);\n        }\n      }), ng(this, \"_handleUserOffline\", e => {\n        if (Dy(\"BLOCK_LOCAL_CLIENT\") && lA(e.uid, this.channelName)) return;\n        const t = this._users.find(t => t.uid === e.uid);\n        t && (this._handleRemoveStream(e), this._handleRemoveDataChannels(e), t._audio_pre_subscribed || t._video_pre_subscribed ? t._is_pre_created = !0 : FI(this._users, t), this._remoteStreamTypeCacheMap.delete(t.uid), this._streamFallbackTypeCacheMap.delete(t.uid), Qy.debug(\"[\".concat(this._clientId, \"] user offline\"), e.uid, \"reason:\", e.reason), this.safeEmit(NI.USER_LEAVED, t, e.reason));\n      }), ng(this, \"_handleAddAudioOrVideoStream\", (e, t, i, n, r, o, s) => {\n        if (Dy(\"BLOCK_LOCAL_CLIENT\") && lA(t, this.channelName)) return;\n        const a = this._users.find(e => e.uid === t);\n        if (!a) return void Qy.error(\"[\".concat(this._clientId, \"] can not find target user!(on_add_stream)\"));\n        Qy.debug(\"[\".concat(this._clientId, \"] stream added with uid \").concat(t, \", type \").concat(e)), this.store.subscribe(a.uid, e, void 0, void 0, void 0, Date.now());\n        const c = \"audio\" === e ? a.hasAudio : a.hasVideo;\n        a._uintid || (a._uintid = r || t), \"audio\" === e ? a._trust_audio_stream_added_state_ = !0 : a._trust_video_stream_added_state_ = !0, \"audio\" === e ? (a._audio_added_ = !0, void 0 !== i && (a._audioSSRC = i), void 0 !== n && (a._cname = n), o && (a._audioOrtc = o)) : (a._video_added_ = !0, void 0 !== i && (a._videoSSRC = i), void 0 !== n && (a._cname = n), void 0 !== s && (a._rtxSsrcId = s), o && (a._videoOrtc = o)), (\"audio\" === e ? a.hasAudio : a.hasVideo) && !c && (Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(a.uid, \" published \").concat(e)), this.safeEmit(NI.USER_PUBLISHED, a, e)), \"video\" === e ? oA.onGatewayStream(this._sessionId, tA.ON_ADD_VIDEO_STREAM, iA.ON_ADD_VIDEO_STREAM, {\n          peer: r || t,\n          ssrc: a._videoSSRC\n        }) : oA.onGatewayStream(this._sessionId, tA.ON_ADD_AUDIO_STREAM, iA.ON_ADD_AUDIO_STREAM, {\n          peer: r || t,\n          ssrc: a._audioSSRC\n        }), this._p2pChannel.remoteMediaSsrcChanged(a, e, i).then(t => {\n          if (t && (Qy.debug(\"[\".concat(this._clientId, \"] resubscribe \").concat(e, \" for user \").concat(a.uid, \" after rejoin because SSRC id changed.\")), this._p2pChannel instanceof gW)) return this._p2pChannel.unsubscribe(a, e, !0).then(() => this._subscribe(a, e, !0).catch(e => {\n            Qy.error(\"[\".concat(this._clientId, \"] resubscribe error\"), e.toString());\n          }));\n        }), this._p2pChannel.hasPendingRemoteMedia(a, e) && (Qy.debug(\"[\".concat(this._clientId, \"] resubscribe \").concat(e, \" for user \").concat(a.uid, \" after reconnect.\")), this._subscribe(a, e, !0).catch(e => {\n          Qy.error(\"[\".concat(this._clientId, \"] resubscribe error\"), e.toString());\n        }));\n      }), ng(this, \"_handleRemoveStream\", e => {\n        if (Dy(\"BLOCK_LOCAL_CLIENT\") && lA(e.uid, this.channelName)) return;\n        const t = this._users.find(t => t.uid === e.uid);\n        if (!t) return void Qy.warning(\"[\".concat(this._clientId, \"] can not find target user!(on_remove_stream)\"));\n        Qy.debug(\"[\".concat(this._clientId, \"] stream removed with uid \").concat(e.uid));\n        let i = () => {};\n        t.hasAudio && t.hasVideo ? i = () => {\n          Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(t.uid, \" unpublished audio track\")), this.safeEmit(NI.USER_UNPUBLISHED, t, \"audio\"), Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(t.uid, \" unpublished video track\")), this.safeEmit(NI.USER_UNPUBLISHED, t, \"video\");\n        } : t.hasVideo ? i = () => {\n          Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(t.uid, \" unpublished video track\")), this.safeEmit(NI.USER_UNPUBLISHED, t, \"video\");\n        } : t.hasAudio && (i = () => {\n          Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(t.uid, \" unpublished audio track\")), this.safeEmit(NI.USER_UNPUBLISHED, t, \"audio\");\n        }), t._video_pre_subscribed || t._audio_pre_subscribed || (t._trust_audio_stream_added_state_ = !0, t._trust_video_stream_added_state_ = !0, t._audio_added_ = !1, t._video_added_ = !1, this._p2pChannel instanceof gW && this._p2pChannel.unsubscribe(t).then(e => {\n          if (e) return this._gateway.unsubscribe(e, t.uid);\n        }), t._audioSSRC = void 0, t._videoSSRC = void 0, t._audioOrtc = void 0, t._videoOrtc = void 0, t._rtxSsrcId = void 0), oA.onGatewayStream(this._sessionId, tA.ON_REMOVE_STREAM, iA.ON_REMOVE_STREAM, {\n          peer: e.uint_id || e.uid\n        }), i();\n      }), ng(this, \"_handleSetStreamLocalEnable\", (e, t, i) => {\n        if (Dy(\"BLOCK_LOCAL_CLIENT\") && lA(t, this.channelName)) return;\n        const n = this._users.find(e => e.uid === t);\n        if (!n) return void Qy.error(\"[\".concat(this._clientId, \"] can not find target user!(disable_local)\"));\n        Qy.debug(\"[\".concat(this._clientId, \"] local \").concat(e, \" \").concat(i ? \"enabled\" : \"disabled\", \" with uid \").concat(t));\n        const r = \"audio\" === e ? n.hasAudio : n.hasVideo;\n        if (\"audio\" === e) {\n          n._trust_audio_enabled_state_ = !0;\n          const e = n._audio_enabled_;\n          if (n._audio_enabled_ = i, n._audio_enabled_ === e) return;\n          {\n            const e = n._audio_enabled_ ? \"enable-local-audio\" : \"disable-local-audio\";\n            Qy.debug(\"[\".concat(this._clientId, \"] user-info-updated, uid: \").concat(t, \", msg: \").concat(e)), this.safeEmit(NI.USER_INFO_UPDATED, t, e);\n          }\n        } else {\n          n._trust_video_enabled_state_ = !0;\n          const e = n._video_enabled_;\n          if (n._video_enabled_ = i, n._video_enabled_ === e) return;\n          {\n            const e = n._video_enabled_ ? \"enable-local-video\" : \"disable-local-video\";\n            Qy.debug(\"[\".concat(this._clientId, \"] user-info-update, uid: \").concat(t, \", msg: \").concat(e)), this.safeEmit(NI.USER_INFO_UPDATED, t, e);\n          }\n        }\n        const o = \"audio\" === e ? n.hasAudio : n.hasVideo;\n        return r !== o ? !r && o ? (Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(t, \" published \").concat(e)), void this.safeEmit(NI.USER_PUBLISHED, n, e)) : (\"video\" === e && n._videoTrack && n._videoTrack._destroy(), \"audio\" === e && n._audioTrack, this._p2pChannel.muteRemote(n, e), Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(t, \" unpublished \").concat(e)), void this.safeEmit(NI.USER_UNPUBLISHED, n, e)) : void 0;\n      }), ng(this, \"_handleMuteStream\", (e, t, i) => {\n        if (Dy(\"BLOCK_LOCAL_CLIENT\") && lA(e, this.channelName)) return;\n        Qy.debug(\"[\".concat(this._clientId, \"] receive mute message\"), e, t, i);\n        const n = this._users.find(t => t.uid === e);\n        if (!n) return void Qy.warning(\"[\".concat(this._clientId, \"] can not find remote user, ignore mute event, uid: \").concat(e));\n        const r = \"audio\" === t ? n.hasAudio : n.hasVideo;\n        if (\"audio\" === t) {\n          n._trust_audio_mute_state_ = !0;\n          const t = n._audio_muted_;\n          if (n._audio_muted_ = i, n._audio_muted_ === t) return;\n          {\n            const t = n._audio_muted_ ? \"mute-audio\" : \"unmute-audio\";\n            Qy.debug(\"[\".concat(this._clientId, \"] user-info-update, uid: \").concat(e, \", msg: \").concat(t)), this.safeEmit(NI.USER_INFO_UPDATED, e, t);\n          }\n        } else {\n          n._trust_video_mute_state_ = !0;\n          const t = n._video_muted_;\n          if (n._video_muted_ = i, n._video_muted_ === t) return;\n          {\n            const t = n._video_muted_ ? \"mute-video\" : \"unmute-video\";\n            Qy.debug(\"[\".concat(this._clientId, \"] user-info-update, uid: \").concat(e, \", msg: \").concat(t)), this.safeEmit(NI.USER_INFO_UPDATED, e, t);\n          }\n        }\n        const o = \"audio\" === t ? n.hasAudio : n.hasVideo;\n        if (r !== o) {\n          if (!r && o) {\n            return (\"audio\" === t ? n._audioSSRC : n._videoSSRC) ? (Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(e, \" published \").concat(t)), void this.safeEmit(NI.USER_PUBLISHED, n, t)) : void Qy.warning(\"[\".concat(this._clientId, \"] remote user \").concat(e, \" receive \").concat(t, \" unmute message  before add stream message, \").concat(t, \" SSRC doesn't exist yet.\"));\n          }\n          \"video\" === t && n._videoTrack && !n._video_pre_subscribed && n._videoTrack._destroy(), \"audio\" === t && n._audioTrack, this._p2pChannel.muteRemote(n, t), Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(e, \" unpublished \").concat(t)), this.safeEmit(NI.USER_UNPUBLISHED, n, t);\n        }\n      }), ng(this, \"_handleP2PLost\", async e => {\n        Qy.debug(\"[\".concat(this._clientId, \"] receive p2p lost\"), e), parseInt(e.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : Qy.warning(\"[\".concat(this._clientId, \"] P2PLost stream not found\"), e);\n      }), ng(this, \"_handleTokenWillExpire\", () => {\n        Qy.debug(\"[\".concat(this._clientId, \"] received message onTokenPrivilegeWillExpire\")), this.safeEmit(NI.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);\n      }), ng(this, \"_handleBeforeUnload\", e => {\n        \"beforeunload\" === e.type && void 0 !== e.returnValue && \"\" !== e.returnValue || (this.leave(), Qy.info(\"[\".concat(this._clientId, \"] auto leave onbeforeunload or pagehide\")));\n      }), ng(this, \"_handleUpdateNetworkQuality\", () => {\n        if (\"normal\" === this._networkQualitySensitivity) return;\n        if (navigator && void 0 !== navigator.onLine && !navigator.onLine) return void this.safeEmit(NI.NETWORK_QUALITY, {\n          downlinkNetworkQuality: 6,\n          uplinkNetworkQuality: 6\n        });\n        const e = {\n          downlinkNetworkQuality: 0,\n          uplinkNetworkQuality: 0\n        };\n        e.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(NI.NETWORK_QUALITY, e);\n      }), ng(this, \"_handleP2PAddAudioOrVideoStream\", (e, t, i, n) => {\n        const r = this._users.find(e => e.uid === t);\n        if (!r) return void Qy.error(\"[\".concat(this._clientId, \"] can not find target user!(on_add_stream)\"));\n        Qy.debug(\"[\".concat(this._clientId, \"] stream added with uid \").concat(t, \", type \").concat(e)), this.store.subscribe(r.uid, e, void 0, void 0, void 0, Date.now());\n        const o = \"audio\" === e ? r.hasAudio : r.hasVideo;\n        \"audio\" === e ? r._trust_audio_stream_added_state_ = !0 : r._trust_video_stream_added_state_ = !0, \"audio\" === e ? (r._audio_added_ = !0, void 0 !== i && (r._audioSSRC = i), void 0 !== n && (r._audioMid = n)) : (r._video_added_ = !0, void 0 !== i && (r._videoSSRC = i), void 0 !== n && (r._videoMid = n)), (\"audio\" === e ? r.hasAudio : r.hasVideo) && !o && (Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(r.uid, \" published \").concat(e)), this.safeEmit(NI.USER_PUBLISHED, r, e)), this._p2pChannel.hasPendingRemoteMedia(r, e) && (Qy.debug(\"[\".concat(this._clientId, \"] resubscribe \").concat(e, \" for user \").concat(r.uid, \" after reconnect.\")), this._subscribe(r, e, !0).catch(e => {\n          Qy.error(\"[\".concat(this._clientId, \"] resubscribe error\"), e.toString());\n        }));\n      }), this._config = e, this._clientId = ey(5, \"client-\"), this.store = new ky(e.codec, e.audioCodec, e.mode, this._clientId), this.store.clientCreated(), e.proxyServer && this.setProxyServer(e.proxyServer, !0), e.turnServer && this.setTurnServer(e.turnServer, !0), Qy.info(\"[\".concat(this._clientId, \"] Initializing AgoraRTC client v\").concat(Iy, \" build: \").concat(wy, \", mode: \").concat(this.mode, \", codec: \").concat(this.codec)), e.clientRoleOptions) try {\n        OI(e.clientRoleOptions), t = Object.assign({}, e.clientRoleOptions);\n      } catch (e) {\n        Qy.warning(\"[\".concat(this._clientId, \"] \").concat(e.toString()));\n      }\n      this._statsCollector = new dG(this.store), this._statsCollector.onStatsException = (e, t, i) => {\n        Qy.debug(\"[\".concat(this._clientId, \"] receive exception msg, code: \").concat(e, \", msg: \").concat(t, \", uid: \").concat(i)), this.safeEmit(NI.EXCEPTION, {\n          code: e,\n          msg: t,\n          uid: i\n        });\n      }, this._statsCollector.onUploadPublishDuration = (e, t, i, n) => {\n        const r = this._users.find(t => t.uid === e);\n        r && oA.peerPublishStatus(this._sessionId, {\n          subscribeElapse: n,\n          audioPublishDuration: t,\n          videoPublishDuration: i,\n          peer: r._uintid\n        });\n      }, this.store.useDataChannel = _U().supportDataChannel && Dy(\"SIGNAL_CHANNEL\"), this.store.useP2P = \"p2p\" === e.mode, this._gateway = new lO(this.store, {\n        clientId: this._clientId,\n        mode: this.mode,\n        codec: this.codec,\n        websocketRetryConfig: e.websocketRetryConfig || _y,\n        httpRetryConfig: e.httpRetryConfig || _y,\n        forceWaitGatewayResponse: void 0 === e.forceWaitGatewayResponse || e.forceWaitGatewayResponse,\n        statsCollector: this._statsCollector,\n        role: e.role,\n        clientRoleOptions: t\n      }), this._configDistribute = new QO(), this.store.useP2P ? (this._p2pChannel = new oG(this.store, this._statsCollector), this._handleP2PEvents()) : this._p2pChannel = new gW(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();\n    }\n    async joinMeta(e, t, i, n, r) {\n      let o = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5],\n        s = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];\n      Ny(\"JOIN_GATEWAY_USE_443PORT_ONLY\", o), Ny(\"JOIN_GATEWAY_USE_DUAL_DOMAIN\", s);\n      const a = this._gateway.signal.websocket;\n      return a instanceof Vw && (a.use443PortOnly = o, a.tryDoubleDomain = s), async function (e, t, i) {\n        mv.get(e) || mv.set(e, []), fv.get(e) || fv.set(e, t), Tv.get(e) || Tv.set(e, 0);\n        const n = mv.get(e),\n          r = fv.get(e);\n        if (!n || !r) throw new Error(\"concurrent: deferQueue or maxConcurrency is null\");\n        if (Tv.get(e) === r) {\n          const e = Ev();\n          n.push(e), await e.promise;\n        }\n        Tv.set(e, Tv.get(e) + 1);\n        for (var o = arguments.length, s = new Array(o > 3 ? o - 3 : 0), a = 3; a < o; a++) s[a - 3] = arguments[a];\n        const c = await i(...s);\n        return Tv.set(e, Tv.get(e) - 1), Tv.get(e) === r - 1 && n.length > 0 && (n[0].resolve(), n.shift()), 0 === Tv.get(e) && (mv.set(e, []), fv.set(e, 0), Tv.set(e, 0)), c;\n      }(\"client.join\", Dy(\"JOIN_MAX_CONCURRENCY\"), this.join.bind(this), e, t, i, n, r);\n    }\n    async join(e, t, i, n, r) {\n      const o = ++this._numberOfJoinCount;\n      this.store.joinStart(), n && (this.store.uid = n);\n      const s = \"HTTPS\" === (Ty || Ty || (Ty = (window.location.protocol.split(\":\")[0] || \"\").toUpperCase(), Ty)),\n        a = vy() ? window.isSecureContext : \"Browser Not Support\";\n      if (!vy() && !s || !window.isSecureContext) {\n        const e = \"The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser\";\n        Qy.warning(e);\n      }\n      \"DISCONNECTED\" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), Qy.debug(\"[\".concat(this._clientId, \"] set avoidJoinStart to \").concat(this.store.avoidJoinStart))), oA.setAppId(e);\n      try {\n        if (!i && null !== i) throw new bb(tI.INVALID_PARAMS, \"Invalid token: \".concat(i, \". If you don not use token, set it to null\"));\n        i && aI(i, \"token\", 1, 2047), aI(e, \"appid\", 1, 2047), wb(t), n && Ob(n), r && aI(r, \"optionalInfo\", 1, 2047);\n      } catch (r) {\n        throw oA.reportApiInvoke(ty(), {\n          name: CI.JOIN,\n          options: [e, t, i, n],\n          states: {\n            isHttps: s,\n            isSecureContext: a\n          },\n          tag: vI.TRACER\n        }).onError(r), r;\n      }\n      const c = await tK({\n          appId: e,\n          cname: t,\n          uid: n,\n          stringUid: \"string\" == typeof n ? n : void 0,\n          token: i || e,\n          cloudProxyServer: this._cloudProxyServerMode\n        }),\n        d = (null == c ? void 0 : c.sid) || ty(),\n        l = oA.reportApiInvoke(d, {\n          name: CI.JOIN,\n          options: [e, t, i, n],\n          states: {\n            isHttps: s,\n            isSecureContext: a\n          },\n          tag: vI.TRACER\n        });\n      if (Qy.info(\"[\".concat(this._clientId, \"] start join channel \").concat(t, \", join number: \").concat(o)), this._leaveMutex.isLocked) {\n        Qy.debug(\"[\".concat(this._clientId, \"] join: waiting leave operation\"));\n        (await this._leaveMutex.lock())(), Qy.debug(\"[\".concat(this._clientId, \"] join: continue\"));\n      }\n      if (this._joinAndNotLeaveYet = !0, \"DISCONNECTED\" !== this.connectionState) {\n        const e = new bb(tI.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Client already in connecting/connected state\"));\n        throw l.onError(e), e;\n      }\n      this._sessionId || (this._sessionId = d, this.store.sessionId = this._sessionId), this._gateway.state = \"CONNECTING\";\n      const h = $K($K({}, this._rtmConfig), {}, {\n        clientId: this._clientId,\n        appId: e,\n        sid: this._sessionId,\n        cname: t,\n        uid: \"string\" != typeof n ? n : null,\n        turnServer: this._turnServer,\n        proxyServer: this._proxyServer,\n        token: i || e,\n        cloudProxyServer: this._cloudProxyServerMode,\n        optionalInfo: r,\n        license: this._license,\n        useLocalAccessPoint: this._useLocalAccessPoint,\n        preload: !!c\n      }, void 0 !== this._remoteDefaultVideoStreamType && {\n        defaultVideoStream: this._remoteDefaultVideoStreamType\n      });\n      if (this._useLocalAccessPoint && (h.setLocalAPVersion = this._setLocalAPVersion), \"string\" == typeof n && (h.stringUid = n, this._uintUid ? (h.uid = this._uintUid, this._uintUid = void 0) : h.uid = 0), \"none\" !== this._encryptionMode && this._encryptionSecret) {\n        if (h.aesmode = this._encryptionMode, h.aespassword = await (async e => {\n          const t = function (e) {\n              const t = window.atob(\"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\\nxQiYDz3vqa6bP29adwIDAQAB\"),\n                i = new Uint8Array(new ArrayBuffer(t.length));\n              for (let e = 0; e < t.length; e += 1) i[e] = t.charCodeAt(e);\n              return i;\n            }(),\n            i = await window.crypto.subtle.importKey(\"spki\", t, {\n              name: \"RSA-OAEP\",\n              hash: \"SHA-256\"\n            }, !0, [\"encrypt\"]),\n            n = mI(e),\n            r = await window.crypto.subtle.encrypt({\n              name: \"RSA-OAEP\"\n            }, i, n);\n          return function (e) {\n            let t = \"\";\n            for (let i = 0; i < e.length; i += 1) t += String.fromCharCode(e[i]);\n            return window.btoa(t);\n          }(new Uint8Array(r));\n        })(this._encryptionSecret), !this._joinAndNotLeaveYet) throw new bb(tI.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Client already left\"));\n        this._encryptionSalt && (h.aessalt = this._encryptionSalt);\n      }\n      if (this._encryptDataStream && (\"aes-128-gcm2\" === this._encryptionMode || \"aes-256-gcm2\" === this._encryptionMode)) if (this._encryptionSalt && this._encryptionSecret) {\n        if (window.crypto.subtle) {\n          const e = new TextEncoder(),\n            t = Dy(\"USE_PURE_ENCRYPTION_MASTER_KEY\") ? e.encode(h.appId + this._encryptionSecret + this._encryptionSecret) : e.encode(h.appId + h.cname + this._encryptionSecret);\n          this._encryptDataStreamIv = await async function (e, t, i) {\n            const n = await window.crypto.subtle.importKey(\"raw\", t, \"PBKDF2\", !1, [\"deriveBits\", \"deriveKey\"]),\n              r = \"aes-128-gcm2\" === e ? 128 : 256,\n              o = await window.crypto.subtle.deriveBits({\n                name: \"PBKDF2\",\n                iterations: Vy,\n                hash: \"SHA-256\",\n                salt: i\n              }, n, r + xy);\n            return new Uint8Array(o).subarray(r / 8);\n          }(this._encryptionMode, t, YI(this._encryptionSalt)), this._encryptDataStreamKey = await async function (e, t, i) {\n            const n = await window.crypto.subtle.importKey(\"raw\", t, \"PBKDF2\", !1, [\"deriveBits\", \"deriveKey\"]),\n              r = \"aes-128-gcm2\" === e ? 128 : 256;\n            return await window.crypto.subtle.deriveKey({\n              name: \"PBKDF2\",\n              iterations: Vy,\n              hash: \"SHA-256\",\n              salt: i\n            }, n, {\n              name: \"AES-GCM\",\n              length: r\n            }, !0, [\"encrypt\", \"decrypt\"]);\n          }(this._encryptionMode, t, YI(this._encryptionSalt));\n        } else a ? Qy.warning(\"[\".concat(this._clientId, \"] encrypt datastream must be running in a secure context, fallback to plain data stream\")) : Qy.warning(\"[\".concat(this._clientId, \"] current browser do not support WebCrypto ,fallback to plain data stream\")), this._encryptDataStream = !1;\n      } else this._encryptDataStream = !1, Qy.debug(\"[\".concat(this._clientId, \"] no salt / secret, cannot support encrypt data stream, fallback to plain data stream\"));\n      this._startSession(this._sessionId, {\n        channel: t,\n        appId: e,\n        stringUid: h.stringUid,\n        preload: h.preload\n      });\n      const u = this._sessionId;\n      setTimeout(() => {\n        \"CONNECTING\" === this.connectionState && u === this._sessionId && oA.joinChannelTimeout(this._sessionId, 5);\n      }, 5e3);\n      try {\n        var p;\n        let n;\n        const r = h.cloudProxyServer;\n        if (Dn(p = [\"proxy3\", \"proxy4\", \"proxy5\"]).call(p, r)) {\n          const e = Dy(\"PROXY_SERVER_TYPE3\");\n          Array.isArray(e) ? h.proxyServer = e[0] : h.proxyServer = e;\n        }\n        if (oA.setProxyServer(h.proxyServer), Qy.setProxyServer(h.proxyServer), this.store.requestAPStart(), c) {\n          if (Qy.debug(\"[\".concat(this._clientId, \"] get serverInfo Success from Preload Cache \").concat(h.stringUid ? \", \".concat(h.stringUid, \" => \").concat(c.intUid) : \"\", \" \")), h.stringUid && !h.uid && (h.uid = c.intUid), n = {\n            gatewayInfo: c.ap.gatewayInfo\n          }, Dy(\"JOIN_WITH_FALLBACK_MEDIA_PROXY\") && \"auto\" === h.turnServer.mode) if (0 === c.ap.proxyInfo.addresses.length) Qy.warning(\"no edge services in ap response of proxy fallback, will not set proxy in iceServers\");else {\n            const e = (await Xw(c.ap.proxyInfo, c.ap.gatewayInfo.uid)).map(e => ({\n              turnServerURL: e.address,\n              tcpport: e.tcpport || aA.tcpport,\n              udpport: e.udpport || aA.udpport,\n              username: e.username || aA.username,\n              password: e.password || aA.password,\n              forceturn: !1,\n              security: !0\n            }));\n            h.turnServer = {\n              mode: \"manual\",\n              servers: e\n            };\n          }\n          oK(c, h.stringUid);\n        } else {\n          if (h.stringUid && !h.uid) {\n            var _await$Gu$all3, _await$Gu$all4;\n            let e;\n            (_await$Gu$all3 = await Gu.all([jO(h.stringUid, h, this._axiosCancelSource.token, this._config.httpRetryConfig || _y, this.store), BO(h, this._axiosCancelSource.token, this._config.httpRetryConfig || _y, !0, this.store)]), _await$Gu$all4 = _slicedToArray(_await$Gu$all3, 2), e = _await$Gu$all4[0], n = _await$Gu$all4[1]), Qy.debug(\"[\".concat(this._clientId, \"] getUserAccount Success \").concat(h.stringUid, \" => \").concat(e)), h.uid = e, n.gatewayInfo.uid = e, n.gatewayInfo.res.uid = e;\n          } else n = await BO(h, this._axiosCancelSource.token, this._config.httpRetryConfig || _y, !0, this.store);\n          if (!this._joinAndNotLeaveYet) throw new bb(tI.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Client already left\"));\n        }\n        this.store.requestAPEnd(), setTimeout(() => {\n          this._configDistribute.startGetConfigDistribute(h, this._axiosCancelSource.token), this._configDistribute.on(ew.UPDATE_BITRATE_LIMIT, e => {\n            this._p2pChannel.updateBitrateLimit(e);\n          });\n        }, 0), this._key = i || e;\n        const o = n.gatewayInfo,\n          s = h.uid ? h.uid : o.uid;\n        this._joinInfo = $K($K({}, h), {}, {\n          cid: o.cid,\n          uid: s,\n          vid: o.vid,\n          apResponse: o.res,\n          uni_lbs_ip: o.uni_lbs_ip,\n          gatewayAddrs: o.gatewayAddrs\n        }), this.store.intUid = s;\n        const a = await this._joinGateway();\n        if (!this._joinAndNotLeaveYet) throw new bb(tI.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Client already left\"));\n        l.onSuccess(a), this._appId = e, this._channelName = h.cname, this._uid = a, this.store.uid = a, setTimeout(() => {\n          this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(Nv() ? \"beforeunload\" : \"pagehide\", this._handleBeforeUnload), this._statsCollector.startUpdateStats();\n        }, 0);\n        const d = h.stringUid ? \"string uid: \".concat(h.stringUid, \",uid: \").concat(h.uid) : \"uid: \".concat(this._uid);\n        return Qy.info(\"[\".concat(this._clientId, \"] Joining channel success: channel: \").concat(t, \",\").concat(d)), setTimeout(() => {\n          Qy.startUpload();\n        }, 5e3), this.store.joinEnd(), _ = this, Dn(dA).call(dA, _) || dA.push(_), \"disabled\" === this._cloudProxyServerMode && _U().supportWebCrypto && Dy(\"ENABLE_PRELOAD\") && nK(this._joinInfo), a;\n      } catch (e) {\n        const t = Array.isArray(e) ? e[0] : e;\n        throw t && t.code === tI.OPERATION_ABORTED ? Qy.warning(\"[\".concat(this._clientId, \"] join number: \").concat(o, \", Joining channel failed, rollback\"), t) : Qy.error(\"[\".concat(this._clientId, \"] join number: \").concat(o, \", Joining channel failed, rollback\"), t), t.code !== tI.OPERATION_ABORTED && this._numberOfJoinCount === o && (this._gateway.state = \"DISCONNECTED\", this._reset()), l.onError(t), t;\n      }\n      var _;\n    }\n    _joinGateway() {\n      if (!this._joinInfo || !this._key) throw new bb(tI.INVALID_OPERATION);\n      return this._gateway.join(this._joinInfo, this._key, !(\"disabled\" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !Dy(\"JOIN_WITH_FALLBACK_SIGNAL_PROXY\"))).then(e => e).catch(e => {\n        if (e.code === tI.INIT_WEBSOCKET_TIMEOUT) return this._gateway.leave(!0, AI.FALLBACK), e;\n        if (e.code === tI.INIT_DATACHANNEL_TIMEOUT) return this._gateway.leave(!0, AI.FALLBACK), e;\n        throw e;\n      }).then(e => {\n        if (e instanceof bb) {\n          if (e.code === tI.INIT_WEBSOCKET_TIMEOUT) {\n            if (Qy.info(\"[\".concat(this._clientId, \"] join timeout, fallback to proxy\")), !this._joinInfo || !this._key) throw new bb(tI.INVALID_OPERATION);\n            this._joinInfo.cloudProxyServer = \"fallback\", this._cloudProxyServerMode = \"fallback\", this.store.cloudProxyServerMode = \"fallback\";\n            const e = Dy(\"PROXY_SERVER_TYPE3\");\n            if (Array.isArray(e)) {\n              if (this._joinInfo.apUrl) {\n                const t = /^https?:\\/\\/(.+?)(\\/.*)?$/.exec(this._joinInfo.apUrl)[1].split(\".\"),\n                  i = t.slice(t.length - 2).join(\".\");\n                e.forEach(e => {\n                  this._joinInfo && Dn(e).call(e, i) && (this._joinInfo.proxyServer = e);\n                }), this._joinInfo.proxyServer || (this._joinInfo.proxyServer = e[0]);\n              } else this._joinInfo.proxyServer = e[0];\n            } else this._joinInfo.proxyServer = e;\n            const t = Dy(\"LOG_UPLOAD_SERVER\").match(/.+:(\\d{1,5})$/);\n            t && t[1] && \"443\" !== t[1] && Qy.setProxyServer(this._joinInfo.proxyServer), \"443\" !== Dy(\"STATS_COLLECTOR_PORT\").toString() && oA.setProxyServer(this._joinInfo.proxyServer);\n            return oA.reportApiInvoke(this._sessionId, {\n              name: CI.JOIN_FALLBACK_TO_PROXY,\n              options: [this._joinInfo.proxyServer],\n              tag: vI.TRACER\n            }).onSuccess(), this.safeEmit(NI.JOIN_FALLBACK_TO_PROXY, this._joinInfo.proxyServer), Dy(\"JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE\") && this._joinInfo.turnServer.servers.forEach(e => {\n              \"forceturn\" in e && (e.forceturn = !0);\n            }), this._gateway.join(this._joinInfo, this._key);\n          }\n          if (Qy.info(\"[\".concat(this._clientId, \"] join by datachannel timeout, fallback to websocket\")), !this._joinInfo || !this._key) throw new bb(tI.INVALID_OPERATION);\n          return oA.reportApiInvoke(this._sessionId, {\n            name: CI.DATACHANNEL_FAILBACK,\n            options: [this.store.clientId],\n            tag: vI.TRACER\n          }).onSuccess(), this._joinGateway();\n        }\n        return e;\n      }).then(e => e);\n    }\n    async leave() {\n      Qy.info(\"[\".concat(this._clientId, \"] Leaving channel\")), window.removeEventListener(Nv() ? \"beforeunload\" : \"pagehide\", this._handleBeforeUnload), this._reset(), function (e) {\n        const t = dA.indexOf(e);\n        -1 !== t && dA.splice(t, 1);\n      }(this), this._statsCollector.stopUpdateStats();\n      const e = await this._leaveMutex.lock();\n      if (\"DISCONNECTED\" === this.connectionState) return Qy.info(\"[\".concat(this._clientId, \"] Leaving channel repeated, success\")), void e();\n      await this._gateway.leave(\"CONNECTED\" !== this.connectionState), Qy.info(\"[\".concat(this._clientId, \"] Leaving channel success\")), this._joinAndNotLeaveYet = !1, this.store.resetJoinChannelServiceRecords(), e();\n    }\n    async publish(e) {\n      let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (!Array.isArray(e)) {\n        if (!(e instanceof ox)) return this._publishDataChannel(e);\n        e = [e];\n      }\n      if (0 === e.length) throw new bb(tI.INVALID_PARAMS, \"param list is empty\");\n      const i = e;\n      if (\"audience\" === this._gateway.role) throw new bb(tI.INVALID_OPERATION, \"audience can not publish stream\");\n      for (const e of i) {\n        if (!(e instanceof ox)) throw new bb(tI.INVALID_PARAMS, \"parameter is not local track\");\n        if (!e._enabled && t) throw new bb(tI.TRACK_IS_DISABLED, \"can not publish a disabled track: \".concat(e.getTrackId()));\n      }\n      Qy.info(\"[\".concat(this._clientId, \"] Publishing tracks, id \").concat(i.map(e => \"\".concat(e.getTrackId(), \" \"))));\n      const n = await this._publishMutex.lock();\n      await this._configDistribute.awaitConfigDistributeComplete(), t && i.forEach(e => {\n        const t = this._configDistribute.getBitrateLimit();\n        e instanceof vF && t && e.setBitrateLimit(t.uplink);\n      });\n      try {\n        await this._publishHighStream(i), Qy.info(\"[\".concat(this._clientId, \"] Publish success, id \").concat(i.map(e => \"\".concat(e.getTrackId(), \" \"))));\n      } catch (e) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] publish error\"), e.toString()), e;\n      } finally {\n        n();\n      }\n    }\n    async _publishDataChannel(e) {\n      oI(e.id, \"id\", 0, 65535, !0), nI(e.ordered, \"ordered\"), aI(e.metadata, \"metadata\", 0, 512), Qy.info(\"[\".concat(this._clientId, \"] Publishing datachannels, id \").concat(e.id));\n      const t = await this._publishMutex.lock();\n      try {\n        if (-1 !== this._p2pChannel.getAllDataChannels().findIndex(t => t.id === e.id)) throw new bb(tI.INVALID_PARAMS, \"Invalid id: \".concat(e.id, \". If you want to republish the datachannel, unpublish first\"));\n        if (!this._joinInfo || void 0 === this._uid) throw new bb(tI.INVALID_OPERATION, \"Can't publish datachannel, haven't joined yet!\");\n        if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"can not publish datachannel in \".concat(this.connectionState, \" state\"));\n        if (\"auto\" === this._turnServer.mode && Dy(\"FORCE_TURN\") && !Dy(\"TURN_ENABLE_TCP\") && !Dy(\"TURN_ENABLE_UDP\")) throw new bb(tI.UNEXPECTED_ERROR, \"force TURN With No TURN Configuration\");\n        const i = new YF(e);\n        if (await this._p2pChannel.publishDataChannel([i]), !this._p2pChannel.isP2PDisconnected()) {\n          if (\"number\" != typeof i._originDataChannelId) throw Qy.error(\"[\".concat(this._clientId, \"] can not publish with mediaType datachannel, cannot get RTCDatachannel id\")), new bb(tI.CREATE_DATACHANNEL_ERROR);\n          try {\n            const t = {\n              streamId: e.id,\n              ordered: e.ordered,\n              maxRetransmits: Dy(\"DATASTREAM_MAX_RETRANSMITS\"),\n              metadata: e.metadata,\n              channelId: i._originDataChannelId\n            };\n            await this._gateway.publishDataChannel(this._uid, t, !0), await i._waitTillOpen();\n          } catch (e) {\n            if (e.code !== tI.DISCONNECT_P2P) throw e;\n          }\n        }\n        return Qy.info(\"[\".concat(this._clientId, \"] Publish dataChannels success, id \").concat(i.id)), i;\n      } catch (e) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] publish datachannels error\"), e.toString()), e;\n      } finally {\n        t();\n      }\n    }\n    async unpublish(e) {\n      if (!this._joinInfo || void 0 === this._uid) throw new bb(tI.INVALID_OPERATION, \"Can't unpublish stream, haven't joined yet!\");\n      let t = [];\n      if (e) {\n        if (Array.isArray(e)) t = e;else {\n          if (!(e instanceof ox)) return this._unpublishDataChannel([e]);\n          t = [e];\n        }\n      } else this.store.useP2P || (await this._unpublishDataChannel()), t = this._p2pChannel.getAllTracks(!0);\n      Qy.info(\"[\".concat(this._clientId, \"] Unpublish tracks, tracks \").concat(t.map(e => \"\".concat(e.getTrackId(), \" \")), \" \"));\n      const i = await this._publishMutex.lock();\n      try {\n        if (this._p2pChannel instanceof oG) {\n          const e = await this._p2pChannel.unpublish(t);\n          e && (await this._gateway.sendExtensionMessage(Tw.UNPUBLISH, {\n            unpubMsg: e\n          }, !0));\n        } else {\n          const e = await this._p2pChannel.unpublish(t);\n          e && (await this._gateway.unpublish(e, this._uid)), Qy.info(\"[\".concat(this._clientId, \"] Unpublish success,tracks \").concat(t.map(e => \"\".concat(e.getTrackId()))));\n        }\n      } catch (e) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] unpublish error\"), e.toString()), e;\n      } finally {\n        i && i();\n      }\n    }\n    async _unpublishDataChannel(e) {\n      void 0 !== e && 0 !== e.length || (e = this._p2pChannel.getAllDataChannels()), Qy.info(\"[\".concat(this._clientId, \"] Unpublish datachannels, datachannels \").concat(e.map(e => \"\".concat(e.id, \" \")), \" \"));\n      const t = await this._publishMutex.lock();\n      try {\n        const i = await this._p2pChannel.unpublishDataChannel(e);\n        i && (await this._gateway.unpublishDataChannel(i)), Qy.info(\"[\".concat(this._clientId, \"] Unpublish dataChannel success,dataChannel \").concat(e.map(e => \"\".concat(e.id))));\n      } catch (e) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] unpublish dataChannel error\"), e.toString()), e;\n      } finally {\n        t && t();\n      }\n    }\n    async subscribe(e, t, i) {\n      if (!(e instanceof Bj)) {\n        const t = this.remoteUsers.find(t => t.uid === e);\n        if (!t) throw new bb(tI.INVALID_REMOTE_USER, \"user is not in the channel\");\n        e = t;\n      }\n      return \"datachannel\" === t ? this._subscribeDataChannel(e, i) : this._subscribe(e, t);\n    }\n    async presubscribe(e, t) {\n      if (rI(t, \"mediaType\", [\"audio\", \"video\"]), this._p2pChannel instanceof oG) throw new bb(tI.INVALID_OPERATION, \"can't presub at p2p mode\");\n      if (!this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"can't presub when not join\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"can't presub in \".concat(this.connectionState, \" state\"));\n      const i = t === nw.AUDIO,\n        n = t === nw.VIDEO,\n        r = await this._subscribeMutex.lock();\n      try {\n        const _await$this$_gateway$ = await this._gateway.presubscribe(e, t, !0),\n          o = _await$this$_gateway$.ssrcId,\n          s = _await$this$_gateway$.ortc,\n          a = _await$this$_gateway$.rtxSsrcId,\n          c = _await$this$_gateway$.cname,\n          d = _await$this$_gateway$.uint_id;\n        if (null == o) throw new bb(tI.UNEXPECTED_RESPONSE, \"no ssrc id\");\n        let l = this._users.find(t => t.uid === e);\n        l || (l = new Bj(e, d || e), l._is_pre_created = !0, this._users.push(l)), c && (l._cname = c), l._uintid || (l._uintid = d || e), i && (l._audioSSRC = o, l._audio_pre_subscribed = !0, s && (l._audioOrtc = s)), n && (l._videoSSRC = o, l._video_pre_subscribed = !0, s && (l._videoOrtc = s), null != a && (l._rtxSsrcId = a)), Qy.info(\"[\".concat(this._clientId, \"] presub succeed ssrc: \").concat(o)), await this._p2pChannel.subscribe(l, t, o, a, s);\n        const h = i ? l._audioTrack : l._videoTrack;\n        if (!h) throw new bb(tI.UNEXPECTED_ERROR, \"can not find remote track in user\");\n        return i && (l._trust_audio_stream_added_state_ = !0, l._audio_added_ = !0), n && (l._trust_video_stream_added_state_ = !0, l._video_added_ = !0), h;\n      } catch (t) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] presub user \").concat(e, \" error\"), t), t;\n      } finally {\n        r();\n      }\n    }\n    async _subscribeDataChannel(e, t) {\n      var i;\n      if (oI(t, \"channelId\", 0, 65535, !0), !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"Can't subscribe datachannel, not joined\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"Can't subscribe datachannel in \".concat(this.connectionState, \" state\"));\n      const n = this._users.find(t => t === e);\n      if (!n) throw Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \", this user is not in the channel\")), new bb(tI.INVALID_REMOTE_USER, \"user is not in the channel\");\n      if (!e.hasAudio && !e.hasVideo && 0 === e._dataChannels.length) throw Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \", user is not published\")), new bb(tI.INVALID_REMOTE_USER, \"user is not published\");\n      const r = null === (i = e._dataChannels) || void 0 === i ? void 0 : i.find(e => e.id === t);\n      if (!r) throw Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \" with mediaType datachannel, remote datachannel is not published\")), new bb(tI.REMOTE_USER_IS_NOT_PUBLISHED);\n      const o = await this._subscribeMutex.lock();\n      Qy.info(\"[\".concat(this._clientId, \"] subscribe user \").concat(e.uid, \", mediaType: datachannel\"));\n      try {\n        const t = await this._p2pChannel.subscribeDataChannel(e, [r]);\n        if (t && Dn(t).call(t, r.id)) try {\n          var s;\n          if (\"number\" != typeof r._originDataChannelId) throw Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \" with mediaType datachannel, cannot get RTCDatachannel\")), new bb(tI.CREATE_DATACHANNEL_ERROR);\n          const t = {\n            id: r.id,\n            datachannelId: r._originDataChannelId,\n            ordered: r.ordered,\n            maxRetransmits: r.maxRetransmits,\n            metadata: null !== (s = r.metadata) && void 0 !== s ? s : \"\"\n          };\n          await this._gateway.subscribeDataChannel(e.uid, t, !0), await r._waitTillOpen();\n        } catch (t) {\n          if ((null == t ? void 0 : t.code) !== tI.WS_ABORT) throw await this._p2pChannel.unsubscribeDataChannel(e, [r]), t;\n          await this._p2pChannel.unsubscribeDataChannel(e, [r]), this._p2pChannel.setPendingRemoteDataChannel(e, r.id);\n        }\n        return Qy.info(\"[\".concat(this._clientId, \"] subscribe success user \").concat(e.uid, \", mediaType: datachannel\")), r;\n      } finally {\n        o();\n      }\n    }\n    async _p2pSubscribe(e, t, i) {\n      if (rI(t, \"mediaType\", [\"audio\", \"video\"]), !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"Can't subscribe stream, not joined\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"Can't subscribe stream in \".concat(this.connectionState, \" state\"));\n      const n = this._users.find(t => t === e);\n      if (!n) {\n        const t = new bb(tI.INVALID_REMOTE_USER, \"user is not in the channel\");\n        throw Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \", this user is not in the channel\")), t;\n      }\n      if (!e.hasAudio && !e.hasVideo) {\n        const t = new bb(tI.INVALID_REMOTE_USER, \"user is not published\");\n        throw Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \", user is not published\")), t;\n      }\n      if (!i && (\"audio\" === t && !e.hasAudio || \"video\" === t && !e.hasVideo)) {\n        const i = new bb(tI.REMOTE_USER_IS_NOT_PUBLISHED);\n        throw Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \" with mediaType \").concat(t, \", remote track is not published\")), i;\n      }\n      const r = await this._subscribeMutex.lock();\n      Qy.info(\"[\".concat(this._clientId, \"] subscribe user \").concat(e.uid, \", mediaType: \").concat(t));\n      try {\n        if (await this._p2pChannel.hasRemoteMediaWithLock(e, t)) await this._p2pChannel.unmuteRemote(e, t);else try {\n          const i = \"audio\" === t ? e._audioSSRC : e._videoSSRC,\n            n = \"audio\" === t ? e._audioMid : e._videoMid;\n          this.store.subscribe(e.uid, t, Date.now()), this._p2pChannel instanceof oG && (await this._p2pChannel.subscribe(e, t, i, n));\n        } catch (e) {\n          throw e;\n        }\n        Qy.info(\"[\".concat(this._clientId, \"] subscribe success user \").concat(e.uid, \", mediaType: \").concat(t)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e.uid, this._defaultStreamFallbackType).catch(e => {\n          Qy.warning(\"[\".concat(this._clientId, \"] auto set fallback failed\"), e);\n        });\n        const i = \"audio\" === t ? e._audioTrack : e._videoTrack;\n        if (!i) throw new bb(tI.UNEXPECTED_ERROR, \"can not find remote track in user object\");\n        return i;\n      } catch (t) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] subscribe user \").concat(e.uid, \" error\"), t), t;\n      } finally {\n        r();\n      }\n    }\n    async _subscribe(e, t, i) {\n      if (this._p2pChannel instanceof oG) return this._p2pSubscribe(e, t);\n      if (rI(t, \"mediaType\", [\"audio\", \"video\"]), !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"Can't subscribe stream, not joined\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"Can't subscribe stream in \".concat(this.connectionState, \" state\"));\n      const n = this._users.find(t => t === e);\n      if (!n) {\n        const t = new bb(tI.INVALID_REMOTE_USER, \"user is not in the channel\");\n        throw Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \", this user is not in the channel\")), t;\n      }\n      if (!e.hasAudio && !e.hasVideo) {\n        const t = new bb(tI.INVALID_REMOTE_USER, \"user is not published\");\n        throw Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \", user is not published\")), t;\n      }\n      if (!(i || (\"audio\" !== t || e.hasAudio && void 0 !== e._audioSSRC) && (\"video\" !== t || e.hasVideo && void 0 !== e._videoSSRC))) {\n        const i = new bb(tI.REMOTE_USER_IS_NOT_PUBLISHED);\n        throw Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \" with mediaType \").concat(t, \", remote track is not published\")), i;\n      }\n      let r = \"audio\" === t ? e._audioSSRC : e._videoSSRC,\n        o = \"audio\" === t ? e._audioOrtc : e._videoOrtc,\n        s = \"video\" === t ? e._rtxSsrcId : void 0,\n        a = {\n          stream_type: \"audio\" === t ? nw.AUDIO : nw.VIDEO,\n          ssrcId: r\n        };\n      const c = await this._subscribeMutex.lock();\n      Qy.info(\"[\".concat(this._clientId, \"] subscribe user \").concat(e.uid, \", mediaType: \").concat(t));\n      try {\n        if (await this._p2pChannel.hasRemoteMediaWithLock(e, t)) await this._p2pChannel.unmuteRemote(e, t);else try {\n          const i = \"audio\" === t ? e._audioSSRC : e._videoSSRC;\n          void 0 !== i && i !== r && (r = i, o = \"audio\" === t ? e._audioOrtc : e._videoOrtc, s = \"video\" === t ? e._rtxSsrcId : void 0, a = {\n            stream_type: \"audio\" === t ? nw.AUDIO : nw.VIDEO,\n            ssrcId: r\n          }), iB.markSubscribeStart(this.store.clientId, r), this.store.subscribe(e.uid, t, Date.now()), await this._p2pChannel.subscribe(e, t, r, s, o);\n          try {\n            await this._gateway.subscribe(e.uid, a, !0);\n          } catch (i) {\n            if ((null == i ? void 0 : i.code) !== tI.WS_ABORT) throw await this._p2pChannel.unsubscribe(e, t), i;\n            await this._p2pChannel.unsubscribe(e, t, !0), this._p2pChannel.setPendingRemoteMedia(e, t);\n          }\n          this.store.subscribe(e.uid, t, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(!0, null, e, t);\n        } catch (i) {\n          throw this._p2pChannel.reportSubscribeEvent(!1, null == i ? void 0 : i.code, e, t), i;\n        }\n        Qy.info(\"[\".concat(this._clientId, \"] subscribe success user \").concat(e.uid, \", mediaType: \").concat(t)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e.uid, this._defaultStreamFallbackType).catch(e => {\n          Qy.warning(\"[\".concat(this._clientId, \"] auto set fallback failed\"), e);\n        });\n        const i = \"audio\" === t ? e._audioTrack : e._videoTrack;\n        if (!i) throw new bb(tI.UNEXPECTED_ERROR, \"can not find remote track in user object\");\n        return i;\n      } catch (t) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] subscribe user \").concat(e.uid, \" error\"), t), t;\n      } finally {\n        c();\n      }\n    }\n    async massSubscribe(e) {\n      if (cI(e, \"subscribeList\"), !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"Can't subscribe stream, not joined\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"Can't subscribe stream in \".concat(this.connectionState, \" state\"));\n      const t = Date.now(),\n        i = new Map(),\n        n = await this._subscribeMutex.lock();\n      Qy.info(\"[\".concat(this._clientId, \"]start massSubscribe user \").concat(e.map(e => {\n        let t = e.user,\n          i = e.mediaType;\n        return \"user: \".concat(null == t ? void 0 : t.uid, \", mediaType: \").concat(i);\n      }).join(\"; \")));\n      const r = (e = [...e]).map(e => {\n          let t = e.user,\n            i = e.mediaType;\n          return {\n            user: t,\n            mediaType: i\n          };\n        }),\n        o = await this._p2pChannel.globalLock();\n      try {\n        var s;\n        for (let t = e.length - 1; t >= 0; t--) {\n          const n = e[t],\n            o = n.user,\n            s = n.mediaType;\n          if (rI(s, \"mediaType\", [\"audio\", \"video\"]), !o) {\n            const e = new bb(tI.INVALID_PARAMS, \"user property does not exist in subscribeList item\");\n            throw Qy.error(\"[\".concat(this._clientId, \"] user property does not exist in subscribeList item\")), e;\n          }\n          const a = this._users.find(e => e === o);\n          if (!a) {\n            const i = new bb(tI.INVALID_REMOTE_USER, \"user is not in the channel\");\n            Qy.error(\"[\".concat(this._clientId, \"] can not massSubscribe \").concat(o.uid, \", this user is not in the channel\")), r[t].error = i, e.splice(t, 1);\n            continue;\n          }\n          if (\"audio\" === s && (!o.hasAudio || void 0 === o._audioSSRC) || \"video\" === s && (!o.hasVideo || void 0 === o._videoSSRC)) {\n            const i = new bb(tI.REMOTE_USER_IS_NOT_PUBLISHED);\n            Qy.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(o.uid, \" with mediaType \").concat(s, \", remote user is not published\")), r[t].error = i, e.splice(t, 1);\n            continue;\n          }\n          const c = zb.Video | zb.LwoVideo,\n            d = i.get(o);\n          if (d) {\n            if (\"video\" === s ? d & c : d & zb.Audio) {\n              e.splice(t, 1), Qy.warning(\"[\".concat(this._clientId, \"] repeat massSubscribe user:\").concat(o.uid, \", mediaType:\").concat(s, \" twice\"));\n              continue;\n            }\n            i.set(o, d | (\"video\" === s ? c : zb.Audio));\n          } else i.set(o, \"video\" === s ? c : zb.Audio);\n        }\n        for (let t = e.length - 1; t >= 0; t--) {\n          const n = e[t],\n            r = n.user,\n            o = n.mediaType,\n            s = zb.Video | zb.LwoVideo;\n          if (this._p2pChannel.hasRemoteMedia(r, o)) {\n            await this._p2pChannel.unmuteRemoteNoLock(r, o);\n            const n = i.get(r);\n            i.set(r, \"video\" === o ? n ^ s : n ^ zb.Audio), e.splice(t, 1);\n          }\n        }\n        this.store.massSubscribe(e.map(e => ({\n          userId: e.user.uid,\n          type: e.mediaType\n        })), t);\n        const a = Jn(s = Array.from(i.entries())).call(s, (e, t) => {\n          let _t20 = _slicedToArray(t, 2),\n            i = _t20[0],\n            n = _t20[1];\n          if (0 === n) return e;\n          const r = {\n            stream_id: i.uid,\n            stream_type: n\n          };\n          return n & zb.Audio && (r.audio_ssrc = i._audioSSRC), n & zb.Video && (r.video_ssrc = i._videoSSRC), e.push(r), e;\n        }, []);\n        try {\n          e.length > 0 && (await this._p2pChannel.massSubscribeNoLock(e.map(e => {\n            let t = e.user,\n              i = e.mediaType;\n            return {\n              user: t,\n              mediaType: i,\n              ssrcId: i === nw.VIDEO ? t._videoSSRC : t._audioSSRC,\n              rtxSsrcId: i === nw.VIDEO ? t._rtxSsrcId : void 0\n            };\n          })));\n          const i = new Map();\n          if (a.length > 0) {\n            const e = await this._gateway.subscribeAll(a, !0);\n            ((null == e ? void 0 : e.users) || []).forEach(e => {\n              let t = e.stream_id,\n                n = e.video_error_code,\n                r = e.audio_error_code,\n                o = e.error_code;\n              (n || r || o) && i.set(t, {\n                video_error_code: n,\n                audio_error_code: r,\n                error_code: o\n              });\n            });\n          }\n          if (Array.from(i.entries()).length > 0) {\n            const e = [];\n            Array.from(i.entries()).forEach(t => {\n              let _t21 = _slicedToArray(t, 2),\n                i = _t21[0],\n                n = _t21[1];\n              const r = this.remoteUsers.find(e => e.uid === i);\n              if (r) {\n                let t;\n                n.error_code || n.video_error_code && n.audio_error_code ? t = void 0 : n.video_error_code ? t = nw.VIDEO : n.audio_error_code && (t = nw.AUDIO), e.push({\n                  user: r,\n                  mediaType: t\n                });\n              }\n            }), e.length > 0 && (await this._p2pChannel.massUnsubscribeNoLock(e));\n          }\n          for (const e of r) {\n            const t = i.get(e.user.uid);\n            if (t) {\n              const i = t.error_code || \"audio\" === e.mediaType && t.audio_error_code || \"video\" === e.mediaType && t.video_error_code;\n              if (i) {\n                const t = yw(i);\n                Qy.error(\"user:\".concat(e.user.uid, \" mediaType:\").concat(e.mediaType, \" has massSubscribe error \").concat(t.desc)), e.error = new bb(tI.SUBSCRIBE_FAILED, \"code \".concat(i, \": \").concat(t.desc));\n              }\n            }\n            e.error || (\"video\" === e.mediaType ? e.track = e.user.videoTrack : e.track = e.user.audioTrack);\n          }\n          return this.store.massSubscribe(r.filter(e => !e.error).map(e => ({\n            userId: e.user.uid,\n            type: e.mediaType\n          })), void 0, Date.now()), r.forEach(e => {\n            var i;\n            oA.subscribe(this.store.sessionId, {\n              succ: !!e.error,\n              ec: (null === (i = e.error) || void 0 === i ? void 0 : i.code) || null,\n              video: e.mediaType === nw.VIDEO,\n              audio: e.mediaType === nw.AUDIO,\n              peerid: e.user.uid,\n              subscribeRequestid: e.mediaType === nw.VIDEO ? e.user._videoSSRC : e.user._audioSSRC,\n              p2pid: this.store.p2pId,\n              eventElapse: Math.floor(performance.now() - t)\n            }, !0);\n          }), Qy.info(\"[\".concat(this._clientId, \"] massSubscribe success \").concat(e.map(e => {\n            let t = e.user,\n              i = e.mediaType;\n            return \"user: \".concat(null == t ? void 0 : t.uid, \", mediaType: \").concat(i);\n          }).join(\"; \"))), r;\n        } catch (t) {\n          throw await this._p2pChannel.massUnsubscribeNoLock(e), t;\n        }\n      } finally {\n        o(), n();\n      }\n    }\n    async unsubscribe(e, t, i) {\n      if (!(e instanceof Bj)) {\n        const t = this.remoteUsers.find(t => t.uid === e);\n        if (!t) throw new bb(tI.INVALID_REMOTE_USER, \"user is not in the channel\");\n        e = t;\n      }\n      if (t || this.store.useP2P) {\n        if (\"datachannel\" === t) return this._unsubscribeDataChannel(e, i);\n      } else await this._unsubscribeDataChannel(e, i);\n      if (t && rI(t, \"mediaType\", [\"audio\", \"video\"]), !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"Can't unsubscribe stream, haven't joined yet!\");\n      const n = this._users.find(t => t === e);\n      if (!n) {\n        const t = new bb(tI.INVALID_REMOTE_USER, \"user is not in the channel\");\n        throw Qy.error(\"[\".concat(this._clientId, \"] can not unsubscribe \").concat(e.uid, \", user is not in the channel\")), t;\n      }\n      Qy.info(\"[\".concat(this._clientId, \"] unsubscribe uid: \").concat(e.uid, \", mediaType: \").concat(t));\n      const r = await this._subscribeMutex.lock();\n      try {\n        if (this._p2pChannel instanceof oG) await this._p2pChannel.unsubscribe(e, t);else {\n          const i = await this._p2pChannel.unsubscribe(e, t);\n          i && (await this._gateway.unsubscribe(i, e.uid)), t && \"audio\" !== t || (e._audio_pre_subscribed = !1), t && \"video\" !== t || (e._video_pre_subscribed = !1), e._is_pre_created && FI(this._users, e), Qy.info(\"[\".concat(this._clientId, \"] unsubscribe success uid: \").concat(e.uid, \", mediaType: \").concat(t));\n        }\n      } catch (t) {\n        if (t.code === tI.DISCONNECT_P2P) return void Qy.warning(\"disconnecting p2p, abort unsubscribe request.\");\n        throw Qy.error(\"[\".concat(this._clientId, \"] unsubscribe user \").concat(e.uid, \" error\"), t.toString()), t;\n      } finally {\n        r();\n      }\n    }\n    async _unsubscribeDataChannel(e, t) {\n      if (t && oI(t, \"id\", 0, 65535, !0), !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"Can't unsubscribe datachannel, haven't joined yet!\");\n      const i = this._users.find(t => t === e);\n      if (!i) {\n        const t = new bb(tI.INVALID_REMOTE_USER, \"user is not in the channel\");\n        throw Qy.error(\"[\".concat(this._clientId, \"] can not unsubscribe \").concat(e.uid, \", user is not in the channel\")), t;\n      }\n      let n;\n      if (\"number\" == typeof t) {\n        const i = e._dataChannels.find(e => e.id === t);\n        i && (n = [i]);\n      } else n = e._dataChannels;\n      if (void 0 === n) {\n        const i = new bb(tI.REMOTE_USER_IS_NOT_PUBLISHED);\n        throw Qy.error(\"[\".concat(this._clientId, \"] can not unsubscribe \").concat(e.uid, \" with channelId \").concat(t, \", remote datachannel is not published\")), i;\n      }\n      Qy.info(\"[\".concat(this._clientId, \"] unsubscribe uid: \").concat(e.uid, \", mediaType: datachannel, ids: \").concat(n.map(e => e.id)));\n      try {\n        const t = await this._p2pChannel.unsubscribeDataChannel(e, n);\n        t && (await this._gateway.unsubscribeDataChannel(t, e.uid)), Qy.info(\"[\".concat(this._clientId, \"] unsubscribe datachannel success uid: \").concat(e.uid, \", mediaType: datachannel, ids: \").concat(t));\n      } catch (t) {\n        if (t.code === tI.DISCONNECT_P2P) return void Qy.warning(\"disconnecting p2p, abort unsubscribe request.\");\n        throw Qy.error(\"[\".concat(this._clientId, \"] unsubscribe user \").concat(e.uid, \" error\"), t.toString()), t;\n      }\n    }\n    async massUnsubscribe(e) {\n      if (cI(e, \"unsubscribeList\"), !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"Can't unsubscribeAll stream, haven't joined yet!\");\n      Qy.info(\"[\".concat(this._clientId, \"] start massUnsubscribe \").concat(e.map(e => {\n        let t = e.user,\n          i = e.mediaType;\n        return \"user: \".concat(null == t ? void 0 : t.uid, \", mediaType: \").concat(i, \";\");\n      }).join())), e = [...e];\n      const t = new Map();\n      for (let i = e.length - 1; i >= 0; i--) {\n        const _e$i2 = e[i],\n          n = _e$i2.user,\n          r = _e$i2.mediaType;\n        if (!n) {\n          const e = new bb(tI.INVALID_PARAMS, \"user property does not exist in unsubscribeList item\");\n          throw Qy.error(\"[\".concat(this._clientId, \"] user property does not exist in unsubscribeList item\")), e;\n        }\n        rI(r, \"mediaType\", [\"video\", \"audio\", void 0]);\n        const o = this._users.find(e => e === n);\n        if (!o) {\n          Qy.warning(\"[\".concat(this._clientId, \"] can not unsubscribe \").concat(n.uid, \", user is not in the channel\")), e.splice(i, 1);\n          continue;\n        }\n        const s = zb.Video | zb.LwoVideo;\n        if (t.has(n)) {\n          const o = t.get(n);\n          let a;\n          switch (r) {\n            case \"video\":\n              a = o & s;\n              break;\n            case \"audio\":\n              a = o & zb.Audio;\n              break;\n            default:\n              a = o & (zb.Audio | s);\n          }\n          if (a) {\n            Qy.warning(\"[\".concat(this._clientId, \"] repeat massUnsubscribe user:\").concat(n.uid, \",mediaType:\").concat(r, \" twice.\")), e.splice(i, 1);\n            continue;\n          }\n          r ? \"audio\" === r ? t.set(n, o | zb.Audio) : \"video\" === r && t.set(n, o | s) : t.set(n, o | zb.Audio | s);\n        } else r ? \"audio\" === r ? t.set(n, zb.Audio) : \"video\" === r && t.set(n, s) : t.set(n, zb.Audio | s);\n      }\n      try {\n        const t = await this._p2pChannel.massUnsubscribe(e);\n        t && (await this._gateway.massUnsubscribe(t)), Qy.info(\"[\".concat(this._clientId, \"] massUnsubscribe success \").concat(e.map(e => {\n          let t = e.user,\n            i = e.mediaType;\n          return \"user: \".concat(null == t ? void 0 : t.uid, \", mediaType: \").concat(i, \";\");\n        }).join()));\n      } catch (e) {\n        if (e.code === tI.DISCONNECT_P2P) return void Qy.warning(\"[\".concat(this._clientId, \"] disconnecting p2p, abort unsubscribe request.\"));\n        throw Qy.error(\"[\".concat(this._clientId, \"] massUnsubscribe error\"), e.toString()), e;\n      }\n    }\n    async setLowStreamParameter(e) {\n      !function (e) {\n        if (!e) throw new iI(tI.INVALID_PARAMS);\n        dI(e.width) || sI(e.width, \"streamParameter.width\"), dI(e.height) || sI(e.height, \"streamParameter.height\"), dI(e.framerate) || sI(e.framerate, \"streamParameter.framerate\"), dI(e.bitrate) || oI(e.bitrate, \"streamParameter.bitrate\");\n      }(e), (!e.width && e.height || e.width && !e.height) && Qy.warning(\"[\".concat(this._clientId, \"] The width and height parameters take effect only when both are set\")), Qy.info(\"[\".concat(this._clientId, \"] set low stream parameter to\"), JSON.stringify(e));\n      const t = this._configDistribute.getLowStreamConfigDistribute();\n      if (t && t.bitrate && e.bitrate && t.bitrate < e.bitrate && (e.bitrate = t.bitrate), this._lowStreamParameter = e, this._isDualStreamEnabled) return this._p2pChannel.updateVideoStreamParameter(e, sw.LocalVideoLowTrack);\n    }\n    async enableDualStream() {\n      if (!_U().supportDualStream) throw oA.streamSwitch(this._sessionId, {\n        lts: Date.now(),\n        isdual: !0,\n        succ: !1\n      }), new bb(tI.NOT_SUPPORTED, \"Your browser is not support dual stream\");\n      if (this._isDualStreamEnabled) throw new bb(tI.INVALID_OPERATION, \"Dual stream is already enabled\");\n      if (this._p2pChannel.canPublishLowStream()) try {\n        await this._publishLowStream();\n      } catch (e) {\n        throw oA.streamSwitch(this._sessionId, {\n          lts: Date.now(),\n          isdual: !0,\n          succ: !1\n        }), e;\n      }\n      this._isDualStreamEnabled = !0, oA.streamSwitch(this._sessionId, {\n        lts: Date.now(),\n        isdual: !0,\n        succ: !0\n      }), Qy.info(\"[\".concat(this._clientId, \"] enable dual stream\"));\n    }\n    async disableDualStream() {\n      if (this._isDualStreamEnabled) {\n        if (!this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"Can't publish stream, haven't joined yet!\");\n        if (this._p2pChannel.getLocalMedia(sw.LocalVideoLowTrack)) try {\n          const e = await this._p2pChannel.unpublishLowStream();\n          e && (await this._gateway.unpublish(e, this._joinInfo.stringUid || this._joinInfo.uid));\n        } catch (e) {\n          throw oA.streamSwitch(this._sessionId, {\n            lts: Date.now(),\n            isdual: !1,\n            succ: !1\n          }), e;\n        }\n        this._isDualStreamEnabled = !1, oA.streamSwitch(this._sessionId, {\n          lts: Date.now(),\n          isdual: !1,\n          succ: !0\n        }), Qy.info(\"[\".concat(this._clientId, \"] disable dual stream\"));\n      }\n    }\n    async setClientRole(e, t) {\n      if (function (e) {\n        rI(e, \"role\", [\"audience\", \"host\"]);\n      }(e), t && OI(t), \"rtc\" === this.mode || \"p2p\" === this.mode) throw Qy.warning(\"[\".concat(this._clientId, \"]\").concat(this.mode, \" mode can not use setClientRole\")), new bb(tI.INVALID_OPERATION, \"\".concat(this.mode, \" mode can not use setClientRole\"));\n      if (t && t.level && \"host\" === e) throw new bb(tI.INVALID_OPERATION, \"host mode can not set audience latency level\");\n      if (\"audience\" === e && this._p2pChannel.hasLocalMedia()) throw new bb(tI.INVALID_OPERATION, \"can not set client role to audience when publishing stream\");\n      await this._gateway.setClientRole(e, t), this._config.role = e, Qy.info(\"[\".concat(this._clientId, \"] set client role to \").concat(e, \", level: \").concat(t && t.level));\n    }\n    getRemoteInboundOffset() {\n      var e;\n      const t = null === (e = this._p2pChannel.getStats()) || void 0 === e ? void 0 : e.audioSend[0];\n      if (!t || !t.timestamp) return 0;\n      const i = t.timestamp - Date.now();\n      return Math.abs(i) > 1e3 + t.rttMs + 100 ? this.ntpAlignErrorCount += 1 : this.ntpAlignErrorCount = 0, this.ntpAlignErrorCount >= 3 ? i : 0;\n    }\n    getNtpWallTimeInMs() {\n      return \"visible\" === document.visibilityState && (this.remoteInboundOffset = this.getRemoteInboundOffset()), this.remoteInboundOffset + Date.now() + this._gateway.ntpOffset;\n    }\n    setProxyServer(e, t) {\n      if (aI(e, \"proxyServer\"), !t) {\n        if (\"DISCONNECTED\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"Set proxy server before join channel\");\n        if (\"disabled\" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new bb(tI.INVALID_OPERATION, \"You have already set the proxy\");\n      }\n      this._proxyServer = e, oA.setProxyServer(this._proxyServer), Qy.setProxyServer(this._proxyServer), Qy.info(\"[\".concat(this._clientId, \"] Set proxy server \").concat(t ? \"by initialize call\" : \"\", \" success.\"));\n    }\n    setTurnServer(e, t) {\n      if (Array.isArray(e) || (e = [e]), !t) {\n        if (\"DISCONNECTED\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"Set turn server before join channel\");\n        if (\"disabled\" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new bb(tI.INVALID_OPERATION, \"You have already set the proxy\");\n      }\n      if (bI(e)) return this._turnServer = {\n        servers: e,\n        mode: \"original-manual\"\n      }, void Qy.info(\"[\".concat(this._clientId, \"] Set original turnserver \").concat(t ? \"by initialize call\" : \"\", \" success: \").concat(e.map(e => e.urls).join(\",\"), \".\"));\n      e.forEach(e => wI(e)), this._turnServer = {\n        servers: e,\n        mode: \"manual\"\n      }, Qy.info(\"[\".concat(this._clientId, \"] Set turnserver \").concat(t ? \"by initialize call\" : \"\", \" success.\"));\n    }\n    setLicense(e) {\n      if (\"DISCONNECTED\" !== this.connectionState) {\n        throw new bb(tI.INVALID_OPERATION, \"you should set license before join channel\");\n      }\n      if (aI(e, \"license\", 32, 32), !/^[A-Za-z\\d]+$/.test(e)) throw new bb(tI.INVALID_PARAMS, \"license should only contains characters from A-Z a-z 0-9\");\n      this._license = e, Qy.info(\"[\".concat(this._clientId, \"] set license success\"), e);\n    }\n    startProxyServer(e) {\n      if (\"DISCONNECTED\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"Start proxy server before join channel\");\n      if (this._proxyServer || \"manual\" === this._turnServer.mode || this._useLocalAccessPoint) throw new bb(tI.INVALID_OPERATION, \"You have already set the proxy\");\n      const t = [3, 4, 5];\n      let i;\n      switch (void 0 === e && (e = 3), e) {\n        case 1:\n        case 2:\n          throw new bb(tI.NOT_SUPPORTED, \"proxy mode 1/2 has been deprecated and not supported.\");\n        case 3:\n          i = \"proxy3\";\n          break;\n        case 4:\n          i = \"proxy4\";\n          break;\n        case 5:\n          i = \"proxy5\";\n          break;\n        default:\n          throw new bb(tI.INVALID_PARAMS, \"proxy server mode must be \".concat(t.join(\"|\")));\n      }\n      this._cloudProxyServerMode = i, this.store.cloudProxyServerMode = i, Qy.info(\"[\".concat(this._clientId, \"] set cloud proxy server mode to\"), this._cloudProxyServerMode);\n    }\n    stopProxyServer() {\n      if (\"DISCONNECTED\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"Stop proxy server after leave channel\");\n      oA.setProxyServer(), Qy.setProxyServer(), this._cloudProxyServerMode = \"disabled\", this.store.cloudProxyServerMode = \"disabled\", Qy.info(\"[\".concat(this._clientId, \"] set cloud proxy server mode to\"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = {\n        mode: \"auto\",\n        servers: []\n      };\n    }\n    setLocalAccessPointsV2(e) {\n      if (!e.accessPoints) throw new bb(tI.INVALID_PARAMS, \"accessPoints is required.\");\n      cI(e.accessPoints.serverList, \"accessPoints.serverList\"), aI(e.accessPoints.domain, \"accessPoints.domain\");\n      const t = (e, t) => {\n        oI(e, t, 0, 65535, !0);\n      };\n      let i = 443;\n      if (e.accessPoints.port && (t(e.accessPoints.port, \"accessPoints.port\"), i = e.accessPoints.port), this._proxyServer || \"disabled\" !== this._cloudProxyServerMode) throw new bb(tI.INVALID_OPERATION, \"set local access point failed, You have already set the cloud proxy\");\n      Dy(\"CLOSE_AFB_FOR_LOCAL_AP\") && (Ny(\"JOIN_WITH_FALLBACK_SIGNAL_PROXY\", !1), Ny(\"JOIN_WITH_FALLBACK_MEDIA_PROXY\", !1));\n      const n = /^((\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$/,\n        r = e.accessPoints.domain,\n        o = e.accessPoints.serverList.map(e => n.test(e) ? \"\".concat(e.replace(/\\./g, \"-\"), \".\").concat(r) : e),\n        s = o.map(e => \"\".concat(e, \":\").concat(i));\n      this._useLocalAccessPoint = !0, this._setLocalAPVersion = 2, Ny(\"WEBCS_DOMAIN\", s), Ny(\"WEBCS_DOMAIN_BACKUP_LIST\", s), Ny(\"GATEWAY_DOMAINS\", [r]), e.report && e.report.hostname && Array.isArray(e.report.hostname) && e.report.hostname.length ? (cI(e.report.hostname, \"report.hostname\"), Ny(\"EVENT_REPORT_DOMAIN\", e.report.hostname[0]), Ny(\"EVENT_REPORT_BACKUP_DOMAIN\", e.report.hostname[1] || e.report.hostname[0])) : (Ny(\"EVENT_REPORT_DOMAIN\", o[0]), Ny(\"EVENT_REPORT_BACKUP_DOMAIN\", o[1] || o[0]));\n      let a = 6443;\n      e.report && e.report.port && (t(e.report.port, \"report.port\"), a = e.report.port), Ny(\"STATS_COLLECTOR_PORT\", a), e.report ? Ny(\"ENABLE_EVENT_REPORT\", !0) : Ny(\"ENABLE_EVENT_REPORT\", !1);\n      let c = \"\";\n      e.log && e.log.hostname && Array.isArray(e.log.hostname) && e.log.hostname.length ? (cI(e.log.hostname, \"log.hostname\"), c = e.log.hostname[0]) : c = o[0];\n      let d = 6444;\n      e.log && e.log.port && (t(e.log.port, \"log.port\"), d = e.log.port), Ny(\"LOG_UPLOAD_SERVER\", \"\".concat(c, \":\").concat(d));\n      let l = [];\n      e.cds && e.cds.hostname && Array.isArray(e.cds.hostname) && e.cds.hostname.length ? (cI(e.cds.hostname, \"cds.hostname\"), l = e.cds.hostname) : l = o;\n      let h = 443;\n      e.cds && e.cds.port && (t(e.cds.port, \"cds.port\"), h = e.cds.port), Ny(\"CDS_AP\", l.map(e => \"\".concat(e, \":\").concat(h))), e.cds ? Ny(\"ENABLE_CONFIG_DISTRIBUTE\", !0) : Ny(\"ENABLE_CONFIG_DISTRIBUTE\", !1), Qy.info(\"set local access point v2 success\");\n    }\n    setLocalAccessPoints(e, t) {\n      if (cI(e, \"serverList\"), aI(t, \"domain\"), this._proxyServer || \"disabled\" !== this._cloudProxyServerMode) throw new bb(tI.INVALID_OPERATION, \"set local access point failed, You have already set the cloud proxy\");\n      const i = /^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$/;\n      e = e.map(e => i.test(e) ? \"\".concat(e.replace(/\\./g, \"-\"), \".\").concat(t) : e), this._useLocalAccessPoint = !0, this._setLocalAPVersion = 1, Ny(\"WEBCS_DOMAIN\", e), Ny(\"WEBCS_DOMAIN_BACKUP_LIST\", e), Ny(\"GATEWAY_DOMAINS\", [t]), Ny(\"EVENT_REPORT_DOMAIN\", e[0]), Ny(\"EVENT_REPORT_BACKUP_DOMAIN\", e[1] || e[0]), Ny(\"LOG_UPLOAD_SERVER\", \"\".concat(e[0], \":6444\")), Qy.info(\"[\".concat(this._clientId, \"] set local access point success\"));\n    }\n    async setRemoteDefaultVideoStreamType(e) {\n      if (rI(e, \"streamType\", [0, 1]), this._remoteDefaultVideoStreamType = e, this._joinInfo) try {\n        await this._gateway.setDefaultRemoteVideoStreamType(e), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;\n      } catch (e) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] set default remote video stream type error\"), e.toString()), e;\n      } else Qy.debug(\"[\".concat(this._clientId, \"] haven't joined yet, cache remoteDefaultVideoStreamType \").concat(e));\n    }\n    async setRemoteVideoStreamType(e, t) {\n      rI(t, \"streamType\", [0, 1]);\n      try {\n        await this._gateway.setRemoteVideoStreamType(e, t), setTimeout(() => {\n          const t = this._users.find(t => t.uid === e);\n          t && t.videoTrack && t.videoTrack.updateMediaStreamTrackResolution();\n        }, 2e3);\n      } catch (e) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] set remote video stream type error\"), e.toString()), e;\n      }\n      Qy.info(\"[\".concat(this._clientId, \"] set remote \").concat(e, \" video stream type to \").concat(t)), this._remoteStreamTypeCacheMap.set(e, t);\n    }\n    async setStreamFallbackOption(e, t) {\n      rI(t, \"fallbackType\", [0, 1, 2]);\n      try {\n        await this._gateway.setStreamFallbackOption(e, t);\n      } catch (e) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] set stream fallback option\"), e.toString()), e;\n      }\n      Qy.info(\"[\".concat(this._clientId, \"] set remote \").concat(e, \" stream fallback type to \").concat(t)), this._streamFallbackTypeCacheMap.set(e, t);\n    }\n    setEncryptionConfig(e, t, i, n) {\n      !function (e) {\n        rI(e, \"encryptionMode\", [\"aes-128-xts\", \"aes-256-xts\", \"aes-128-ecb\", \"sm4-128-ecb\", \"aes-128-gcm\", \"aes-256-gcm\", \"aes-128-gcm2\", \"aes-256-gcm2\", \"none\"]);\n      }(e), aI(t, \"secret\");\n      const r = [\"aes-128-gcm2\", \"aes-256-gcm2\"];\n      if (Dn(r).call(r, e)) {\n        if (!i || !(i instanceof Uint8Array && 32 === i.length)) throw new bb(tI.INVALID_PARAMS, \"salt must be an Uint8Array and exactly equal to 32 bytes\");\n      } else if (i) throw new bb(tI.INVALID_PARAMS, \"current encrypt mode does not need salt\");\n      if (n) {\n        if (nI(n, \"encryptDataStream\"), !Dn(r).call(r, e)) throw new bb(tI.INVALID_PARAMS, \"current encrypt mode does not support data stream\");\n        this._encryptDataStream = !0;\n      }\n      new RegExp(\"^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'\\\"|{}\\\\[\\\\]])(?=.{8,})\").test(t) || Qy.warning(\"The secret is not strong:\\n      The secret must contain at least 1 lowercase alphabetical character,\\n      The secret must contain at least 1 uppercase alphabetical character,\\n      The secret must contain at least 1 numeric character,\\n      The secret must contain at least one special character,\\n      The secret must be eight characters or longer.\\n      \"), this._encryptionMode = e, this._encryptionSecret = t, i && (this._encryptionSalt = qI(i));\n    }\n    async renewToken(e) {\n      if (aI(e, \"token\", 1, 2047), !this._key || !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"renewToken should not be called before user join\");\n      const t = this._key;\n      this._key = e, this._joinInfo && (this._joinInfo.token = e);\n      const i = await this._renewTokenMutex.lock();\n      try {\n        if (Dy(\"USE_NEW_TOKEN\")) {\n          Qy.debug(\"[\".concat(this._clientId, \"] start renew token with ticket from unilbs\"));\n          const t = await zO(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || _y);\n          Qy.debug(\"[\".concat(this._clientId, \"] get ticket from unilbs success\")), await this._gateway.renewToken({\n            token: e,\n            ticket: t\n          });\n        } else Qy.debug(\"[\".concat(this._clientId, \"] start renew token without ticket\")), await this._gateway.renewToken({\n          token: e\n        });\n        Qy.debug(\"[\".concat(this._clientId, \"] renewToken success\"));\n      } catch (e) {\n        throw this._key = t, this._joinInfo.token = t, Qy.error(\"[\".concat(this._clientId, \"] renewToken failed\"), e.toString()), e;\n      } finally {\n        i();\n      }\n    }\n    enableAudioVolumeIndicator() {\n      this._audioVolumeIndicationInterval ? Qy.warning(\"you have already enabled audio volume indicator!\") : this._audioVolumeIndicationInterval = window.setInterval(() => {\n        const e = this._p2pChannel.getAudioLevels();\n        this.safeEmit(NI.VOLUME_INDICATOR, e);\n      }, Dy(\"AUDIO_VOLUME_INDICATION_INTERVAL\") || 2e3);\n    }\n    getRTCStats() {\n      const e = this._statsCollector.getRTCStats(),\n        t = this._gateway.getInChannelInfo();\n      return e.Duration = Math.round(t.duration / 1e3), e;\n    }\n    async startLiveStreaming(e, t) {\n      if (!t) {\n        if (\"h264\" !== this.codec) throw new bb(tI.LIVE_STREAMING_INVALID_RAW_STREAM, \"raw streaming is only support h264\");\n        if (!this._p2pChannel.hasLocalMedia()) throw new bb(tI.LIVE_STREAMING_INVALID_RAW_STREAM, \"can not find stream to raw streaming\");\n      }\n      if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e)) throw new bb(tI.LIVE_STREAMING_TASK_CONFLICT);\n      const i = t ? Nb.TRANSCODE : Nb.RAW;\n      return this._createLiveStreamingClient(i).startLiveStreamingTask(e, i);\n    }\n    setLiveTranscoding(e) {\n      return this._createLiveStreamingClient(Nb.TRANSCODE).setTranscodingConfig(e);\n    }\n    async stopLiveStreaming(e) {\n      const t = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter(t => t && t.hasUrl(e));\n      if (!t.length) throw new bb(tI.INVALID_PARAMS, \"can not find live streaming url to stop\");\n      await Gu.all(t.map(t => t && t.stopLiveStreamingTask(e)));\n    }\n    async addInjectStreamUrl(e, t) {\n      if (!this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"can not addInjectStreamUrl, no joininfo\");\n      const i = this._createLiveStreamingClient(Nb.INJECT);\n      i.setInjectStreamConfig(t, 0), await i.startLiveStreamingTask(e, Nb.INJECT);\n    }\n    async removeInjectStreamUrl() {\n      var e;\n      const t = this._createLiveStreamingClient(Nb.INJECT),\n        i = Array.from(ub(e = t.streamingTasks).call(e)).find(e => e.mode === Nb.INJECT);\n      if (!this._joinInfo || !i) throw new bb(tI.INVALID_OPERATION, \"can remove addInjectStreamUrl, no joininfo or inject task\");\n      await t.stopLiveStreamingTask(i.url);\n    }\n    async startChannelMediaRelay(e) {\n      fG(e);\n      const t = this._createChannelMediaRelayClient();\n      await t.startChannelMediaRelay(e);\n    }\n    async updateChannelMediaRelay(e) {\n      fG(e);\n      const t = this._createChannelMediaRelayClient();\n      await t.updateChannelMediaRelay(e);\n    }\n    async stopChannelMediaRelay() {\n      const e = this._createChannelMediaRelayClient();\n      await e.stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0);\n    }\n    async sendStreamMessage(e) {\n      var t;\n      let i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (!this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"can not send data stream, not joined\");\n      if ((\"string\" == typeof e || e instanceof Uint8Array) && (e = {\n        payload: e\n      }), \"string\" == typeof e.payload) {\n        const t = new TextEncoder();\n        e.payload = t.encode(e.payload);\n      }\n      let n = !1;\n      this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && Dn(t = [\"aes-128-gcm2\", \"aes-256-gcm2\"]).call(t, this._encryptionMode) && (n = !0, e.payload = await async function (e, t, i) {\n        var n;\n        const r = Jn(n = Array.from(i)).call(n, (e, t) => e + t, 0),\n          o = {\n            serverTs: 0,\n            seq: By++,\n            length: i.length,\n            checkSum: r\n          },\n          s = new Uint8Array(ay(r, 2)),\n          a = new ArrayBuffer(Fy),\n          c = new DataView(a);\n        c.setUint32(0, o.serverTs), c.setUint16(4, o.seq), c.setUint16(6, o.length), c.setUint16(8, o.checkSum);\n        const d = 16 - i.length % 16;\n        i = JI(i, new Uint8Array(d));\n        const l = await window.crypto.subtle.encrypt({\n          name: \"AES-GCM\",\n          iv: e,\n          tagLength: Uy,\n          additionalData: s\n        }, t, i);\n        return JI(new Uint8Array(a), new Uint8Array(l));\n      }(this._encryptDataStreamIv, this._encryptDataStreamKey, e.payload));\n      if (new Blob([e.payload]).size > 1024) throw new bb(tI.INVALID_PARAMS, n ? \"encrypted stream message out of range.\" : \"stream message out of range.\");\n      return this._gateway.signal.request(Cb.DATA_STREAM, {\n        payload: qI(e.payload),\n        syncWithAudio: e.syncWithAudio,\n        sendTs: Date.now() - LH\n      }, !i);\n    }\n    sendMetadata(e) {\n      if (!this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"can not send metadata, not joined\");\n      if (new Blob([e]).size > 1024) throw new bb(tI.METADATA_OUT_OF_RANGE);\n      return this._gateway.signal.request(Cb.SEND_METADATA, {\n        session_id: this._joinInfo.sid,\n        metadata: qI(e)\n      });\n    }\n    async sendCustomReportMessage(e) {\n      if (Array.isArray(e) || (e = [e]), e.forEach($y), !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"can not send custom report, not joined\");\n      await oA.sendCustomReportMessage(this._joinInfo.sid, e);\n    }\n    getLocalAudioStats() {\n      return this._statsCollector.getLocalAudioTrackStats();\n    }\n    getRemoteAudioStats() {\n      return this._statsCollector.getRemoteAudioTrackStats();\n    }\n    getLocalVideoStats() {\n      return this._statsCollector.getLocalVideoTrackStats();\n    }\n    getRemoteVideoStats() {\n      return this._statsCollector.getRemoteVideoTrackStats();\n    }\n    getRemoteNetworkQuality() {\n      return this._statsCollector.getRemoteNetworkQualityStats();\n    }\n    async pickSVCLayer(e, t) {\n      rI(t.spatialLayer, \"spatialLayer\", [0, 1, 2, 3]), rI(t.temporalLayer, \"temporalLayer\", [0, 1, 2, 3]);\n      try {\n        await this._gateway.pickSVCLayer(e, t);\n      } catch (e) {\n        throw Qy.error(\"[\".concat(this._clientId, \"] pick SVC layer failed\"), e.toString()), e;\n      }\n    }\n    async setRTMConfig(e) {\n      const _e$apRTM = e.apRTM,\n        t = _e$apRTM === void 0 ? !1 : _e$apRTM,\n        i = e.rtmFlag;\n      if (nI(t, \"apRTM\"), oI(i, \"rtmFlag\", 0), this._rtmConfig.apRTM = t, this._rtmConfig.rtmFlag = i, Qy.debug(\"[\".concat(this._clientId, \"] setRTMconfig \").concat(JSON.stringify(e), \" in \").concat(this.connectionState, \" state\")), (\"CONNECTED\" === this.connectionState || \"RECONNECTING\" === this.connectionState) && this._joinInfo) return this._joinInfo.apRTM = t, this._joinInfo.rtmFlag = i, this._gateway.setRTM2Flag(i);\n    }\n    _reset() {\n      if (Qy.debug(\"[\".concat(this._clientId, \"] reset client\")), this._axiosCancelSource.cancel(), this._axiosCancelSource = pv.CancelToken.source(), this._streamFallbackTypeCacheMap = new Map(), this._remoteStreamTypeCacheMap = new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo && rK(this._joinInfo), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = \"none\", this._encryptionSecret = null, this._encryptionSalt = null, this._encryptDataStreamKey = null, this._encryptDataStreamIv = null, this._pendingPublishedUsers = [], this._users.forEach(e => {\n        e._audioTrack && e._audioTrack._destroy(), e._videoTrack && e._videoTrack._destroy(), e._dataChannels && (e._dataChannels.forEach(e => e._close()), e._dataChannels.length = 0);\n      }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), \"fallback\" === this._cloudProxyServerMode && (this._cloudProxyServerMode = \"disabled\", this.store.cloudProxyServerMode = \"disabled\"), this._p2pChannel.reset(), this._publishMutex = new uy(\"client-publish\"), this._subscribeMutex = new uy(\"client-subscribe\"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect) try {\n        this._inspect.close(), this._inspect = void 0;\n      } catch (e) {}\n      if (this._moderation) try {\n        this.setImageModeration(!1);\n      } catch (e) {}\n    }\n    _startSession(e, t) {\n      var i;\n      const n = e || ty();\n      e ? Qy.debug(\"[\".concat(this._clientId, \"] new Session \").concat(n)) : Qy.debug(\"[\".concat(this._clientId, \"] renewSession \").concat(this._sessionId, \" => \").concat(n));\n      const r = e ? \"\" : this._sessionId || \"\";\n      this._sessionId = n, this.store.sessionId = n;\n      const o = {\n        lts: new Date().getTime(),\n        mode: this.mode,\n        buildFormat: 1,\n        stringUid: (null == t ? void 0 : t.stringUid) || (null === (i = this._joinInfo) || void 0 === i ? void 0 : i.stringUid),\n        channelProfile: \"live\" === this.mode ? 1 : 0,\n        channelMode: 0,\n        isABTestSuccess: Number(this._configDistribute.isSuccess),\n        lsid: r,\n        clientRole: \"audience\" === this.role ? 2 : 1\n      };\n      t ? oA.sessionInit(this._sessionId, $K({\n        cname: t.channel,\n        appid: t.appId,\n        preload: t.preload\n      }, o)) : this._joinInfo ? oA.sessionInit(this._sessionId, $K({\n        cname: this._joinInfo.cname,\n        appid: this._joinInfo.appId,\n        preload: !!this._joinInfo.recoverPreloadCache\n      }, o)) : this._gateway.joinInfo && oA.sessionInit(this._sessionId, $K({\n        cname: this._gateway.joinInfo.cname,\n        appid: this._gateway.joinInfo.appId\n      }, o)), this._joinInfo && (this._joinInfo.sid = n), this._gateway.joinInfo && (this._gateway.joinInfo.sid = n);\n    }\n    async _publishHighStream(e) {\n      if (!this._joinInfo || void 0 === this._uid) throw new bb(tI.INVALID_OPERATION, \"Can't publish stream, haven't joined yet!\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"can not publish stream in \".concat(this.connectionState, \" state\"));\n      if (\"auto\" === this._turnServer.mode && Dy(\"FORCE_TURN\") && !Dy(\"TURN_ENABLE_TCP\") && !Dy(\"TURN_ENABLE_UDP\")) throw new bb(tI.UNEXPECTED_ERROR, \"force TURN With No TURN Configuration\");\n      Qy.debug(\"[\".concat(this._clientId, \"] publish high stream\"));\n      try {\n        const i = await this._p2pChannel.publish(e, this._isDualStreamEnabled, this._lowStreamParameter);\n        if (this._p2pChannel instanceof oG) {\n          const e = (await i.next()).value;\n          if (e) {\n            try {\n              await this._gateway.sendExtensionMessage(Tw.PUBLISH, e, !0);\n            } catch (e) {\n              throw i.throw(e), e;\n            }\n            await i.next();\n          }\n          this._p2pChannel.reportPublishEvent(!0, null);\n        } else {\n          const n = (await i.next()).value;\n          if (n) {\n            var t;\n            let e;\n            try {\n              e = await this._gateway.publish(this._uid, n, !0);\n            } catch (e) {\n              if (e.code !== tI.DISCONNECT_P2P) throw i.throw(e), e;\n            }\n            await i.next((null === (t = e) || void 0 === t ? void 0 : t.ortc) || []);\n          }\n          this._p2pChannel.reportPublishEvent(!0, null);\n          for (const t of e) t instanceof vF && t._encoderConfig && this._gateway.setVideoProfile(t._encoderConfig), !t.muted && t.enabled || (await this._p2pChannel.muteLocalTrack(t));\n        }\n      } catch (t) {\n        if (this._p2pChannel.reportPublishEvent(!1, null == t ? void 0 : t.code, e), (null == t ? void 0 : t.code) === tI.WS_ABORT) return;\n        throw t;\n      }\n    }\n    async _publishLowStream() {\n      if (!this._joinInfo || void 0 === this._uid) throw new bb(tI.INVALID_OPERATION, \"Can't publish stream, haven't joined yet!\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new bb(tI.INVALID_OPERATION, \"can not publish stream in \".concat(this.connectionState, \" state\"));\n      Qy.debug(\"[\".concat(this._clientId, \"] publish low stream\"));\n      const e = this._configDistribute.getLowStreamConfigDistribute();\n      e && e.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = {\n        width: 160,\n        height: 120,\n        framerate: 15,\n        bitrate: 50\n      }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e.bitrate));\n      try {\n        const e = await this._p2pChannel.publishLowStream(this._lowStreamParameter),\n          i = (await e.next()).value;\n        if (i) {\n          var t;\n          let n;\n          try {\n            n = await this._gateway.publish(this._uid, i, !0);\n          } catch (t) {\n            if (t.code !== tI.DISCONNECT_P2P) throw e.throw(t), t;\n          }\n          e.next((null === (t = n) || void 0 === t ? void 0 : t.ortc) || []), this._p2pChannel.reportPublishEvent(!0, null, void 0, !0);\n        }\n      } catch (e) {\n        if (this._p2pChannel.reportPublishEvent(!1, null == e ? void 0 : e.code, void 0, !0), (null == e ? void 0 : e.code) === tI.WS_ABORT) return;\n        throw e;\n      }\n    }\n    _createLiveStreamingClient(e) {\n      if (!this._joinInfo || !this._appId) {\n        return new bb(tI.INVALID_OPERATION, \"can not create live streaming client, please join channel first\").throw();\n      }\n      const t = () => new EG(this._joinInfo, this._config.websocketRetryConfig || _y, this._config.httpRetryConfig || _y),\n        i = e => {\n          e.onLiveStreamError = (e, t) => {\n            oA.reportApiInvoke(this._sessionId, {\n              name: CI.ON_LIVE_STREAM_ERROR,\n              options: [e, t],\n              tag: vI.TRACER\n            }).onSuccess(), this.safeEmit(NI.LIVE_STREAMING_ERROR, e, t);\n          }, e.onLiveStreamWarning = (e, t) => {\n            oA.reportApiInvoke(this._sessionId, {\n              name: CI.ON_LIVE_STREAM_WARNING,\n              options: [e, t],\n              tag: vI.TRACER\n            }).onSuccess(), this.safeEmit(NI.LIVE_STREAMING_WARNING, e, t);\n          }, e.on(Vb.REQUEST_WORKER_MANAGER_LIST, (e, t, i) => {\n            if (!this._joinInfo) return i(new bb(tI.INVALID_OPERATION, \"can not find join info to get worker manager\"));\n            YO(e, this._joinInfo, this._axiosCancelSource.token, _y).then(t).catch(i);\n          });\n        };\n      switch (e) {\n        case Nb.RAW:\n          return this._liveRawStreamingClient || (this._liveRawStreamingClient = t(), i(this._liveRawStreamingClient)), this._liveRawStreamingClient;\n        case Nb.TRANSCODE:\n          return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = t(), i(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient;\n        case Nb.INJECT:\n          return this._injectStreamingClient || (this._injectStreamingClient = t(), this._injectStreamingClient.on(Vb.REQUEST_WORKER_MANAGER_LIST, (e, t, i) => {\n            if (!this._joinInfo) return i(new bb(tI.INVALID_OPERATION, \"can not find join info to get worker manager\"));\n            YO(e, this._joinInfo, this._axiosCancelSource.token, _y).then(t).catch(i);\n          }), this._injectStreamingClient.onInjectStatusChange = (e, t, i) => {\n            this.safeEmit(NI.INJECT_STREAM_STATUS, e, t, i);\n          }), this._injectStreamingClient;\n      }\n    }\n    _createChannelMediaRelayClient() {\n      if (!this._joinInfo) {\n        return new bb(tI.INVALID_OPERATION, \"can not create channel media relay client, please join channel first\").throw();\n      }\n      if (!this._channelMediaRelayClient) {\n        const _this$getLocalVideoSt = this.getLocalVideoStats(),\n          e = _this$getLocalVideoSt.sendResolutionWidth,\n          t = _this$getLocalVideoSt.sendResolutionHeight,\n          i = {\n            width: e,\n            height: t\n          };\n        this._channelMediaRelayClient = new SG(this._joinInfo, this._clientId, this._config.websocketRetryConfig || _y, this._config.httpRetryConfig || _y, i), this._channelMediaRelayClient.on(\"state\", e => {\n          e === Wb.RELAY_STATE_FAILURE && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose(), this.safeEmit(NI.CHANNEL_MEDIA_RELAY_STATE, e);\n        }), this._channelMediaRelayClient.on(\"event\", e => {\n          this.safeEmit(NI.CHANNEL_MEDIA_RELAY_EVENT, e);\n        }), this._statsCollector.onStatsChanged = (e, t) => {\n          var i;\n          \"resolution\" === e && (null === (i = this._channelMediaRelayClient) || void 0 === i || i.setVideoProfile(t));\n        };\n      }\n      return this._channelMediaRelayClient;\n    }\n    _handleUpdateDataChannel(e, t) {\n      const i = e.added,\n        n = e.deleted,\n        r = [];\n      Array.isArray(i) && i.length > 0 && i.forEach(e => {\n        const i = e.uid,\n          n = e.stream_id,\n          o = e.ordered,\n          s = e.max_retrans_times,\n          a = e.metadata,\n          c = this._users.find(e => e._uintid === i);\n        if (!c) return void Qy.error(\"[\".concat(this._clientId, \"] can not find target user!(on_add_data_channel)\"));\n        Qy.debug(\"[\".concat(this._clientId, \"] data_channel added with uid \").concat(i)), Dn(r).call(r, c) || r.push(c), c._uintid || (c._uintid = i);\n        if (!(-1 !== c._dataChannels.findIndex(t => t.id === e.stream_id))) {\n          const e = {\n              id: n,\n              ordered: !!o,\n              maxRetransmits: s,\n              metadata: a\n            },\n            i = new KF(e);\n          c._dataChannels.push(i), Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(c.uid, \" published datachannel\")), t || this.safeEmit(NI.USER_PUBLISHED, c, \"datachannel\", e);\n        }\n        this._p2pChannel.hasPendingRemoteDataChannel(c, e.stream_id) && (Qy.debug(\"[\".concat(this._clientId, \"] resubscribe datachannel for user \").concat(c.uid, \" after reconnect.\")), this._subscribeDataChannel(c, e.stream_id).catch(e => {\n          Qy.error(\"[\".concat(this._clientId, \"] resubscribe datachannel error\"), e.toString());\n        }));\n      }), t && (this.safeEmit(NI.PUBLISHED_USER_LIST, this._pendingPublishedUsers), this._pendingPublishedUsers = []), Array.isArray(n) && n.length > 0 && n.forEach(e => {\n        const t = e.uid,\n          i = e.stream_id,\n          n = this._users.find(e => e._uintid === t);\n        if (!n) return void Qy.error(\"[\".concat(this._clientId, \"] can not find target user!(on_delete_data_channel)\"));\n        const r = n._dataChannels.find(t => t.id === e.stream_id);\n        r && (Qy.debug(\"[\".concat(this._clientId, \"] data_stream delete with uid \").concat(t)), this._p2pChannel.unsubscribeDataChannel(n, [r]).then(e => {\n          if (n._dataChannels = n._dataChannels.filter(e => e !== r), e) return this._gateway.unsubscribeDataChannel(e, n.uid);\n        }), Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(t, \" unpublished datachannel ,id:\").concat(r.id)), this.safeEmit(NI.USER_UNPUBLISHED, n, \"datachannel\", r._config));\n      });\n    }\n    _handleRemoveDataChannels(e) {\n      const t = this._users.find(t => t.uid === e.uid);\n      if (t) {\n        if (void 0 !== t._dataChannels && t._dataChannels.length > 0) {\n          Qy.debug(\"[\".concat(this._clientId, \"] datachannel removed with uid \").concat(e.uid));\n          const i = () => {\n            Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(t.uid, \" unpublished datachannel\")), t._dataChannels.forEach(e => {\n              this.safeEmit(NI.USER_UNPUBLISHED, t, \"datachannel\", e._config);\n            });\n          };\n          this._p2pChannel.unsubscribeDataChannel(t, t._dataChannels).then(e => {\n            if (e) return this._gateway.unsubscribeDataChannel(e, t.uid);\n          }), i();\n        }\n      } else Qy.warning(\"[\".concat(this._clientId, \"] can not find target user!(on_remove_datachannel)\"));\n    }\n    _handleGatewayEvents() {\n      this._gateway.on(Yb.DISCONNECT_P2P, async () => {\n        await this._p2pChannel.disconnectForReconnect();\n      }), this._gateway.on(Yb.CONNECTION_STATE_CHANGE, (e, t, i) => {\n        var n;\n        if (i === AI.FALLBACK) return;\n        const r = () => {\n          this.safeEmit(NI.CONNECTION_STATE_CHANGE, e, t, i);\n        };\n        if (oA.reportApiInvoke(this._sessionId || (null === (n = this._gateway.joinInfo) || void 0 === n ? void 0 : n.sid) || null, {\n          name: CI.CONNECTION_STATE_CHANGE,\n          options: [e, t, i],\n          tag: vI.TRACER\n        }).onSuccess(JSON.stringify({\n          cur: e,\n          prev: t,\n          reason: i\n        })), Qy.info(\"[\".concat(this._clientId, \"] connection state change: \").concat(t, \" -> \").concat(e)), \"DISCONNECTED\" === e) return this._reset(), void r();\n        if (\"RECONNECTING\" === e) this._users.forEach(e => {\n          e._trust_in_room_ = !1, e._trust_audio_enabled_state_ = !1, e._trust_video_enabled_state_ = !1, e._trust_audio_mute_state_ = !1, e._trust_video_mute_state_ = !1, e._trust_audio_stream_added_state_ = !1, e._trust_video_stream_added_state_ = !1, e._is_pre_created || (e._audio_pre_subscribed || (e._audioSSRC = void 0, e._audioOrtc = void 0), e._video_pre_subscribed || (e._videoSSRC = void 0, e._videoOrtc = void 0, e._rtxSsrcId = void 0), e._cname = void 0);\n        }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;else if (\"CONNECTED\" === e) {\n          var o;\n          this._streamFallbackTypeCacheMap.forEach((e, t) => {\n            this._gateway.setStreamFallbackOption(t, e).catch(e => {\n              Qy.warning(\"[\".concat(this._clientId, \"] auto set stream fallback option failed\"), e);\n            });\n          }), this._remoteStreamTypeCacheMap.forEach((e, t) => {\n            this._gateway.setRemoteVideoStreamType(t, e).catch(e => {\n              Qy.warning(\"[\".concat(this._clientId, \"] auto set remote stream type failed\"), e);\n            });\n          }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o = this._joinInfo) || void 0 === o ? void 0 : o.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {\n            Qy.debug(\"[\".concat(this._clientId, \"] setRemoteDefaultVideoStreamType after gateway connected\"));\n          }).catch(e => {\n            Qy.error(\"[\".concat(this._clientId, \"] setRemoteDefaultVideoStreamType after gateway failed, \").concat(e));\n          }), this.store.useP2P || (this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {\n            if (\"CONNECTED\" !== this.connectionState) return;\n            this._userOfflineTimeout = void 0;\n            this._users.filter(e => !e._trust_in_room_).forEach(e => {\n              Qy.debug(\"[\".concat(this._clientId, \"] user offline timeout, emit user offline \").concat(e.uid)), this._handleUserOffline({\n                uid: e.uid\n              });\n            });\n          }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {\n            \"CONNECTED\" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach(e => {\n              e._trust_audio_mute_state_ || (Qy.debug(\"[\".concat(this._clientId, \"] auto dispatch audio unmute event \").concat(e.uid)), this._handleMuteStream(e.uid, nw.AUDIO, !1)), e._trust_video_mute_state_ || (Qy.debug(\"[\".concat(this._clientId, \"] auto dispatch video unmute event \").concat(e.uid)), this._handleMuteStream(e.uid, nw.VIDEO, !1)), e._trust_audio_enabled_state_ || (Qy.debug(\"[\".concat(this._clientId, \"] auto dispatch enable local audio \").concat(e.uid)), this._handleSetStreamLocalEnable(\"audio\", e.uid, !0)), e._trust_video_enabled_state_ || (Qy.debug(\"[\".concat(this._clientId, \"] auto dispatch enable local video \").concat(e.uid)), this._handleSetStreamLocalEnable(\"video\", e.uid, !0)), e._trust_video_stream_added_state_ || (Qy.debug(\"[\".concat(this._clientId, \"] auto dispatch reset video stream added \").concat(e.uid)), this._handleResetAddStream(e, \"video\")), e._trust_audio_stream_added_state_ || (Qy.debug(\"[\".concat(this._clientId, \"] auto dispatch reset audio stream added \").concat(e.uid)), this._handleResetAddStream(e, \"audio\")), e._video_added_ || e._audio_added_ || (Qy.debug(\"[\".concat(this._clientId, \"] auto dispatch stream remove \").concat(e.uid)), this._handleRemoveStream({\n                uid: e.uid,\n                uint_id: e._uintid\n              }));\n            }));\n          }, 1e3));\n        }\n        r();\n      }), this._gateway.on(Yb.REQUEST_NEW_GATEWAY_LIST, async (e, t) => {\n        if (!this._joinInfo) return t(new bb(tI.UNEXPECTED_ERROR, \"can not recover, no join info\"));\n        try {\n          let t;\n          this._joinInfo.recoverPreloadCache ? (t = this._joinInfo.recoverPreloadCache.ap, oK(this._joinInfo.recoverPreloadCache), this._joinInfo.recoverPreloadCache = void 0) : t = await FO(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || _y, this.store), this._joinInfo && (this._joinInfo.apResponse = t.gatewayInfo.res, this._joinInfo.gatewayAddrs = t.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t.gatewayInfo.uni_lbs_ip);\n          const i = [];\n          t.gatewayInfo.gatewayAddrs.forEach(e => {\n            let t = e.address;\n            const _t$split = t.split(\":\"),\n              _t$split2 = _slicedToArray(_t$split, 2),\n              n = _t$split2[0],\n              r = _t$split2[1];\n            this._joinInfo && this._joinInfo.proxyServer ? i.push({\n              proxy: this._joinInfo.proxyServer,\n              host: n,\n              port: r\n            }) : i.push({\n              host: n,\n              port: r\n            });\n          }), e(i);\n        } catch (e) {\n          t(e);\n        }\n      }), this._gateway.on(Yb.NETWORK_QUALITY, e => {\n        \"normal\" === this._networkQualitySensitivity && this.safeEmit(NI.NETWORK_QUALITY, e);\n      }), this._gateway.on(Yb.STREAM_TYPE_CHANGE, (e, t) => {\n        this.safeEmit(NI.STREAM_TYPE_CHANGED, e, t);\n        oA.reportApiInvoke(this._sessionId, {\n          name: CI.STREAM_TYPE_CHANGE,\n          options: [e, t],\n          tag: vI.TRACER\n        }).onSuccess(JSON.stringify({\n          uid: e,\n          streamType: t\n        }));\n      }), this._gateway.on(Yb.IS_P2P_DISCONNECTED, e => {\n        this._p2pChannel.isP2PDisconnected() ? e(!0) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e(!1) : e(!0);\n      }), this._gateway.on(Yb.NEED_RENEW_SESSION, async e => {\n        if (\"recover\" === e && this._joinInfo) {\n          const e = await tK($K($K({}, this._joinInfo), {}, {\n            uid: this._joinInfo.uid,\n            stringUid: void 0\n          }));\n          this._joinInfo.recoverPreloadCache = e, this._startSession(null == e ? void 0 : e.sid);\n        } else this._startSession();\n      }), this._gateway.on(Yb.REQUEST_P2P_CONNECTION_PARAMS, async (e, t, i) => {\n        try {\n          t(await this._p2pChannel.startP2PConnection(e));\n        } catch (e) {\n          i(e);\n        }\n      }), this._gateway.on(Yb.JOIN_RESPONSE, (e, t) => {\n        if (this.store.useP2P) return;\n        const _ej = ej(e.ortc, t),\n          i = _ej.dtlsParameters,\n          n = _ej.iceParameters,\n          r = _ej.candidates,\n          o = _ej.rtpCapabilities,\n          s = _ej.setup,\n          a = _ej.cname;\n        this._p2pChannel.connect(n, i, r, o, s, a);\n      }), this._gateway.on(Yb.REQUEST_DC_CONNECTION_PARAMS, e => {\n        e(this._p2pChannel.getEstablishParams());\n      }), this._gateway.on(Yb.RESET_SIGNAL, e => {\n        this._p2pChannel.resetConnection(e), this._handleGatewaySignalEvents();\n      }), this._gateway.on(Yb.DATACHANNEL_FAILBACK, () => {\n        this._joinGateway();\n      }), this._gateway.on(Yb.DATACHANNEL_PRECONNECT, async (e, t, i, n) => {\n        var r, o, s, a, c, d;\n        await this._p2pChannel.startP2PConnection({\n          turnServer: null === (r = this._joinInfo) || void 0 === r ? void 0 : r.turnServer\n        }, !0);\n        const l = function (e, t) {\n          let i;\n          return t && t.ip && \"number\" == typeof t.port ? (i = [{\n            foundation: \"udpcandidate\",\n            componentId: \"1\",\n            transport: \"udp\",\n            priority: \"2103266323\",\n            connectionAddress: t.ip,\n            port: t.port.toString(),\n            type: \"host\",\n            extension: {}\n          }], Qy.debug(\"Using remote candidate from AP \".concat(t.ip, \":\").concat(t.port)), t.ip6 && (i.push({\n            foundation: \"udpcandidate\",\n            componentId: \"1\",\n            transport: \"udp\",\n            priority: \"2103266323\",\n            connectionAddress: t.ip6,\n            port: t.port.toString(),\n            type: \"host\",\n            extension: {}\n          }), Qy.debug(\"Using IPV6 remote candidate from AP \".concat(t.ip6, \":\").concat(t.port)))) : i = [{\n            foundation: \"udpcandidate\",\n            componentId: \"1\",\n            transport: \"udp\",\n            priority: \"2103266323\",\n            connectionAddress: e.ip,\n            port: e.port.toString(),\n            type: \"host\",\n            extension: {}\n          }], i;\n        }(e, t);\n        return this._p2pChannel.preConnect({\n          iceUfrag: \"\".concat(null === (o = this._joinInfo) || void 0 === o ? void 0 : o.apResponse.cid, \"_\").concat(null === (s = this._joinInfo) || void 0 === s ? void 0 : s.apResponse.cert),\n          icePwd: \"\".concat(null === (a = this._joinInfo) || void 0 === a ? void 0 : a.apResponse.cid, \"_\").concat(null === (c = this._joinInfo) || void 0 === c ? void 0 : c.apResponse.cert)\n        }, {\n          fingerprints: [{\n            hashFunction: \"sha-256\",\n            fingerprint: null !== (d = Dy(\"FINGERPRINT\")) && void 0 !== d ? d : e.fingerprint\n          }]\n        }, l, {\n          send: {\n            audioCodecs: [],\n            videoCodecs: [],\n            audioExtensions: [],\n            videoExtensions: []\n          },\n          recv: {\n            audioCodecs: [],\n            videoCodecs: [],\n            audioExtensions: [],\n            videoExtensions: []\n          }\n        }, \"active\", \"o/i14u9pJrxRKAsu\").then(i).catch(n);\n      });\n    }\n    _handleGatewaySignalEvents() {\n      this._gateway.signal.on(Ib.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(Ib.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(Ib.ON_ADD_AUDIO_STREAM, e => this._handleAddAudioOrVideoStream(\"audio\", e.uid, e.ssrcId, e.cname, e.uint_id, e.ortc)), this._gateway.signal.on(Ib.ON_ADD_VIDEO_STREAM, e => this._handleAddAudioOrVideoStream(\"video\", e.uid, e.ssrcId, e.cname, e.uint_id, e.ortc, e.rtxSsrcId)), this._gateway.signal.on(Ib.ON_REMOTE_DATASTREAM_UPDATE, e => {\n        this._handleUpdateDataChannel(e);\n      }), this._gateway.signal.on(Ib.ON_REMOTE_FULL_DATASTREAM_INFO, e => {\n        this._handleUpdateDataChannel({\n          added: e.datastreams,\n          deleted: []\n        }, !0);\n      }), this._gateway.signal.on(Ib.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(Ib.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(Ib.MUTE_AUDIO, e => this._handleMuteStream(e.uid, nw.AUDIO, !0)), this._gateway.signal.on(Ib.UNMUTE_AUDIO, e => this._handleMuteStream(e.uid, nw.AUDIO, !1)), this._gateway.signal.on(Ib.MUTE_VIDEO, e => this._handleMuteStream(e.uid, nw.VIDEO, !0)), this._gateway.signal.on(Ib.UNMUTE_VIDEO, e => this._handleMuteStream(e.uid, nw.VIDEO, !1)), this._gateway.signal.on(Ib.RECEIVE_METADATA, e => {\n        const t = YI(e.metadata);\n        this.safeEmit(NI.RECEIVE_METADATA, e.uid, t);\n      }), this._gateway.signal.on(Ib.ON_DATA_STREAM, async e => {\n        var t;\n        if (!e) return;\n        let i = YI(e.payload);\n        if (this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && Dn(t = [\"aes-128-gcm2\", \"aes-256-gcm2\"]).call(t, this._encryptionMode)) {\n          if (e.payload.length < Fy) throw new bb(tI.UNEXPECTED_RESPONSE, \"payload length \".concat(e.payload.length, \" is less than header length \").concat(Fy));\n          const t = await async function (e, t, i) {\n            const n = i.subarray(0, Fy),\n              r = n.slice(8, Fy),\n              o = (r[0] << 8) + r[1],\n              s = (n[6] << 8) + n[7],\n              a = await window.crypto.subtle.decrypt({\n                name: \"AES-GCM\",\n                iv: e,\n                tagLength: Uy,\n                additionalData: new Uint8Array(ay(o, 2))\n              }, t, i.subarray(Fy));\n            return new Uint8Array(a).subarray(0, s);\n          }(this._encryptDataStreamIv, this._encryptDataStreamKey, i);\n          i = t;\n        }\n        let n = 0;\n        if (e.ordered || e.syncWithAudio) {\n          const t = this._p2pChannel.getStats(),\n            i = this.remoteUsers.find(t => t.uid === e.uid),\n            r = null == t ? void 0 : t.audioRecv.find(e => e.ssrc === (null == i ? void 0 : i._audioSSRC));\n          n = null == r ? void 0 : r.jitterBufferMs;\n        }\n        null == n && (n = 0), FH($K($K({}, e), {}, {\n          payload: i\n        }), n, {\n          id: this._clientId,\n          onStreamMessage: \"function\" == typeof this.onStreamMessage ? this.onStreamMessage.bind(this) : void 0,\n          safeEmit: this.safeEmit.bind(this)\n        });\n      }), this._gateway.signal.on(Ib.ON_CRYPT_ERROR, () => {\n        KI(() => {\n          Qy.warning(\"[\".concat(this._clientId, \"] on crypt error\")), this.safeEmit(NI.CRYPT_ERROR);\n        }, this._sessionId);\n      }), this._gateway.signal.on(Ib.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(Ib.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {\n        Qy.warning(\"[\".concat(this._clientId, \"] received message onTokenPrivilegeDidExpire, please get new token and join again\")), this._gateway.leave(!0, AI.TOKEN_EXPIRE), this.safeEmit(NI.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();\n      }), this._gateway.signal.on(Ib.ON_STREAM_FALLBACK_UPDATE, e => {\n        Qy.debug(\"[\".concat(this._clientId, \"] stream fallback peerId: \").concat(e.stream_id, \", attr: \").concat(e.stream_type)), this.safeEmit(NI.STREAM_FALLBACK, e.stream_id, 1 === e.stream_type ? \"fallback\" : \"recover\");\n      }), this._gateway.signal.on(Ib.ON_PUBLISH_STREAM, e => {\n        this.uid === this._uid && (this._p2pChannel.reportPublishEvent(!0, null, void 0, !1, JSON.stringify({\n          proxy: e.proxy\n        })), Qy.info(\"[\".concat(this._clientId, \"] on publish stream, \").concat(JSON.stringify(e))));\n      }), this._gateway.signal.on(Ib.ENABLE_LOCAL_VIDEO, e => {\n        this._handleSetStreamLocalEnable(\"video\", e.uid, !0);\n      }), this._gateway.signal.on(Ib.DISABLE_LOCAL_VIDEO, e => {\n        this._handleSetStreamLocalEnable(\"video\", e.uid, !1);\n      }), this._gateway.signal.on(Rb.REQUEST_TIMEOUT, (e, t) => {\n        if (this._joinInfo) switch (e) {\n          case Cb.PUBLISH:\n            {\n              if (!t) return;\n              const e = t.ortc;\n              if (e) {\n                var i, n;\n                const r = e.some(e => {\n                    let t = e.stream_type;\n                    return t === Kb.Audio;\n                  }),\n                  o = e.some(e => {\n                    let t = e.stream_type;\n                    return t !== Kb.Audio;\n                  }),\n                  s = e.some(e => {\n                    let t = e.stream_type;\n                    return t === Kb.Screen || t === Kb.ScreenLow;\n                  });\n                \"offer\" === t.state && oA.publish(this._joinInfo.sid, {\n                  eventElapse: iB.measureFromPublishStart(this.store.clientId, this.store.pubId),\n                  succ: !1,\n                  ec: tI.TIMEOUT,\n                  audio: r,\n                  video: o,\n                  p2pid: t.p2p_id,\n                  publishRequestid: this.store.pubId,\n                  screenshare: s,\n                  audioName: r ? null === (i = e.find(e => {\n                    let t = e.stream_type;\n                    return t === Kb.Audio;\n                  })) || void 0 === i || null === (i = i.ssrcs[0]) || void 0 === i ? void 0 : i.ssrcId.toString() : void 0,\n                  videoName: o ? null === (n = e.find(e => {\n                    let t = e.stream_type;\n                    return t !== Kb.Audio;\n                  })) || void 0 === n || null === (n = n.ssrcs[0]) || void 0 === n ? void 0 : n.ssrcId.toString() : void 0\n                });\n              }\n              break;\n            }\n          case Cb.SUBSCRIBE:\n            t && oA.subscribe(this._joinInfo.sid, {\n              succ: !1,\n              ec: tI.TIMEOUT,\n              audio: t.stream_type === nw.AUDIO,\n              video: t.stream_type === nw.VIDEO,\n              peerid: t.stream_id,\n              subscribeRequestid: t.ssrcId,\n              p2pid: this.store.p2pId,\n              eventElapse: iB.measureFromSubscribeStart(this.store.clientId, t.ssrcId)\n            });\n        }\n      }), this._gateway.signal.on(Ib.ON_P2P_OK, e => {\n        this.uid, this._uid;\n      }), this._gateway.signal.on(Ib.ON_PUBLISHED_USER_LIST, e => {\n        if (null == e || !e.users) return;\n        Dy(\"BLOCK_LOCAL_CLIENT\") && (e.users = e.users.filter(e => !lA(e.string_id || e.stream_id, this.channelName)));\n        const t = [],\n          i = [];\n        for (const n of e.users) {\n          let e = this._users.find(e => e._uintid === n.stream_id);\n          e ? e._trust_in_room_ = !0 : (e = new Bj(n.string_id || n.stream_id, n.stream_id), this._users.push(e), 0 === this.getListeners(NI.PUBLISHED_USER_LIST).length && (Qy.debug(\"[\".concat(this._clientId, \"] user online\"), n.stream_id), this.safeEmit(NI.USER_JOINED, e)));\n          const r = zb.Audio & n.stream_type,\n            o = (zb.Video | zb.LwoVideo) & n.stream_type,\n            s = 0 != (65280 & n.stream_type),\n            a = r && e.hasAudio,\n            c = o && e.hasVideo;\n          o && (e._trust_video_stream_added_state_ = !0, e._video_added_ = !0, e._videoSSRC = n.video_ssrc, e._rtxSsrcId = n.video_rtx), r && (e._trust_audio_stream_added_state_ = !0, e._audio_added_ = !0, e._audioSSRC = n.audio_ssrc), r && !a && 0 === this.getListeners(NI.PUBLISHED_USER_LIST).length && (Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(e.uid, \" published audio\")), this.safeEmit(NI.USER_PUBLISHED, e, \"audio\")), o && !c && 0 === this.getListeners(NI.PUBLISHED_USER_LIST).length && (Qy.info(\"[\".concat(this._clientId, \"] remote user \").concat(e.uid, \" published video\")), this.safeEmit(NI.USER_PUBLISHED, e, \"video\")), (r && !a || o && !c || s) && t.push(e), o && this._p2pChannel.hasPendingRemoteMedia(e, \"video\") && i.push({\n            user: e,\n            mediaType: \"video\"\n          }), r && this._p2pChannel.hasPendingRemoteMedia(e, \"audio\") && i.push({\n            user: e,\n            mediaType: \"audio\"\n          });\n        }\n        i.length > 0 && (Qy.debug(\"[\".concat(this._clientId, \"] RE massSubscribe after reconnect \").concat(i.map(e => \"user: \".concat(e.user.uid, \", mediaType: \").concat(e.mediaType)).join(\"; \"), \" \")), this.massSubscribe(i).catch(e => {\n          Qy.error(\"[\".concat(this._clientId, \"] mass resubscribe error\"), e.toString());\n        })), this.getListeners(NI.PUBLISHED_USER_LIST).length > 0 ? Dy(\"ENABLE_DATASTREAM_2\") ? this._pendingPublishedUsers = t : (Qy.info(\"[\".concat(this._clientId, \"] client emit user-list event, users: \").concat(t.map(e => e.uid).join(\", \"))), this.safeEmit(NI.PUBLISHED_USER_LIST, t)) : Qy.info(\"[\".concat(this._clientId, \"] client not emit user-list event case there is no user-list listener, users: \").concat(t.map(e => e.uid).join(\", \")));\n      }), this._gateway.signal.on(Ib.ON_RTP_CAPABILITY_CHANGE, e => {\n        const t = e.video_codec;\n        this._p2pChannel instanceof gW && this._p2pChannel.updateRemoteRTPCapabilities(t.map(e => e.toLowerCase()).filter(e => {\n          var t;\n          return Dn(t = Object.keys(My)).call(t, e);\n        }));\n      });\n    }\n    _handleP2PEvents() {\n      this._gateway.signal.on(Ib.ON_USER_OFFLINE, () => {\n        this._p2pChannel.disconnectForReconnect();\n      }), this._gateway.signal.on(Tw.PUBLISH, (e, t, i) => {\n        const n = e.uid;\n        e.forEach(e => {\n          const r = e.kind,\n            o = e.ssrcs,\n            s = e.mid,\n            a = e.isMuted;\n          this._handleP2PAddAudioOrVideoStream(r, n, o[0].ssrcId, s);\n          const c = this._users.find(e => e.uid === n);\n          return c && this._p2pChannel instanceof oG ? this._p2pChannel.mockSubscribe(c, r, o[0].ssrcId, s).then(() => {\n            t();\n          }).catch(i) : t(), this._handleMuteStream(n, r, !!a);\n        });\n      }), this._gateway.signal.on(Tw.CALL, async (e, t, i) => {\n        if (this._p2pChannel instanceof oG) try {\n          var n;\n          t(await this._p2pChannel.startP2P({\n            turnServer: null === (n = this._joinInfo) || void 0 === n ? void 0 : n.turnServer\n          }, e));\n        } catch (e) {\n          i(e);\n        }\n      }), this._gateway.signal.on(Rb.P2P_CONNECTION, async e => {\n        this._p2pChannel instanceof oG && (await this._p2pChannel.p2pConnect(e));\n      }), this._gateway.signal.on(Tw.UNPUBLISH, async (e, t, i) => {\n        if (this._p2pChannel instanceof oG) {\n          const n = e.unpubMsg,\n            r = e.uid,\n            o = this._users.find(e => e.uid === r);\n          if (!o) return Qy.warning(\"[\".concat(this._clientId, \"] can not find remote user, ignore mute event, uid: \").concat(r)), void t();\n          try {\n            n.forEach(async e => {\n              let t = e.stream_type;\n              const i = t === Kb.Audio ? nw.AUDIO : nw.VIDEO;\n              await this._p2pChannel.unsubscribe(o, i), this._handleMuteStream(r, i, !0);\n            }), t();\n          } catch (e) {\n            i(e);\n          }\n        }\n      }), this._gateway.signal.on(Tw.CONTROL, async (e, t) => {\n        const i = e.action;\n        switch (i) {\n          case gw.MUTE_LOCAL_VIDEO:\n            this._handleMuteStream(t, nw.VIDEO, !0);\n            break;\n          case gw.MUTE_LOCAL_AUDIO:\n            this._handleMuteStream(t, nw.AUDIO, !0);\n            break;\n          case gw.UNMUTE_LOCAL_VIDEO:\n            this._handleP2PAddAudioOrVideoStream(\"video\", t), this._handleMuteStream(t, nw.VIDEO, !1);\n            break;\n          case gw.UNMUTE_LOCAL_AUDIO:\n            this._handleP2PAddAudioOrVideoStream(\"audio\", t), this._handleMuteStream(t, nw.AUDIO, !1);\n        }\n      }), this._gateway.signal.on(Tw.RESTART_ICE, async (e, t, i) => {\n        if (this._p2pChannel instanceof oG) try {\n          const i = e.direction,\n            n = e.iceParameter;\n          if (i !== yb.SEND_ONLY || n) {\n            t(await this._p2pChannel.restartICE(i, n));\n          } else this._p2pChannel.handleDisconnect(i), t();\n        } catch (e) {\n          i(e);\n        }\n      }), this._gateway.signal.on(Tw.CANDIDATE, e => {\n        if (this._p2pChannel instanceof oG) {\n          const t = e.candidate,\n            i = e.direction;\n          this._p2pChannel.addRemoteCandidate(t, i);\n        }\n      }), this._p2pChannel.on(cw.RequestP2PRestartICE, async (e, t, i) => {\n        try {\n          const i = e.direction;\n          t(await this._gateway.sendExtensionMessage(Tw.RESTART_ICE, e, i === yb.SEND_ONLY));\n        } catch (e) {\n          i(e);\n        }\n      }), this._p2pChannel.on(cw.LocalCandidate, e => {\n        this._gateway.sendExtensionMessage(Tw.CANDIDATE, JSON.stringify(e), !0);\n      }), this._p2pChannel.on(cw.RequestP2PMuteLocal, async (e, t, i) => {\n        try {\n          await this._gateway.sendExtensionMessage(Tw.CONTROL, e, !0), t();\n        } catch (e) {\n          i(e);\n        }\n      }), this._p2pChannel.on(cw.RequestP2PUnmuteRemote, async (e, t, i) => {\n        if (this._joinInfo) try {\n          await this._gateway.unmuteRemote(e, this._joinInfo.stringUid || this._joinInfo.uid), t();\n        } catch (e) {\n          e.code === tI.DISCONNECT_P2P ? t() : i(e);\n        } else t();\n      }), this._p2pChannel.on(cw.RequestP2PMuteRemote, async (e, t, i) => {\n        if (this._joinInfo) try {\n          await this._gateway.muteRemote(e, this._joinInfo.stringUid || this._joinInfo.uid), t();\n        } catch (e) {\n          e.code === tI.DISCONNECT_P2P ? t() : i(e);\n        } else t();\n      }), this._p2pChannel.on(cw.StateChange, (e, t) => {\n        t === aw.Connected && this._p2pChannel.republish();\n      });\n    }\n    _handleP2PChannelEvents() {\n      this._p2pChannel.on(cw.RequestMuteLocal, async (e, t, i) => {\n        if (this._joinInfo) try {\n          await this._gateway.muteLocal(e, this._joinInfo.stringUid || this._joinInfo.uid), t();\n        } catch (e) {\n          e.code === tI.DISCONNECT_P2P ? t() : i(e);\n        } else t();\n      }), this._p2pChannel.on(cw.RequestUnmuteLocal, async (e, t, i) => {\n        if (this._joinInfo) try {\n          await this._gateway.unmuteLocal(e, this._joinInfo.stringUid || this._joinInfo.uid), t();\n        } catch (e) {\n          e.code === tI.DISCONNECT_P2P ? t() : i(e);\n        } else t();\n      }), this._p2pChannel.on(cw.RequestRePublish, (e, t, i) => {\n        this.publish(e, !1).then(t).catch(i);\n      }), this._p2pChannel.on(cw.RequestRePublishDataChannel, (e, t, i) => {\n        Gu.all(e.map(async e => {\n          await this._p2pChannel.publishDataChannel([e]);\n          const t = {\n            streamId: e.id,\n            ordered: e.ordered,\n            maxRetransmits: e.maxRetransmits,\n            metadata: e.metadata,\n            channelId: e._originDataChannelId\n          };\n          try {\n            await this._gateway.publishDataChannel(this._uid, t, !0);\n          } catch (e) {\n            if (e.code !== tI.DISCONNECT_P2P) throw e;\n          }\n        })).then(t).catch(i);\n      }), this._p2pChannel.on(cw.RequestReSubscribe, async (e, t, i) => {\n        try {\n          for (const _ref30 of e) {\n            const t = _ref30.user;\n            const i = _ref30.kind;\n            i === nw.VIDEO ? await this.subscribe(t, \"video\") : await this.subscribe(t, \"audio\");\n          }\n          t();\n        } catch (e) {\n          i(e);\n        }\n      }), this._p2pChannel.on(cw.RequestUpload, (e, t) => {\n        this._gateway.upload(e, t);\n      }), this._p2pChannel.on(cw.RequestUploadStats, e => {\n        this._gateway.uploadWRTCStats(e);\n      }), this._p2pChannel.on(cw.MediaReconnectStart, e => {\n        this.safeEmit(NI.MEDIA_RECONNECT_START, e);\n      }), this._p2pChannel.on(cw.MediaReconnectEnd, e => {\n        this.safeEmit(NI.MEDIA_RECONNECT_END, e);\n      }), this._p2pChannel.on(cw.NeedSignalRTT, e => {\n        e(this._gateway.getSignalRTT());\n      }), this._p2pChannel.on(cw.RequestRestartICE, async e => {\n        if (this._p2pChannel instanceof oG) return;\n        const t = await this._p2pChannel.restartICE(e),\n          i = await t.next();\n        if (i.done) return;\n        const n = i.value;\n        let r;\n        try {\n          r = await this._gateway.restartICE({\n            iceParameters: n\n          });\n        } catch (e) {\n          return void t.throw(e);\n        }\n        const _ref31 = function (e) {\n            const t = e.iceParameters;\n            return {\n              iceParameters: {\n                iceUfrag: t.iceUfrag,\n                icePwd: t.icePwd\n              }\n            };\n          }(r),\n          o = _ref31.iceParameters;\n        await t.next({\n          remoteIceParameters: o\n        });\n      }), this._p2pChannel.on(cw.RequestReconnect, async () => {\n        this._gateway.reconnect();\n      }), this._p2pChannel.on(cw.RequestReconnectPC, async () => {\n        var e;\n        const _await$this$_p2pChann = await this._p2pChannel.startP2PConnection({\n            turnServer: null === (e = this._joinInfo) || void 0 === e ? void 0 : e.turnServer\n          }),\n          t = _await$this$_p2pChann.iceParameters,\n          i = _await$this$_p2pChann.dtlsParameters,\n          n = _await$this$_p2pChann.rtpCapabilities,\n          _await$this$_gateway$2 = await this._gateway.reconnectPC({\n            iceParameters: t,\n            dtlsParameters: i,\n            rtpCapabilities: n\n          }),\n          r = _await$this$_gateway$2.gatewayEstablishParams,\n          o = _await$this$_gateway$2.gatewayAddress,\n          _ej2 = ej(r, o),\n          s = _ej2.dtlsParameters,\n          a = _ej2.iceParameters,\n          c = _ej2.candidates,\n          d = _ej2.rtpCapabilities,\n          l = _ej2.setup,\n          h = _ej2.cname;\n        await this._p2pChannel.connect(a, s, c, d, l, h), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();\n      }), this._p2pChannel.on(cw.RequestUnpublishForReconnectPC, async (e, t, i) => {\n        this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e, this._uid), t()) : i();\n      }), this._p2pChannel.on(cw.P2PLost, () => {\n        this.safeEmit(NI.P2P_LOST, this.store.uid);\n      }), this._p2pChannel.on(cw.UpdateVideoEncoder, e => {\n        e._encoderConfig && this._gateway.setVideoProfile(e._encoderConfig);\n      }), this._p2pChannel.on(cw.ConnectionTypeChange, e => {\n        this.safeEmit(NI.IS_USING_CLOUD_PROXY, e);\n      }), this._p2pChannel.on(cw.RequestLowStreamParameter, e => {\n        e(this._lowStreamParameter || {\n          width: 160,\n          height: 120,\n          framerate: 15,\n          bitrate: 50\n        });\n      }), this._p2pChannel.on(cw.QueryClientConnectionState, e => {\n        e(this.connectionState);\n      });\n    }\n    getKeyMetrics() {\n      return this.store.keyMetrics;\n    }\n    async enableContentInspect(e) {\n      if (\"CONNECTED\" !== this.connectionState || !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Client did not join channel\"));\n      if (this._inspect) throw new bb(tI.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Inspect content service already in connecting/connected state\"));\n      if (!e) throw new bb(tI.INVALID_PARAMS, \"[\".concat(this._clientId, \"] inspectConfig is necessary\"));\n      if (!e.inspectType || !Array.isArray(e.inspectType)) throw new bb(tI.INVALID_PARAMS, \"[\".concat(this._clientId, \"] inspectConfig.inspectType is necessary and is an instance of Array.\"));\n      {\n        const t = [...new Set(e.inspectType)];\n        t.forEach(e => {\n          var t;\n          if (!Dn(t = [\"supervise\", \"moderation\"]).call(t, e)) throw new bb(tI.INVALID_PARAMS, \"[\".concat(this._clientId, \"] \").concat(e, \" is not a valid inspect type.\"));\n        }), e.inspectType = t;\n      }\n      if (e && e.extraInfo && e.extraInfo.length > 1024) throw new bb(tI.INVALID_PARAMS, \"[\".concat(this._clientId, \"] inspectConfig.extraInfo length cannot exceed 1024 bytes\"));\n      try {\n        const t = new QW(e);\n        this._inspect = t, this.handleVideoInspectEvents(this._inspect), await t.init({\n          appId: this._joinInfo.appId,\n          areaCode: \"\",\n          cname: this._joinInfo.cname,\n          sid: this._joinInfo.sid,\n          token: this._joinInfo.token,\n          uid: this._joinInfo.uid,\n          cid: this._joinInfo.cid,\n          vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0\n        }, _y);\n      } catch (e) {\n        throw Array.isArray(e) ? e[0] : e;\n      }\n    }\n    async disableContentInspect() {\n      if (!this._inspect) throw new bb(tI.INVALID_OPERATION, \"[\".concat(this._clientId, \"] inspectVideoContent not started\"));\n      try {\n        this._inspect.close(), this._inspect = void 0;\n      } catch (e) {\n        throw Array.isArray(e) ? e[0] : e;\n      }\n    }\n    async setImageModeration(e, t) {\n      if (nI(e, \"enabled\"), e) {\n        if (!t) throw new bb(tI.INVALID_PARAMS, \"[\".concat(this._clientId, \"] config is necessary\"));\n        if (oI(t.interval, \"interval\", 1e3, 1 / 0), t && t.extraInfo && t.extraInfo.length > 1024) throw new bb(tI.INVALID_PARAMS, \"[\".concat(this._clientId, \"] config.extraInfo length cannot exceed 1024 bytes\"));\n        if (t && t.vendor && t.vendor.length > 1024) throw new bb(tI.INVALID_PARAMS, \"[\".concat(this._clientId, \"] config.vendor length cannot exceed 1024 bytes\"));\n        if (\"CONNECTED\" !== this.connectionState || !this._joinInfo) throw new bb(tI.INVALID_OPERATION, \"[\".concat(this._clientId, '] can not enable image moderation, not joined\"'));\n        try {\n          if (this._moderation) return void this._moderation.updateConfig(t);\n          const e = new NH(t);\n          this._moderation = e, this.handleImageModerationEvents(this._moderation), await e.init({\n            appId: this._joinInfo.appId,\n            areaCode: \"\",\n            cname: this._joinInfo.cname,\n            sid: this._joinInfo.sid,\n            token: this._joinInfo.token,\n            uid: this._joinInfo.uid,\n            cid: this._joinInfo.cid,\n            vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0\n          }, _y);\n        } catch (e) {\n          throw Array.isArray(e) ? e[0] : e;\n        }\n      } else {\n        if (!this._moderation) throw new bb(tI.INVALID_OPERATION, \"[\".concat(this._clientId, \"] image moderation not started\"));\n        try {\n          this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0;\n        } catch (e) {\n          throw Array.isArray(e) ? e[0] : e;\n        }\n      }\n    }\n    setP2PTransport(e) {\n      if (function (e) {\n        rI(e, \"transport\", [\"default\", \"auto\", \"relay\", \"sd-rtn\"]);\n      }(e), \"p2p\" !== this.mode) throw new bb(tI.INVALID_OPERATION, \"only p2p mode can set p2pTransport\");\n      this.store.p2pTransport = e, Qy.info(\"[\".concat(this._clientId, \"] set client p2pTransport to \").concat(e));\n    }\n    handleImageModerationEvents(e) {\n      e.on(mw.CONNECTION_STATE_CHANGE, (t, i) => {\n        if (this.safeEmit(NI.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t, i), t === Ew.CONNECTED) {\n          if (\"CONNECTED\" !== this.connectionState) throw this.setImageModeration(!1), new bb(tI.OPERATION_ABORTED, \"Image moderation was cancelled because it left the channel\");\n          e.inspectImage();\n        }\n      }), e.on(mw.CLIENT_LOCAL_VIDEO_TRACK, e => {\n        e(this.localTracks.filter(e => \"video\" === e.trackMediaType)[0]);\n      });\n    }\n    handleVideoInspectEvents(e) {\n      e.on(hw.CONNECTION_STATE_CHANGE, (t, i) => {\n        if (this.safeEmit(NI.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t, i), i === dw.CONNECTED) {\n          if (\"CONNECTED\" !== this.connectionState) return void this.safeEmit(NI.CONTENT_INSPECT_ERROR, new bb(tI.OPERATION_ABORTED, \"Content inspect was cancelled because it left the channel\"));\n          e.inspectImage();\n        }\n      }), e.on(hw.INSPECT_RESULT, (e, t) => {\n        var i;\n        if ((null == t ? void 0 : t.code) === tI.INVALID_OPERATION && \"DISCONNECTED\" === this.connectionState) return Qy.debug(\"Stop inspect content because that has left channel\"), null == this || null === (i = this._inspect) || void 0 === i || i.close(), void (this._inspect = void 0);\n        this.safeEmit(NI.CONTENT_INSPECT_RESULT, e, t);\n      }), e.on(hw.CLIENT_LOCAL_VIDEO_TRACK, e => {\n        e(this.localTracks.filter(e => \"video\" === e.trackMediaType)[0]);\n      });\n    }\n    getJoinChannelServiceRecords() {\n      return Qy.debug(\"getJoinChannelServiceRecords\"), this.store.joinChannelServiceRecords;\n    }\n    async setPublishAudioFilterEnabled(e) {\n      nI(e, \"enabled\"), Ny(\"ENABLE_PUBLISH_AUDIO_FILTER\", e), this._joinInfo && (await this._gateway.setPublishAudioFilterEnabled(e));\n    }\n    _handleResetAddStream(e, t) {\n      switch (t) {\n        case \"audio\":\n          e._audio_added_ = !1, e._trust_audio_stream_added_state_ = !0;\n          break;\n        case \"video\":\n          e._video_added_ = !1, e._trust_video_stream_added_state_ = !0;\n      }\n    }\n  }, nb(QK.prototype, \"leave\", [dK], Object.getOwnPropertyDescriptor(QK.prototype, \"leave\"), QK.prototype), nb(QK.prototype, \"publish\", [lK], Object.getOwnPropertyDescriptor(QK.prototype, \"publish\"), QK.prototype), nb(QK.prototype, \"unpublish\", [hK], Object.getOwnPropertyDescriptor(QK.prototype, \"unpublish\"), QK.prototype), nb(QK.prototype, \"subscribe\", [uK], Object.getOwnPropertyDescriptor(QK.prototype, \"subscribe\"), QK.prototype), nb(QK.prototype, \"presubscribe\", [pK], Object.getOwnPropertyDescriptor(QK.prototype, \"presubscribe\"), QK.prototype), nb(QK.prototype, \"massSubscribe\", [_K], Object.getOwnPropertyDescriptor(QK.prototype, \"massSubscribe\"), QK.prototype), nb(QK.prototype, \"unsubscribe\", [EK], Object.getOwnPropertyDescriptor(QK.prototype, \"unsubscribe\"), QK.prototype), nb(QK.prototype, \"massUnsubscribe\", [mK], Object.getOwnPropertyDescriptor(QK.prototype, \"massUnsubscribe\"), QK.prototype), nb(QK.prototype, \"setLowStreamParameter\", [fK], Object.getOwnPropertyDescriptor(QK.prototype, \"setLowStreamParameter\"), QK.prototype), nb(QK.prototype, \"enableDualStream\", [TK], Object.getOwnPropertyDescriptor(QK.prototype, \"enableDualStream\"), QK.prototype), nb(QK.prototype, \"disableDualStream\", [SK], Object.getOwnPropertyDescriptor(QK.prototype, \"disableDualStream\"), QK.prototype), nb(QK.prototype, \"setClientRole\", [gK], Object.getOwnPropertyDescriptor(QK.prototype, \"setClientRole\"), QK.prototype), nb(QK.prototype, \"setProxyServer\", [RK], Object.getOwnPropertyDescriptor(QK.prototype, \"setProxyServer\"), QK.prototype), nb(QK.prototype, \"setTurnServer\", [CK], Object.getOwnPropertyDescriptor(QK.prototype, \"setTurnServer\"), QK.prototype), nb(QK.prototype, \"setLicense\", [vK], Object.getOwnPropertyDescriptor(QK.prototype, \"setLicense\"), QK.prototype), nb(QK.prototype, \"startProxyServer\", [IK], Object.getOwnPropertyDescriptor(QK.prototype, \"startProxyServer\"), QK.prototype), nb(QK.prototype, \"stopProxyServer\", [yK], Object.getOwnPropertyDescriptor(QK.prototype, \"stopProxyServer\"), QK.prototype), nb(QK.prototype, \"setLocalAccessPointsV2\", [AK], Object.getOwnPropertyDescriptor(QK.prototype, \"setLocalAccessPointsV2\"), QK.prototype), nb(QK.prototype, \"setLocalAccessPoints\", [bK], Object.getOwnPropertyDescriptor(QK.prototype, \"setLocalAccessPoints\"), QK.prototype), nb(QK.prototype, \"setRemoteDefaultVideoStreamType\", [wK], Object.getOwnPropertyDescriptor(QK.prototype, \"setRemoteDefaultVideoStreamType\"), QK.prototype), nb(QK.prototype, \"setRemoteVideoStreamType\", [OK], Object.getOwnPropertyDescriptor(QK.prototype, \"setRemoteVideoStreamType\"), QK.prototype), nb(QK.prototype, \"setStreamFallbackOption\", [NK], Object.getOwnPropertyDescriptor(QK.prototype, \"setStreamFallbackOption\"), QK.prototype), nb(QK.prototype, \"setEncryptionConfig\", [DK], Object.getOwnPropertyDescriptor(QK.prototype, \"setEncryptionConfig\"), QK.prototype), nb(QK.prototype, \"renewToken\", [PK], Object.getOwnPropertyDescriptor(QK.prototype, \"renewToken\"), QK.prototype), nb(QK.prototype, \"enableAudioVolumeIndicator\", [LK], Object.getOwnPropertyDescriptor(QK.prototype, \"enableAudioVolumeIndicator\"), QK.prototype), nb(QK.prototype, \"startLiveStreaming\", [kK], Object.getOwnPropertyDescriptor(QK.prototype, \"startLiveStreaming\"), QK.prototype), nb(QK.prototype, \"setLiveTranscoding\", [MK], Object.getOwnPropertyDescriptor(QK.prototype, \"setLiveTranscoding\"), QK.prototype), nb(QK.prototype, \"stopLiveStreaming\", [UK], Object.getOwnPropertyDescriptor(QK.prototype, \"stopLiveStreaming\"), QK.prototype), nb(QK.prototype, \"addInjectStreamUrl\", [xK], Object.getOwnPropertyDescriptor(QK.prototype, \"addInjectStreamUrl\"), QK.prototype), nb(QK.prototype, \"removeInjectStreamUrl\", [VK], Object.getOwnPropertyDescriptor(QK.prototype, \"removeInjectStreamUrl\"), QK.prototype), nb(QK.prototype, \"startChannelMediaRelay\", [FK], Object.getOwnPropertyDescriptor(QK.prototype, \"startChannelMediaRelay\"), QK.prototype), nb(QK.prototype, \"updateChannelMediaRelay\", [BK], Object.getOwnPropertyDescriptor(QK.prototype, \"updateChannelMediaRelay\"), QK.prototype), nb(QK.prototype, \"stopChannelMediaRelay\", [jK], Object.getOwnPropertyDescriptor(QK.prototype, \"stopChannelMediaRelay\"), QK.prototype), nb(QK.prototype, \"sendCustomReportMessage\", [GK], Object.getOwnPropertyDescriptor(QK.prototype, \"sendCustomReportMessage\"), QK.prototype), nb(QK.prototype, \"pickSVCLayer\", [WK], Object.getOwnPropertyDescriptor(QK.prototype, \"pickSVCLayer\"), QK.prototype), nb(QK.prototype, \"setRTMConfig\", [HK], Object.getOwnPropertyDescriptor(QK.prototype, \"setRTMConfig\"), QK.prototype), nb(QK.prototype, \"enableContentInspect\", [KK], Object.getOwnPropertyDescriptor(QK.prototype, \"enableContentInspect\"), QK.prototype), nb(QK.prototype, \"disableContentInspect\", [YK], Object.getOwnPropertyDescriptor(QK.prototype, \"disableContentInspect\"), QK.prototype), nb(QK.prototype, \"setImageModeration\", [qK], Object.getOwnPropertyDescriptor(QK.prototype, \"setImageModeration\"), QK.prototype), nb(QK.prototype, \"setP2PTransport\", [zK], Object.getOwnPropertyDescriptor(QK.prototype, \"setP2PTransport\"), QK.prototype), nb(QK.prototype, \"getJoinChannelServiceRecords\", [JK], Object.getOwnPropertyDescriptor(QK.prototype, \"getJoinChannelServiceRecords\"), QK.prototype), nb(QK.prototype, \"setPublishAudioFilterEnabled\", [XK], Object.getOwnPropertyDescriptor(QK.prototype, \"setPublishAudioFilterEnabled\"), QK.prototype), QK);\n  class tY {\n    constructor(e, t) {\n      ng(this, \"id\", 0), ng(this, \"element\", void 0), ng(this, \"peerPair\", void 0), ng(this, \"context\", void 0), ng(this, \"audioPlayerElement\", void 0), ng(this, \"audioTrack\", void 0), tY.count += 1, this.id = tY.count, this.element = e, this.context = t;\n    }\n    initPeers() {\n      this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = e => {\n        const t = document.createElement(\"audio\");\n        t.srcObject = new MediaStream([e.track]), t.play(), this.audioPlayerElement = t;\n      };\n    }\n    async switchSdp() {\n      if (!this.peerPair) return;\n      const e = async (e, t) => {\n          const i = \"offer\" === t ? await e.createOffer() : await e.createAnswer();\n          return await e.setLocalDescription(i), \"complete\" === e.iceGatheringState ? e.localDescription : new Gu(t => {\n            e.onicegatheringstatechange = () => {\n              \"complete\" === e.iceGatheringState && t(e.localDescription);\n            };\n          });\n        },\n        t = async (e, t) => await e.setRemoteDescription(t);\n      try {\n        const i = await e(this.peerPair[0], \"offer\");\n        await t(this.peerPair[1], i);\n        const n = await e(this.peerPair[1], \"answer\");\n        await t(this.peerPair[0], n);\n      } catch (e) {\n        throw new bb(tI.LOCAL_AEC_ERROR, e.toString()).print();\n      }\n    }\n    async getTracksFromMediaElement(e) {\n      if (this.audioTrack) return this.audioTrack;\n      let t;\n      try {\n        e instanceof HTMLVideoElement && (e.captureStream ? e.captureStream() : e.mozCaptureStream()), t = this.context.createMediaStreamDestination();\n        this.context.createMediaElementSource(e).connect(t);\n      } catch (e) {\n        throw new bb(tI.LOCAL_AEC_ERROR, e.toString()).print();\n      }\n      if (!t) {\n        throw new bb(tI.LOCAL_AEC_ERROR, \"no dest node when local aec\").print();\n      }\n      const i = t.stream.getAudioTracks()[0];\n      return this.audioTrack = i, i;\n    }\n    getElement() {\n      return this.element;\n    }\n    async startEchoCancellation() {\n      this.context.resume(), this.peerPair && this.close(), this.initPeers();\n      const e = this.element,\n        t = await this.getTracksFromMediaElement(e);\n      this.peerPair && this.peerPair[0].addTrack(t), await this.switchSdp();\n    }\n    close() {\n      Qy.debug(\"close echo cancellation unit, id is\", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach(e => {\n        e.close();\n      }), this.peerPair = void 0, this.audioPlayerElement = void 0;\n    }\n  }\n  var iY, nY;\n  ng(tY, \"count\", 0);\n  const rY = window.AudioContext || window.webkitAudioContext;\n  const oY = new (iY = rA({\n    report: oA\n  }), nb((nY = class {\n    constructor() {\n      ng(this, \"units\", []), ng(this, \"context\", void 0);\n    }\n    processExternalMediaAEC(e) {\n      if (!this._doesEnvironmentNeedAEC()) return Qy.debug(\"the system does not need to process local aec\"), -1;\n      this.context || (this.context = new rY());\n      let t = this.units.find(t => t && t.getElement() === e);\n      return t || (t = new tY(e, this.context), this.units.push(t)), t.startEchoCancellation(), Qy.debug(\"start processing local audio echo cancellation, id is\", t.id), t.id;\n    }\n    _doesEnvironmentNeedAEC() {\n      return Iv().name !== gv.SAFARI;\n    }\n  }).prototype, \"processExternalMediaAEC\", [iY], Object.getOwnPropertyDescriptor(nY.prototype, \"processExternalMediaAEC\"), nY.prototype), nY)();\n  function sY(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var n = Object.getOwnPropertySymbols(e);\n      t && (n = n.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, n);\n    }\n    return i;\n  }\n  function aY(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? sY(Object(i), !0).forEach(function (t) {\n        ng(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : sY(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  const cY = window || document;\n  function dY(e) {\n    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n    if (!cY) return;\n    const i = hY._cspEventHandlerPointer;\n    if (i && t) return void console.error(i, t);\n    const n = e => {\n      if (!(e && e.blockedURI && (hY.onSecurityPolicyViolation || hY.getListeners(_w.SECURITY_POLICY_VIOLATION).length > 0))) return;\n      const t = e.blockedURI;\n      Dy(\"CSP_DETECTED_HOSTNAME_LIST\").some(e => Dn(t).call(t, e)) && (hY.onSecurityPolicyViolation && \"function\" == typeof hY.onSecurityPolicyViolation && hY.onSecurityPolicyViolation(e), hY.getListeners(_w.SECURITY_POLICY_VIOLATION).length > 0 && hY.safeEmit(_w.SECURITY_POLICY_VIOLATION, e));\n    };\n    i && cY.removeEventListener(\"securitypolicyviolation\", i), (t || e && \"function\" == typeof e || hY.getListeners(_w.SECURITY_POLICY_VIOLATION).length > 0) && cY.addEventListener(\"securitypolicyviolation\", n), hY._cspEventHandlerPointer = n;\n  }\n  Ny(\"PROCESS_ID\", \"process-\".concat(ey(8, \"\"), \"-\").concat(ey(4, \"\"), \"-\").concat(ey(4, \"\"), \"-\").concat(ey(4, \"\"), \"-\").concat(ey(12, \"\"))), function () {\n    let e;\n    try {\n      e = window.localStorage.getItem(\"websdk_ng_global_parameter\");\n    } catch (e) {\n      return void Qy.error(\"Error loading sdk config\", e.message);\n    }\n    if (e) try {\n      const t = JSON.parse(window.atob(e)),\n        i = Date.now();\n      Qy.debug(\"Loading global parameters from cache\", t), Object.keys(t).forEach(e => {\n        if (Object.prototype.hasOwnProperty.call(Oy, e)) {\n          const _t$e = t[e],\n            n = _t$e.value,\n            r = _t$e.expires;\n          if (r && r <= i) return;\n          Py[e] = n, Oy[e] = n;\n        }\n      });\n    } catch (t) {\n      Qy.error(\"Error loading mutableParamsCache: \".concat(e), t.message);\n    }\n  }(), Array.isArray(Py.AREAS) && Py.AREAS.length > 0 && CO(Py.AREAS, !0);\n  const lY = (e, t, i) => {\n      Qy.debug(\"setParameter key:\".concat(e, \", value:\").concat(JSON.stringify(t))), Ny(e, t, i);\n    },\n    hY = function (e) {\n      const t = new SI(),\n        i = e,\n        n = {\n          getListeners: t.getListeners.bind(t),\n          on: (e, i) => (function (e, t) {\n            e === _w.SECURITY_POLICY_VIOLATION && dY(t, !0);\n          }(e, i), t.on.bind(t)(e, i)),\n          addListener: t.addListener.bind(t),\n          once: t.once.bind(t),\n          off: t.off.bind(t),\n          removeAllListeners: t.removeAllListeners.bind(t),\n          emit: t.emit.bind(t),\n          safeEmit: t.safeEmit.bind(t)\n        };\n      return aY(aY({}, i), n);\n    }({\n      __TRACK_LIST__: NU,\n      VERSION: Iy,\n      BUILD: wy,\n      ESM_BUNDLER: !1,\n      ESM: !1,\n      UMD: !0,\n      DEV: !1,\n      setParameter: lY,\n      getParameter: Dy,\n      getSupportedCodec: async function () {\n        let e = {\n          audio: [],\n          video: []\n        };\n        try {\n          let t = new RTCPeerConnection();\n          const i = await async function (e) {\n            let t;\n            return _U().supportUnifiedPlan ? (e.addTransceiver(\"video\", {\n              direction: \"recvonly\"\n            }), e.addTransceiver(\"audio\", {\n              direction: \"recvonly\"\n            }), t = (await e.createOffer()).sdp) : t = (await e.createOffer({\n              offerToReceiveAudio: !0,\n              offerToReceiveVideo: !0\n            })).sdp, t;\n          }(t);\n          if (!i) return e;\n          t.close(), t = null, e = function (e) {\n            const t = {\n              video: [],\n              audio: []\n            };\n            return e.match(/ VP8/i) && t.video.push(\"VP8\"), e.match(/ VP9/i) && t.video.push(\"VP9\"), e.match(/ AV1/i) && t.video.push(\"AV1\"), e.match(/ H264/i) && t.video.push(\"H264\"), e.match(/ H265/i) && t.video.push(\"H265\"), e.match(/ opus/i) && t.audio.push(\"OPUS\"), e.match(/ PCMU/i) && t.audio.push(\"PCMU\"), e.match(/ PCMA/i) && t.audio.push(\"PCMA\"), e.match(/ G722/i) && t.audio.push(\"G722\"), t;\n          }(i);\n        } catch (e) {\n          throw new bb(tI.CREATE_OFFER_FAILED, e.toString && e.toString()).print();\n        }\n        return e;\n      },\n      checkSystemRequirements: function () {\n        const e = oA.reportApiInvoke(null, {\n          name: CI.CHECK_SYSTEM_REQUIREMENTS,\n          options: [],\n          tag: vI.TRACER\n        });\n        let t = !1;\n        try {\n          const e = window.RTCPeerConnection,\n            i = navigator.mediaDevices && navigator.mediaDevices.getUserMedia,\n            n = window.WebSocket;\n          t = !!(e && i && n), t && zv() && function (e) {\n            const t = Iv();\n            return !(t.name !== gv.CHROME || !t.osVersion) && Number(t.version) < e;\n          }(75) && new e().close();\n        } catch (e) {\n          return Qy.error(\"check system requirement failed: \", e), !1;\n        }\n        let i = !1;\n        const n = Iv();\n        n.name === gv.CHROME && Number(n.version) >= 58 && (\"WebKit\" !== Cv.engine.name || function () {\n          const e = Iv();\n          if (wv()) {\n            if (e.os === Sv.MAC_OS) return !0;\n            if (e.os === Sv.IOS) {\n              const e = Cv.os.version && Cv.os.version.split(\".\");\n              if (e && 14 === Number(e[0]) && e[1] && Number(e[1]) >= 3) return !0;\n              if (e && Number(e[0]) > 14) return !0;\n            }\n          }\n          return !1;\n        }()) && (i = !0), (n.name === gv.FIREFOX && Number(n.version) >= 56 || n.name === gv.OPERA && Number(n.version) >= 45 || n.name === gv.SAFARI && Number(n.version) >= 11 || \"WebKit\" === n.name && (Lv() || Kv()) && n.osVersion && Number(n.osVersion.split(\".\")[0]) >= 11 || Yv() || Iv().name === gv.QQ) && (i = !0), Qy.debug(\"checkSystemRequirements, api:\", t, \"browser\", i);\n        const r = t && i;\n        return e.onSuccess(r), r;\n      },\n      getDevices: function (e) {\n        return Ax.enumerateDevices(!0, !0, e);\n      },\n      getMicrophones: function (e) {\n        return Ax.getRecordingDevices(e);\n      },\n      getCameras: function (e) {\n        return Ax.getCamerasDevices(e);\n      },\n      getElectronScreenSources: Tx,\n      getPlaybackDevices: function (e) {\n        return Ax.getSpeakers(e);\n      },\n      createClient: function () {\n        var e;\n        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {\n          codec: \"vp8\",\n          audioCodec: \"opus\",\n          mode: \"rtc\"\n        };\n        const i = oA.reportApiInvoke(null, {\n          name: CI.CREATE_CLIENT,\n          options: [t],\n          tag: vI.TRACER\n        });\n        try {\n          !function (e) {\n            rI(e.codec, \"config.codec\", [\"vp8\", \"vp9\", \"av1\", \"h264\", \"h265\"]), rI(e.mode, \"config.mode\", [\"rtc\", \"live\", \"p2p\"]), void 0 !== e.audioCodec && rI(e.audioCodec, \"config.audioCodec\", [\"opus\", \"pcmu\", \"pcma\", \"g722\"]), void 0 !== e.proxyServer && aI(e.proxyServer, \"config.proxyServer\", 1, 1e4), void 0 !== e.turnServer && wI(e.turnServer), void 0 !== e.httpRetryConfig && II(e.httpRetryConfig), void 0 !== e.websocketRetryConfig && II(e.websocketRetryConfig);\n          }(t);\n        } catch (e) {\n          throw i.onError(e), e;\n        }\n        return (xv(16, 0, !0) || Vv(16, 0, !0)) && (\"vp9\" === t.codec && (t.codec = \"vp8\", Qy.debug(\"browser not support vp9, force use vp8\")), Ny(\"UNSUPPORTED_VIDEO_CODEC\", [\"vp9\"])), void 0 === t.audioCodec && (t.audioCodec = \"opus\"), i.onSuccess(), new eY($K($K({\n          forceWaitGatewayResponse: !0\n        }, t), {}, {\n          role: Dn(e = [\"rtc\", \"p2p\"]).call(e, t.mode) ? \"host\" : t.role || \"audience\"\n        }));\n      },\n      createCameraVideoTrack: async function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n        const t = Dy(\"CAMERA_CAPTURE_CONFIG\"),\n          i = oA.reportApiInvoke(null, {\n            tag: vI.TRACER,\n            name: CI.CREATE_CAM_VIDEO_TRACK,\n            options: [tx({}, e), t]\n          });\n        t && (e.encoderConfig = t);\n        const n = jx(e),\n          r = ey(8, \"track-cam-\");\n        let o = null;\n        const s = \"720p_auto\" === e.encoderConfig;\n        Qy.info(\"start create camera video track with config\", JSON.stringify(e), \"trackId\", r);\n        try {\n          o = (await Cx({\n            video: n\n          }, r)).getVideoTracks()[0] || null;\n        } catch (e) {\n          throw i.onError(e), e;\n        }\n        if (!o) {\n          const e = new iI(tI.UNEXPECTED_ERROR, \"can not find track in media stream\");\n          return i.onError(e), e.throw(Qy);\n        }\n        e.optimizationMode && yF(r, o, e, yU(e.encoderConfig));\n        const a = new IF(o, e, n, e.scalabiltyMode ? bU(e.scalabiltyMode) : {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        }, e.optimizationMode, r);\n        return s && a.startMonitorStats(), i.onSuccess(a.getTrackId()), Qy.info(\"create camera video success, trackId:\", r), a;\n      },\n      createCustomVideoTrack: function (e) {\n        const t = oA.reportApiInvoke(null, {\n            tag: vI.TRACER,\n            name: CI.CREATE_CUSTOM_VIDEO_TRACK,\n            options: [e]\n          }),\n          i = new vF(e.mediaStreamTrack, {\n            width: e.width,\n            height: e.height,\n            frameRate: e.frameRate,\n            bitrateMax: e.bitrateMax,\n            bitrateMin: e.bitrateMin\n          }, e.scalabiltyMode ? bU(e.scalabiltyMode) : {\n            numSpatialLayers: 1,\n            numTemporalLayers: 1\n          }, e.optimizationMode, ey(8, \"track-cus-\"), [LU.CUSTOM_TRACK]);\n        return t.onSuccess(i.getTrackId()), Qy.info(\"create custom video track success with config\", e, \"trackId\", i.getTrackId()), i;\n      },\n      createScreenVideoTrack: async function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n          t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"disable\";\n        const i = oA.reportApiInvoke(null, {\n            tag: vI.TRACER,\n            name: CI.CREATE_SCREEN_VIDEO_TRACK,\n            options: [tx({}, e), t]\n          }),\n          n = \"720p_auto\" === e.encoderConfig;\n        e.encoderConfig ? \"string\" == typeof e.encoderConfig || e.encoderConfig.width && e.encoderConfig.height || (e.encoderConfig.width = {\n          max: 1920\n        }, e.encoderConfig.height = {\n          max: 1080\n        }) : e.encoderConfig = \"1080p_2\";\n        const r = function (e) {\n            const t = {};\n            e.screenSourceType && (t.mediaSource = e.screenSourceType), e.extensionId && Ov() && (t.extensionId = e.extensionId);\n            const i = e.displaySurface,\n              n = e.selfBrowserSurface,\n              r = e.surfaceSwitching,\n              o = e.systemAudio;\n            (kv(107) || Mv(107) || Fv(93)) && (i && (rI(i, \"displaySurface\", [\"browser\", \"window\", \"monitor\"]), t.displaySurface = i), n ? (rI(n, \"selfBrowserSurface\", [\"exclude\", \"include\"]), t.selfBrowserSurface = n) : t.selfBrowserSurface = \"include\", r && (rI(r, \"surfaceSwitching\", [\"exclude\", \"include\"]), t.surfaceSwitching = r)), (kv(105) || Mv(105) || Fv(91)) && o && (rI(o, \"systemAudio\", [\"exclude\", \"include\"]), t.systemAudio = o), e.electronScreenSourceId && (t.sourceId = e.electronScreenSourceId);\n            const s = e.encoderConfig ? AU(e.encoderConfig) : null;\n            return t.mandatory = {\n              chromeMediaSource: \"desktop\",\n              maxWidth: s ? s.width : void 0,\n              maxHeight: s ? s.height : void 0\n            }, s && (s.frameRate && (\"number\" == typeof s.frameRate ? (t.mandatory.maxFrameRate = s.frameRate, t.mandatory.minFrameRate = s.frameRate) : (t.mandatory.maxFrameRate = s.frameRate.max || s.frameRate.ideal || s.frameRate.exact || void 0, t.mandatory.minFrameRate = s.frameRate.min || s.frameRate.ideal || s.frameRate.exact || void 0), t.frameRate = s.frameRate), s.width && (t.width = s.width), s.height && (t.height = s.height)), t;\n          }(e),\n          o = ey(8, \"track-scr-v-\");\n        let s = null,\n          a = null;\n        const c = _U();\n        if (!c.supportShareAudio && \"enable\" === t) {\n          const e = new iI(tI.NOT_SUPPORTED, \"your browser or platform is not support share-screen with audio\");\n          return i.onError(e), e.throw(Qy);\n        }\n        Qy.info(\"start create screen video track with config\", e, \"withAudio\", t, \"trackId\", o);\n        try {\n          const e = await Cx({\n            screen: r,\n            screenAudio: \"auto\" === t ? c.supportShareAudio : \"enable\" === t\n          }, o);\n          s = e.getVideoTracks()[0] || null, a = e.getAudioTracks()[0] || null;\n        } catch (e) {\n          throw i.onError(e), e;\n        }\n        if (!s) {\n          const e = new iI(tI.UNEXPECTED_ERROR, \"can not find track in media stream\");\n          return i.onError(e), e.throw(Qy);\n        }\n        if (!a && \"enable\" === t) {\n          s && s.stop();\n          const e = new iI(tI.SHARE_AUDIO_NOT_ALLOWED);\n          return i.onError(e), e.throw(Qy);\n        }\n        e.optimizationMode || (e.optimizationMode = \"detail\"), e.optimizationMode && (yF(o, s, e, e.encoderConfig && AU(e.encoderConfig) || void 0), e.encoderConfig && \"string\" != typeof e.encoderConfig && (e.encoderConfig.bitrateMin = e.encoderConfig.bitrateMax));\n        const d = new vF(s, e.encoderConfig ? AU(e.encoderConfig) : {}, e.scalabiltyMode ? bU(e.scalabiltyMode) : {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        }, e.optimizationMode, o, [LU.SCREEN_TRACK]);\n        if (n && d.startMonitorStats(), !a) return i.onSuccess(d.getTrackId()), Qy.info(\"create screen video track success\", \"video:\", d.getTrackId()), d;\n        const l = new LV(a, void 0, ey(8, \"track-scr-a-\"), !1);\n        return i.onSuccess([d.getTrackId(), l.getTrackId()]), Qy.info(\"create screen video track success\", \"video:\", d.getTrackId(), \"audio:\", l.getTrackId()), [d, l];\n      },\n      createMicrophoneAndCameraTracks: async function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n          t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        const i = Dy(\"CAMERA_CAPTURE_CONFIG\"),\n          n = oA.reportApiInvoke(null, {\n            tag: vI.TRACER,\n            name: CI.CREATE_MIC_AND_CAM_TRACKS,\n            options: [e, t, i]\n          });\n        i && (t.encoderConfig = i);\n        const r = \"720p_auto\" === t.encoderConfig,\n          o = jx(t),\n          s = Gx(e),\n          a = ey(8, \"track-mic-\"),\n          c = ey(8, \"track-cam-\");\n        let d = null,\n          l = null;\n        Qy.info(\"start create camera video track(\".concat(c, \") and microphone audio track(\").concat(a, \") with config, audio: \").concat(JSON.stringify(e), \", video: \").concat(JSON.stringify(t)));\n        try {\n          const e = await Cx({\n            audio: s,\n            video: o\n          }, \"\".concat(a, \"-\").concat(c));\n          d = e.getAudioTracks()[0], l = e.getVideoTracks()[0];\n        } catch (e) {\n          throw n.onError(e), e;\n        }\n        if (!d || !l) {\n          const e = new iI(tI.UNEXPECTED_ERROR, \"can not find tracks in media stream\");\n          return n.onError(e), e.throw(Qy);\n        }\n        t.optimizationMode && yF(c, l, t, yU(t.encoderConfig));\n        const h = new kV(d, e, s, a),\n          u = new IF(l, t, o, t.scalabiltyMode ? bU(t.scalabiltyMode) : {\n            numSpatialLayers: 1,\n            numTemporalLayers: 1\n          }, t.optimizationMode, c);\n        return r && u.startMonitorStats(), n.onSuccess([h.getTrackId(), u.getTrackId()]), Qy.info(\"create camera video track(\".concat(c, \") and microphone audio track(\").concat(a, \") success\")), [h, u];\n      },\n      createMicrophoneAudioTrack: async function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n        const t = oA.reportApiInvoke(null, {\n            tag: vI.TRACER,\n            name: CI.CREATE_MIC_AUDIO_TRACK,\n            options: [e]\n          }),\n          i = Gx(e),\n          n = ey(8, \"track-mic-\");\n        let r = null;\n        Qy.info(\"start create microphone audio track with config\", JSON.stringify(e), \"trackId\", n);\n        try {\n          r = (await Cx({\n            audio: i\n          }, n)).getAudioTracks()[0] || null;\n        } catch (e) {\n          throw t.onError(e), e;\n        }\n        if (!r) {\n          const e = new iI(tI.UNEXPECTED_ERROR, \"can not find track in media stream\");\n          return t.onError(e), e.throw(Qy);\n        }\n        const o = new kV(r, e, i, n);\n        return t.onSuccess(o.getTrackId()), Qy.info(\"create microphone audio track success, trackId:\", n), o;\n      },\n      createCustomAudioTrack: function (e) {\n        const t = oA.reportApiInvoke(null, {\n            tag: vI.TRACER,\n            name: CI.CREATE_CUSTOM_AUDIO_TRACK,\n            options: [e]\n          }),\n          i = new LV(e.mediaStreamTrack, e.encoderConfig ? OU(e.encoderConfig) : {}, ey(8, \"track-cus-\"), !1);\n        return Qy.info(\"create custom audio track success with config\", e, \"trackId\", i.getTrackId()), t.onSuccess(i.getTrackId()), i;\n      },\n      createBufferSourceAudioTrack: async function (e) {\n        var t;\n        const i = e.cacheOnlineFile,\n          n = e.encoderConfig;\n        let r = e.source;\n        const o = {\n            source: r instanceof AudioBuffer ? \"AudioBuffer\" : r instanceof File ? null !== (t = File.name) && void 0 !== t ? t : \"File\" : r,\n            cacheOnlineFile: i,\n            encoderConfig: n\n          },\n          s = oA.reportApiInvoke(null, {\n            tag: vI.TRACER,\n            name: CI.CREATE_BUFFER_AUDIO_TRACK,\n            options: [o]\n          });\n        if (Dy(\"DISABLE_WEBAUDIO\")) throw new iI(tI.NOT_SUPPORTED, \"can not create BufferSourceAudioTrack when WebAudio disabled\");\n        const a = ey(8, \"track-buf-\");\n        Qy.info(\"start create buffer source audio track with config\", JSON.stringify(o), \"trackId\", a);\n        const c = r;\n        if (!(r instanceof AudioBuffer)) try {\n          r = await async function (e, t) {\n            let i = null;\n            if (\"string\" == typeof e) {\n              const t = VV.get(e);\n              if (t) return Qy.debug(\"use cached audio resource: \", e), t;\n              try {\n                i = (await my(() => pv.get(e, {\n                  responseType: \"arraybuffer\"\n                }), void 0, void 0, {\n                  maxRetryCount: 3\n                })).data;\n              } catch (e) {\n                throw new iI(tI.FETCH_AUDIO_FILE_FAILED, e.toString());\n              }\n            } else {\n              const t = new Gu((t, i) => {\n                const n = new FileReader();\n                n.onload = e => {\n                  e.target ? t(e.target.result) : i(new iI(tI.READ_LOCAL_AUDIO_FILE_ERROR));\n                }, n.onerror = () => {\n                  i(new iI(tI.READ_LOCAL_AUDIO_FILE_ERROR));\n                }, n.readAsArrayBuffer(e);\n              });\n              i = await t;\n            }\n            const n = await function (e) {\n              const t = dx();\n              return new Gu((i, n) => {\n                t.decodeAudioData(e, e => {\n                  i(e);\n                }, e => {\n                  n(new iI(tI.DECODE_AUDIO_FILE_FAILED, e.toString()));\n                });\n              });\n            }(i);\n            return \"string\" == typeof e && t && VV.set(e, n), n;\n          }(r, i);\n        } catch (e) {\n          return s.onError(e), e.throw(Qy);\n        }\n        const d = new xV(r),\n          l = new MV(c, d, n ? OU(n) : {}, a);\n        return Qy.info(\"create buffer source audio track success, trackId:\", a), s.onSuccess(l.getTrackId()), l;\n      },\n      setAppType: function (e) {\n        if (Qy.debug(\"setAppType: \".concat(e)), !(Number.isInteger(e) && e >= 0)) throw Qy.debug(\"Invalid appType\"), new bb(tI.INVALID_PARAMS, \"invalid app type\", e);\n        Ny(\"APP_TYPE\", Math.floor(e));\n      },\n      setLogLevel: function (e) {\n        Qy.setLogLevel(e);\n      },\n      enableLogUpload: function () {\n        Dy(\"USE_NEW_LOG\") ? Ny(\"UPLOAD_LOG\", !0) : Qy.enableLogUpload();\n      },\n      disableLogUpload: function () {\n        Dy(\"USE_NEW_LOG\") ? Ny(\"UPLOAD_LOG\", !1) : Qy.disableLogUpload();\n      },\n      createChannelMediaRelayConfiguration: function () {\n        return new mG();\n      },\n      checkAudioTrackIsActive: async function (e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;\n        const i = oA.reportApiInvoke(null, {\n          tag: vI.TRACER,\n          name: CI.CHECK_AUDIO_TRACK_IS_ACTIVE,\n          options: [t]\n        });\n        if (!(e instanceof LV || e instanceof BF)) {\n          const e = new bb(tI.INVALID_TRACK, \"the parameter is not a audio track\");\n          return i.onError(e), e.throw();\n        }\n        t && t < 1e3 && (t = 1e3);\n        const n = e instanceof LV ? e.getTrackLabel() : \"remote_track\",\n          r = e.getVolumeLevel();\n        let o = r,\n          s = r;\n        const a = Date.now();\n        return new Gu(r => {\n          const c = setInterval(() => {\n            const d = e.getVolumeLevel();\n            o = d > o ? d : o, s = d < s ? d : s;\n            const l = o - s > 1e-4,\n              h = Date.now() - a;\n            if (l || h > t) {\n              clearInterval(c);\n              const t = l,\n                s = {\n                  duration: h,\n                  deviceLabel: n,\n                  maxVolumeLevel: o,\n                  result: t\n                };\n              Qy.info(\"[track-\".concat(e.getTrackId(), \"] check audio track active completed. \").concat(JSON.stringify(s))), i.onSuccess(s), r(t);\n            }\n          }, 200);\n        });\n      },\n      checkVideoTrackIsActive: async function (e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;\n        const i = oA.reportApiInvoke(null, {\n          tag: vI.TRACER,\n          name: CI.CHECK_VIDEO_TRACK_IS_ACTIVE,\n          options: [t]\n        });\n        if (!(e instanceof vF || e instanceof FF)) {\n          const e = new bb(tI.INVALID_TRACK, \"the parameter is not a video track\");\n          return i.onError(e), e.throw();\n        }\n        t && t < 1e3 && (t = 1e3);\n        const n = e instanceof vF ? e.getTrackLabel() : \"remote_track\",\n          r = e.getMediaStreamTrack(!0),\n          o = document.createElement(\"video\");\n        o.style.width = \"1px\", o.style.height = \"1px\", o.setAttribute(\"muted\", \"\"), o.muted = !0, o.setAttribute(\"playsinline\", \"\"), o.controls = !1, (Nv() || wv()) && (o.style.opacity = \"0.01\", o.style.position = \"fixed\", o.style.left = \"0\", o.style.top = \"0\", document.body.appendChild(o)), o.srcObject = new MediaStream([r]), o.play();\n        const s = document.createElement(\"canvas\");\n        s.width = 160, s.height = 120;\n        let a = 0,\n          c = 0;\n        try {\n          const e = Date.now();\n          a = await function (e, t, i, n) {\n            let r,\n              o = 0,\n              s = null;\n            return new Gu((a, c) => {\n              function d() {\n                o > n && r && (r(), a(o));\n                const t = i.getContext(\"2d\");\n                if (!t) {\n                  const e = new bb(tI.UNEXPECTED_ERROR, \"can not get canvas 2d context.\");\n                  return Qy.error(e.toString()), void c(e);\n                }\n                t.drawImage(e, 0, 0, 160, 120);\n                const d = t.getImageData(0, 0, i.width, i.height),\n                  l = Math.floor(d.data.length / 3);\n                if (s) {\n                  for (let e = 0; e < l; e += 3) if (d.data[e] !== s[e]) return o += 1, void (s = d.data);\n                  s = d.data;\n                } else s = d.data;\n              }\n              setTimeout(() => {\n                r && (r(), a(o));\n              }, t), r = ux(() => {\n                d();\n              }, 30);\n            });\n          }(o, t, s, 4), c = Date.now() - e;\n        } catch (e) {\n          throw i.onError(e), e;\n        }\n        BH === gv.SAFARI && (o.pause(), o.remove()), o.srcObject = null;\n        const d = a > 4,\n          l = {\n            duration: c,\n            changedPicNum: a,\n            deviceLabel: n,\n            result: d\n          };\n        return Qy.info(\"[track-\".concat(e.getTrackId(), \"] check video track active completed. \").concat(JSON.stringify(l))), i.onSuccess(l), d;\n      },\n      setArea: CO,\n      audioElementPlayCenter: Px,\n      resumeAudioContext: function () {\n        Px.autoResumeAfterInterruption(!0);\n      },\n      processExternalMediaAEC: function (e) {\n        oY.processExternalMediaAEC(e);\n      },\n      registerExtensions: function (e) {\n        const t = Dy(\"PLUGIN_INFO\") || [];\n        e.forEach(e => {\n          \"name\" in e && !Dn(t).call(t, e.name) && t.push(e.name);\n          const i = e;\n          i.__registered__ = !0, i.logger.hookLog = Qy.extLog, i.reporter.hookApiInvoke = oA.extApiInvoke, i.parameters && Object.keys(i.parameters).forEach(e => {\n            i.parameters[e] = Dy(e);\n          });\n        }), lY(\"PLUGIN_INFO\", t);\n      },\n      ChannelMediaRelayError: Hb,\n      ChannelMediaRelayEvent: Gb,\n      ChannelMediaRelayState: Wb,\n      RemoteStreamFallbackType: UU,\n      RemoteStreamType: MU,\n      ConnectionDisconnectedReason: AI,\n      AudienceLatencyLevelType: yI,\n      AREAS: Xb,\n      preload: async function (e, t, i, n) {\n        return eK(e, t, i, n);\n      }\n    });\n  return Object.defineProperties(hY, {\n    onAudioAutoplayFailed: {\n      get: () => wx.onAudioAutoplayFailed,\n      set: e => {\n        wx.onAudioAutoplayFailed = e;\n      }\n    },\n    onAutoplayFailed: {\n      get: () => wx.onAutoplayFailed,\n      set: e => {\n        wx.onAutoplayFailed = e;\n      }\n    },\n    _onSecurityPolicyViolation: {\n      value: void 0,\n      writable: !0\n    },\n    _cspEventHandlerPointer: {\n      value: void 0,\n      writable: !0\n    },\n    onSecurityPolicyViolation: {\n      get: () => hY._onSecurityPolicyViolation,\n      set(e) {\n        hY._onSecurityPolicyViolation = e, dY(e);\n      }\n    },\n    __CLIENT_LIST__: {\n      get: () => Dy(\"SHOW_GLOBAL_CLIENT_LIST\") ? dA : []\n    }\n  }), Ax.on(JU.CAMERA_DEVICE_CHANGED, e => {\n    Qy.info(\"camera device changed\", JSON.stringify(e)), hY.onCameraChanged && hY.onCameraChanged(e), hY.safeEmit(_w.CAMERA_CHANGED, e);\n  }), Ax.on(JU.RECORDING_DEVICE_CHANGED, e => {\n    Qy.info(\"microphone device changed\", JSON.stringify(e)), hY.onMicrophoneChanged && hY.onMicrophoneChanged(e), hY.safeEmit(_w.MICROPHONE_CHANGED, e);\n  }), Ax.on(JU.PLAYOUT_DEVICE_CHANGED, e => {\n    Qy.debug(\"playout device changed\", JSON.stringify(e)), hY.onPlaybackDeviceChanged && hY.onPlaybackDeviceChanged(e), hY.safeEmit(_w.PLAYBACK_DEVICE_CHANGED, e);\n  }), Px.onAutoplayFailed = () => {\n    Qy.info(\"detect audio element autoplay failed\"), wx.onAudioAutoplayFailed && wx.onAudioAutoplayFailed();\n  }, cx.on(\"autoplay-failed\", () => {\n    Qy.info(\"detect webaudio autoplay failed\"), wx.onAudioAutoplayFailed && wx.onAudioAutoplayFailed(), hY.safeEmit(_w.AUTOPLAY_FAILED);\n  }), cx.on(mU.STATE_CHANGE, (e, t) => {\n    Qy.info(\"audio context state changed: \".concat(t, \" => \").concat(e)), hY.onAudioContextStateChanged && hY.onAudioContextStateChanged(e, t), hY.safeEmit(_w.AUDIO_CONTEXT_STATE_CHANGED, e, t);\n  }), VI.on(LI.NETWORK_STATE_CHANGE, (e, t) => {\n    Qy.info(\"[network-indicator] network state changed, \".concat(t, \" => \").concat(e));\n  }), window && (window.__ARTC__ = hY), hY;\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}