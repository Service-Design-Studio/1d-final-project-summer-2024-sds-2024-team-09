{"ast":null,"code":"/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n  \"use strict\";\n\n  if (typeof define === 'function' && define.amd) {\n    define(definition);\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = definition();\n  } else {\n    root.log = definition();\n  }\n})(this, function () {\n  \"use strict\";\n\n  // Slightly dubious tricks to cut down minimized file size\n  var noop = function () {};\n  var undefinedType = \"undefined\";\n  var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n  var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n  var _loggersByName = {};\n  var defaultLogger = null;\n\n  // Cross-browser bind equivalent that works at least back to IE6\n  function bindMethod(obj, methodName) {\n    var method = obj[methodName];\n    if (typeof method.bind === 'function') {\n      return method.bind(obj);\n    } else {\n      try {\n        return Function.prototype.bind.call(method, obj);\n      } catch (e) {\n        // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n        return function () {\n          return Function.prototype.apply.apply(method, [obj, arguments]);\n        };\n      }\n    }\n  }\n\n  // Trace() doesn't print the message in IE, so for that case we need to wrap it\n  function traceForIE() {\n    if (console.log) {\n      if (console.log.apply) {\n        console.log.apply(console, arguments);\n      } else {\n        // In old IE, native console methods themselves don't have apply().\n        Function.prototype.apply.apply(console.log, [console, arguments]);\n      }\n    }\n    if (console.trace) console.trace();\n  }\n\n  // Build the best logging method possible for this env\n  // Wherever possible we want to bind, not wrap, to preserve stack traces\n  function realMethod(methodName) {\n    if (methodName === 'debug') {\n      methodName = 'log';\n    }\n    if (typeof console === undefinedType) {\n      return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n    } else if (methodName === 'trace' && isIE) {\n      return traceForIE;\n    } else if (console[methodName] !== undefined) {\n      return bindMethod(console, methodName);\n    } else if (console.log !== undefined) {\n      return bindMethod(console, 'log');\n    } else {\n      return noop;\n    }\n  }\n\n  // These private functions always need `this` to be set properly\n\n  function replaceLoggingMethods() {\n    /*jshint validthis:true */\n    var level = this.getLevel();\n\n    // Replace the actual methods.\n    for (var i = 0; i < logMethods.length; i++) {\n      var methodName = logMethods[i];\n      this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n    }\n\n    // Define log.log as an alias for log.debug\n    this.log = this.debug;\n\n    // Return any important warnings.\n    if (typeof console === undefinedType && level < this.levels.SILENT) {\n      return \"No console available for logging\";\n    }\n  }\n\n  // In old IE versions, the console isn't present until you first open it.\n  // We build realMethod() replacements here that regenerate logging methods\n  function enableLoggingWhenConsoleArrives(methodName) {\n    return function () {\n      if (typeof console !== undefinedType) {\n        replaceLoggingMethods.call(this);\n        this[methodName].apply(this, arguments);\n      }\n    };\n  }\n\n  // By default, we use closely bound real methods wherever possible, and\n  // otherwise we wait for a console to appear, and then try again.\n  function defaultMethodFactory(methodName, _level, _loggerName) {\n    /*jshint validthis:true */\n    return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n  }\n  function Logger(name, factory) {\n    // Private instance variables.\n    var self = this;\n    /**\n     * The level inherited from a parent logger (or a global default). We\n     * cache this here rather than delegating to the parent so that it stays\n     * in sync with the actual logging methods that we have installed (the\n     * parent could change levels but we might not have rebuilt the loggers\n     * in this child yet).\n     * @type {number}\n     */\n    var inheritedLevel;\n    /**\n     * The default level for this logger, if any. If set, this overrides\n     * `inheritedLevel`.\n     * @type {number|null}\n     */\n    var defaultLevel;\n    /**\n     * A user-specific level for this logger. If set, this overrides\n     * `defaultLevel`.\n     * @type {number|null}\n     */\n    var userLevel;\n    var storageKey = \"loglevel\";\n    if (typeof name === \"string\") {\n      storageKey += \":\" + name;\n    } else if (typeof name === \"symbol\") {\n      storageKey = undefined;\n    }\n    function persistLevelIfPossible(levelNum) {\n      var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n      if (typeof window === undefinedType || !storageKey) return;\n\n      // Use localStorage if available\n      try {\n        window.localStorage[storageKey] = levelName;\n        return;\n      } catch (ignore) {}\n\n      // Use session cookie as fallback\n      try {\n        window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n      } catch (ignore) {}\n    }\n    function getPersistedLevel() {\n      var storedLevel;\n      if (typeof window === undefinedType || !storageKey) return;\n      try {\n        storedLevel = window.localStorage[storageKey];\n      } catch (ignore) {}\n\n      // Fallback to cookies if local storage gives us nothing\n      if (typeof storedLevel === undefinedType) {\n        try {\n          var cookie = window.document.cookie;\n          var cookieName = encodeURIComponent(storageKey);\n          var location = cookie.indexOf(cookieName + \"=\");\n          if (location !== -1) {\n            storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n          }\n        } catch (ignore) {}\n      }\n\n      // If the stored level is not valid, treat it as if nothing was stored.\n      if (self.levels[storedLevel] === undefined) {\n        storedLevel = undefined;\n      }\n      return storedLevel;\n    }\n    function clearPersistedLevel() {\n      if (typeof window === undefinedType || !storageKey) return;\n\n      // Use localStorage if available\n      try {\n        window.localStorage.removeItem(storageKey);\n      } catch (ignore) {}\n\n      // Use session cookie as fallback\n      try {\n        window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n      } catch (ignore) {}\n    }\n    function normalizeLevel(input) {\n      var level = input;\n      if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n        level = self.levels[level.toUpperCase()];\n      }\n      if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n        return level;\n      } else {\n        throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n      }\n    }\n\n    /*\n     *\n     * Public logger API - see https://github.com/pimterry/loglevel for details\n     *\n     */\n\n    self.name = name;\n    self.levels = {\n      \"TRACE\": 0,\n      \"DEBUG\": 1,\n      \"INFO\": 2,\n      \"WARN\": 3,\n      \"ERROR\": 4,\n      \"SILENT\": 5\n    };\n    self.methodFactory = factory || defaultMethodFactory;\n    self.getLevel = function () {\n      if (userLevel != null) {\n        return userLevel;\n      } else if (defaultLevel != null) {\n        return defaultLevel;\n      } else {\n        return inheritedLevel;\n      }\n    };\n    self.setLevel = function (level, persist) {\n      userLevel = normalizeLevel(level);\n      if (persist !== false) {\n        // defaults to true\n        persistLevelIfPossible(userLevel);\n      }\n\n      // NOTE: in v2, this should call rebuild(), which updates children.\n      return replaceLoggingMethods.call(self);\n    };\n    self.setDefaultLevel = function (level) {\n      defaultLevel = normalizeLevel(level);\n      if (!getPersistedLevel()) {\n        self.setLevel(level, false);\n      }\n    };\n    self.resetLevel = function () {\n      userLevel = null;\n      clearPersistedLevel();\n      replaceLoggingMethods.call(self);\n    };\n    self.enableAll = function (persist) {\n      self.setLevel(self.levels.TRACE, persist);\n    };\n    self.disableAll = function (persist) {\n      self.setLevel(self.levels.SILENT, persist);\n    };\n    self.rebuild = function () {\n      if (defaultLogger !== self) {\n        inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n      }\n      replaceLoggingMethods.call(self);\n      if (defaultLogger === self) {\n        for (var childName in _loggersByName) {\n          _loggersByName[childName].rebuild();\n        }\n      }\n    };\n\n    // Initialize all the internal levels.\n    inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n    var initialLevel = getPersistedLevel();\n    if (initialLevel != null) {\n      userLevel = normalizeLevel(initialLevel);\n    }\n    replaceLoggingMethods.call(self);\n  }\n\n  /*\n   *\n   * Top-level API\n   *\n   */\n\n  defaultLogger = new Logger();\n  defaultLogger.getLogger = function getLogger(name) {\n    if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n      throw new TypeError(\"You must supply a name when creating a logger.\");\n    }\n    var logger = _loggersByName[name];\n    if (!logger) {\n      logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n    }\n    return logger;\n  };\n\n  // Grab the current global log variable in case of overwrite\n  var _log = typeof window !== undefinedType ? window.log : undefined;\n  defaultLogger.noConflict = function () {\n    if (typeof window !== undefinedType && window.log === defaultLogger) {\n      window.log = _log;\n    }\n    return defaultLogger;\n  };\n  defaultLogger.getLoggers = function getLoggers() {\n    return _loggersByName;\n  };\n\n  // ES6 default export, for compatibility\n  defaultLogger['default'] = defaultLogger;\n  return defaultLogger;\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}